<?xml version="1.0" encoding="UTF-8" ?>
<resource_file type="CanvasItemShader" subresource_count="1" version="1.0" version_name="Godot Engine v1.0.stable.custom_build">
	<main_resource>
		<dictionary name="_code" shared="false">
			<string> "fragment_ofs" </string>
			<int> 0 </int>
			<string> "fragment" </string>
			<string> "// Water effect&#000a;// Based on code by Viktor Korsun&#000a;// speed&#000a;uniform float speed = 0.1;&#000a;uniform float speed_x = 0.3;&#000a;uniform float speed_y = 0.3;&#000a;// geometry&#000a;uniform float intensity = 3;&#000a;uniform float frequency = 4;&#000a;uniform float angle = 7; // better when a prime&#000a;// reflection and emboss&#000a;uniform float delta = 20;&#000a;uniform float intence = 400;&#000a;uniform float emboss = 0.3;&#000a;&#000a;float steps = 8;&#000a;float col(vec2 coord)&#000a;{&#000a;&#0009;float PI = 3.1415926535897932;&#000a;&#0009;float delta_theta = 2.0 * PI / angle;&#000a;&#0009;float cols = 0.0;&#000a;&#0009;float theta = 0.0;&#000a;&#0009;float seconds = TIME;&#000a;&#0009;vec2 adjc;&#000a;&#0009;&#000a;&#0009;adjc = coord;&#000a;&#0009;theta = delta_theta*float(0);&#000a;&#0009;adjc.x += cos(theta)*seconds*speed + seconds * speed_x;&#000a;&#0009;adjc.y -= sin(theta)*seconds*speed - seconds * speed_y;&#000a;&#0009;cols = cols + cos( (adjc.x*cos(theta) - adjc.y*sin(theta))*frequency)*intensity;&#000a;&#000a;&#0009;adjc = coord;&#000a;&#0009;theta = delta_theta*float(1);&#000a;&#0009;adjc.x += cos(theta)*seconds*speed + seconds * speed_x;&#000a;&#0009;adjc.y -= sin(theta)*seconds*speed - seconds * speed_y;&#000a;&#0009;cols = cols + cos( (adjc.x*cos(theta) - adjc.y*sin(theta))*frequency)*intensity;&#000a;&#0009;&#000a;&#0009;adjc = coord;&#000a;&#0009;theta = delta_theta*float(2);&#000a;&#0009;adjc.x += cos(theta)*seconds*speed + seconds * speed_x;&#000a;&#0009;adjc.y -= sin(theta)*seconds*speed - seconds * speed_y;&#000a;&#0009;cols = cols + cos( (adjc.x*cos(theta) - adjc.y*sin(theta))*frequency)*intensity;&#000a;&#0009;&#000a;&#0009;adjc = coord;&#000a;&#0009;theta = delta_theta*float(3);&#000a;&#0009;adjc.x += cos(theta)*seconds*speed + seconds * speed_x;&#000a;&#0009;adjc.y -= sin(theta)*seconds*speed - seconds * speed_y;&#000a;&#0009;cols = cols + cos( (adjc.x*cos(theta) - adjc.y*sin(theta))*frequency)*intensity;&#000a;&#0009;&#000a;&#0009;adjc = coord;&#000a;&#0009;theta = delta_theta*float(4);&#000a;&#0009;adjc.x += cos(theta)*seconds*speed + seconds * speed_x;&#000a;&#0009;adjc.y -= sin(theta)*seconds*speed - seconds * speed_y;&#000a;&#0009;cols = cols + cos( (adjc.x*cos(theta) - adjc.y*sin(theta))*frequency)*intensity;&#000a;&#0009;&#000a;&#0009;adjc = coord;&#000a;&#0009;theta = delta_theta*float(5);&#000a;&#0009;adjc.x += cos(theta)*seconds*speed + seconds * speed_x;&#000a;&#0009;adjc.y -= sin(theta)*seconds*speed - seconds * speed_y;&#000a;&#0009;cols = cols + cos( (adjc.x*cos(theta) - adjc.y*sin(theta))*frequency)*intensity;&#000a;&#0009;&#000a;&#0009;adjc = coord;&#000a;&#0009;theta = delta_theta*float(6);&#000a;&#0009;adjc.x += cos(theta)*seconds*speed + seconds * speed_x;&#000a;&#0009;adjc.y -= sin(theta)*seconds*speed - seconds * speed_y;&#000a;&#0009;cols = cols + cos( (adjc.x*cos(theta) - adjc.y*sin(theta))*frequency)*intensity;&#000a;&#0009;&#000a;&#0009;adjc = coord;&#000a;&#0009;theta = delta_theta*float(7);&#000a;&#0009;adjc.x += cos(theta)*seconds*speed + seconds * speed_x;&#000a;&#0009;adjc.y -= sin(theta)*seconds*speed - seconds * speed_y;&#000a;&#0009;cols = cols + cos( (adjc.x*cos(theta) - adjc.y*sin(theta))*frequency)*intensity;&#000a;&#0009;&#000a;&#0009;return cols;&#000a;}&#000a;&#000a;vec2 p = UV;&#000a;vec2 c1 = p;&#000a;vec2 c2 = p;&#000a;float cc1 = col(c1);&#000a;&#000a;c2.x += (1.0 / TEXTURE_PIXEL_SIZE.x) / delta;&#000a;float dx = emboss*(cc1-col(c2))/delta;&#000a;&#000a;c2.x = p.x;&#000a;c2.y += (1.0 / TEXTURE_PIXEL_SIZE.y) / delta;&#000a;float dy = emboss*(cc1-col(c2))/delta;&#000a;&#000a;c1.x += dx;&#000a;c1.y = -(c1.y+dy);&#000a;&#000a;float alpha = 1.0+dot(dx,dy)*intence;&#000a;c1.y = -c1.y;&#000a;COLOR = tex(TEXTURE,c1) * alpha;&#000a;" </string>
			<string> "vertex_ofs" </string>
			<int> 0 </int>
			<string> "vertex" </string>
			<string> "" </string>
			<string> "light_ofs" </string>
			<int> 0 </int>
			<string> "light" </string>
			<string> "" </string>
		</dictionary>

	</main_resource>
</resource_file>