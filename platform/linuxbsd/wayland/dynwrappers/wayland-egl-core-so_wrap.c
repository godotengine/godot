// This file is generated. Do not edit!
// see https://github.com/hpvb/dynload-wrapper for details
// generated by ../dynload-wrapper/generate-wrapper.py 0.3 on 2023-01-25 17:49:37
// flags: ../dynload-wrapper/generate-wrapper.py --include ./thirdparty/linuxbsd_headers/wayland/wayland-egl-core.h --sys-include "./thirdparty/linuxbsd_headers/wayland/wayland-egl-core.h" --soname libwayland-egl.so.1 --init-name wayland_egl --output-header platform/linuxbsd/wayland/dynwrappers/wayland-egl-core-so_wrap.h --output-implementation platform/linuxbsd/wayland/dynwrappers/wayland-egl-core-so_wrap.c
//
#include <stdint.h>

#define wl_egl_window_create wl_egl_window_create_dylibloader_orig_wayland_egl
#define wl_egl_window_destroy wl_egl_window_destroy_dylibloader_orig_wayland_egl
#define wl_egl_window_resize wl_egl_window_resize_dylibloader_orig_wayland_egl
#define wl_egl_window_get_attached_size wl_egl_window_get_attached_size_dylibloader_orig_wayland_egl
#include "./thirdparty/linuxbsd_headers/wayland/wayland-egl-core.h"
#undef wl_egl_window_create
#undef wl_egl_window_destroy
#undef wl_egl_window_resize
#undef wl_egl_window_get_attached_size
#include <dlfcn.h>
#include <stdio.h>
struct wl_egl_window* (*wl_egl_window_create_dylibloader_wrapper_wayland_egl)(struct wl_surface*, int, int);
void (*wl_egl_window_destroy_dylibloader_wrapper_wayland_egl)(struct wl_egl_window*);
void (*wl_egl_window_resize_dylibloader_wrapper_wayland_egl)(struct wl_egl_window*, int, int, int, int);
void (*wl_egl_window_get_attached_size_dylibloader_wrapper_wayland_egl)(struct wl_egl_window*, int*, int*);
int initialize_wayland_egl(int verbose) {
  void *handle;
  char *error;
#if defined(__OpenBSD__) || defined(__NetBSD)
  handle = dlopen("libwayland-egl.so", RTLD_LAZY);
#else
  handle = dlopen("libwayland-egl.so.1", RTLD_LAZY);
#endif
  if (!handle) {
    if (verbose) {
      fprintf(stderr, "%s\n", dlerror());
    }
    return(1);
  }
  dlerror();
// wl_egl_window_create
  *(void **) (&wl_egl_window_create_dylibloader_wrapper_wayland_egl) = dlsym(handle, "wl_egl_window_create");
  if (verbose) {
    error = dlerror();
    if (error != NULL) {
      fprintf(stderr, "%s\n", error);
    }
  }
// wl_egl_window_destroy
  *(void **) (&wl_egl_window_destroy_dylibloader_wrapper_wayland_egl) = dlsym(handle, "wl_egl_window_destroy");
  if (verbose) {
    error = dlerror();
    if (error != NULL) {
      fprintf(stderr, "%s\n", error);
    }
  }
// wl_egl_window_resize
  *(void **) (&wl_egl_window_resize_dylibloader_wrapper_wayland_egl) = dlsym(handle, "wl_egl_window_resize");
  if (verbose) {
    error = dlerror();
    if (error != NULL) {
      fprintf(stderr, "%s\n", error);
    }
  }
// wl_egl_window_get_attached_size
  *(void **) (&wl_egl_window_get_attached_size_dylibloader_wrapper_wayland_egl) = dlsym(handle, "wl_egl_window_get_attached_size");
  if (verbose) {
    error = dlerror();
    if (error != NULL) {
      fprintf(stderr, "%s\n", error);
    }
  }
return 0;
}
