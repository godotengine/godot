Follow the following instructions. Begin by copying this prompt to a new documentation file in .codex/ then assess the suggested plan below in the context of the current repo. If you agree with the strategy create a series of subtasks to implement the changes.

Focus on breaking each task into chunks that can be run sequentially, each task designed to build on the output of the previous task. so as not to try and batch too many steps and too complex a task into any one task. Begin...

üü£ Project Brief to Codex: Hardening and Maintaining gdverify (Version 4 baseline)
Project Vision and Rationale
You are tasked with supporting a standalone GDScript parser/validator tool (gdverify) that compiles against a drop-in copy of the Godot source tree. The goal is:

No forking or patching Godot core‚Äîall adjustments stay in gdverify.

Drop-in upgrade: When a new Godot version releases (e.g., 4.5, 4.6, etc.), the maintainer should be able to replace the Godot source directory, run the build, and (ideally) everything ‚Äújust works‚Äù or only needs a trivial update to a shim header.

Zero or near-zero refactors: No ongoing churn or breaking changes required for Godot mainline upgrades.

Maximum maintainability: Make it easy to keep gdverify in sync with the Godot parser, require minimal code changes, and support CI builds and test coverage.

Strengths of Version 4
Modern, Clean CMake

Enforces C++17 standard and proper public/private include separation.

Build options (flags for TOOLS_ENABLED, DEBUG_ENABLED, UNIX_ENABLED) are passed explicitly.

The GODOT_SRC_DIR is a configurable path, allowing flexible repo layouts.

Standalone Error Handling Macros

All Godot error macros needed for compilation are stubbed or emulated in mini_godot_core.h.

Enables parser and core Godot files to compile without requiring the entire Godot dependency graph.

Minimal, Focused Headers

godot_defs.h and mini_godot_core.h cover the most common types and macros expected by Godot modules.

Simplicity reduces maintenance burden and avoids unnecessary complexity.

Robust Parser CLI

The main program (src/main.cpp) wraps the parser, provides user-friendly error messages, and returns an explicit error code (65) on parse error.

Uses idiomatic C++ file handling and streams.

Up-to-Date with Godot Practices

Sample scripts/tests include actual Godot parser tests.

Encourages real-world test coverage and easy validation against future Godot releases.

Documentation

The README documents build and usage clearly and hints at future extension points (updating Godot, etc.).

Current Weaknesses / Barriers to Drop-in Upgradability
Missing Generated Headers

Godot relies on many auto-generated headers (e.g., core/disabled_classes.gen.h) created during its SCons build.

These are not shipped in source and so must be stubbed or generated for gdverify to compile.

Partial Macro/Type Coverage

If Godot parser code starts referencing new macros, types, or utility functions, mini_godot_core.h and godot_defs.h must be updated by hand.

Over time, divergence here may break builds unless you keep up with Godot‚Äôs macro evolution.

Manual Shim Maintenance

Any time Godot‚Äôs parser code introduces new dependencies on other engine modules or new headers, stubs must be updated by hand.

There‚Äôs no automation for detecting or generating these stubs.

Tests/Fixtures Live in Upstream

Some test files are duplicated from Godot‚Äôs tree, which could get out of sync with future parser changes.

If Godot reorganizes, tests may need to be refreshed or replaced.

Error Handling Divergence

If Godot changes the error reporting format, error codes, or interface of the parser, the CLI/main must be updated.

Actionable Suggestions for Long-Term Maintainability
A. Automated Header Stub Generation
Script Solution:
Create a setup script (Python, Bash, etc.) to scan for missing headers after a failed build. For every missing header that‚Äôs auto-generated by Godot, generate a minimal stub into gdverify/include that contains just enough to let the build continue (e.g., header guards, empty macros).
Example:

python
Copy code
#!/usr/bin/env python3
import os, sys
missing = [line.strip() for line in sys.stdin if "No such file or directory" in line]
for path in missing:
    full = os.path.join('gdverify/include', path)
    os.makedirs(os.path.dirname(full), exist_ok=True)
    with open(full, 'w') as f:
        f.write(f'#ifndef {os.path.basename(path).replace(".", "_").upper()}_H\n')
        f.write(f'#define {os.path.basename(path).replace(".", "_").upper()}_H\n')
        f.write('#endif\n')
Integration:
Make this script part of your build pipeline or pre-build step so you never get blocked by a missing header.

B. Macro/Type Shim Auto-Extension
Greedy Forwarding:
Periodically scan the Godot source for new macros/types referenced by parser code and append stubs to your shim headers as needed.

CI Hook:
If build fails due to an unknown symbol, grep the failed symbol and inject a placeholder or forward-declare in mini_godot_core.h.

C. Test Suite Synchronization
Sync Scripts:
Write a small script that copies relevant parser tests from the Godot source tree into your local test directory each time you upgrade Godot.

Optional:
Support for user-defined test scripts, or a local override directory, so users can add new parser regression tests.

D. Error Reporting Abstraction
Stable CLI Contract:
Document the CLI contract (what error codes mean, what output format is used) and try to avoid breaking changes even if Godot‚Äôs internal error messages change.

Adapter Layer:
If Godot‚Äôs parser interface changes, add a thin wrapper/adapter in main.cpp so that the CLI stays stable.

E. Build and Upgrade Flow
Drop-in Upgrade Process:

Replace godot/ directory with new Godot version.

Run the header-stub generator script.

Run CMake build. If new symbols/headers are needed, update/add shims as necessary.

Optionally, run the test sync script.

Commit the updated tool.

Documentation:
Update the README with clear upgrade instructions so future maintainers know exactly what to do.

F. Future-Proofing for New Godot Dependencies
Dynamic Dependency Scanner:
If the Godot parser starts referencing new submodules, add the relevant files or minimal stubs, but do not expand the scope to the whole engine.

Explicit Non-Goals:
Document that you are not aiming to compile the full Godot runtime, just enough to parse scripts.

Summary to Codex (or another maintainer/assistant)
Your ultimate goal is to have a tool that compiles against a vanilla Godot drop-in source tree with only trivial/automated maintenance work each time Godot is updated.

Everything lives outside of Godot‚Äôs own repo.

All Godot changes are upstream; you do not patch or fork Godot itself.

You provide scripts/tools to automate header stubbing and test sync.

You keep the CLI stable, documented, and reliable for scripting/CI use.

Success = Minimal human effort, minimal risk of breakage, maximum long-term maintainability and ease-of-upgrade.
