/*************************************************************************/
/*  rendering_device_d3d12.cpp                                           */
/*************************************************************************/
/*                       This file is part of:                           */
/*                           GODOT ENGINE                                */
/*                      https://godotengine.org                          */
/*************************************************************************/
/* Copyright (c) 2007-2022 Juan Linietsky, Ariel Manzur.                 */
/* Copyright (c) 2014-2022 Godot Engine contributors (cf. AUTHORS.md).   */
/*                                                                       */
/* Permission is hereby granted, free of charge, to any person obtaining */
/* a copy of this software and associated documentation files (the       */
/* "Software"), to deal in the Software without restriction, including   */
/* without limitation the rights to use, copy, modify, merge, publish,   */
/* distribute, sublicense, and/or sell copies of the Software, and to    */
/* permit persons to whom the Software is furnished to do so, subject to */
/* the following conditions:                                             */
/*                                                                       */
/* The above copyright notice and this permission notice shall be        */
/* included in all copies or substantial portions of the Software.       */
/*                                                                       */
/* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,       */
/* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF    */
/* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.*/
/* IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY  */
/* CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,  */
/* TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE     */
/* SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.                */
/*************************************************************************/

#define _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS // Keep in sync with DXC flags in SCSub.

#include "rendering_device_d3d12.h"

#include "core/config/project_settings.h"
#include "core/io/compression.h"
#include "core/io/file_access.h"
#include "core/io/marshalls.h"
#include "core/object/worker_thread_pool.h"
#include "core/os/os.h"
#include "core/templates/hashfuncs.h"
#include "core/version.h"
#include "modules/regex/regex.h"
#include "thirdparty/zlib/zlib.h"

#ifdef DEV_ENABLED
#include "core/crypto/hashing_context.h"
#endif

#include "d3d12shader.h"
#include "spirv_hlsl.hpp"

#pragma warning(push)
#pragma warning(push, 0) // Keep in sync with DXC flags in SCSub.
#include "dxc/DxilContainer/DxilContainerAssembler.h"
#include "dxc/DxilContainer/DxilContainerReader.h"
#include "dxc/Support/FileIOHelper.h"
#include "llvm/Bitcode/ReaderWriter.h"
#include "llvm/IR/Constants.h"
#include "llvm/IR/Instructions.h"
#include "llvm/IR/LLVMContext.h"
#include "llvm/Transforms/Utils/Local.h"
#ifdef DEV_ENABLED
#include "llvm/IR/ModuleSlotTracker.h"
#include "llvm/Support/raw_ostream.h"
#endif
#pragma warning(pop)

#define ARRAY_SIZE(a) (sizeof(a) / sizeof(a[0]))
#define ALIGN(m_number, m_alignment) ((((m_number) + ((m_alignment)-1)) / (m_alignment)) * (m_alignment))

#ifdef USE_SMALL_ALLOCS_POOL
static const uint32_t SMALL_ALLOCATION_MAX_SIZE = 4096;
#endif

static const D3D12_RANGE VOID_RANGE = {};

static const uint32_t ROOT_CONSTANTS_REGISTER = 0;
static const uint32_t ROOT_CONSTANTS_SPACE = 0;

static const uint32_t MAX_IMAGE_FORMAT_PLANES = 2;

// Our current support for float specialization constants (based on the hack done between HLSL and DXIL)
// is limited, but enough for now. We'll use 4:3 fixed point (we have 7 bits for the value) and patch
// the shader to apply the shift and cast back to float.
// [[FLOAT_SPEC_CONSTANT]]
static const uint32_t FLOAT_SC_SHIFT = 3;
static const float FLOAT_SC_STEP = 1.0f / (1 << FLOAT_SC_SHIFT);

#ifdef DEV_ENABLED
//#define DEBUG_COUNT_BARRIERS
#endif

RenderingDeviceD3D12::Buffer *RenderingDeviceD3D12::_get_buffer_from_owner(RID p_buffer) {
	Buffer *buffer = nullptr;
	if (vertex_buffer_owner.owns(p_buffer)) {
		buffer = vertex_buffer_owner.get_or_null(p_buffer);
	} else if (index_buffer_owner.owns(p_buffer)) {
		buffer = index_buffer_owner.get_or_null(p_buffer);
	} else if (uniform_buffer_owner.owns(p_buffer)) {
		buffer = uniform_buffer_owner.get_or_null(p_buffer);
	} else if (texture_buffer_owner.owns(p_buffer)) {
		buffer = &texture_buffer_owner.get_or_null(p_buffer)->buffer;
	} else if (storage_buffer_owner.owns(p_buffer)) {
		buffer = storage_buffer_owner.get_or_null(p_buffer);
	}
	return buffer;
}

void RenderingDeviceD3D12::_add_dependency(RID p_id, RID p_depends_on) {
	if (!dependency_map.has(p_depends_on)) {
		dependency_map[p_depends_on] = HashSet<RID>();
	}

	dependency_map[p_depends_on].insert(p_id);

	if (!reverse_dependency_map.has(p_id)) {
		reverse_dependency_map[p_id] = HashSet<RID>();
	}

	reverse_dependency_map[p_id].insert(p_depends_on);
}

void RenderingDeviceD3D12::_free_dependencies(RID p_id) {
	// Direct dependencies must be freed.

	HashMap<RID, HashSet<RID>>::Iterator E = dependency_map.find(p_id);
	if (E) {
		while (E->value.size()) {
			free(*E->value.begin());
		}
		dependency_map.remove(E);
	}

	// Reverse dependencies must be unreferenced.
	E = reverse_dependency_map.find(p_id);

	if (E) {
		for (const RID &F : E->value) {
			HashMap<RID, HashSet<RID>>::Iterator G = dependency_map.find(F);
			ERR_CONTINUE(!G);
			ERR_CONTINUE(!G->value.has(p_id));
			G->value.erase(p_id);
		}

		reverse_dependency_map.remove(E);
	}
}

// NOTE: RD's packed format names are reversed in relation to DXGI's; e.g.:.
// - DATA_FORMAT_A8B8G8R8_UNORM_PACK32 -> DXGI_FORMAT_R8G8B8A8_UNORM (packed; note ABGR vs. RGBA).
// - DATA_FORMAT_B8G8R8A8_UNORM -> DXGI_FORMAT_B8G8R8A8_UNORM (not packed; note BGRA order matches).
// TODO: Add YUV formats properly, which would require better support for planes in the RD API.
const RenderingDeviceD3D12::D3D12Format RenderingDeviceD3D12::d3d12_formats[RenderingDevice::DATA_FORMAT_MAX] = {
	/* DATA_FORMAT_R4G4_UNORM_PACK8 */ {},
	/* DATA_FORMAT_R4G4B4A4_UNORM_PACK16 */ { DXGI_FORMAT_B4G4R4A4_UNORM, DXGI_FORMAT_B4G4R4A4_UNORM, D3D12_ENCODE_SHADER_4_COMPONENT_MAPPING(1, 2, 3, 0) },
	/* DATA_FORMAT_B4G4R4A4_UNORM_PACK16 */ { DXGI_FORMAT_B4G4R4A4_UNORM, DXGI_FORMAT_B4G4R4A4_UNORM, D3D12_ENCODE_SHADER_4_COMPONENT_MAPPING(3, 2, 1, 0) },
	/* DATA_FORMAT_R5G6B5_UNORM_PACK16 */ { DXGI_FORMAT_B5G6R5_UNORM, DXGI_FORMAT_B5G6R5_UNORM },
	/* DATA_FORMAT_B5G6R5_UNORM_PACK16 */ { DXGI_FORMAT_B5G6R5_UNORM, DXGI_FORMAT_B5G6R5_UNORM, D3D12_ENCODE_SHADER_4_COMPONENT_MAPPING(2, 1, 0, 3) },
	/* DATA_FORMAT_R5G5B5A1_UNORM_PACK16 */ { DXGI_FORMAT_B5G6R5_UNORM, DXGI_FORMAT_B5G5R5A1_UNORM, D3D12_ENCODE_SHADER_4_COMPONENT_MAPPING(1, 2, 3, 0) },
	/* DATA_FORMAT_B5G5R5A1_UNORM_PACK16 */ { DXGI_FORMAT_B5G6R5_UNORM, DXGI_FORMAT_B5G5R5A1_UNORM, D3D12_ENCODE_SHADER_4_COMPONENT_MAPPING(3, 2, 1, 0) },
	/* DATA_FORMAT_A1R5G5B5_UNORM_PACK16 */ { DXGI_FORMAT_B5G6R5_UNORM, DXGI_FORMAT_B5G5R5A1_UNORM },
	/* DATA_FORMAT_R8_UNORM */ { DXGI_FORMAT_R8_TYPELESS, DXGI_FORMAT_R8_UNORM },
	/* DATA_FORMAT_R8_SNORM */ { DXGI_FORMAT_R8_TYPELESS, DXGI_FORMAT_R8_SNORM },
	/* DATA_FORMAT_R8_USCALED */ { DXGI_FORMAT_R8_TYPELESS, DXGI_FORMAT_R8_UINT },
	/* DATA_FORMAT_R8_SSCALED */ { DXGI_FORMAT_R8_TYPELESS, DXGI_FORMAT_R8_SINT },
	/* DATA_FORMAT_R8_UINT */ { DXGI_FORMAT_R8_TYPELESS, DXGI_FORMAT_R8_UINT },
	/* DATA_FORMAT_R8_SINT */ { DXGI_FORMAT_R8_TYPELESS, DXGI_FORMAT_R8_SINT },
	/* DATA_FORMAT_R8_SRGB */ {},
	/* DATA_FORMAT_R8G8_UNORM */ { DXGI_FORMAT_R8G8_TYPELESS, DXGI_FORMAT_R8G8_UNORM },
	/* DATA_FORMAT_R8G8_SNORM */ { DXGI_FORMAT_R8G8_TYPELESS, DXGI_FORMAT_R8G8_SNORM },
	/* DATA_FORMAT_R8G8_USCALED */ { DXGI_FORMAT_R8G8_TYPELESS, DXGI_FORMAT_R8G8_UINT },
	/* DATA_FORMAT_R8G8_SSCALED */ { DXGI_FORMAT_R8G8_TYPELESS, DXGI_FORMAT_R8G8_SINT },
	/* DATA_FORMAT_R8G8_UINT */ { DXGI_FORMAT_R8G8_TYPELESS, DXGI_FORMAT_R8G8_UINT },
	/* DATA_FORMAT_R8G8_SINT */ { DXGI_FORMAT_R8G8_TYPELESS, DXGI_FORMAT_R8G8_SINT },
	/* DATA_FORMAT_R8G8_SRGB */ {},
	/* DATA_FORMAT_R8G8B8_UNORM */ {},
	/* DATA_FORMAT_R8G8B8_SNORM */ {},
	/* DATA_FORMAT_R8G8B8_USCALED */ {},
	/* DATA_FORMAT_R8G8B8_SSCALED */ {},
	/* DATA_FORMAT_R8G8B8_UINT */ {},
	/* DATA_FORMAT_R8G8B8_SINT */ {},
	/* DATA_FORMAT_R8G8B8_SRGB */ {},
	/* DATA_FORMAT_B8G8R8_UNORM */ {},
	/* DATA_FORMAT_B8G8R8_SNORM */ {},
	/* DATA_FORMAT_B8G8R8_USCALED */ {},
	/* DATA_FORMAT_B8G8R8_SSCALED */ {},
	/* DATA_FORMAT_B8G8R8_UINT */ {},
	/* DATA_FORMAT_B8G8R8_SINT */ {},
	/* DATA_FORMAT_B8G8R8_SRGB */ {},
	/* DATA_FORMAT_R8G8B8A8_UNORM */ { DXGI_FORMAT_R8G8B8A8_TYPELESS, DXGI_FORMAT_R8G8B8A8_UNORM },
	/* DATA_FORMAT_R8G8B8A8_SNORM */ { DXGI_FORMAT_R8G8B8A8_TYPELESS, DXGI_FORMAT_R8G8B8A8_SNORM },
	/* DATA_FORMAT_R8G8B8A8_USCALED */ { DXGI_FORMAT_R8G8B8A8_TYPELESS, DXGI_FORMAT_R8G8B8A8_UINT },
	/* DATA_FORMAT_R8G8B8A8_SSCALED */ { DXGI_FORMAT_R8G8B8A8_TYPELESS, DXGI_FORMAT_R8G8B8A8_SINT },
	/* DATA_FORMAT_R8G8B8A8_UINT */ { DXGI_FORMAT_R8G8B8A8_TYPELESS, DXGI_FORMAT_R8G8B8A8_UINT },
	/* DATA_FORMAT_R8G8B8A8_SINT */ { DXGI_FORMAT_R8G8B8A8_TYPELESS, DXGI_FORMAT_R8G8B8A8_SINT },
	/* DATA_FORMAT_R8G8B8A8_SRGB */ { DXGI_FORMAT_R8G8B8A8_TYPELESS, DXGI_FORMAT_R8G8B8A8_UNORM_SRGB },
	/* DATA_FORMAT_B8G8R8A8_UNORM */ { DXGI_FORMAT_B8G8R8A8_TYPELESS, DXGI_FORMAT_B8G8R8A8_UNORM },
	/* DATA_FORMAT_B8G8R8A8_SNORM */ { DXGI_FORMAT_R8G8B8A8_TYPELESS, DXGI_FORMAT_R8G8B8A8_SNORM },
	/* DATA_FORMAT_B8G8R8A8_USCALED */ { DXGI_FORMAT_R8G8B8A8_TYPELESS, DXGI_FORMAT_R8G8B8A8_UINT },
	/* DATA_FORMAT_B8G8R8A8_SSCALED */ { DXGI_FORMAT_R8G8B8A8_TYPELESS, DXGI_FORMAT_R8G8B8A8_SINT },
	/* DATA_FORMAT_B8G8R8A8_UINT */ { DXGI_FORMAT_R8G8B8A8_TYPELESS, DXGI_FORMAT_R8G8B8A8_UINT },
	/* DATA_FORMAT_B8G8R8A8_SINT */ { DXGI_FORMAT_R8G8B8A8_TYPELESS, DXGI_FORMAT_R8G8B8A8_SINT },
	/* DATA_FORMAT_B8G8R8A8_SRGB */ { DXGI_FORMAT_B8G8R8A8_TYPELESS, DXGI_FORMAT_R8G8B8A8_UNORM_SRGB },
	/* DATA_FORMAT_A8B8G8R8_UNORM_PACK32 */ { DXGI_FORMAT_R8G8B8A8_TYPELESS, DXGI_FORMAT_R8G8B8A8_UNORM },
	/* DATA_FORMAT_A8B8G8R8_SNORM_PACK32 */ { DXGI_FORMAT_R8G8B8A8_TYPELESS, DXGI_FORMAT_R8G8B8A8_SNORM },
	/* DATA_FORMAT_A8B8G8R8_USCALED_PACK32 */ { DXGI_FORMAT_R8G8B8A8_TYPELESS, DXGI_FORMAT_R8G8B8A8_UINT },
	/* DATA_FORMAT_A8B8G8R8_SSCALED_PACK32 */ { DXGI_FORMAT_R8G8B8A8_TYPELESS, DXGI_FORMAT_R8G8B8A8_SINT },
	/* DATA_FORMAT_A8B8G8R8_UINT_PACK32 */ { DXGI_FORMAT_R8G8B8A8_TYPELESS, DXGI_FORMAT_R8G8B8A8_UINT },
	/* DATA_FORMAT_A8B8G8R8_SINT_PACK32 */ { DXGI_FORMAT_R8G8B8A8_TYPELESS, DXGI_FORMAT_R8G8B8A8_SINT },
	/* DATA_FORMAT_A8B8G8R8_SRGB_PACK32 */ { DXGI_FORMAT_B8G8R8A8_TYPELESS, DXGI_FORMAT_B8G8R8A8_UNORM_SRGB },
	/* DATA_FORMAT_A2R10G10B10_UNORM_PACK32 */ { DXGI_FORMAT_R10G10B10A2_TYPELESS, DXGI_FORMAT_R10G10B10A2_UNORM, D3D12_ENCODE_SHADER_4_COMPONENT_MAPPING(2, 1, 0, 3) },
	/* DATA_FORMAT_A2R10G10B10_SNORM_PACK32 */ {},
	/* DATA_FORMAT_A2R10G10B10_USCALED_PACK32 */ { DXGI_FORMAT_R10G10B10A2_TYPELESS, DXGI_FORMAT_R10G10B10A2_UINT, D3D12_ENCODE_SHADER_4_COMPONENT_MAPPING(2, 1, 0, 3) },
	/* DATA_FORMAT_A2R10G10B10_SSCALED_PACK32 */ {},
	/* DATA_FORMAT_A2R10G10B10_UINT_PACK32 */ { DXGI_FORMAT_R10G10B10A2_TYPELESS, DXGI_FORMAT_R10G10B10A2_UINT, D3D12_ENCODE_SHADER_4_COMPONENT_MAPPING(2, 1, 0, 3) },
	/* DATA_FORMAT_A2R10G10B10_SINT_PACK32 */ {},
	/* DATA_FORMAT_A2B10G10R10_UNORM_PACK32 */ { DXGI_FORMAT_R10G10B10A2_TYPELESS, DXGI_FORMAT_R10G10B10A2_UNORM },
	/* DATA_FORMAT_A2B10G10R10_SNORM_PACK32 */ {},
	/* DATA_FORMAT_A2B10G10R10_USCALED_PACK32 */ { DXGI_FORMAT_R10G10B10A2_TYPELESS, DXGI_FORMAT_R10G10B10A2_UINT },
	/* DATA_FORMAT_A2B10G10R10_SSCALED_PACK32 */ {},
	/* DATA_FORMAT_A2B10G10R10_UINT_PACK32 */ { DXGI_FORMAT_R10G10B10A2_TYPELESS, DXGI_FORMAT_R10G10B10A2_UINT },
	/* DATA_FORMAT_A2B10G10R10_SINT_PACK32 */ {},
	/* DATA_FORMAT_R16_UNORM */ { DXGI_FORMAT_R16_TYPELESS, DXGI_FORMAT_R16_UNORM },
	/* DATA_FORMAT_R16_SNORM */ { DXGI_FORMAT_R16_TYPELESS, DXGI_FORMAT_R16_SNORM },
	/* DATA_FORMAT_R16_USCALED */ { DXGI_FORMAT_R16_TYPELESS, DXGI_FORMAT_R16_UINT },
	/* DATA_FORMAT_R16_SSCALED */ { DXGI_FORMAT_R16_TYPELESS, DXGI_FORMAT_R16_SINT },
	/* DATA_FORMAT_R16_UINT */ { DXGI_FORMAT_R16_TYPELESS, DXGI_FORMAT_R16_UINT },
	/* DATA_FORMAT_R16_SINT */ { DXGI_FORMAT_R16_TYPELESS, DXGI_FORMAT_R16_SINT },
	/* DATA_FORMAT_R16_SFLOAT */ { DXGI_FORMAT_R16_TYPELESS, DXGI_FORMAT_R16_FLOAT },
	/* DATA_FORMAT_R16G16_UNORM */ { DXGI_FORMAT_R16G16_TYPELESS, DXGI_FORMAT_R16G16_UNORM },
	/* DATA_FORMAT_R16G16_SNORM */ { DXGI_FORMAT_R16G16_TYPELESS, DXGI_FORMAT_R16G16_SNORM },
	/* DATA_FORMAT_R16G16_USCALED */ { DXGI_FORMAT_R16G16_TYPELESS, DXGI_FORMAT_R16G16_UINT },
	/* DATA_FORMAT_R16G16_SSCALED */ { DXGI_FORMAT_R16G16_TYPELESS, DXGI_FORMAT_R16G16_SINT },
	/* DATA_FORMAT_R16G16_UINT */ { DXGI_FORMAT_R16G16_TYPELESS, DXGI_FORMAT_R16G16_UINT },
	/* DATA_FORMAT_R16G16_SINT */ { DXGI_FORMAT_R16G16_TYPELESS, DXGI_FORMAT_R16G16_SINT },
	/* DATA_FORMAT_R16G16_SFLOAT */ { DXGI_FORMAT_R16G16_TYPELESS, DXGI_FORMAT_R16G16_FLOAT },
	/* DATA_FORMAT_R16G16B16_UNORM */ {},
	/* DATA_FORMAT_R16G16B16_SNORM */ {},
	/* DATA_FORMAT_R16G16B16_USCALED */ {},
	/* DATA_FORMAT_R16G16B16_SSCALED */ {},
	/* DATA_FORMAT_R16G16B16_UINT */ {},
	/* DATA_FORMAT_R16G16B16_SINT */ {},
	/* DATA_FORMAT_R16G16B16_SFLOAT */ {},
	/* DATA_FORMAT_R16G16B16A16_UNORM */ { DXGI_FORMAT_R16G16B16A16_TYPELESS, DXGI_FORMAT_R16G16B16A16_UNORM },
	/* DATA_FORMAT_R16G16B16A16_SNORM */ { DXGI_FORMAT_R16G16B16A16_TYPELESS, DXGI_FORMAT_R16G16B16A16_SNORM },
	/* DATA_FORMAT_R16G16B16A16_USCALED */ { DXGI_FORMAT_R16G16B16A16_TYPELESS, DXGI_FORMAT_R16G16B16A16_UINT },
	/* DATA_FORMAT_R16G16B16A16_SSCALED */ { DXGI_FORMAT_R16G16B16A16_TYPELESS, DXGI_FORMAT_R16G16B16A16_SINT },
	/* DATA_FORMAT_R16G16B16A16_UINT */ { DXGI_FORMAT_R16G16B16A16_TYPELESS, DXGI_FORMAT_R16G16B16A16_UINT },
	/* DATA_FORMAT_R16G16B16A16_SINT */ { DXGI_FORMAT_R16G16B16A16_TYPELESS, DXGI_FORMAT_R16G16B16A16_SINT },
	/* DATA_FORMAT_R16G16B16A16_SFLOAT */ { DXGI_FORMAT_R16G16B16A16_TYPELESS, DXGI_FORMAT_R16G16B16A16_FLOAT },
	/* DATA_FORMAT_R32_UINT */ { DXGI_FORMAT_R32_TYPELESS, DXGI_FORMAT_R32_UINT },
	/* DATA_FORMAT_R32_SINT */ { DXGI_FORMAT_R32_TYPELESS, DXGI_FORMAT_R32_SINT },
	/* DATA_FORMAT_R32_SFLOAT */ { DXGI_FORMAT_R32_TYPELESS, DXGI_FORMAT_R32_FLOAT },
	/* DATA_FORMAT_R32G32_UINT */ { DXGI_FORMAT_R32G32_TYPELESS, DXGI_FORMAT_R32G32_UINT },
	/* DATA_FORMAT_R32G32_SINT */ { DXGI_FORMAT_R32G32_TYPELESS, DXGI_FORMAT_R32G32_SINT },
	/* DATA_FORMAT_R32G32_SFLOAT */ { DXGI_FORMAT_R32G32_TYPELESS, DXGI_FORMAT_R32G32_FLOAT },
	/* DATA_FORMAT_R32G32B32_UINT */ { DXGI_FORMAT_R32G32B32_TYPELESS, DXGI_FORMAT_R32G32B32_UINT },
	/* DATA_FORMAT_R32G32B32_SINT */ { DXGI_FORMAT_R32G32B32_TYPELESS, DXGI_FORMAT_R32G32B32_SINT },
	/* DATA_FORMAT_R32G32B32_SFLOAT */ { DXGI_FORMAT_R32G32B32_TYPELESS, DXGI_FORMAT_R32G32B32_FLOAT },
	/* DATA_FORMAT_R32G32B32A32_UINT */ { DXGI_FORMAT_R32G32B32A32_TYPELESS, DXGI_FORMAT_R32G32B32A32_UINT },
	/* DATA_FORMAT_R32G32B32A32_SINT */ { DXGI_FORMAT_R32G32B32A32_TYPELESS, DXGI_FORMAT_R32G32B32A32_SINT },
	/* DATA_FORMAT_R32G32B32A32_SFLOAT */ { DXGI_FORMAT_R32G32B32A32_TYPELESS, DXGI_FORMAT_R32G32B32A32_FLOAT },
	/* DATA_FORMAT_R64_UINT */ {},
	/* DATA_FORMAT_R64_SINT */ {},
	/* DATA_FORMAT_R64_SFLOAT */ {},
	/* DATA_FORMAT_R64G64_UINT */ {},
	/* DATA_FORMAT_R64G64_SINT */ {},
	/* DATA_FORMAT_R64G64_SFLOAT */ {},
	/* DATA_FORMAT_R64G64B64_UINT */ {},
	/* DATA_FORMAT_R64G64B64_SINT */ {},
	/* DATA_FORMAT_R64G64B64_SFLOAT */ {},
	/* DATA_FORMAT_R64G64B64A64_UINT */ {},
	/* DATA_FORMAT_R64G64B64A64_SINT */ {},
	/* DATA_FORMAT_R64G64B64A64_SFLOAT */ {},
	/* DATA_FORMAT_B10G11R11_UFLOAT_PACK32 */ { DXGI_FORMAT_R11G11B10_FLOAT, DXGI_FORMAT_R11G11B10_FLOAT },
	/* DATA_FORMAT_E5B9G9R9_UFLOAT_PACK32 */ { DXGI_FORMAT_R9G9B9E5_SHAREDEXP, DXGI_FORMAT_R9G9B9E5_SHAREDEXP },
	/* DATA_FORMAT_D16_UNORM */ { DXGI_FORMAT_R16_TYPELESS, DXGI_FORMAT_R16_UNORM, 0, DXGI_FORMAT_D16_UNORM },
	/* DATA_FORMAT_X8_D24_UNORM_PACK32 */ { DXGI_FORMAT_R24G8_TYPELESS, DXGI_FORMAT_UNKNOWN, 0, DXGI_FORMAT_D24_UNORM_S8_UINT },
	/* DATA_FORMAT_D32_SFLOAT */ { DXGI_FORMAT_R32_TYPELESS, DXGI_FORMAT_R32_FLOAT, D3D12_DEFAULT_SHADER_4_COMPONENT_MAPPING, DXGI_FORMAT_D32_FLOAT },
	/* DATA_FORMAT_S8_UINT */ {},
	/* DATA_FORMAT_D16_UNORM_S8_UINT */ {},
	/* DATA_FORMAT_D24_UNORM_S8_UINT */ { DXGI_FORMAT_R24G8_TYPELESS, DXGI_FORMAT_UNKNOWN, 0, DXGI_FORMAT_D24_UNORM_S8_UINT },
	/* DATA_FORMAT_D32_SFLOAT_S8_UINT */ { DXGI_FORMAT_R32G8X24_TYPELESS, DXGI_FORMAT_R32_FLOAT_X8X24_TYPELESS, D3D12_DEFAULT_SHADER_4_COMPONENT_MAPPING, DXGI_FORMAT_D32_FLOAT_S8X24_UINT },
	/* DATA_FORMAT_BC1_RGB_UNORM_BLOCK */ { DXGI_FORMAT_BC1_TYPELESS, DXGI_FORMAT_BC1_UNORM, D3D12_ENCODE_SHADER_4_COMPONENT_MAPPING(0, 1, 2, D3D12_SHADER_COMPONENT_MAPPING_FORCE_VALUE_1) },
	/* DATA_FORMAT_BC1_RGB_SRGB_BLOCK */ { DXGI_FORMAT_BC1_TYPELESS, DXGI_FORMAT_BC1_UNORM_SRGB, D3D12_ENCODE_SHADER_4_COMPONENT_MAPPING(0, 1, 2, D3D12_SHADER_COMPONENT_MAPPING_FORCE_VALUE_1) },
	/* DATA_FORMAT_BC1_RGBA_UNORM_BLOCK */ { DXGI_FORMAT_BC1_TYPELESS, DXGI_FORMAT_BC1_UNORM },
	/* DATA_FORMAT_BC1_RGBA_SRGB_BLOCK */ { DXGI_FORMAT_BC1_TYPELESS, DXGI_FORMAT_BC1_UNORM_SRGB },
	/* DATA_FORMAT_BC2_UNORM_BLOCK */ { DXGI_FORMAT_BC2_TYPELESS, DXGI_FORMAT_BC2_UNORM },
	/* DATA_FORMAT_BC2_SRGB_BLOCK */ { DXGI_FORMAT_BC2_TYPELESS, DXGI_FORMAT_BC2_UNORM_SRGB },
	/* DATA_FORMAT_BC3_UNORM_BLOCK */ { DXGI_FORMAT_BC3_TYPELESS, DXGI_FORMAT_BC3_UNORM },
	/* DATA_FORMAT_BC3_SRGB_BLOCK */ { DXGI_FORMAT_BC3_TYPELESS, DXGI_FORMAT_BC3_UNORM_SRGB },
	/* DATA_FORMAT_BC4_UNORM_BLOCK */ { DXGI_FORMAT_BC4_TYPELESS, DXGI_FORMAT_BC4_UNORM },
	/* DATA_FORMAT_BC4_SNORM_BLOCK */ { DXGI_FORMAT_BC4_TYPELESS, DXGI_FORMAT_BC4_SNORM },
	/* DATA_FORMAT_BC5_UNORM_BLOCK */ { DXGI_FORMAT_BC5_TYPELESS, DXGI_FORMAT_BC5_UNORM },
	/* DATA_FORMAT_BC5_SNORM_BLOCK */ { DXGI_FORMAT_BC5_TYPELESS, DXGI_FORMAT_BC5_SNORM },
	/* DATA_FORMAT_BC6H_UFLOAT_BLOCK */ { DXGI_FORMAT_BC6H_TYPELESS, DXGI_FORMAT_BC6H_UF16 },
	/* DATA_FORMAT_BC6H_SFLOAT_BLOCK */ { DXGI_FORMAT_BC6H_TYPELESS, DXGI_FORMAT_BC6H_SF16 },
	/* DATA_FORMAT_BC7_UNORM_BLOCK */ { DXGI_FORMAT_BC7_TYPELESS, DXGI_FORMAT_BC7_UNORM },
	/* DATA_FORMAT_BC7_SRGB_BLOCK */ { DXGI_FORMAT_BC7_TYPELESS, DXGI_FORMAT_BC7_UNORM_SRGB },
	/* DATA_FORMAT_ETC2_R8G8B8_UNORM_BLOCK */ {},
	/* DATA_FORMAT_ETC2_R8G8B8_SRGB_BLOCK */ {},
	/* DATA_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK */ {},
	/* DATA_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK */ {},
	/* DATA_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK */ {},
	/* DATA_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK */ {},
	/* DATA_FORMAT_EAC_R11_UNORM_BLOCK */ {},
	/* DATA_FORMAT_EAC_R11_SNORM_BLOCK */ {},
	/* DATA_FORMAT_EAC_R11G11_UNORM_BLOCK */ {},
	/* DATA_FORMAT_EAC_R11G11_SNORM_BLOCK */ {},
	/* DATA_FORMAT_ASTC_4x4_UNORM_BLOCK */ {},
	/* DATA_FORMAT_ASTC_4x4_SRGB_BLOCK */ {},
	/* DATA_FORMAT_ASTC_5x4_UNORM_BLOCK */ {},
	/* DATA_FORMAT_ASTC_5x4_SRGB_BLOCK */ {},
	/* DATA_FORMAT_ASTC_5x5_UNORM_BLOCK */ {},
	/* DATA_FORMAT_ASTC_5x5_SRGB_BLOCK */ {},
	/* DATA_FORMAT_ASTC_6x5_UNORM_BLOCK */ {},
	/* DATA_FORMAT_ASTC_6x5_SRGB_BLOCK */ {},
	/* DATA_FORMAT_ASTC_6x6_UNORM_BLOCK */ {},
	/* DATA_FORMAT_ASTC_6x6_SRGB_BLOCK */ {},
	/* DATA_FORMAT_ASTC_8x5_UNORM_BLOCK */ {},
	/* DATA_FORMAT_ASTC_8x5_SRGB_BLOCK */ {},
	/* DATA_FORMAT_ASTC_8x6_UNORM_BLOCK */ {},
	/* DATA_FORMAT_ASTC_8x6_SRGB_BLOCK */ {},
	/* DATA_FORMAT_ASTC_8x8_UNORM_BLOCK */ {},
	/* DATA_FORMAT_ASTC_8x8_SRGB_BLOCK */ {},
	/* DATA_FORMAT_ASTC_10x5_UNORM_BLOCK */ {},
	/* DATA_FORMAT_ASTC_10x5_SRGB_BLOCK */ {},
	/* DATA_FORMAT_ASTC_10x6_UNORM_BLOCK */ {},
	/* DATA_FORMAT_ASTC_10x6_SRGB_BLOCK */ {},
	/* DATA_FORMAT_ASTC_10x8_UNORM_BLOCK */ {},
	/* DATA_FORMAT_ASTC_10x8_SRGB_BLOCK */ {},
	/* DATA_FORMAT_ASTC_10x10_UNORM_BLOCK */ {},
	/* DATA_FORMAT_ASTC_10x10_SRGB_BLOCK */ {},
	/* DATA_FORMAT_ASTC_12x10_UNORM_BLOCK */ {},
	/* DATA_FORMAT_ASTC_12x10_SRGB_BLOCK */ {},
	/* DATA_FORMAT_ASTC_12x12_UNORM_BLOCK */ {},
	/* DATA_FORMAT_ASTC_12x12_SRGB_BLOCK */ {},
	/* DATA_FORMAT_G8B8G8R8_422_UNORM */ {},
	/* DATA_FORMAT_B8G8R8G8_422_UNORM */ {},
	/* DATA_FORMAT_G8_B8_R8_3PLANE_420_UNORM */ {},
	/* DATA_FORMAT_G8_B8R8_2PLANE_420_UNORM */ {},
	/* DATA_FORMAT_G8_B8_R8_3PLANE_422_UNORM */ {},
	/* DATA_FORMAT_G8_B8R8_2PLANE_422_UNORM */ {},
	/* DATA_FORMAT_G8_B8_R8_3PLANE_444_UNORM */ {},
	/* DATA_FORMAT_R10X6_UNORM_PACK16 */ {},
	/* DATA_FORMAT_R10X6G10X6_UNORM_2PACK16 */ {},
	/* DATA_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16 */ {},
	/* DATA_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16 */ {},
	/* DATA_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16 */ {},
	/* DATA_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16 */ {},
	/* DATA_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16 */ {},
	/* DATA_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16 */ {},
	/* DATA_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16 */ {},
	/* DATA_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16 */ {},
	/* DATA_FORMAT_R12X4_UNORM_PACK16 */ {},
	/* DATA_FORMAT_R12X4G12X4_UNORM_2PACK16 */ {},
	/* DATA_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16 */ {},
	/* DATA_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16 */ {},
	/* DATA_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16 */ {},
	/* DATA_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16 */ {},
	/* DATA_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16 */ {},
	/* DATA_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16 */ {},
	/* DATA_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16 */ {},
	/* DATA_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16 */ {},
	/* DATA_FORMAT_G16B16G16R16_422_UNORM */ {},
	/* DATA_FORMAT_B16G16R16G16_422_UNORM */ {},
	/* DATA_FORMAT_G16_B16_R16_3PLANE_420_UNORM */ {},
	/* DATA_FORMAT_G16_B16R16_2PLANE_420_UNORM */ {},
	/* DATA_FORMAT_G16_B16_R16_3PLANE_422_UNORM */ {},
	/* DATA_FORMAT_G16_B16R16_2PLANE_422_UNORM */ {},
	/* DATA_FORMAT_G16_B16_R16_3PLANE_444_UNORM */ {},
};

const char *RenderingDeviceD3D12::named_formats[RenderingDevice::DATA_FORMAT_MAX] = {
	"R4G4_Unorm_Pack8",
	"R4G4B4A4_Unorm_Pack16",
	"B4G4R4A4_Unorm_Pack16",
	"R5G6B5_Unorm_Pack16",
	"B5G6R5_Unorm_Pack16",
	"R5G5B5A1_Unorm_Pack16",
	"B5G5R5A1_Unorm_Pack16",
	"A1R5G5B5_Unorm_Pack16",
	"R8_Unorm",
	"R8_Snorm",
	"R8_Uscaled",
	"R8_Sscaled",
	"R8_Uint",
	"R8_Sint",
	"R8_Srgb",
	"R8G8_Unorm",
	"R8G8_Snorm",
	"R8G8_Uscaled",
	"R8G8_Sscaled",
	"R8G8_Uint",
	"R8G8_Sint",
	"R8G8_Srgb",
	"R8G8B8_Unorm",
	"R8G8B8_Snorm",
	"R8G8B8_Uscaled",
	"R8G8B8_Sscaled",
	"R8G8B8_Uint",
	"R8G8B8_Sint",
	"R8G8B8_Srgb",
	"B8G8R8_Unorm",
	"B8G8R8_Snorm",
	"B8G8R8_Uscaled",
	"B8G8R8_Sscaled",
	"B8G8R8_Uint",
	"B8G8R8_Sint",
	"B8G8R8_Srgb",
	"R8G8B8A8_Unorm",
	"R8G8B8A8_Snorm",
	"R8G8B8A8_Uscaled",
	"R8G8B8A8_Sscaled",
	"R8G8B8A8_Uint",
	"R8G8B8A8_Sint",
	"R8G8B8A8_Srgb",
	"B8G8R8A8_Unorm",
	"B8G8R8A8_Snorm",
	"B8G8R8A8_Uscaled",
	"B8G8R8A8_Sscaled",
	"B8G8R8A8_Uint",
	"B8G8R8A8_Sint",
	"B8G8R8A8_Srgb",
	"A8B8G8R8_Unorm_Pack32",
	"A8B8G8R8_Snorm_Pack32",
	"A8B8G8R8_Uscaled_Pack32",
	"A8B8G8R8_Sscaled_Pack32",
	"A8B8G8R8_Uint_Pack32",
	"A8B8G8R8_Sint_Pack32",
	"A8B8G8R8_Srgb_Pack32",
	"A2R10G10B10_Unorm_Pack32",
	"A2R10G10B10_Snorm_Pack32",
	"A2R10G10B10_Uscaled_Pack32",
	"A2R10G10B10_Sscaled_Pack32",
	"A2R10G10B10_Uint_Pack32",
	"A2R10G10B10_Sint_Pack32",
	"A2B10G10R10_Unorm_Pack32",
	"A2B10G10R10_Snorm_Pack32",
	"A2B10G10R10_Uscaled_Pack32",
	"A2B10G10R10_Sscaled_Pack32",
	"A2B10G10R10_Uint_Pack32",
	"A2B10G10R10_Sint_Pack32",
	"R16_Unorm",
	"R16_Snorm",
	"R16_Uscaled",
	"R16_Sscaled",
	"R16_Uint",
	"R16_Sint",
	"R16_Sfloat",
	"R16G16_Unorm",
	"R16G16_Snorm",
	"R16G16_Uscaled",
	"R16G16_Sscaled",
	"R16G16_Uint",
	"R16G16_Sint",
	"R16G16_Sfloat",
	"R16G16B16_Unorm",
	"R16G16B16_Snorm",
	"R16G16B16_Uscaled",
	"R16G16B16_Sscaled",
	"R16G16B16_Uint",
	"R16G16B16_Sint",
	"R16G16B16_Sfloat",
	"R16G16B16A16_Unorm",
	"R16G16B16A16_Snorm",
	"R16G16B16A16_Uscaled",
	"R16G16B16A16_Sscaled",
	"R16G16B16A16_Uint",
	"R16G16B16A16_Sint",
	"R16G16B16A16_Sfloat",
	"R32_Uint",
	"R32_Sint",
	"R32_Sfloat",
	"R32G32_Uint",
	"R32G32_Sint",
	"R32G32_Sfloat",
	"R32G32B32_Uint",
	"R32G32B32_Sint",
	"R32G32B32_Sfloat",
	"R32G32B32A32_Uint",
	"R32G32B32A32_Sint",
	"R32G32B32A32_Sfloat",
	"R64_Uint",
	"R64_Sint",
	"R64_Sfloat",
	"R64G64_Uint",
	"R64G64_Sint",
	"R64G64_Sfloat",
	"R64G64B64_Uint",
	"R64G64B64_Sint",
	"R64G64B64_Sfloat",
	"R64G64B64A64_Uint",
	"R64G64B64A64_Sint",
	"R64G64B64A64_Sfloat",
	"B10G11R11_Ufloat_Pack32",
	"E5B9G9R9_Ufloat_Pack32",
	"D16_Unorm",
	"X8_D24_Unorm_Pack32",
	"D32_Sfloat",
	"S8_Uint",
	"D16_Unorm_S8_Uint",
	"D24_Unorm_S8_Uint",
	"D32_Sfloat_S8_Uint",
	"Bc1_Rgb_Unorm_Block",
	"Bc1_Rgb_Srgb_Block",
	"Bc1_Rgba_Unorm_Block",
	"Bc1_Rgba_Srgb_Block",
	"Bc2_Unorm_Block",
	"Bc2_Srgb_Block",
	"Bc3_Unorm_Block",
	"Bc3_Srgb_Block",
	"Bc4_Unorm_Block",
	"Bc4_Snorm_Block",
	"Bc5_Unorm_Block",
	"Bc5_Snorm_Block",
	"Bc6H_Ufloat_Block",
	"Bc6H_Sfloat_Block",
	"Bc7_Unorm_Block",
	"Bc7_Srgb_Block",
	"Etc2_R8G8B8_Unorm_Block",
	"Etc2_R8G8B8_Srgb_Block",
	"Etc2_R8G8B8A1_Unorm_Block",
	"Etc2_R8G8B8A1_Srgb_Block",
	"Etc2_R8G8B8A8_Unorm_Block",
	"Etc2_R8G8B8A8_Srgb_Block",
	"Eac_R11_Unorm_Block",
	"Eac_R11_Snorm_Block",
	"Eac_R11G11_Unorm_Block",
	"Eac_R11G11_Snorm_Block",
	"Astc_4X4_Unorm_Block",
	"Astc_4X4_Srgb_Block",
	"Astc_5X4_Unorm_Block",
	"Astc_5X4_Srgb_Block",
	"Astc_5X5_Unorm_Block",
	"Astc_5X5_Srgb_Block",
	"Astc_6X5_Unorm_Block",
	"Astc_6X5_Srgb_Block",
	"Astc_6X6_Unorm_Block",
	"Astc_6X6_Srgb_Block",
	"Astc_8X5_Unorm_Block",
	"Astc_8X5_Srgb_Block",
	"Astc_8X6_Unorm_Block",
	"Astc_8X6_Srgb_Block",
	"Astc_8X8_Unorm_Block",
	"Astc_8X8_Srgb_Block",
	"Astc_10X5_Unorm_Block",
	"Astc_10X5_Srgb_Block",
	"Astc_10X6_Unorm_Block",
	"Astc_10X6_Srgb_Block",
	"Astc_10X8_Unorm_Block",
	"Astc_10X8_Srgb_Block",
	"Astc_10X10_Unorm_Block",
	"Astc_10X10_Srgb_Block",
	"Astc_12X10_Unorm_Block",
	"Astc_12X10_Srgb_Block",
	"Astc_12X12_Unorm_Block",
	"Astc_12X12_Srgb_Block",
	"G8B8G8R8_422_Unorm",
	"B8G8R8G8_422_Unorm",
	"G8_B8_R8_3Plane_420_Unorm",
	"G8_B8R8_2Plane_420_Unorm",
	"G8_B8_R8_3Plane_422_Unorm",
	"G8_B8R8_2Plane_422_Unorm",
	"G8_B8_R8_3Plane_444_Unorm",
	"R10X6_Unorm_Pack16",
	"R10X6G10X6_Unorm_2Pack16",
	"R10X6G10X6B10X6A10X6_Unorm_4Pack16",
	"G10X6B10X6G10X6R10X6_422_Unorm_4Pack16",
	"B10X6G10X6R10X6G10X6_422_Unorm_4Pack16",
	"G10X6_B10X6_R10X6_3Plane_420_Unorm_3Pack16",
	"G10X6_B10X6R10X6_2Plane_420_Unorm_3Pack16",
	"G10X6_B10X6_R10X6_3Plane_422_Unorm_3Pack16",
	"G10X6_B10X6R10X6_2Plane_422_Unorm_3Pack16",
	"G10X6_B10X6_R10X6_3Plane_444_Unorm_3Pack16",
	"R12X4_Unorm_Pack16",
	"R12X4G12X4_Unorm_2Pack16",
	"R12X4G12X4B12X4A12X4_Unorm_4Pack16",
	"G12X4B12X4G12X4R12X4_422_Unorm_4Pack16",
	"B12X4G12X4R12X4G12X4_422_Unorm_4Pack16",
	"G12X4_B12X4_R12X4_3Plane_420_Unorm_3Pack16",
	"G12X4_B12X4R12X4_2Plane_420_Unorm_3Pack16",
	"G12X4_B12X4_R12X4_3Plane_422_Unorm_3Pack16",
	"G12X4_B12X4R12X4_2Plane_422_Unorm_3Pack16",
	"G12X4_B12X4_R12X4_3Plane_444_Unorm_3Pack16",
	"G16B16G16R16_422_Unorm",
	"B16G16R16G16_422_Unorm",
	"G16_B16_R16_3Plane_420_Unorm",
	"G16_B16R16_2Plane_420_Unorm",
	"G16_B16_R16_3Plane_422_Unorm",
	"G16_B16R16_2Plane_422_Unorm",
	"G16_B16_R16_3Plane_444_Unorm",
};

int RenderingDeviceD3D12::get_format_vertex_size(DataFormat p_format) {
	switch (p_format) {
		case DATA_FORMAT_R8_UNORM:
		case DATA_FORMAT_R8_SNORM:
		case DATA_FORMAT_R8_UINT:
		case DATA_FORMAT_R8_SINT:
		case DATA_FORMAT_R8G8_UNORM:
		case DATA_FORMAT_R8G8_SNORM:
		case DATA_FORMAT_R8G8_UINT:
		case DATA_FORMAT_R8G8_SINT:
		case DATA_FORMAT_R8G8B8_UNORM:
		case DATA_FORMAT_R8G8B8_SNORM:
		case DATA_FORMAT_R8G8B8_UINT:
		case DATA_FORMAT_R8G8B8_SINT:
		case DATA_FORMAT_B8G8R8_UNORM:
		case DATA_FORMAT_B8G8R8_SNORM:
		case DATA_FORMAT_B8G8R8_UINT:
		case DATA_FORMAT_B8G8R8_SINT:
		case DATA_FORMAT_R8G8B8A8_UNORM:
		case DATA_FORMAT_R8G8B8A8_SNORM:
		case DATA_FORMAT_R8G8B8A8_UINT:
		case DATA_FORMAT_R8G8B8A8_SINT:
		case DATA_FORMAT_B8G8R8A8_UNORM:
		case DATA_FORMAT_B8G8R8A8_SNORM:
		case DATA_FORMAT_B8G8R8A8_UINT:
		case DATA_FORMAT_B8G8R8A8_SINT:
		case DATA_FORMAT_A2B10G10R10_UNORM_PACK32:
			return 4;
		case DATA_FORMAT_R16_UNORM:
		case DATA_FORMAT_R16_SNORM:
		case DATA_FORMAT_R16_UINT:
		case DATA_FORMAT_R16_SINT:
		case DATA_FORMAT_R16_SFLOAT:
			return 4;
		case DATA_FORMAT_R16G16_UNORM:
		case DATA_FORMAT_R16G16_SNORM:
		case DATA_FORMAT_R16G16_UINT:
		case DATA_FORMAT_R16G16_SINT:
		case DATA_FORMAT_R16G16_SFLOAT:
			return 4;
		case DATA_FORMAT_R16G16B16_UNORM:
		case DATA_FORMAT_R16G16B16_SNORM:
		case DATA_FORMAT_R16G16B16_UINT:
		case DATA_FORMAT_R16G16B16_SINT:
		case DATA_FORMAT_R16G16B16_SFLOAT:
			return 8;
		case DATA_FORMAT_R16G16B16A16_UNORM:
		case DATA_FORMAT_R16G16B16A16_SNORM:
		case DATA_FORMAT_R16G16B16A16_UINT:
		case DATA_FORMAT_R16G16B16A16_SINT:
		case DATA_FORMAT_R16G16B16A16_SFLOAT:
			return 8;
		case DATA_FORMAT_R32_UINT:
		case DATA_FORMAT_R32_SINT:
		case DATA_FORMAT_R32_SFLOAT:
			return 4;
		case DATA_FORMAT_R32G32_UINT:
		case DATA_FORMAT_R32G32_SINT:
		case DATA_FORMAT_R32G32_SFLOAT:
			return 8;
		case DATA_FORMAT_R32G32B32_UINT:
		case DATA_FORMAT_R32G32B32_SINT:
		case DATA_FORMAT_R32G32B32_SFLOAT:
			return 12;
		case DATA_FORMAT_R32G32B32A32_UINT:
		case DATA_FORMAT_R32G32B32A32_SINT:
		case DATA_FORMAT_R32G32B32A32_SFLOAT:
			return 16;
		case DATA_FORMAT_R64_UINT:
		case DATA_FORMAT_R64_SINT:
		case DATA_FORMAT_R64_SFLOAT:
			return 8;
		case DATA_FORMAT_R64G64_UINT:
		case DATA_FORMAT_R64G64_SINT:
		case DATA_FORMAT_R64G64_SFLOAT:
			return 16;
		case DATA_FORMAT_R64G64B64_UINT:
		case DATA_FORMAT_R64G64B64_SINT:
		case DATA_FORMAT_R64G64B64_SFLOAT:
			return 24;
		case DATA_FORMAT_R64G64B64A64_UINT:
		case DATA_FORMAT_R64G64B64A64_SINT:
		case DATA_FORMAT_R64G64B64A64_SFLOAT:
			return 32;
		default:
			return 0;
	}
}

uint32_t RenderingDeviceD3D12::get_image_format_pixel_size(DataFormat p_format) {
	switch (p_format) {
		case DATA_FORMAT_R4G4_UNORM_PACK8:
			return 1;
		case DATA_FORMAT_R4G4B4A4_UNORM_PACK16:
		case DATA_FORMAT_B4G4R4A4_UNORM_PACK16:
		case DATA_FORMAT_R5G6B5_UNORM_PACK16:
		case DATA_FORMAT_B5G6R5_UNORM_PACK16:
		case DATA_FORMAT_R5G5B5A1_UNORM_PACK16:
		case DATA_FORMAT_B5G5R5A1_UNORM_PACK16:
		case DATA_FORMAT_A1R5G5B5_UNORM_PACK16:
			return 2;
		case DATA_FORMAT_R8_UNORM:
		case DATA_FORMAT_R8_SNORM:
		case DATA_FORMAT_R8_USCALED:
		case DATA_FORMAT_R8_SSCALED:
		case DATA_FORMAT_R8_UINT:
		case DATA_FORMAT_R8_SINT:
		case DATA_FORMAT_R8_SRGB:
			return 1;
		case DATA_FORMAT_R8G8_UNORM:
		case DATA_FORMAT_R8G8_SNORM:
		case DATA_FORMAT_R8G8_USCALED:
		case DATA_FORMAT_R8G8_SSCALED:
		case DATA_FORMAT_R8G8_UINT:
		case DATA_FORMAT_R8G8_SINT:
		case DATA_FORMAT_R8G8_SRGB:
			return 2;
		case DATA_FORMAT_R8G8B8_UNORM:
		case DATA_FORMAT_R8G8B8_SNORM:
		case DATA_FORMAT_R8G8B8_USCALED:
		case DATA_FORMAT_R8G8B8_SSCALED:
		case DATA_FORMAT_R8G8B8_UINT:
		case DATA_FORMAT_R8G8B8_SINT:
		case DATA_FORMAT_R8G8B8_SRGB:
		case DATA_FORMAT_B8G8R8_UNORM:
		case DATA_FORMAT_B8G8R8_SNORM:
		case DATA_FORMAT_B8G8R8_USCALED:
		case DATA_FORMAT_B8G8R8_SSCALED:
		case DATA_FORMAT_B8G8R8_UINT:
		case DATA_FORMAT_B8G8R8_SINT:
		case DATA_FORMAT_B8G8R8_SRGB:
			return 3;
		case DATA_FORMAT_R8G8B8A8_UNORM:
		case DATA_FORMAT_R8G8B8A8_SNORM:
		case DATA_FORMAT_R8G8B8A8_USCALED:
		case DATA_FORMAT_R8G8B8A8_SSCALED:
		case DATA_FORMAT_R8G8B8A8_UINT:
		case DATA_FORMAT_R8G8B8A8_SINT:
		case DATA_FORMAT_R8G8B8A8_SRGB:
		case DATA_FORMAT_B8G8R8A8_UNORM:
		case DATA_FORMAT_B8G8R8A8_SNORM:
		case DATA_FORMAT_B8G8R8A8_USCALED:
		case DATA_FORMAT_B8G8R8A8_SSCALED:
		case DATA_FORMAT_B8G8R8A8_UINT:
		case DATA_FORMAT_B8G8R8A8_SINT:
		case DATA_FORMAT_B8G8R8A8_SRGB:
			return 4;
		case DATA_FORMAT_A8B8G8R8_UNORM_PACK32:
		case DATA_FORMAT_A8B8G8R8_SNORM_PACK32:
		case DATA_FORMAT_A8B8G8R8_USCALED_PACK32:
		case DATA_FORMAT_A8B8G8R8_SSCALED_PACK32:
		case DATA_FORMAT_A8B8G8R8_UINT_PACK32:
		case DATA_FORMAT_A8B8G8R8_SINT_PACK32:
		case DATA_FORMAT_A8B8G8R8_SRGB_PACK32:
		case DATA_FORMAT_A2R10G10B10_UNORM_PACK32:
		case DATA_FORMAT_A2R10G10B10_SNORM_PACK32:
		case DATA_FORMAT_A2R10G10B10_USCALED_PACK32:
		case DATA_FORMAT_A2R10G10B10_SSCALED_PACK32:
		case DATA_FORMAT_A2R10G10B10_UINT_PACK32:
		case DATA_FORMAT_A2R10G10B10_SINT_PACK32:
		case DATA_FORMAT_A2B10G10R10_UNORM_PACK32:
		case DATA_FORMAT_A2B10G10R10_SNORM_PACK32:
		case DATA_FORMAT_A2B10G10R10_USCALED_PACK32:
		case DATA_FORMAT_A2B10G10R10_SSCALED_PACK32:
		case DATA_FORMAT_A2B10G10R10_UINT_PACK32:
		case DATA_FORMAT_A2B10G10R10_SINT_PACK32:
			return 4;
		case DATA_FORMAT_R16_UNORM:
		case DATA_FORMAT_R16_SNORM:
		case DATA_FORMAT_R16_USCALED:
		case DATA_FORMAT_R16_SSCALED:
		case DATA_FORMAT_R16_UINT:
		case DATA_FORMAT_R16_SINT:
		case DATA_FORMAT_R16_SFLOAT:
			return 2;
		case DATA_FORMAT_R16G16_UNORM:
		case DATA_FORMAT_R16G16_SNORM:
		case DATA_FORMAT_R16G16_USCALED:
		case DATA_FORMAT_R16G16_SSCALED:
		case DATA_FORMAT_R16G16_UINT:
		case DATA_FORMAT_R16G16_SINT:
		case DATA_FORMAT_R16G16_SFLOAT:
			return 4;
		case DATA_FORMAT_R16G16B16_UNORM:
		case DATA_FORMAT_R16G16B16_SNORM:
		case DATA_FORMAT_R16G16B16_USCALED:
		case DATA_FORMAT_R16G16B16_SSCALED:
		case DATA_FORMAT_R16G16B16_UINT:
		case DATA_FORMAT_R16G16B16_SINT:
		case DATA_FORMAT_R16G16B16_SFLOAT:
			return 6;
		case DATA_FORMAT_R16G16B16A16_UNORM:
		case DATA_FORMAT_R16G16B16A16_SNORM:
		case DATA_FORMAT_R16G16B16A16_USCALED:
		case DATA_FORMAT_R16G16B16A16_SSCALED:
		case DATA_FORMAT_R16G16B16A16_UINT:
		case DATA_FORMAT_R16G16B16A16_SINT:
		case DATA_FORMAT_R16G16B16A16_SFLOAT:
			return 8;
		case DATA_FORMAT_R32_UINT:
		case DATA_FORMAT_R32_SINT:
		case DATA_FORMAT_R32_SFLOAT:
			return 4;
		case DATA_FORMAT_R32G32_UINT:
		case DATA_FORMAT_R32G32_SINT:
		case DATA_FORMAT_R32G32_SFLOAT:
			return 8;
		case DATA_FORMAT_R32G32B32_UINT:
		case DATA_FORMAT_R32G32B32_SINT:
		case DATA_FORMAT_R32G32B32_SFLOAT:
			return 12;
		case DATA_FORMAT_R32G32B32A32_UINT:
		case DATA_FORMAT_R32G32B32A32_SINT:
		case DATA_FORMAT_R32G32B32A32_SFLOAT:
			return 16;
		case DATA_FORMAT_R64_UINT:
		case DATA_FORMAT_R64_SINT:
		case DATA_FORMAT_R64_SFLOAT:
			return 8;
		case DATA_FORMAT_R64G64_UINT:
		case DATA_FORMAT_R64G64_SINT:
		case DATA_FORMAT_R64G64_SFLOAT:
			return 16;
		case DATA_FORMAT_R64G64B64_UINT:
		case DATA_FORMAT_R64G64B64_SINT:
		case DATA_FORMAT_R64G64B64_SFLOAT:
			return 24;
		case DATA_FORMAT_R64G64B64A64_UINT:
		case DATA_FORMAT_R64G64B64A64_SINT:
		case DATA_FORMAT_R64G64B64A64_SFLOAT:
			return 32;
		case DATA_FORMAT_B10G11R11_UFLOAT_PACK32:
		case DATA_FORMAT_E5B9G9R9_UFLOAT_PACK32:
			return 4;
		case DATA_FORMAT_D16_UNORM:
			return 2;
		case DATA_FORMAT_X8_D24_UNORM_PACK32:
			return 4;
		case DATA_FORMAT_D32_SFLOAT:
			return 4;
		case DATA_FORMAT_S8_UINT:
			return 1;
		case DATA_FORMAT_D16_UNORM_S8_UINT:
			return 4;
		case DATA_FORMAT_D24_UNORM_S8_UINT:
			return 4;
		case DATA_FORMAT_D32_SFLOAT_S8_UINT:
			return 5; // ?
		case DATA_FORMAT_BC1_RGB_UNORM_BLOCK:
		case DATA_FORMAT_BC1_RGB_SRGB_BLOCK:
		case DATA_FORMAT_BC1_RGBA_UNORM_BLOCK:
		case DATA_FORMAT_BC1_RGBA_SRGB_BLOCK:
		case DATA_FORMAT_BC2_UNORM_BLOCK:
		case DATA_FORMAT_BC2_SRGB_BLOCK:
		case DATA_FORMAT_BC3_UNORM_BLOCK:
		case DATA_FORMAT_BC3_SRGB_BLOCK:
		case DATA_FORMAT_BC4_UNORM_BLOCK:
		case DATA_FORMAT_BC4_SNORM_BLOCK:
		case DATA_FORMAT_BC5_UNORM_BLOCK:
		case DATA_FORMAT_BC5_SNORM_BLOCK:
		case DATA_FORMAT_BC6H_UFLOAT_BLOCK:
		case DATA_FORMAT_BC6H_SFLOAT_BLOCK:
		case DATA_FORMAT_BC7_UNORM_BLOCK:
		case DATA_FORMAT_BC7_SRGB_BLOCK:
			return 1;
		case DATA_FORMAT_ETC2_R8G8B8_UNORM_BLOCK:
		case DATA_FORMAT_ETC2_R8G8B8_SRGB_BLOCK:
		case DATA_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK:
		case DATA_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK:
		case DATA_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK:
		case DATA_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK:
			return 1;
		case DATA_FORMAT_EAC_R11_UNORM_BLOCK:
		case DATA_FORMAT_EAC_R11_SNORM_BLOCK:
		case DATA_FORMAT_EAC_R11G11_UNORM_BLOCK:
		case DATA_FORMAT_EAC_R11G11_SNORM_BLOCK:
			return 1;
		case DATA_FORMAT_ASTC_4x4_UNORM_BLOCK:
		case DATA_FORMAT_ASTC_4x4_SRGB_BLOCK:
		case DATA_FORMAT_ASTC_5x4_UNORM_BLOCK:
		case DATA_FORMAT_ASTC_5x4_SRGB_BLOCK:
		case DATA_FORMAT_ASTC_5x5_UNORM_BLOCK:
		case DATA_FORMAT_ASTC_5x5_SRGB_BLOCK:
		case DATA_FORMAT_ASTC_6x5_UNORM_BLOCK:
		case DATA_FORMAT_ASTC_6x5_SRGB_BLOCK:
		case DATA_FORMAT_ASTC_6x6_UNORM_BLOCK:
		case DATA_FORMAT_ASTC_6x6_SRGB_BLOCK:
		case DATA_FORMAT_ASTC_8x5_UNORM_BLOCK:
		case DATA_FORMAT_ASTC_8x5_SRGB_BLOCK:
		case DATA_FORMAT_ASTC_8x6_UNORM_BLOCK:
		case DATA_FORMAT_ASTC_8x6_SRGB_BLOCK:
		case DATA_FORMAT_ASTC_8x8_UNORM_BLOCK:
		case DATA_FORMAT_ASTC_8x8_SRGB_BLOCK:
		case DATA_FORMAT_ASTC_10x5_UNORM_BLOCK:
		case DATA_FORMAT_ASTC_10x5_SRGB_BLOCK:
		case DATA_FORMAT_ASTC_10x6_UNORM_BLOCK:
		case DATA_FORMAT_ASTC_10x6_SRGB_BLOCK:
		case DATA_FORMAT_ASTC_10x8_UNORM_BLOCK:
		case DATA_FORMAT_ASTC_10x8_SRGB_BLOCK:
		case DATA_FORMAT_ASTC_10x10_UNORM_BLOCK:
		case DATA_FORMAT_ASTC_10x10_SRGB_BLOCK:
		case DATA_FORMAT_ASTC_12x10_UNORM_BLOCK:
		case DATA_FORMAT_ASTC_12x10_SRGB_BLOCK:
		case DATA_FORMAT_ASTC_12x12_UNORM_BLOCK:
		case DATA_FORMAT_ASTC_12x12_SRGB_BLOCK:
			return 1;
		case DATA_FORMAT_G8B8G8R8_422_UNORM:
		case DATA_FORMAT_B8G8R8G8_422_UNORM:
			return 4;
		case DATA_FORMAT_G8_B8_R8_3PLANE_420_UNORM:
		case DATA_FORMAT_G8_B8R8_2PLANE_420_UNORM:
		case DATA_FORMAT_G8_B8_R8_3PLANE_422_UNORM:
		case DATA_FORMAT_G8_B8R8_2PLANE_422_UNORM:
		case DATA_FORMAT_G8_B8_R8_3PLANE_444_UNORM:
			return 4;
		case DATA_FORMAT_R10X6_UNORM_PACK16:
		case DATA_FORMAT_R10X6G10X6_UNORM_2PACK16:
		case DATA_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16:
		case DATA_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16:
		case DATA_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16:
		case DATA_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16:
		case DATA_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16:
		case DATA_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16:
		case DATA_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16:
		case DATA_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16:
		case DATA_FORMAT_R12X4_UNORM_PACK16:
		case DATA_FORMAT_R12X4G12X4_UNORM_2PACK16:
		case DATA_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16:
		case DATA_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16:
		case DATA_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16:
		case DATA_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16:
		case DATA_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16:
		case DATA_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16:
		case DATA_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16:
		case DATA_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16:
			return 2;
		case DATA_FORMAT_G16B16G16R16_422_UNORM:
		case DATA_FORMAT_B16G16R16G16_422_UNORM:
		case DATA_FORMAT_G16_B16_R16_3PLANE_420_UNORM:
		case DATA_FORMAT_G16_B16R16_2PLANE_420_UNORM:
		case DATA_FORMAT_G16_B16_R16_3PLANE_422_UNORM:
		case DATA_FORMAT_G16_B16R16_2PLANE_422_UNORM:
		case DATA_FORMAT_G16_B16_R16_3PLANE_444_UNORM:
			return 8;
		default: {
			ERR_PRINT("Format not handled, bug");
		}
	}

	return 1;
}

// https://www.khronos.org/registry/DataFormat/specs/1.1/dataformat.1.1.pdf

void RenderingDeviceD3D12::get_compressed_image_format_block_dimensions(DataFormat p_format, uint32_t &r_w, uint32_t &r_h) {
	switch (p_format) {
		case DATA_FORMAT_BC1_RGB_UNORM_BLOCK:
		case DATA_FORMAT_BC1_RGB_SRGB_BLOCK:
		case DATA_FORMAT_BC1_RGBA_UNORM_BLOCK:
		case DATA_FORMAT_BC1_RGBA_SRGB_BLOCK:
		case DATA_FORMAT_BC2_UNORM_BLOCK:
		case DATA_FORMAT_BC2_SRGB_BLOCK:
		case DATA_FORMAT_BC3_UNORM_BLOCK:
		case DATA_FORMAT_BC3_SRGB_BLOCK:
		case DATA_FORMAT_BC4_UNORM_BLOCK:
		case DATA_FORMAT_BC4_SNORM_BLOCK:
		case DATA_FORMAT_BC5_UNORM_BLOCK:
		case DATA_FORMAT_BC5_SNORM_BLOCK:
		case DATA_FORMAT_BC6H_UFLOAT_BLOCK:
		case DATA_FORMAT_BC6H_SFLOAT_BLOCK:
		case DATA_FORMAT_BC7_UNORM_BLOCK:
		case DATA_FORMAT_BC7_SRGB_BLOCK:
		case DATA_FORMAT_ETC2_R8G8B8_UNORM_BLOCK:
		case DATA_FORMAT_ETC2_R8G8B8_SRGB_BLOCK:
		case DATA_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK:
		case DATA_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK:
		case DATA_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK:
		case DATA_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK:
		case DATA_FORMAT_EAC_R11_UNORM_BLOCK:
		case DATA_FORMAT_EAC_R11_SNORM_BLOCK:
		case DATA_FORMAT_EAC_R11G11_UNORM_BLOCK:
		case DATA_FORMAT_EAC_R11G11_SNORM_BLOCK:
		case DATA_FORMAT_ASTC_4x4_UNORM_BLOCK: // Again, not sure about astc.
		case DATA_FORMAT_ASTC_4x4_SRGB_BLOCK:
		case DATA_FORMAT_ASTC_5x4_UNORM_BLOCK:
		case DATA_FORMAT_ASTC_5x4_SRGB_BLOCK:
		case DATA_FORMAT_ASTC_5x5_UNORM_BLOCK:
		case DATA_FORMAT_ASTC_5x5_SRGB_BLOCK:
		case DATA_FORMAT_ASTC_6x5_UNORM_BLOCK:
		case DATA_FORMAT_ASTC_6x5_SRGB_BLOCK:
		case DATA_FORMAT_ASTC_6x6_UNORM_BLOCK:
		case DATA_FORMAT_ASTC_6x6_SRGB_BLOCK:
		case DATA_FORMAT_ASTC_8x5_UNORM_BLOCK:
		case DATA_FORMAT_ASTC_8x5_SRGB_BLOCK:
		case DATA_FORMAT_ASTC_8x6_UNORM_BLOCK:
		case DATA_FORMAT_ASTC_8x6_SRGB_BLOCK:
		case DATA_FORMAT_ASTC_8x8_UNORM_BLOCK:
		case DATA_FORMAT_ASTC_8x8_SRGB_BLOCK:
		case DATA_FORMAT_ASTC_10x5_UNORM_BLOCK:
		case DATA_FORMAT_ASTC_10x5_SRGB_BLOCK:
		case DATA_FORMAT_ASTC_10x6_UNORM_BLOCK:
		case DATA_FORMAT_ASTC_10x6_SRGB_BLOCK:
		case DATA_FORMAT_ASTC_10x8_UNORM_BLOCK:
		case DATA_FORMAT_ASTC_10x8_SRGB_BLOCK:
		case DATA_FORMAT_ASTC_10x10_UNORM_BLOCK:
		case DATA_FORMAT_ASTC_10x10_SRGB_BLOCK:
		case DATA_FORMAT_ASTC_12x10_UNORM_BLOCK:
		case DATA_FORMAT_ASTC_12x10_SRGB_BLOCK:
		case DATA_FORMAT_ASTC_12x12_UNORM_BLOCK:
		case DATA_FORMAT_ASTC_12x12_SRGB_BLOCK:
			r_w = 4;
			r_h = 4;
			return;
		default: {
			r_w = 1;
			r_h = 1;
		}
	}
}

uint32_t RenderingDeviceD3D12::get_compressed_image_format_block_byte_size(DataFormat p_format) {
	switch (p_format) {
		case DATA_FORMAT_BC1_RGB_UNORM_BLOCK:
		case DATA_FORMAT_BC1_RGB_SRGB_BLOCK:
		case DATA_FORMAT_BC1_RGBA_UNORM_BLOCK:
		case DATA_FORMAT_BC1_RGBA_SRGB_BLOCK:
			return 8;
		case DATA_FORMAT_BC2_UNORM_BLOCK:
		case DATA_FORMAT_BC2_SRGB_BLOCK:
			return 16;
		case DATA_FORMAT_BC3_UNORM_BLOCK:
		case DATA_FORMAT_BC3_SRGB_BLOCK:
			return 16;
		case DATA_FORMAT_BC4_UNORM_BLOCK:
		case DATA_FORMAT_BC4_SNORM_BLOCK:
			return 8;
		case DATA_FORMAT_BC5_UNORM_BLOCK:
		case DATA_FORMAT_BC5_SNORM_BLOCK:
			return 16;
		case DATA_FORMAT_BC6H_UFLOAT_BLOCK:
		case DATA_FORMAT_BC6H_SFLOAT_BLOCK:
			return 16;
		case DATA_FORMAT_BC7_UNORM_BLOCK:
		case DATA_FORMAT_BC7_SRGB_BLOCK:
			return 16;
		case DATA_FORMAT_ETC2_R8G8B8_UNORM_BLOCK:
		case DATA_FORMAT_ETC2_R8G8B8_SRGB_BLOCK:
			return 8;
		case DATA_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK:
		case DATA_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK:
			return 8;
		case DATA_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK:
		case DATA_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK:
			return 16;
		case DATA_FORMAT_EAC_R11_UNORM_BLOCK:
		case DATA_FORMAT_EAC_R11_SNORM_BLOCK:
			return 8;
		case DATA_FORMAT_EAC_R11G11_UNORM_BLOCK:
		case DATA_FORMAT_EAC_R11G11_SNORM_BLOCK:
			return 16;
		case DATA_FORMAT_ASTC_4x4_UNORM_BLOCK: // Again, not sure about astc.
		case DATA_FORMAT_ASTC_4x4_SRGB_BLOCK:
		case DATA_FORMAT_ASTC_5x4_UNORM_BLOCK:
		case DATA_FORMAT_ASTC_5x4_SRGB_BLOCK:
		case DATA_FORMAT_ASTC_5x5_UNORM_BLOCK:
		case DATA_FORMAT_ASTC_5x5_SRGB_BLOCK:
		case DATA_FORMAT_ASTC_6x5_UNORM_BLOCK:
		case DATA_FORMAT_ASTC_6x5_SRGB_BLOCK:
		case DATA_FORMAT_ASTC_6x6_UNORM_BLOCK:
		case DATA_FORMAT_ASTC_6x6_SRGB_BLOCK:
		case DATA_FORMAT_ASTC_8x5_UNORM_BLOCK:
		case DATA_FORMAT_ASTC_8x5_SRGB_BLOCK:
		case DATA_FORMAT_ASTC_8x6_UNORM_BLOCK:
		case DATA_FORMAT_ASTC_8x6_SRGB_BLOCK:
		case DATA_FORMAT_ASTC_8x8_UNORM_BLOCK:
		case DATA_FORMAT_ASTC_8x8_SRGB_BLOCK:
		case DATA_FORMAT_ASTC_10x5_UNORM_BLOCK:
		case DATA_FORMAT_ASTC_10x5_SRGB_BLOCK:
		case DATA_FORMAT_ASTC_10x6_UNORM_BLOCK:
		case DATA_FORMAT_ASTC_10x6_SRGB_BLOCK:
		case DATA_FORMAT_ASTC_10x8_UNORM_BLOCK:
		case DATA_FORMAT_ASTC_10x8_SRGB_BLOCK:
		case DATA_FORMAT_ASTC_10x10_UNORM_BLOCK:
		case DATA_FORMAT_ASTC_10x10_SRGB_BLOCK:
		case DATA_FORMAT_ASTC_12x10_UNORM_BLOCK:
		case DATA_FORMAT_ASTC_12x10_SRGB_BLOCK:
		case DATA_FORMAT_ASTC_12x12_UNORM_BLOCK:
		case DATA_FORMAT_ASTC_12x12_SRGB_BLOCK:
			return 8; // Wrong.
		default: {
		}
	}
	return 1;
}

uint32_t RenderingDeviceD3D12::get_compressed_image_format_pixel_rshift(DataFormat p_format) {
	switch (p_format) {
		case DATA_FORMAT_BC1_RGB_UNORM_BLOCK: // These formats are half byte size, so rshift is 1.
		case DATA_FORMAT_BC1_RGB_SRGB_BLOCK:
		case DATA_FORMAT_BC1_RGBA_UNORM_BLOCK:
		case DATA_FORMAT_BC1_RGBA_SRGB_BLOCK:
		case DATA_FORMAT_BC4_UNORM_BLOCK:
		case DATA_FORMAT_BC4_SNORM_BLOCK:
		case DATA_FORMAT_ETC2_R8G8B8_UNORM_BLOCK:
		case DATA_FORMAT_ETC2_R8G8B8_SRGB_BLOCK:
		case DATA_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK:
		case DATA_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK:
		case DATA_FORMAT_EAC_R11_UNORM_BLOCK:
		case DATA_FORMAT_EAC_R11_SNORM_BLOCK:
			return 1;
		default: {
		}
	}

	return 0;
}

uint32_t RenderingDeviceD3D12::get_image_format_plane_count(DataFormat p_format) {
	uint32_t planes = 1;
	switch (p_format) {
		case DATA_FORMAT_D16_UNORM_S8_UINT:
		case DATA_FORMAT_D24_UNORM_S8_UINT:
		case DATA_FORMAT_D32_SFLOAT_S8_UINT: {
			planes = 2;
		}
		default: {
		}
	}
	DEV_ASSERT(planes <= MAX_IMAGE_FORMAT_PLANES);
	return planes;
}

uint32_t RenderingDeviceD3D12::get_image_format_required_size(DataFormat p_format, uint32_t p_width, uint32_t p_height, uint32_t p_depth, uint32_t p_mipmaps, uint32_t *r_blockw, uint32_t *r_blockh, uint32_t *r_depth) {
	ERR_FAIL_COND_V(p_mipmaps == 0, 0);
	uint32_t w = p_width;
	uint32_t h = p_height;
	uint32_t d = p_depth;

	uint32_t size = 0;

	uint32_t pixel_size = get_image_format_pixel_size(p_format);
	uint32_t pixel_rshift = get_compressed_image_format_pixel_rshift(p_format);
	uint32_t blockw, blockh;
	get_compressed_image_format_block_dimensions(p_format, blockw, blockh);

	for (uint32_t i = 0; i < p_mipmaps; i++) {
		uint32_t bw = w % blockw != 0 ? w + (blockw - w % blockw) : w;
		uint32_t bh = h % blockh != 0 ? h + (blockh - h % blockh) : h;

		uint32_t s = bw * bh;

		s *= pixel_size;
		s >>= pixel_rshift;
		size += s * d;
		if (r_blockw) {
			*r_blockw = bw;
		}
		if (r_blockh) {
			*r_blockh = bh;
		}
		if (r_depth) {
			*r_depth = d;
		}
		w = MAX(blockw, w >> 1);
		h = MAX(blockh, h >> 1);
		d = MAX(1u, d >> 1);
	}

	return size;
}

uint32_t RenderingDeviceD3D12::get_image_required_mipmaps(uint32_t p_width, uint32_t p_height, uint32_t p_depth) {
	// Formats and block size don't really matter here since they can all go down to 1px (even if block is larger).
	uint32_t w = p_width;
	uint32_t h = p_height;
	uint32_t d = p_depth;

	uint32_t mipmaps = 1;

	while (true) {
		if (w == 1 && h == 1 && d == 1) {
			break;
		}

		w = MAX(1u, w >> 1);
		h = MAX(1u, h >> 1);
		d = MAX(1u, d >> 1);

		mipmaps++;
	}

	return mipmaps;
}

///////////////////////

const D3D12_COMPARISON_FUNC RenderingDeviceD3D12::compare_operators[RenderingDevice::COMPARE_OP_MAX] = {
	D3D12_COMPARISON_FUNC_NEVER,
	D3D12_COMPARISON_FUNC_LESS,
	D3D12_COMPARISON_FUNC_EQUAL,
	D3D12_COMPARISON_FUNC_LESS_EQUAL,
	D3D12_COMPARISON_FUNC_GREATER,
	D3D12_COMPARISON_FUNC_NOT_EQUAL,
	D3D12_COMPARISON_FUNC_GREATER_EQUAL,
	D3D12_COMPARISON_FUNC_ALWAYS,
};

const D3D12_STENCIL_OP RenderingDeviceD3D12::stencil_operations[RenderingDevice::STENCIL_OP_MAX] = {
	D3D12_STENCIL_OP_KEEP,
	D3D12_STENCIL_OP_ZERO,
	D3D12_STENCIL_OP_REPLACE,
	D3D12_STENCIL_OP_INCR_SAT,
	D3D12_STENCIL_OP_DECR_SAT,
	D3D12_STENCIL_OP_INVERT,
	D3D12_STENCIL_OP_INCR,
	D3D12_STENCIL_OP_DECR,
};

const UINT RenderingDeviceD3D12::rasterization_sample_count[RenderingDevice::TEXTURE_SAMPLES_MAX] = {
	1,
	2,
	4,
	8,
	16,
	32,
	64,
};

const D3D12_LOGIC_OP RenderingDeviceD3D12::logic_operations[RenderingDevice::LOGIC_OP_MAX] = {
	D3D12_LOGIC_OP_CLEAR,
	D3D12_LOGIC_OP_AND,
	D3D12_LOGIC_OP_AND_REVERSE,
	D3D12_LOGIC_OP_COPY,
	D3D12_LOGIC_OP_AND_INVERTED,
	D3D12_LOGIC_OP_NOOP,
	D3D12_LOGIC_OP_XOR,
	D3D12_LOGIC_OP_OR,
	D3D12_LOGIC_OP_NOR,
	D3D12_LOGIC_OP_EQUIV,
	D3D12_LOGIC_OP_INVERT,
	D3D12_LOGIC_OP_OR_REVERSE,
	D3D12_LOGIC_OP_COPY_INVERTED,
	D3D12_LOGIC_OP_OR_INVERTED,
	D3D12_LOGIC_OP_NAND,
	D3D12_LOGIC_OP_SET,
};

const D3D12_BLEND RenderingDeviceD3D12::blend_factors[RenderingDevice::BLEND_FACTOR_MAX] = {
	D3D12_BLEND_ZERO,
	D3D12_BLEND_ONE,
	D3D12_BLEND_SRC_COLOR,
	D3D12_BLEND_INV_SRC_COLOR,
	D3D12_BLEND_DEST_COLOR,
	D3D12_BLEND_INV_DEST_COLOR,
	D3D12_BLEND_SRC_ALPHA,
	D3D12_BLEND_INV_SRC_ALPHA,
	D3D12_BLEND_DEST_ALPHA,
	D3D12_BLEND_INV_DEST_ALPHA,
	D3D12_BLEND_BLEND_FACTOR,
	D3D12_BLEND_INV_BLEND_FACTOR,
	D3D12_BLEND_BLEND_FACTOR,
	D3D12_BLEND_INV_BLEND_FACTOR,
	D3D12_BLEND_SRC_ALPHA_SAT,
	D3D12_BLEND_SRC1_COLOR,
	D3D12_BLEND_INV_SRC1_COLOR,
	D3D12_BLEND_SRC1_ALPHA,
	D3D12_BLEND_INV_SRC1_ALPHA,
};

const D3D12_BLEND_OP RenderingDeviceD3D12::blend_operations[RenderingDevice::BLEND_OP_MAX] = {
	D3D12_BLEND_OP_ADD,
	D3D12_BLEND_OP_SUBTRACT,
	D3D12_BLEND_OP_REV_SUBTRACT,
	D3D12_BLEND_OP_MIN,
	D3D12_BLEND_OP_MAX,
};

const D3D12_TEXTURE_ADDRESS_MODE RenderingDeviceD3D12::address_modes[RenderingDevice::SAMPLER_REPEAT_MODE_MAX] = {
	D3D12_TEXTURE_ADDRESS_MODE_WRAP,
	D3D12_TEXTURE_ADDRESS_MODE_MIRROR,
	D3D12_TEXTURE_ADDRESS_MODE_CLAMP,
	D3D12_TEXTURE_ADDRESS_MODE_BORDER,
	D3D12_TEXTURE_ADDRESS_MODE_MIRROR_ONCE,
};

const FLOAT RenderingDeviceD3D12::sampler_border_colors[RenderingDevice::SAMPLER_BORDER_COLOR_MAX][4] = {
	{ 0, 0, 0, 0 },
	{ 0, 0, 0, 0 },
	{ 0, 0, 0, 1 },
	{ 0, 0, 0, 1 },
	{ 1, 1, 1, 1 },
	{ 1, 1, 1, 1 },
};

const D3D12_RESOURCE_DIMENSION RenderingDeviceD3D12::d3d12_texture_dimension[RenderingDevice::TEXTURE_TYPE_MAX] = {
	D3D12_RESOURCE_DIMENSION_TEXTURE1D,
	D3D12_RESOURCE_DIMENSION_TEXTURE2D,
	D3D12_RESOURCE_DIMENSION_TEXTURE3D,
	D3D12_RESOURCE_DIMENSION_TEXTURE2D,
	D3D12_RESOURCE_DIMENSION_TEXTURE1D,
	D3D12_RESOURCE_DIMENSION_TEXTURE2D,
	D3D12_RESOURCE_DIMENSION_TEXTURE2D,
};

/******************/
/**** RESOURCE ****/
/******************/

static const D3D12_RESOURCE_STATES RESOURCE_READ_STATES =
		D3D12_RESOURCE_STATE_VERTEX_AND_CONSTANT_BUFFER |
		D3D12_RESOURCE_STATE_INDEX_BUFFER |
		D3D12_RESOURCE_STATE_DEPTH_READ |
		D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE |
		D3D12_RESOURCE_STATE_PIXEL_SHADER_RESOURCE |
		D3D12_RESOURCE_STATE_INDIRECT_ARGUMENT |
		D3D12_RESOURCE_STATE_COPY_SOURCE |
		D3D12_RESOURCE_STATE_RESOLVE_SOURCE |
		D3D12_RESOURCE_STATE_SHADING_RATE_SOURCE;

static const D3D12_RESOURCE_STATES RESOURCE_WRITE_STATES =
		D3D12_RESOURCE_STATE_RENDER_TARGET |
		D3D12_RESOURCE_STATE_DEPTH_WRITE |
		D3D12_RESOURCE_STATE_COPY_DEST |
		D3D12_RESOURCE_STATE_RESOLVE_DEST;

static const D3D12_RESOURCE_STATES RESOURCE_RW_STATES =
		D3D12_RESOURCE_STATE_UNORDERED_ACCESS;

void RenderingDeviceD3D12::ResourceState::extend(D3D12_RESOURCE_STATES p_states_to_add) {
	states |= p_states_to_add;

#ifdef DEV_ENABLED
	if ((states & RESOURCE_RW_STATES)) {
		if ((states & RESOURCE_READ_STATES)) {
			ERR_PRINT("Error in new state mask: has R/W state plus some R/O state(s).");
		}
		if ((states & RESOURCE_WRITE_STATES)) {
			ERR_PRINT("Error in new state mask: has R/W state plus some W/O state(s).");
		}
	} else {
		if ((states & RESOURCE_WRITE_STATES)) {
			if ((states & RESOURCE_READ_STATES)) {
				ERR_PRINT("Error in new state mask: mixes R/O and W/O states.");
			} else {
				uint32_t num_w_states = 0;
				for (uint32_t i = 0; i < sizeof(D3D12_RESOURCE_STATES) * 8; i++) {
					num_w_states += ((states & RESOURCE_WRITE_STATES) & (1 << i)) ? 1 : 0;
				}
				ERR_PRINT("Error in new state mask: has multiple W/O states.");
			}
		}
	}
#endif
}

void RenderingDeviceD3D12::_resource_transition_batch(Resource *p_resource, uint32_t p_subresource, uint32_t p_num_planes, D3D12_RESOURCE_STATES p_new_state, ID3D12Resource *p_resource_override) {
	DEV_ASSERT(p_subresource != UINT32_MAX); // We don't support an "all-resources" command here.
	DEV_ASSERT(p_new_state != D3D12_RESOURCE_STATE_COMMON); // No need to support this for now.

#ifdef DEBUG_COUNT_BARRIERS
	uint64_t start = OS::get_singleton()->get_ticks_usec();
#endif

	Resource::States *res_states = p_resource->get_states_ptr();
	if (p_new_state == D3D12_RESOURCE_STATE_UNORDERED_ACCESS) {
		res_states->generation++;
	}
	D3D12_RESOURCE_STATES *curr_state = &res_states->subresource_states[p_subresource];
	bool redundant_transition = ((*curr_state) & p_new_state) == p_new_state;
	if (!redundant_transition) {
		ID3D12Resource *res_to_transition = p_resource_override ? p_resource_override : p_resource->resource;

		uint64_t subres_mask_piece = ((uint64_t)1 << (p_subresource & 0b111111));
		uint8_t subres_qword = p_subresource >> 6;

		if (res_barriers_requests.has(res_states)) {
			BarrierRequest &br = res_barriers_requests.get(res_states);
			DEV_ASSERT(br.dx_resource == res_to_transition);
			DEV_ASSERT(br.subres_mask_qwords == ALIGN(res_states->subresource_states.size(), 64) / 64);
			DEV_ASSERT(br.planes == p_num_planes);

			// First, find if the subresource already has a barrier scheduled.
			uint8_t curr_group_idx = 0;
			bool same_transition_scheduled = false;
			for (curr_group_idx = 0; curr_group_idx < br.groups_count; curr_group_idx++) {
				if (unlikely(br.groups[curr_group_idx].state.get_state_mask() == BarrierRequest::DELETED_GROUP)) {
					continue;
				}
				if ((br.groups[curr_group_idx].subres_mask[subres_qword] & subres_mask_piece)) {
					uint32_t state_mask = br.groups[curr_group_idx].state.get_state_mask();
					same_transition_scheduled = (state_mask & (uint32_t)p_new_state) == (uint32_t)p_new_state;
					break;
				}
			}
			if (!same_transition_scheduled) {
				bool subres_already_there = curr_group_idx != br.groups_count;
				ResourceState final_state;
				if (subres_already_there) {
					final_state = br.groups[curr_group_idx].state;
					final_state.extend(p_new_state);
					bool subres_alone = true;
					for (uint8_t i = 0; i < br.subres_mask_qwords; i++) {
						if (i == subres_qword) {
							if (br.groups[curr_group_idx].subres_mask[i] != subres_mask_piece) {
								subres_alone = false;
								break;
							}
						} else {
							if (br.groups[curr_group_idx].subres_mask[i] != 0) {
								subres_alone = false;
								break;
							}
						}
					}
					bool relocated = false;
					if (subres_alone) {
						// Subresource is there by itself.
						for (uint8_t i = 0; i < br.groups_count; i++) {
							if (unlikely(i == curr_group_idx)) {
								continue;
							}
							if (unlikely(br.groups[i].state.get_state_mask() == BarrierRequest::DELETED_GROUP)) {
								continue;
							}
							// There's another group with the final state; relocate to it.
							if (br.groups[i].state.get_state_mask() == final_state.get_state_mask()) {
								br.groups[curr_group_idx].subres_mask[subres_qword] &= ~subres_mask_piece;
								relocated = true;
								break;
							}
						}
						if (relocated) {
							// Let's delete the group where it used to be by itself.
							if (curr_group_idx == br.groups_count - 1) {
								br.groups_count--;
							} else {
								br.groups[curr_group_idx].state = ResourceState(BarrierRequest::DELETED_GROUP);
							}
						} else {
							// Its current group, where it's alone, can extend its state.
							br.groups[curr_group_idx].state = final_state;
						}
					} else {
						// Already there, but not by itself and the state mask is different, so it now belongs to a different group.
						br.groups[curr_group_idx].subres_mask[subres_qword] &= ~subres_mask_piece;
						subres_already_there = false;
					}
				} else {
					final_state = p_new_state;
				}
				if (!subres_already_there) {
					// See if it fits exactly the state of some of the groups to fit it there.
					for (uint8_t i = 0; i < br.groups_count; i++) {
						if (unlikely(i == curr_group_idx)) {
							continue;
						}
						if (unlikely(br.groups[i].state.get_state_mask() == BarrierRequest::DELETED_GROUP)) {
							continue;
						}
						if (br.groups[i].state.get_state_mask() == final_state.get_state_mask()) {
							br.groups[i].subres_mask[subres_qword] |= subres_mask_piece;
							subres_already_there = true;
							break;
						}
					}
					if (!subres_already_there) {
						// Add a new group to accommodate this subresource.
						uint8_t group_to_fill = 0;
						if (br.groups_count < BarrierRequest::MAX_GROUPS) {
							// There are still free groups.
							group_to_fill = br.groups_count;
							br.groups_count++;
						} else {
							// Let's try to take over a deleted one.
							for (; group_to_fill < br.groups_count; group_to_fill++) {
								if (unlikely(br.groups[group_to_fill].state.get_state_mask() == BarrierRequest::DELETED_GROUP)) {
									break;
								}
							}
							CRASH_COND(group_to_fill == br.groups_count);
						}

						br.groups[group_to_fill].state = final_state;
						for (uint8_t i = 0; i < br.subres_mask_qwords; i++) {
							if (unlikely(i == subres_qword)) {
								br.groups[group_to_fill].subres_mask[i] = subres_mask_piece;
							} else {
								br.groups[group_to_fill].subres_mask[i] = 0;
							}
						}
					}
				}
			}
		} else {
			BarrierRequest &br = res_barriers_requests[res_states];
			br.dx_resource = res_to_transition;
			br.subres_mask_qwords = ALIGN(p_resource->get_states_ptr()->subresource_states.size(), 64) / 64;
			CRASH_COND(p_resource->get_states_ptr()->subresource_states.size() >= BarrierRequest::SUBRES_MASK_BITS);
			br.planes = p_num_planes;
			br.groups[0].state = p_new_state;
			for (uint8_t i = 0; i < br.subres_mask_qwords; i++) {
				if (unlikely(i == subres_qword)) {
					br.groups[0].subres_mask[i] = subres_mask_piece;
				} else {
					br.groups[0].subres_mask[i] = 0;
				}
			}
			br.groups_count = 1;
		}
	}

#ifdef DEBUG_COUNT_BARRIERS
	frame_barriers_cpu_time += OS::get_singleton()->get_ticks_usec() - start;
#endif
}

void RenderingDeviceD3D12::_resource_transitions_flush(ID3D12GraphicsCommandList *p_command_list) {
	if (res_barriers_requests.is_empty()) {
		return;
	}

#ifdef DEBUG_COUNT_BARRIERS
	uint64_t start = OS::get_singleton()->get_ticks_usec();
#endif

	uint32_t res_barriers_count = 0;
	for (const KeyValue<Resource::States *, BarrierRequest> &E : res_barriers_requests) {
		Resource::States *res_states = E.key;
		const BarrierRequest &br = E.value;

		uint32_t num_subresources = res_states->subresource_states.size();

		// When there's not a lot of subresources, the empirical finding is that it's better
		// to avoid attempting the single-barrier optimization.
		static const uint32_t SINGLE_BARRIER_ATTEMPT_MAX_NUM_SUBRESOURCES = 48;

		bool may_do_single_barrier = br.groups_count == 1 && num_subresources * br.planes >= SINGLE_BARRIER_ATTEMPT_MAX_NUM_SUBRESOURCES;
		if (may_do_single_barrier) {
			// A single group means we may be able to do a single all-subresources barrier.

			{
				// First requisite is that all subresources are involved.

				uint8_t subres_mask_full_qwords = num_subresources / 64;
				for (uint32_t i = 0; i < subres_mask_full_qwords; i++) {
					if (br.groups[0].subres_mask[i] != UINT64_MAX) {
						may_do_single_barrier = false;
						break;
					}
				}
				if (may_do_single_barrier) {
					if (num_subresources % 64) {
						DEV_ASSERT(br.subres_mask_qwords == subres_mask_full_qwords + 1);
						uint64_t mask_tail_qword = 0;
						for (uint8_t i = 0; i < num_subresources % 64; i++) {
							mask_tail_qword |= ((uint64_t)1 << i);
						}
						if ((br.groups[0].subres_mask[subres_mask_full_qwords] & mask_tail_qword) != mask_tail_qword) {
							may_do_single_barrier = false;
						}
					}
				}
			}

			if (may_do_single_barrier) {
				// Second requisite is that the source state is the same for all.

				bool just_written = res_states->subresource_states[0] == D3D12_RESOURCE_STATE_UNORDERED_ACCESS;
				for (uint32_t i = 1; i < num_subresources; i++) {
					if (res_states->subresource_states[i] != res_states->subresource_states[0]) {
						may_do_single_barrier = false;
						break;
					}
				}

				if (may_do_single_barrier) {
					// Hurray!, we can do a single barrier (plus maybe a UAV one, too).

					bool needs_uav_barrier = just_written && br.groups[0].state.get_state_mask() != D3D12_RESOURCE_STATE_UNORDERED_ACCESS && res_states->last_uav_generation != res_states->generation;

					uint32_t needed_barriers = (needs_uav_barrier ? 1 : 0) + 1;
					if (res_barriers.size() < res_barriers_count + needed_barriers) {
						res_barriers.resize(res_barriers_count + needed_barriers);
					}

					if (needs_uav_barrier) {
						res_barriers[res_barriers_count] = CD3DX12_RESOURCE_BARRIER::UAV(br.dx_resource);
						res_barriers_count++;
						res_states->last_uav_generation = res_states->generation;
					}

					res_barriers[res_barriers_count] = CD3DX12_RESOURCE_BARRIER::Transition(br.dx_resource, res_states->subresource_states[0], br.groups[0].state.get_state_mask(), D3D12_RESOURCE_BARRIER_ALL_SUBRESOURCES);
					res_barriers_count++;

					for (uint32_t i = 0; i < num_subresources; i++) {
						res_states->subresource_states[i] = br.groups[0].state.get_state_mask();
					}
				}
			}
		}

		if (!may_do_single_barrier) {
			for (uint8_t i = 0; i < br.groups_count; i++) {
				const BarrierRequest::Group &g = E.value.groups[i];

				if (unlikely(g.state.get_state_mask() == BarrierRequest::DELETED_GROUP)) {
					continue;
				}

				uint32_t subresource = 0;
				do {
					uint64_t subres_mask_piece = ((uint64_t)1 << (subresource % 64));
					uint8_t subres_qword = subresource / 64;

					if (likely(g.subres_mask[subres_qword] == 0)) {
						subresource += 64;
						continue;
					}

					if (likely(!(g.subres_mask[subres_qword] & subres_mask_piece))) {
						subresource++;
						continue;
					}

					D3D12_RESOURCE_STATES *curr_state = &res_states->subresource_states[subresource];

					bool just_written = *curr_state == D3D12_RESOURCE_STATE_UNORDERED_ACCESS;
					bool needs_uav_barrier = just_written && g.state.get_state_mask() != D3D12_RESOURCE_STATE_UNORDERED_ACCESS && res_states->last_uav_generation != res_states->generation;

					uint32_t needed_barriers = (needs_uav_barrier ? 1 : 0) + br.planes;
					if (res_barriers.size() < res_barriers_count + needed_barriers) {
						res_barriers.resize(res_barriers_count + needed_barriers);
					}

					if (needs_uav_barrier) {
						res_barriers[res_barriers_count] = CD3DX12_RESOURCE_BARRIER::UAV(br.dx_resource);
						res_barriers_count++;
						res_states->last_uav_generation = res_states->generation;
					}

					for (uint8_t k = 0; k < br.planes; k++) {
						res_barriers[res_barriers_count] = CD3DX12_RESOURCE_BARRIER::Transition(br.dx_resource, *curr_state, g.state.get_state_mask(), subresource + k * num_subresources);
						res_barriers_count++;
					}

					*curr_state = g.state.get_state_mask();

					subresource++;
				} while (subresource < num_subresources);
			}
		}
	}

	p_command_list->ResourceBarrier(res_barriers_count, res_barriers.ptr());
	res_barriers_requests.clear();

#ifdef DEBUG_COUNT_BARRIERS
	frame_barriers_count += res_barriers_count;
	frame_barriers_batches_count++;
	frame_barriers_cpu_time += OS::get_singleton()->get_ticks_usec() - start;
#endif
}

/***************************/
/**** BUFFER MANAGEMENT ****/
/***************************/

Error RenderingDeviceD3D12::_buffer_allocate(Buffer *p_buffer, uint32_t p_size, D3D12_RESOURCE_STATES p_usage, D3D12_HEAP_TYPE p_heap_type) {
	ERR_FAIL_COND_V(p_heap_type != D3D12_HEAP_TYPE_DEFAULT && p_heap_type != D3D12_HEAP_TYPE_READBACK, ERR_INVALID_PARAMETER);

	// D3D12 debug layers complain at CBV creation time if the size is not multiple of 256,
	// but also if you give a rounded size at that point because it will extend beyond the
	// memory of the resource. Therefore, it seems the only way is to create it with a
	// rounded size.
	CD3DX12_RESOURCE_DESC resource_desc = CD3DX12_RESOURCE_DESC::Buffer(ALIGN(p_size, 256));
	if ((p_usage & D3D12_RESOURCE_STATE_UNORDERED_ACCESS)) {
		resource_desc.Flags |= D3D12_RESOURCE_FLAG_ALLOW_UNORDERED_ACCESS;
	}

	D3D12MA::ALLOCATION_DESC allocation_desc = {};
	allocation_desc.HeapType = p_heap_type;
#ifdef USE_SMALL_ALLOCS_POOL
	if (p_size <= SMALL_ALLOCATION_MAX_SIZE) {
		allocation_desc.CustomPool = _find_or_create_small_allocs_pool(p_heap_type, D3D12_HEAP_FLAG_ALLOW_ONLY_BUFFERS);
	}
#endif

	HRESULT res = allocator->CreateResource(
			&allocation_desc,
			&resource_desc,
			D3D12_RESOURCE_STATE_COPY_DEST,
			nullptr,
			&p_buffer->allocation,
			IID_PPV_ARGS(&p_buffer->resource));
	ERR_FAIL_COND_V_MSG(res, ERR_CANT_CREATE, "Can't create buffer of size: " + itos(p_size) + ", error " + vformat("0x%08x", res) + ".");

	p_buffer->size = p_size;
	p_buffer->usage = p_usage;
	p_buffer->own_states.subresource_states.push_back(D3D12_RESOURCE_STATE_COPY_DEST);

	buffer_memory += p_size;

	return OK;
}

Error RenderingDeviceD3D12::_buffer_free(Buffer *p_buffer) {
	ERR_FAIL_COND_V(p_buffer->size == 0, ERR_INVALID_PARAMETER);

	buffer_memory -= p_buffer->size;

	p_buffer->resource->Release();
	p_buffer->resource = nullptr;
	p_buffer->allocation->Release();
	p_buffer->allocation = nullptr;
	p_buffer->size = 0;

	return OK;
}

Error RenderingDeviceD3D12::_insert_staging_block() {
	StagingBufferBlock block;

	D3D12_RESOURCE_DESC resource_desc = {};
	resource_desc.Dimension = D3D12_RESOURCE_DIMENSION_BUFFER;
	resource_desc.Alignment = 0;
	resource_desc.Width = staging_buffer_block_size;
	resource_desc.Height = 1;
	resource_desc.DepthOrArraySize = 1;
	resource_desc.MipLevels = 1;
	resource_desc.Format = DXGI_FORMAT_UNKNOWN;
	resource_desc.SampleDesc.Count = 1;
	resource_desc.SampleDesc.Quality = 0;
	resource_desc.Layout = D3D12_TEXTURE_LAYOUT_ROW_MAJOR;
	resource_desc.Flags = D3D12_RESOURCE_FLAG_NONE;

	D3D12MA::ALLOCATION_DESC allocation_desc = {};
	allocation_desc.HeapType = D3D12_HEAP_TYPE_UPLOAD;

	HRESULT res = allocator->CreateResource(
			&allocation_desc,
			&resource_desc,
			D3D12_RESOURCE_STATE_GENERIC_READ,
			NULL,
			&block.allocation,
			IID_PPV_ARGS(&block.resource));
	ERR_FAIL_COND_V_MSG(res, ERR_CANT_CREATE, "CreateResource failed with error " + vformat("0x%08x", res) + ".");

	staging_buffer_blocks.insert(staging_buffer_current, block);
	return OK;
}

Error RenderingDeviceD3D12::_staging_buffer_allocate(uint32_t p_amount, uint32_t p_required_align, uint32_t &r_alloc_offset, uint32_t &r_alloc_size, bool p_can_segment) {
	// Determine a block to use.

	r_alloc_size = p_amount;

	while (true) {
		r_alloc_offset = 0;

		// See if we can use current block.
		if (staging_buffer_blocks[staging_buffer_current].frame_used == frames_drawn) {
			// We used this block this frame, let's see if there is still room.

			uint32_t write_from = staging_buffer_blocks[staging_buffer_current].fill_amount;

			{
				uint32_t align_remainder = write_from % p_required_align;
				if (align_remainder != 0) {
					write_from += p_required_align - align_remainder;
				}
			}

			int32_t available_bytes = int32_t(staging_buffer_block_size) - int32_t(write_from);

			if ((int32_t)p_amount < available_bytes) {
				// All is good, we should be ok, all will fit.
				r_alloc_offset = write_from;
			} else if (p_can_segment && available_bytes >= (int32_t)p_required_align) {
				// Ok all won't fit but at least we can fit a chunkie.
				// All is good, update what needs to be written to.
				r_alloc_offset = write_from;
				r_alloc_size = available_bytes - (available_bytes % p_required_align);

			} else {
				// Can't fit it into this buffer.
				// Will need to try next buffer.

				staging_buffer_current = (staging_buffer_current + 1) % staging_buffer_blocks.size();

				// Before doing anything, though, let's check that we didn't manage to fill all functions.
				// Possible in a single frame.
				if (staging_buffer_blocks[staging_buffer_current].frame_used == frames_drawn) {
					// Guess we did.. ok, let's see if we can insert a new block.
					if ((uint64_t)staging_buffer_blocks.size() * staging_buffer_block_size < staging_buffer_max_size) {
						// We can, so we are safe.
						Error err = _insert_staging_block();
						if (err) {
							return err;
						}
						// Claim for this frame.
						staging_buffer_blocks.write[staging_buffer_current].frame_used = frames_drawn;
					} else {
						// Ok, worst case scenario, all the staging buffers belong to this frame
						// and this frame is not even done
						// If this is the main thread, it means the user is likely loading a lot of resources at once,.
						// Otherwise, the thread should just be blocked until the next frame (currently unimplemented).

						if (false) { // Separate thread from render.

							//block_until_next_frame()
							continue;
						} else {
							// Flush EVERYTHING including setup commands. IF not immediate, also need to flush the draw commands.
							_flush(true);

							// Clear the whole staging buffer.
							for (int i = 0; i < staging_buffer_blocks.size(); i++) {
								staging_buffer_blocks.write[i].frame_used = 0;
								staging_buffer_blocks.write[i].fill_amount = 0;
							}
							// Claim current.
							staging_buffer_blocks.write[staging_buffer_current].frame_used = frames_drawn;
						}
					}

				} else {
					// Not from current frame, so continue and try again.
					continue;
				}
			}

		} else if (staging_buffer_blocks[staging_buffer_current].frame_used <= frames_drawn - frame_count) {
			// This is an old block, which was already processed, let's reuse.
			staging_buffer_blocks.write[staging_buffer_current].frame_used = frames_drawn;
			staging_buffer_blocks.write[staging_buffer_current].fill_amount = 0;
		} else {
			// This block may still be in use, let's not touch it unless we have to, so.. can we create a new one?
			if ((uint64_t)staging_buffer_blocks.size() * staging_buffer_block_size < staging_buffer_max_size) {
				// We are still allowed to create a new block, so let's do that and insert it for current pos.
				Error err = _insert_staging_block();
				if (err) {
					return err;
				}
				// Claim for this frame.
				staging_buffer_blocks.write[staging_buffer_current].frame_used = frames_drawn;
			} else {
				// Oops, we are out of room and we can't create more.
				// Let's flush older frames.
				// The logic here is that if a game is loading a lot of data from the main thread, it will need to be stalled anyway.
				// If loading from a separate thread, we can block that thread until next frame when more room is made (not currently implemented, though).

				if (false) {
					// Separate thread from render.
					//block_until_next_frame()
					continue; // And try again.
				} else {
					_flush(false);

					for (int i = 0; i < staging_buffer_blocks.size(); i++) {
						// Clear all functions but the ones from this frame.
						int block_idx = (i + staging_buffer_current) % staging_buffer_blocks.size();
						if (staging_buffer_blocks[block_idx].frame_used == frames_drawn) {
							break; // Ok, we reached something from this frame, abort.
						}

						staging_buffer_blocks.write[block_idx].frame_used = 0;
						staging_buffer_blocks.write[block_idx].fill_amount = 0;
					}

					// Claim for current frame.
					staging_buffer_blocks.write[staging_buffer_current].frame_used = frames_drawn;
				}
			}
		}

		// All was good, break.
		break;
	}

	staging_buffer_used = true;

	return OK;
}

Error RenderingDeviceD3D12::_buffer_update(Buffer *p_buffer, size_t p_offset, const uint8_t *p_data, size_t p_data_size, bool p_use_draw_command_list, uint32_t p_required_align) {
	// Submitting may get chunked for various reasons, so convert this to a task.
	size_t to_submit = p_data_size;
	size_t submit_from = 0;

	while (to_submit > 0) {
		uint32_t block_write_offset;
		uint32_t block_write_amount;

		Error err = _staging_buffer_allocate(MIN(to_submit, staging_buffer_block_size), p_required_align, block_write_offset, block_write_amount);
		if (err) {
			return err;
		}

		// Map staging buffer.

		void *data_ptr = nullptr;
		{
			HRESULT res = staging_buffer_blocks[staging_buffer_current].resource->Map(0, &VOID_RANGE, &data_ptr);
			ERR_FAIL_COND_V_MSG(res, ERR_CANT_CREATE, "Map failed with error " + vformat("0x%08x", res) + ".");
		}

		// Copy to staging buffer.
		memcpy(((uint8_t *)data_ptr) + block_write_offset, p_data + submit_from, block_write_amount);

		// Unmap.
		staging_buffer_blocks[staging_buffer_current].resource->Unmap(0, &VOID_RANGE);

		// Insert a command to copy this.
		ID3D12GraphicsCommandList *command_list = (p_use_draw_command_list ? frames[frame].draw_command_list : frames[frame].setup_command_list).Get();
		command_list->CopyBufferRegion(p_buffer->resource, submit_from + p_offset, staging_buffer_blocks[staging_buffer_current].resource, block_write_offset, block_write_amount);

		staging_buffer_blocks.write[staging_buffer_current].fill_amount = block_write_offset + block_write_amount;

		to_submit -= block_write_amount;
		submit_from += block_write_amount;
	}

	return OK;
}

/*****************/
/**** TEXTURE ****/
/*****************/

RID RenderingDeviceD3D12::texture_create(const TextureFormat &p_format, const TextureView &p_view, const Vector<Vector<uint8_t>> &p_data) {
	_THREAD_SAFE_METHOD_

	D3D12_RESOURCE_DESC resource_desc = {};
	resource_desc.Alignment = 0; // D3D12MA will override this to use a smaller alignment than the default if possible.

	Vector<DataFormat> allowed_formats;
	if (p_format.shareable_formats.size()) {
		ERR_FAIL_COND_V_MSG(p_format.shareable_formats.find(p_format.format) == -1, RID(),
				"If supplied a list of shareable formats, the current format must be present in the list");
		ERR_FAIL_COND_V_MSG(p_view.format_override != DATA_FORMAT_MAX && p_format.shareable_formats.find(p_view.format_override) == -1, RID(),
				"If supplied a list of shareable formats, the current view format override must be present in the list");
		allowed_formats = p_format.shareable_formats;
	} else {
		allowed_formats.push_back(p_format.format);
		if (p_view.format_override != DATA_FORMAT_MAX) {
			allowed_formats.push_back(p_view.format_override);
		}
	}

	ERR_FAIL_INDEX_V(p_format.texture_type, TEXTURE_TYPE_MAX, RID());

	resource_desc.Dimension = d3d12_texture_dimension[p_format.texture_type];

	ERR_FAIL_COND_V_MSG(p_format.width < 1, RID(), "Width must be equal or greater than 1 for all textures");

	resource_desc.Format = d3d12_formats[p_format.format].family;

	resource_desc.Width = p_format.width;
	if (resource_desc.Dimension == D3D12_RESOURCE_DIMENSION_TEXTURE3D || resource_desc.Dimension == D3D12_RESOURCE_DIMENSION_TEXTURE2D) {
		ERR_FAIL_COND_V_MSG(p_format.height < 1, RID(), "Height must be equal or greater than 1 for 2D and 3D textures");
		resource_desc.Height = p_format.height;
	} else {
		resource_desc.Height = 1;
	}

	if (resource_desc.Dimension == D3D12_RESOURCE_DIMENSION_TEXTURE3D) {
		ERR_FAIL_COND_V_MSG(p_format.depth < 1, RID(), "Depth must be equal or greater than 1 for 3D textures");
		resource_desc.DepthOrArraySize = p_format.depth;
	} else {
		resource_desc.DepthOrArraySize = 1;
	}

	ERR_FAIL_COND_V(p_format.mipmaps < 1, RID());

	resource_desc.MipLevels = p_format.mipmaps;

	if (p_format.texture_type == TEXTURE_TYPE_1D_ARRAY || p_format.texture_type == TEXTURE_TYPE_2D_ARRAY || p_format.texture_type == TEXTURE_TYPE_CUBE_ARRAY || p_format.texture_type == TEXTURE_TYPE_CUBE) {
		ERR_FAIL_COND_V_MSG(p_format.array_layers < 1, RID(),
				"Amount of layers must be equal or greater than 1 for arrays and cubemaps.");
		ERR_FAIL_COND_V_MSG((p_format.texture_type == TEXTURE_TYPE_CUBE_ARRAY || p_format.texture_type == TEXTURE_TYPE_CUBE) && (p_format.array_layers % 6) != 0, RID(),
				"Cubemap and cubemap array textures must provide a layer number that is multiple of 6");
		resource_desc.DepthOrArraySize *= p_format.array_layers;
	}

	ERR_FAIL_INDEX_V(p_format.samples, TEXTURE_SAMPLES_MAX, RID());

	// Usage.

	if ((p_format.usage_bits & TEXTURE_USAGE_COLOR_ATTACHMENT_BIT)) {
		resource_desc.Flags |= D3D12_RESOURCE_FLAG_ALLOW_RENDER_TARGET;
	} else {
		if ((p_format.usage_bits & TEXTURE_USAGE_CAN_COPY_TO_BIT)) {
			resource_desc.Flags |= D3D12_RESOURCE_FLAG_ALLOW_UNORDERED_ACCESS; // For clearing via UAV.
		}
	}

	if (p_format.usage_bits & TEXTURE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT) {
		resource_desc.Flags |= D3D12_RESOURCE_FLAG_ALLOW_DEPTH_STENCIL;
	}

	if (p_format.usage_bits & TEXTURE_USAGE_STORAGE_BIT) {
		resource_desc.Flags |= D3D12_RESOURCE_FLAG_ALLOW_UNORDERED_ACCESS;
	}

	resource_desc.SampleDesc = {};
	DXGI_FORMAT format_to_test = (resource_desc.Flags & D3D12_RESOURCE_FLAG_ALLOW_DEPTH_STENCIL) ? d3d12_formats[p_format.format].dsv_format : d3d12_formats[p_format.format].general_format;
	if (!(resource_desc.Flags & D3D12_RESOURCE_FLAG_ALLOW_UNORDERED_ACCESS)) {
		resource_desc.SampleDesc.Count = MIN(
				_find_max_common_supported_sample_count(&format_to_test, 1),
				rasterization_sample_count[p_format.samples]);
	} else {
		// No MSAA in D3D12 if storage. May have become possible recently where supported, though.
		resource_desc.SampleDesc.Count = 1;
	}
	resource_desc.SampleDesc.Quality = resource_desc.SampleDesc.Count == 1 ? 0 : DXGI_STANDARD_MULTISAMPLE_QUALITY_PATTERN;

	uint32_t required_mipmaps = get_image_required_mipmaps(p_format.width, p_format.height, p_format.depth);

	ERR_FAIL_COND_V_MSG(required_mipmaps < p_format.mipmaps, RID(),
			"Too many mipmaps requested for texture format and dimensions (" + itos(p_format.mipmaps) + "), maximum allowed: (" + itos(required_mipmaps) + ").");

	if (p_data.size()) {
		ERR_FAIL_COND_V_MSG(!(p_format.usage_bits & TEXTURE_USAGE_CAN_UPDATE_BIT), RID(),
				"Texture needs the TEXTURE_USAGE_CAN_UPDATE_BIT usage flag in order to be updated at initialization or later");

		int expected_images = p_format.array_layers;
		ERR_FAIL_COND_V_MSG(p_data.size() != expected_images, RID(),
				"Default supplied data for image format is of invalid length (" + itos(p_data.size()) + "), should be (" + itos(expected_images) + ").");

		for (uint32_t i = 0; i < p_format.array_layers; i++) {
			uint32_t required_size = get_image_format_required_size(p_format.format, p_format.width, p_format.height, p_format.depth, p_format.mipmaps);
			ERR_FAIL_COND_V_MSG((uint32_t)p_data[i].size() != required_size, RID(),
					"Data for slice index " + itos(i) + " (mapped to layer " + itos(i) + ") differs in size (supplied: " + itos(p_data[i].size()) + ") than what is required by the format (" + itos(required_size) + ").");
		}
	}

	// Validate that this image is supported for the intended use.
	bool aliasing_needed = false; // If view of different format "families" are wanted. [[CROSS_FAMILY_ALIASING]]
	HashMap<DataFormat, D3D12_RESOURCE_FLAGS> aliases_forbidden_flags;
	D3D12_RESOURCE_FLAGS accum_forbidden_flags = {};
	for (DataFormat curr_format : allowed_formats) {
		// For now, we'll validate usages only the main format, to match what Vulkan RD does.
		// TODO: The aliasing trick assumes the main format is the only writable one. We should either validate for that or handle a different order gracefully.
		bool checking_main_format = curr_format == p_format.format;

		String format_text = "'" + String(named_formats[p_format.format]) + "'";

		ERR_FAIL_COND_V_MSG(d3d12_formats[curr_format].family == DXGI_FORMAT_UNKNOWN, RID(), "Format " + format_text + " is not supported.");

		if (d3d12_formats[curr_format].family != d3d12_formats[allowed_formats[0]].family) {
			aliasing_needed = true;
		}

		D3D12_FEATURE_DATA_FORMAT_SUPPORT srv_rtv_support = {};
		srv_rtv_support.Format = d3d12_formats[curr_format].general_format;
		HRESULT res = device->CheckFeatureSupport(D3D12_FEATURE_FORMAT_SUPPORT, &srv_rtv_support, sizeof(srv_rtv_support));
		ERR_FAIL_COND_V_MSG(res, RID(), "CheckFeatureSupport failed with error " + vformat("0x%08x", res) + ".");

		D3D12_FEATURE_DATA_FORMAT_SUPPORT uav_support = srv_rtv_support; // Fine for now.

		D3D12_FEATURE_DATA_FORMAT_SUPPORT dsv_support = {};
		dsv_support.Format = d3d12_formats[curr_format].dsv_format;
		res = device->CheckFeatureSupport(D3D12_FEATURE_FORMAT_SUPPORT, &dsv_support, sizeof(dsv_support));
		ERR_FAIL_COND_V_MSG(res, RID(), "CheckFeatureSupport failed with error " + vformat("0x%08x", res) + ".");

		if (checking_main_format) {
			if ((p_format.usage_bits & (TEXTURE_USAGE_SAMPLING_BIT | TEXTURE_USAGE_COLOR_ATTACHMENT_BIT))) {
				if ((p_format.texture_type == TEXTURE_TYPE_1D || p_format.texture_type == TEXTURE_TYPE_1D_ARRAY) && !(srv_rtv_support.Support1 & D3D12_FORMAT_SUPPORT1_TEXTURE1D)) {
					ERR_FAIL_V_MSG(RID(), "Format " + format_text + " does not support usage as a 1D texture.");
				}

				if ((p_format.texture_type == TEXTURE_TYPE_2D || p_format.texture_type == TEXTURE_TYPE_2D_ARRAY) && !(srv_rtv_support.Support1 & D3D12_FORMAT_SUPPORT1_TEXTURE2D)) {
					ERR_FAIL_V_MSG(RID(), "Format " + format_text + " does not support usage as a 2D texture.");
				}

				if (p_format.texture_type == TEXTURE_TYPE_3D && !(srv_rtv_support.Support1 & D3D12_FORMAT_SUPPORT1_TEXTURE3D)) {
					ERR_FAIL_V_MSG(RID(), "Format " + format_text + " does not support usage as a 3D texture.");
				}

				if ((p_format.texture_type == TEXTURE_TYPE_CUBE || p_format.texture_type == TEXTURE_TYPE_CUBE_ARRAY) && !(srv_rtv_support.Support1 & D3D12_FORMAT_SUPPORT1_TEXTURE1D)) {
					ERR_FAIL_V_MSG(RID(), "Format " + format_text + " does not support usage as a cube texture.");
				}

				if (p_format.mipmaps && !(srv_rtv_support.Support1 & D3D12_FORMAT_SUPPORT1_MIP)) {
					ERR_FAIL_V_MSG(RID(), "Format " + format_text + " does not support mip.maps.");
				}
			}

			// Per https://docs.microsoft.com/en-us/windows/win32/api/d3d12/ne-d3d12-d3d12_format_support1,
			// as long as the resource can be used as a texture, Sample() will work with point filter at least.
			// However, we've empirically found that checking for at least D3D12_FORMAT_SUPPORT1_SHADER_LOAD is needed.
			// That's almost good for integer formats. The problem is that theoretically there may be
			// float formats that support LOAD but not SAMPLE fully, so this check will not detect
			// such a flaw in the format. Linearly interpolated sampling would just not work on them.
			// [[IMPLICIT_SAMPLE]]
			if ((p_format.usage_bits & TEXTURE_USAGE_SAMPLING_BIT) && !(srv_rtv_support.Support1 & (D3D12_FORMAT_SUPPORT1_SHADER_LOAD | D3D12_FORMAT_SUPPORT1_SHADER_SAMPLE))) {
				ERR_FAIL_V_MSG(RID(), "Format " + format_text + " does not support usage as a sampled texture.");
			}

			if ((p_format.usage_bits & TEXTURE_USAGE_COLOR_ATTACHMENT_BIT) && !(srv_rtv_support.Support1 & D3D12_FORMAT_SUPPORT1_RENDER_TARGET)) {
				ERR_FAIL_V_MSG(RID(), "Format " + format_text + " does not support usage as color attachment.");
			}
		}

		if ((p_format.usage_bits & TEXTURE_USAGE_CAN_COPY_TO_BIT)) {
			// We need to check if the texture can be cleared; if it's not flagged for color attachemnt, we have to see if it's possible via a UAV.
			if (!(p_format.usage_bits & TEXTURE_USAGE_COLOR_ATTACHMENT_BIT)) {
				if (!(uav_support.Support1 & D3D12_FORMAT_SUPPORT1_TYPED_UNORDERED_ACCESS_VIEW)) {
					if (checking_main_format) {
						ERR_FAIL_V_MSG(RID(), "Format " + format_text + " does not support usage as a copy-to texture, because clearing it is not supported.");
					} else {
						aliases_forbidden_flags[curr_format] |= D3D12_RESOURCE_FLAG_ALLOW_UNORDERED_ACCESS;
						accum_forbidden_flags |= D3D12_RESOURCE_FLAG_ALLOW_UNORDERED_ACCESS;
					}
				}
			}
		}

		if ((p_format.usage_bits & TEXTURE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT) && !(dsv_support.Support1 & D3D12_FORMAT_SUPPORT1_DEPTH_STENCIL)) {
			if (checking_main_format) {
				printf("dxgiformat: %x\n", resource_desc.Format);
				ERR_FAIL_V_MSG(RID(), "Format " + format_text + " does not support usage as depth-stencil attachment.");
			} else {
				aliases_forbidden_flags[curr_format] |= D3D12_RESOURCE_FLAG_ALLOW_DEPTH_STENCIL;
				accum_forbidden_flags |= D3D12_RESOURCE_FLAG_ALLOW_DEPTH_STENCIL;
			}
		}

		if ((p_format.usage_bits & TEXTURE_USAGE_STORAGE_BIT)) {
			if (!(uav_support.Support1 & D3D12_FORMAT_SUPPORT1_TYPED_UNORDERED_ACCESS_VIEW)) { // Maybe check LOAD/STORE, too?
				if (checking_main_format) {
					ERR_FAIL_V_MSG(RID(), "Format " + format_text + " does not support usage as storage image.");
				} else {
					aliases_forbidden_flags[curr_format] |= D3D12_RESOURCE_FLAG_ALLOW_UNORDERED_ACCESS;
					accum_forbidden_flags |= D3D12_RESOURCE_FLAG_ALLOW_UNORDERED_ACCESS;
				}
			}
		}

		if (checking_main_format) {
			if ((p_format.usage_bits & TEXTURE_USAGE_STORAGE_ATOMIC_BIT) && !(uav_support.Support2 & D3D12_FORMAT_SUPPORT2_UAV_ATOMIC_ADD)) { // Check a basic atomic at least.
				ERR_FAIL_V_MSG(RID(), "Format " + format_text + " does not support usage as atomic storage image.");
			}

			if ((p_format.usage_bits & TEXTURE_USAGE_VRS_ATTACHMENT_BIT) && d3d12_formats[curr_format].general_format != DXGI_FORMAT_R8_UINT) {
				ERR_FAIL_V_MSG(RID(), "Format " + format_text + " does not support usage as VRS attachment.");
			}
		}
	}

	if (aliasing_needed) {
		// At least guarantee the same layout among aliases.
		resource_desc.Layout = D3D12_TEXTURE_LAYOUT_64KB_UNDEFINED_SWIZZLE;

		// Per https://docs.microsoft.com/en-us/windows/win32/api/d3d12/ne-d3d12-d3d12_texture_layout.
		if (p_format.texture_type == TEXTURE_TYPE_1D) {
			ERR_FAIL_V_MSG(RID(), "This texture's views require aliasing, but that's not supported for a 1D texture.");
		}
		if (p_format.samples != TEXTURE_SAMPLES_1) {
			ERR_FAIL_V_MSG(RID(), "This texture's views require aliasing, but that's not supported for a multi-sample texture.");
		}
		if ((p_format.usage_bits & TEXTURE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT)) {
			ERR_FAIL_V_MSG(RID(), "This texture's views require aliasing, but that's not supported for a depth-stencil texture.");
		}
		if (d3d12_formats[p_format.format].family == DXGI_FORMAT_R32G32B32_TYPELESS) {
			ERR_FAIL_V_MSG(RID(), "This texture's views require aliasing, but that's not supported for an R32G32B32 texture.");
		}
	} else {
		resource_desc.Layout = D3D12_TEXTURE_LAYOUT_UNKNOWN;
	}

	if ((p_format.usage_bits & TEXTURE_USAGE_VRS_ATTACHMENT_BIT)) {
		// For VRS images we can't use the typeless format.
		resource_desc.Format = DXGI_FORMAT_R8_UINT;
	}

	// Some view validation.

	if (p_view.format_override != DATA_FORMAT_MAX) {
		ERR_FAIL_INDEX_V(p_view.format_override, DATA_FORMAT_MAX, RID());
	}
	ERR_FAIL_INDEX_V(p_view.swizzle_r, TEXTURE_SWIZZLE_MAX, RID());
	ERR_FAIL_INDEX_V(p_view.swizzle_g, TEXTURE_SWIZZLE_MAX, RID());
	ERR_FAIL_INDEX_V(p_view.swizzle_b, TEXTURE_SWIZZLE_MAX, RID());
	ERR_FAIL_INDEX_V(p_view.swizzle_a, TEXTURE_SWIZZLE_MAX, RID());

	// Allocate memory.

	D3D12MA::ALLOCATION_DESC allocation_desc = {};
	// NOTE: D3D12MA::ALLOCATION_FLAG_CAN_ALIAS in allocation_desc.Flags seems not to be needed for one-to-one aliasing.
	allocation_desc.HeapType = (p_format.usage_bits & TEXTURE_USAGE_CPU_READ_BIT) ? D3D12_HEAP_TYPE_READBACK : D3D12_HEAP_TYPE_DEFAULT;
	if ((resource_desc.Flags & (D3D12_RESOURCE_FLAG_ALLOW_RENDER_TARGET | D3D12_RESOURCE_FLAG_ALLOW_DEPTH_STENCIL))) {
		if (!(accum_forbidden_flags & (D3D12_RESOURCE_FLAG_ALLOW_RENDER_TARGET | D3D12_RESOURCE_FLAG_ALLOW_DEPTH_STENCIL))) {
			allocation_desc.ExtraHeapFlags = D3D12_HEAP_FLAG_ALLOW_ONLY_RT_DS_TEXTURES;
		}
	} else {
		allocation_desc.ExtraHeapFlags = D3D12_HEAP_FLAG_ALLOW_ONLY_NON_RT_DS_TEXTURES;
	}
	if ((resource_desc.Flags & D3D12_RESOURCE_FLAG_ALLOW_UNORDERED_ACCESS)) {
		if (!(accum_forbidden_flags & D3D12_RESOURCE_FLAG_ALLOW_UNORDERED_ACCESS)) {
			allocation_desc.ExtraHeapFlags |= D3D12_HEAP_FLAG_ALLOW_SHADER_ATOMICS;
		}
	}

#ifdef USE_SMALL_ALLOCS_POOL
	uint32_t width, height;
	uint32_t image_size = get_image_format_required_size(p_format.format, p_format.width, p_format.height, p_format.depth, p_format.mipmaps, &width, &height);
	if (image_size <= SMALL_ALLOCATION_MAX_SIZE) {
		allocation_desc.CustomPool = _find_or_create_small_allocs_pool(allocation_desc.HeapType, allocation_desc.ExtraHeapFlags);
	}
#endif

	Texture texture;

	D3D12_RESOURCE_STATES initial_state = p_data.size() || (p_format.usage_bits & TEXTURE_USAGE_CPU_READ_BIT) ? D3D12_RESOURCE_STATE_COPY_DEST : D3D12_RESOURCE_STATE_ALL_SHADER_RESOURCE;
	FLOAT black[4] = {};
	D3D12_CLEAR_VALUE clear_value = CD3DX12_CLEAR_VALUE(d3d12_formats[p_format.format].general_format, black);
	D3D12_CLEAR_VALUE *clear_value_ptr = (resource_desc.Flags & D3D12_RESOURCE_FLAG_ALLOW_RENDER_TARGET) ? &clear_value : nullptr;
	HRESULT res = allocator->CreateResource(
			&allocation_desc,
			&resource_desc,
			initial_state,
			clear_value_ptr,
			&texture.allocation,
			IID_PPV_ARGS(&texture.owner_resource));
	ERR_FAIL_COND_V_MSG(res, RID(), "CreateResource failed with error " + vformat("0x%08x", res) + ".");
	texture.resource = texture.owner_resource;
	image_memory += texture.allocation->GetSize();
	texture.type = p_format.texture_type;
	texture.format = p_format.format;
	texture.planes = get_image_format_plane_count(p_format.format);
	texture.width = p_format.width;
	texture.height = p_format.height;
	texture.depth = p_format.depth;
	texture.layers = p_format.array_layers;
	texture.mipmaps = p_format.mipmaps;
	texture.owner_layers = texture.layers;
	texture.owner_mipmaps = texture.mipmaps;
	texture.base_mipmap = 0;
	texture.base_layer = 0;
	texture.is_resolve_buffer = p_format.is_resolve_buffer;
	texture.usage_flags = p_format.usage_bits;
	texture.samples = p_format.samples;
	texture.allowed_shared_formats = p_format.shareable_formats;
	texture.own_states.subresource_states.resize(texture.mipmaps * texture.layers);
	for (uint32_t i = 0; i < texture.own_states.subresource_states.size(); i++) {
		texture.own_states.subresource_states[i] = initial_state;
	}
	texture.bound = false;

	// Describe view.

	static const D3D12_SRV_DIMENSION view_dimensions[TEXTURE_TYPE_MAX] = {
		D3D12_SRV_DIMENSION_TEXTURE1D,
		D3D12_SRV_DIMENSION_TEXTURE2D,
		D3D12_SRV_DIMENSION_TEXTURE3D,
		D3D12_SRV_DIMENSION_TEXTURECUBE,
		D3D12_SRV_DIMENSION_TEXTURE1DARRAY,
		D3D12_SRV_DIMENSION_TEXTURE2DARRAY,
		D3D12_SRV_DIMENSION_TEXTURECUBEARRAY,
	};
	static const D3D12_SRV_DIMENSION view_dimensions_ms[TEXTURE_TYPE_MAX] = {
		D3D12_SRV_DIMENSION_UNKNOWN,
		D3D12_SRV_DIMENSION_TEXTURE2DMS,
		D3D12_SRV_DIMENSION_UNKNOWN,
		D3D12_SRV_DIMENSION_UNKNOWN,
		D3D12_SRV_DIMENSION_UNKNOWN,
		D3D12_SRV_DIMENSION_TEXTURE2DMSARRAY,
		D3D12_SRV_DIMENSION_UNKNOWN,
	};
	static const D3D12_UAV_DIMENSION uav_dimensions[TEXTURE_TYPE_MAX] = {
		D3D12_UAV_DIMENSION_TEXTURE1D,
		D3D12_UAV_DIMENSION_TEXTURE2D,
		D3D12_UAV_DIMENSION_TEXTURE3D,
		D3D12_UAV_DIMENSION_TEXTURE2DARRAY,
		D3D12_UAV_DIMENSION_TEXTURE1DARRAY,
		D3D12_UAV_DIMENSION_TEXTURE2DARRAY,
		D3D12_UAV_DIMENSION_TEXTURE2DARRAY,
	};

	texture.srv_desc.ViewDimension = p_format.samples == TEXTURE_SAMPLES_1 ? view_dimensions[p_format.texture_type] : view_dimensions_ms[p_format.texture_type];

	texture.owner_uav_desc.Format = d3d12_formats[p_format.format].general_format;
	texture.owner_uav_desc.ViewDimension = p_format.samples == TEXTURE_SAMPLES_1 ? uav_dimensions[p_format.texture_type] : D3D12_UAV_DIMENSION_UNKNOWN;

	UINT base_swizzle = D3D12_DEFAULT_SHADER_4_COMPONENT_MAPPING;
	if (p_view.format_override == DATA_FORMAT_MAX) {
		texture.srv_desc.Format = d3d12_formats[p_format.format].general_format;
		base_swizzle = d3d12_formats[p_format.format].swizzle;
	} else {
		texture.srv_desc.Format = d3d12_formats[p_view.format_override].general_format;
		base_swizzle = d3d12_formats[p_view.format_override].swizzle;
	}

	// Apply requested swizzle (component mapping) on top of the one from the format database.

	D3D12_SHADER_COMPONENT_MAPPING component_swizzles[TEXTURE_SWIZZLE_MAX] = {
		D3D12_SHADER_COMPONENT_MAPPING_FORCE_VALUE_0, // Unused.
		D3D12_SHADER_COMPONENT_MAPPING_FORCE_VALUE_0,
		D3D12_SHADER_COMPONENT_MAPPING_FORCE_VALUE_1,
		// These will be D3D12_SHADER_COMPONENT_MAPPING_FROM_MEMORY_COMPONENT_*.
		D3D12_DECODE_SHADER_4_COMPONENT_MAPPING(0, base_swizzle),
		D3D12_DECODE_SHADER_4_COMPONENT_MAPPING(1, base_swizzle),
		D3D12_DECODE_SHADER_4_COMPONENT_MAPPING(2, base_swizzle),
		D3D12_DECODE_SHADER_4_COMPONENT_MAPPING(3, base_swizzle),
	};

	texture.srv_desc.Shader4ComponentMapping = D3D12_ENCODE_SHADER_4_COMPONENT_MAPPING(
			p_view.swizzle_r == TEXTURE_SWIZZLE_IDENTITY ? component_swizzles[TEXTURE_SWIZZLE_R] : component_swizzles[p_view.swizzle_r],
			p_view.swizzle_g == TEXTURE_SWIZZLE_IDENTITY ? component_swizzles[TEXTURE_SWIZZLE_G] : component_swizzles[p_view.swizzle_g],
			p_view.swizzle_b == TEXTURE_SWIZZLE_IDENTITY ? component_swizzles[TEXTURE_SWIZZLE_B] : component_swizzles[p_view.swizzle_b],
			p_view.swizzle_a == TEXTURE_SWIZZLE_IDENTITY ? component_swizzles[TEXTURE_SWIZZLE_A] : component_swizzles[p_view.swizzle_a]);

	switch (texture.srv_desc.ViewDimension) {
		case D3D12_SRV_DIMENSION_TEXTURE1D: {
			texture.srv_desc.Texture1D.MipLevels = p_format.mipmaps;
		} break;
		case D3D12_SRV_DIMENSION_TEXTURE1DARRAY: {
			texture.srv_desc.Texture1DArray.MipLevels = p_format.mipmaps;
			texture.srv_desc.Texture1DArray.ArraySize = p_format.array_layers;
		} break;
		case D3D12_SRV_DIMENSION_TEXTURE2D: {
			texture.srv_desc.Texture2D.MipLevels = p_format.mipmaps;
		} break;
		case D3D12_SRV_DIMENSION_TEXTURE2DMS: {
		} break;
		case D3D12_SRV_DIMENSION_TEXTURE2DARRAY: {
			texture.srv_desc.Texture2DArray.MipLevels = p_format.mipmaps;
			texture.srv_desc.Texture2DArray.ArraySize = p_format.array_layers;
		} break;
		case D3D12_SRV_DIMENSION_TEXTURE2DMSARRAY: {
			texture.srv_desc.Texture2DMSArray.ArraySize = p_format.array_layers;
		} break;
		case D3D12_SRV_DIMENSION_TEXTURECUBEARRAY: {
			texture.srv_desc.TextureCubeArray.MipLevels = p_format.mipmaps;
			texture.srv_desc.TextureCubeArray.NumCubes = p_format.array_layers / 6;
		} break;
		case D3D12_SRV_DIMENSION_TEXTURE3D: {
			texture.srv_desc.Texture3D.MipLevels = p_format.mipmaps;
		} break;
		case D3D12_SRV_DIMENSION_TEXTURECUBE: {
			texture.srv_desc.TextureCube.MipLevels = p_format.mipmaps;
		} break;
	}

	switch (texture.owner_uav_desc.ViewDimension) {
		case D3D12_UAV_DIMENSION_TEXTURE1DARRAY: {
			texture.owner_uav_desc.Texture1DArray.ArraySize = p_format.array_layers;
		} break;
		case D3D12_UAV_DIMENSION_TEXTURE2DARRAY: {
			// Either for an actual 2D texture array, cubemap or cubemap array.
			texture.owner_uav_desc.Texture2DArray.ArraySize = p_format.array_layers;
		} break;
		case D3D12_UAV_DIMENSION_TEXTURE3D: {
			texture.owner_uav_desc.Texture3D.WSize = p_format.depth;
		} break;
		default: {
		}
	}

	texture.uav_desc = texture.owner_uav_desc;
	if (p_view.format_override != DATA_FORMAT_MAX) {
		texture.uav_desc.Format = d3d12_formats[p_view.format_override].general_format;
	}

	if (aliasing_needed) {
		D3D12_RESOURCE_DESC resource_desc_backup = resource_desc;
		D3D12MA::ALLOCATION_DESC allocation_desc_backup = allocation_desc;

		texture.aliases.resize(texture.allowed_shared_formats.size());
		for (int i = 0; i < texture.allowed_shared_formats.size(); i++) {
			DataFormat curr_format = texture.allowed_shared_formats[i];

			DXGI_FORMAT format_family = d3d12_formats[curr_format].family;
			if (format_family == d3d12_formats[p_format.format].family) {
				texture.aliases[i] = nullptr;
				continue;
			}

			D3D12_RESOURCE_DESC alias_resource_desc = resource_desc;
			alias_resource_desc.Format = format_family;
			if (aliases_forbidden_flags.has(curr_format)) {
				alias_resource_desc.Flags &= ~aliases_forbidden_flags[curr_format];
			}
			clear_value.Format = format_family;
			res = allocator->CreateAliasingResource(
					texture.allocation,
					0,
					&alias_resource_desc,
					initial_state,
					(alias_resource_desc.Flags & D3D12_RESOURCE_FLAG_ALLOW_RENDER_TARGET) ? clear_value_ptr : nullptr,
					IID_PPV_ARGS(&texture.aliases[i]));
			ERR_FAIL_COND_V_MSG(res, RID(), "CreateAliasingResource failed with error " + vformat("0x%08x", res) + ".");

			if (curr_format == p_view.format_override) {
				texture.resource = texture.aliases[i];
			}
		}
	}

	RID id = texture_owner.make_rid(texture);
#ifdef DEV_ENABLED
	set_resource_name(id, "RID:" + itos(id.get_id()));
#endif

	if (p_data.size()) {
		Texture *texture_ptr = texture_owner.get_or_null(id);
		ERR_FAIL_COND_V(!texture_ptr, RID());

		ID3D12GraphicsCommandList *command_list = frames[frame].setup_command_list.Get();

		for (uint32_t i = 0; i < p_format.array_layers; i++) {
			_texture_update(texture_ptr, i, p_data[i], RD::BARRIER_MASK_ALL_BARRIERS, command_list);
		}
	}
	return id;
}

RID RenderingDeviceD3D12::texture_create_shared(const TextureView &p_view, RID p_with_texture) {
	_THREAD_SAFE_METHOD_

	Texture *src_texture = texture_owner.get_or_null(p_with_texture);
	ERR_FAIL_COND_V(!src_texture, RID());

	if (src_texture->owner.is_valid()) { // Ahh this is a share.
		p_with_texture = src_texture->owner;
		src_texture = texture_owner.get_or_null(src_texture->owner);
		ERR_FAIL_COND_V(!src_texture, RID()); // This is a bug.
	}

	// Describe view.

	Texture texture = *src_texture;
	texture.own_states.subresource_states.clear();
	texture.states = &src_texture->own_states;

	UINT base_swizzle = D3D12_DEFAULT_SHADER_4_COMPONENT_MAPPING;
	if (p_view.format_override == DATA_FORMAT_MAX || p_view.format_override == texture.format) {
		texture.srv_desc.Format = d3d12_formats[texture.format].general_format;
		base_swizzle = d3d12_formats[texture.format].swizzle;
		texture.uav_desc.Format = d3d12_formats[texture.format].general_format;
	} else {
		ERR_FAIL_INDEX_V(p_view.format_override, DATA_FORMAT_MAX, RID());

		ERR_FAIL_COND_V_MSG(texture.allowed_shared_formats.find(p_view.format_override) == -1, RID(),
				"Format override is not in the list of allowed shareable formats for original texture.");
		texture.srv_desc.Format = d3d12_formats[p_view.format_override].general_format;
		base_swizzle = d3d12_formats[p_view.format_override].swizzle;
		texture.uav_desc.Format = d3d12_formats[p_view.format_override].general_format;

		if (texture.aliases.size()) {
			for (int i = 0; i < texture.allowed_shared_formats.size(); i++) {
				if (texture.allowed_shared_formats[i] == p_view.format_override) {
					texture.resource = texture.aliases[i];
					break;
				}
			}
		}
	}

	// Apply requested swizzle (component mapping) on top of the one from the format database.

	D3D12_SHADER_COMPONENT_MAPPING component_swizzles[TEXTURE_SWIZZLE_MAX] = {
		D3D12_SHADER_COMPONENT_MAPPING_FORCE_VALUE_0, // Unused.
		D3D12_SHADER_COMPONENT_MAPPING_FORCE_VALUE_0,
		D3D12_SHADER_COMPONENT_MAPPING_FORCE_VALUE_1,
		// These will be D3D12_SHADER_COMPONENT_MAPPING_FROM_MEMORY_COMPONENT_*.
		D3D12_DECODE_SHADER_4_COMPONENT_MAPPING(0, base_swizzle),
		D3D12_DECODE_SHADER_4_COMPONENT_MAPPING(1, base_swizzle),
		D3D12_DECODE_SHADER_4_COMPONENT_MAPPING(2, base_swizzle),
		D3D12_DECODE_SHADER_4_COMPONENT_MAPPING(3, base_swizzle),
	};

	texture.srv_desc.Shader4ComponentMapping = D3D12_ENCODE_SHADER_4_COMPONENT_MAPPING(
			p_view.swizzle_r == TEXTURE_SWIZZLE_IDENTITY ? component_swizzles[TEXTURE_SWIZZLE_R] : component_swizzles[p_view.swizzle_r],
			p_view.swizzle_g == TEXTURE_SWIZZLE_IDENTITY ? component_swizzles[TEXTURE_SWIZZLE_G] : component_swizzles[p_view.swizzle_g],
			p_view.swizzle_b == TEXTURE_SWIZZLE_IDENTITY ? component_swizzles[TEXTURE_SWIZZLE_B] : component_swizzles[p_view.swizzle_b],
			p_view.swizzle_a == TEXTURE_SWIZZLE_IDENTITY ? component_swizzles[TEXTURE_SWIZZLE_A] : component_swizzles[p_view.swizzle_a]);

	texture.owner = p_with_texture;
	RID id = texture_owner.make_rid(texture);
#ifdef DEV_ENABLED
	set_resource_name(id, "RID:" + itos(id.get_id()));
#endif
	_add_dependency(id, p_with_texture);

	return id;
}

RID RenderingDeviceD3D12::texture_create_from_extension(TextureType p_type, DataFormat p_format, TextureSamples p_samples, uint64_t p_flags, uint64_t p_image, uint64_t p_width, uint64_t p_height, uint64_t p_depth, uint64_t p_layers) {
	ERR_FAIL_V_MSG(RID(), "Unimplemented!");
}

RID RenderingDeviceD3D12::texture_create_shared_from_slice(const TextureView &p_view, RID p_with_texture, uint32_t p_layer, uint32_t p_mipmap, uint32_t p_mipmaps, TextureSliceType p_slice_type) {
	_THREAD_SAFE_METHOD_

	Texture *src_texture = texture_owner.get_or_null(p_with_texture);
	ERR_FAIL_COND_V(!src_texture, RID());

	if (src_texture->owner.is_valid()) { // Ahh this is a share.
		p_with_texture = src_texture->owner;
		src_texture = texture_owner.get_or_null(src_texture->owner);
		ERR_FAIL_COND_V(!src_texture, RID()); // This is a bug.
	}

	ERR_FAIL_COND_V_MSG(p_slice_type == TEXTURE_SLICE_CUBEMAP && (src_texture->type != TEXTURE_TYPE_CUBE && src_texture->type != TEXTURE_TYPE_CUBE_ARRAY), RID(),
			"Can only create a cubemap slice from a cubemap or cubemap array mipmap");

	ERR_FAIL_COND_V_MSG(p_slice_type == TEXTURE_SLICE_3D && src_texture->type != TEXTURE_TYPE_3D, RID(),
			"Can only create a 3D slice from a 3D texture");

	ERR_FAIL_COND_V_MSG(p_slice_type == TEXTURE_SLICE_2D_ARRAY && (src_texture->type != TEXTURE_TYPE_2D_ARRAY), RID(),
			"Can only create an array slice from a 2D array mipmap");

	// Describe view.

	ERR_FAIL_UNSIGNED_INDEX_V(p_mipmap, src_texture->mipmaps, RID());
	ERR_FAIL_COND_V(p_mipmap + p_mipmaps > src_texture->mipmaps, RID());
	ERR_FAIL_UNSIGNED_INDEX_V(p_layer, src_texture->layers, RID());

	int slice_layers = 1;
	if (p_slice_type == TEXTURE_SLICE_2D_ARRAY) {
		ERR_FAIL_COND_V_MSG(p_layer != 0, RID(), "layer must be 0 when obtaining a 2D array mipmap slice");
		slice_layers = src_texture->layers;
	} else if (p_slice_type == TEXTURE_SLICE_CUBEMAP) {
		slice_layers = 6;
	}

	Texture texture = *src_texture;
	get_image_format_required_size(texture.format, texture.width, texture.height, texture.depth, p_mipmap + 1, &texture.width, &texture.height);
	texture.mipmaps = p_mipmaps;
	texture.layers = slice_layers;
	texture.base_mipmap = p_mipmap;
	texture.base_layer = p_layer;
	texture.own_states.subresource_states.clear();
	texture.states = &src_texture->own_states;

	UINT base_swizzle = D3D12_DEFAULT_SHADER_4_COMPONENT_MAPPING;
	if (p_view.format_override == DATA_FORMAT_MAX || p_view.format_override == texture.format) {
		texture.srv_desc.Format = d3d12_formats[texture.format].general_format;
		base_swizzle = d3d12_formats[texture.format].swizzle;
		texture.uav_desc.Format = d3d12_formats[texture.format].general_format;
	} else {
		ERR_FAIL_INDEX_V(p_view.format_override, DATA_FORMAT_MAX, RID());

		ERR_FAIL_COND_V_MSG(texture.allowed_shared_formats.find(p_view.format_override) == -1, RID(),
				"Format override is not in the list of allowed shareable formats for original texture.");
		texture.srv_desc.Format = d3d12_formats[p_view.format_override].general_format;
		base_swizzle = d3d12_formats[p_view.format_override].swizzle;
		texture.uav_desc.Format = d3d12_formats[p_view.format_override].general_format;

		if (texture.aliases.size()) {
			for (int i = 0; i < texture.allowed_shared_formats.size(); i++) {
				if (texture.allowed_shared_formats[i] == p_view.format_override) {
					texture.resource = texture.aliases[i];
					break;
				}
			}
		}
	}

	// Apply requested swizzle (component mapping) on top of the one from the format database.

	D3D12_SHADER_COMPONENT_MAPPING component_swizzles[TEXTURE_SWIZZLE_MAX] = {
		D3D12_SHADER_COMPONENT_MAPPING_FORCE_VALUE_0, // Unused.
		D3D12_SHADER_COMPONENT_MAPPING_FORCE_VALUE_0,
		D3D12_SHADER_COMPONENT_MAPPING_FORCE_VALUE_1,
		// These will be D3D12_SHADER_COMPONENT_MAPPING_FROM_MEMORY_COMPONENT_*.
		D3D12_DECODE_SHADER_4_COMPONENT_MAPPING(0, base_swizzle),
		D3D12_DECODE_SHADER_4_COMPONENT_MAPPING(1, base_swizzle),
		D3D12_DECODE_SHADER_4_COMPONENT_MAPPING(2, base_swizzle),
		D3D12_DECODE_SHADER_4_COMPONENT_MAPPING(3, base_swizzle),
	};

	texture.srv_desc.Shader4ComponentMapping = D3D12_ENCODE_SHADER_4_COMPONENT_MAPPING(
			p_view.swizzle_r == TEXTURE_SWIZZLE_IDENTITY ? component_swizzles[TEXTURE_SWIZZLE_R] : component_swizzles[p_view.swizzle_r],
			p_view.swizzle_g == TEXTURE_SWIZZLE_IDENTITY ? component_swizzles[TEXTURE_SWIZZLE_G] : component_swizzles[p_view.swizzle_g],
			p_view.swizzle_b == TEXTURE_SWIZZLE_IDENTITY ? component_swizzles[TEXTURE_SWIZZLE_B] : component_swizzles[p_view.swizzle_b],
			p_view.swizzle_a == TEXTURE_SWIZZLE_IDENTITY ? component_swizzles[TEXTURE_SWIZZLE_A] : component_swizzles[p_view.swizzle_a]);

	if (p_slice_type == TEXTURE_SLICE_CUBEMAP) {
		ERR_FAIL_COND_V_MSG(p_layer >= src_texture->layers, RID(),
				"Specified layer is invalid for cubemap");
		ERR_FAIL_COND_V_MSG((p_layer % 6) != 0, RID(),
				"Specified layer must be a multiple of 6.");
	}

	// Leveraging aliasing in members of the union as much as possible.

	texture.srv_desc.Texture1D.MostDetailedMip = p_mipmap;
	texture.srv_desc.Texture1D.MipLevels = 1;

	texture.uav_desc.Texture1D.MipSlice = p_mipmap;

	switch (p_slice_type) {
		case TEXTURE_SLICE_2D: {
			if (texture.srv_desc.ViewDimension == D3D12_SRV_DIMENSION_TEXTURE2D && p_layer == 0) {
				CRASH_COND(texture.uav_desc.ViewDimension != D3D12_UAV_DIMENSION_TEXTURE2D);
			} else if (texture.srv_desc.ViewDimension == D3D12_SRV_DIMENSION_TEXTURE2DMS && p_layer == 0) {
				CRASH_COND(texture.uav_desc.ViewDimension != D3D12_UAV_DIMENSION_UNKNOWN);
			} else if ((texture.srv_desc.ViewDimension == D3D12_SRV_DIMENSION_TEXTURE2DARRAY || (texture.srv_desc.ViewDimension == D3D12_SRV_DIMENSION_TEXTURE2D && p_layer)) || texture.srv_desc.ViewDimension == D3D12_SRV_DIMENSION_TEXTURECUBE || texture.srv_desc.ViewDimension == D3D12_SRV_DIMENSION_TEXTURECUBEARRAY) {
				texture.srv_desc.ViewDimension = D3D12_SRV_DIMENSION_TEXTURE2DARRAY;
				texture.srv_desc.Texture2DArray.FirstArraySlice = p_layer;
				texture.srv_desc.Texture2DArray.ArraySize = 1;
				texture.srv_desc.Texture2DArray.PlaneSlice = 0;
				texture.srv_desc.Texture2DArray.ResourceMinLODClamp = 0.0f;

				texture.uav_desc.ViewDimension = D3D12_UAV_DIMENSION_TEXTURE2DARRAY;
				texture.uav_desc.Texture2DArray.FirstArraySlice = p_layer;
				texture.uav_desc.Texture2DArray.ArraySize = 1;
				texture.uav_desc.Texture2DArray.PlaneSlice = 0;
			} else if ((texture.srv_desc.ViewDimension == D3D12_SRV_DIMENSION_TEXTURE2DMSARRAY || (texture.srv_desc.ViewDimension == D3D12_SRV_DIMENSION_TEXTURE2DMS && p_layer))) {
				texture.srv_desc.ViewDimension = D3D12_SRV_DIMENSION_TEXTURE2DARRAY;
				texture.srv_desc.Texture2DMSArray.FirstArraySlice = p_layer;
				texture.srv_desc.Texture2DMSArray.ArraySize = 1;

				texture.uav_desc.ViewDimension = D3D12_UAV_DIMENSION_UNKNOWN;
			} else {
				CRASH_NOW();
			}
		} break;
		case TEXTURE_SLICE_CUBEMAP: {
			if (texture.srv_desc.ViewDimension == D3D12_SRV_DIMENSION_TEXTURECUBE) {
				CRASH_COND(texture.uav_desc.ViewDimension != D3D12_UAV_DIMENSION_TEXTURE2DARRAY);
			} else if (texture.srv_desc.ViewDimension == D3D12_SRV_DIMENSION_TEXTURECUBE || p_layer == 0) {
				texture.srv_desc.ViewDimension = D3D12_SRV_DIMENSION_TEXTURECUBE;

				CRASH_COND(texture.uav_desc.ViewDimension != D3D12_UAV_DIMENSION_TEXTURE2DARRAY);
				texture.uav_desc.ViewDimension = D3D12_UAV_DIMENSION_TEXTURE2DARRAY;
				texture.uav_desc.Texture2DArray.FirstArraySlice = 0;
				texture.uav_desc.Texture2DArray.ArraySize = 6;
				texture.uav_desc.Texture2DArray.PlaneSlice = 0;
			} else if (texture.srv_desc.ViewDimension == D3D12_SRV_DIMENSION_TEXTURECUBEARRAY || p_layer != 0) {
				texture.srv_desc.ViewDimension = D3D12_SRV_DIMENSION_TEXTURECUBEARRAY;
				texture.srv_desc.TextureCubeArray.First2DArrayFace = p_layer;
				texture.srv_desc.TextureCubeArray.NumCubes = 1;
				texture.srv_desc.TextureCubeArray.ResourceMinLODClamp = 0.0f;

				CRASH_COND(texture.uav_desc.ViewDimension != D3D12_UAV_DIMENSION_TEXTURE2DARRAY);
				texture.uav_desc.ViewDimension = D3D12_UAV_DIMENSION_TEXTURE2DARRAY;
				texture.uav_desc.Texture2DArray.FirstArraySlice = p_layer;
				texture.uav_desc.Texture2DArray.ArraySize = 6;
				texture.uav_desc.Texture2DArray.PlaneSlice = 0;
			} else {
				CRASH_NOW();
			}
		} break;
		case TEXTURE_SLICE_3D: {
			CRASH_COND(texture.srv_desc.ViewDimension != D3D12_SRV_DIMENSION_TEXTURE3D);
			CRASH_COND(texture.uav_desc.ViewDimension != D3D12_UAV_DIMENSION_TEXTURE3D);
		} break;
		case TEXTURE_SLICE_2D_ARRAY: {
			CRASH_COND(texture.srv_desc.ViewDimension != D3D12_SRV_DIMENSION_TEXTURE2DARRAY);
			texture.srv_desc.Texture2DArray.FirstArraySlice = p_layer;
			texture.srv_desc.Texture2DArray.ArraySize = slice_layers;

			CRASH_COND(texture.uav_desc.ViewDimension != D3D12_UAV_DIMENSION_TEXTURE2DARRAY);
			texture.uav_desc.Texture2DArray.FirstArraySlice = p_layer;
			texture.uav_desc.Texture2DArray.ArraySize = slice_layers;
		} break;
	}

	texture.owner = p_with_texture;
	RID id = texture_owner.make_rid(texture);
#ifdef DEV_ENABLED
	set_resource_name(id, "RID:" + itos(id.get_id()));
#endif
	_add_dependency(id, p_with_texture);

	return id;
}

Error RenderingDeviceD3D12::texture_update(RID p_texture, uint32_t p_layer, const Vector<uint8_t> &p_data, BitField<BarrierMask> p_post_barrier) {
	ERR_FAIL_COND_V_MSG((draw_list || compute_list), ERR_INVALID_PARAMETER,
			"Updating textures is forbidden during creation of a draw or compute list");

	Texture *texture = texture_owner.get_or_null(p_texture);
	ERR_FAIL_COND_V(!texture, ERR_INVALID_PARAMETER);

	if (texture->owner != RID()) {
		texture = texture_owner.get_or_null(texture->owner);
		ERR_FAIL_COND_V(!texture, ERR_BUG); // This is a bug.
	}

	ID3D12GraphicsCommandList *command_list = frames[frame].draw_command_list.Get();

	uint32_t subresource = D3D12CalcSubresource(0, p_layer, 0, texture->mipmaps, texture->layers);
	_resource_transition_batch(texture, subresource, texture->planes, D3D12_RESOURCE_STATE_COPY_DEST);
	_resource_transitions_flush(command_list);
	Error err = _texture_update(texture, p_layer, p_data, p_post_barrier, command_list);

	return err;
}

static _ALWAYS_INLINE_ void _copy_region(uint8_t const *__restrict p_src, uint8_t *__restrict p_dst, uint32_t p_src_x, uint32_t p_src_y, uint32_t p_src_w, uint32_t p_src_h, uint32_t p_src_full_w, uint32_t p_dst_pitch, uint32_t p_unit_size) {
	uint32_t src_offset = (p_src_y * p_src_full_w + p_src_x) * p_unit_size;
	uint32_t dst_offset = 0;
	for (uint32_t y = p_src_h; y > 0; y--) {
		uint8_t const *__restrict src = p_src + src_offset;
		uint8_t *__restrict dst = p_dst + dst_offset;
		for (uint32_t x = p_src_w * p_unit_size; x > 0; x--) {
			*dst = *src;
			src++;
			dst++;
		}
		src_offset += p_src_full_w * p_unit_size;
		dst_offset += p_dst_pitch;
	}
}

Error RenderingDeviceD3D12::_texture_update(Texture *p_texture, uint32_t p_layer, const Vector<uint8_t> &p_data, BitField<BarrierMask> p_post_barrier, ID3D12GraphicsCommandList *p_command_list) {
	_THREAD_SAFE_METHOD_

	ERR_FAIL_COND_V_MSG(p_texture->bound, ERR_CANT_ACQUIRE_RESOURCE,
			"Texture can't be updated while a render pass that uses it is being created. Ensure render pass is finalized (and that it was created with RENDER_PASS_CONTENTS_FINISH) to unbind this texture.");

	ERR_FAIL_COND_V_MSG(!(p_texture->usage_flags & TEXTURE_USAGE_CAN_UPDATE_BIT), ERR_INVALID_PARAMETER,
			"Texture requires the TEXTURE_USAGE_CAN_UPDATE_BIT in order to be updatable.");

	uint32_t layer_count = p_texture->layers;
	if (p_texture->type == TEXTURE_TYPE_CUBE || p_texture->type == TEXTURE_TYPE_CUBE_ARRAY) {
		layer_count *= 6;
	}
	ERR_FAIL_COND_V(p_layer >= layer_count, ERR_INVALID_PARAMETER);

	uint32_t width, height;
	uint32_t image_size = get_image_format_required_size(p_texture->format, p_texture->width, p_texture->height, p_texture->depth, p_texture->mipmaps, &width, &height);
	uint32_t required_size = image_size;
	uint32_t required_align = get_compressed_image_format_block_byte_size(p_texture->format);
	if (required_align == 1) {
		required_align = get_image_format_pixel_size(p_texture->format);
	}
	if ((required_align % 4) != 0) { // Alignment rules are really strange.
		required_align *= 4;
	}

	required_align = ALIGN(required_align, D3D12_TEXTURE_DATA_PLACEMENT_ALIGNMENT);

	ERR_FAIL_COND_V_MSG(required_size != (uint32_t)p_data.size(), ERR_INVALID_PARAMETER,
			"Required size for texture update (" + itos(required_size) + ") does not match data supplied size (" + itos(p_data.size()) + ").");

	uint32_t region_size = texture_upload_region_size_px;

	const uint8_t *r = p_data.ptr();

	uint32_t mipmap_offset = 0;

	uint32_t logic_width = p_texture->width;
	uint32_t logic_height = p_texture->height;

	for (uint32_t mm_i = 0; mm_i < p_texture->mipmaps; mm_i++) {
		uint32_t depth;
		uint32_t image_total = get_image_format_required_size(p_texture->format, p_texture->width, p_texture->height, p_texture->depth, mm_i + 1, &width, &height, &depth);

		const uint8_t *read_ptr_mipmap = r + mipmap_offset;
		image_size = image_total - mipmap_offset;

		UINT dst_subresource = D3D12CalcSubresource(mm_i, p_layer, 0, p_texture->mipmaps, p_texture->layers);
		CD3DX12_TEXTURE_COPY_LOCATION copy_dst(p_texture->resource, dst_subresource);

		for (uint32_t z = 0; z < depth; z++) { // For 3D textures, depth may be > 0.

			const uint8_t *read_ptr = read_ptr_mipmap + image_size * z / depth;

			for (uint32_t y = 0; y < height; y += region_size) {
				for (uint32_t x = 0; x < width; x += region_size) {
					uint32_t region_w = MIN(region_size, width - x);
					uint32_t region_h = MIN(region_size, height - y);

					uint32_t pixel_size = get_image_format_pixel_size(p_texture->format);
					uint32_t block_w, block_h;
					get_compressed_image_format_block_dimensions(p_texture->format, block_w, block_h);

					uint32_t region_pitch = (region_w * pixel_size * block_w) >> get_compressed_image_format_pixel_rshift(p_texture->format);
					region_pitch = ALIGN(region_pitch, D3D12_TEXTURE_DATA_PITCH_ALIGNMENT);
					uint32_t to_allocate = region_pitch * region_h;

					uint32_t alloc_offset, alloc_size;
					Error err = _staging_buffer_allocate(to_allocate, required_align, alloc_offset, alloc_size, false);
					ERR_FAIL_COND_V(err, ERR_CANT_CREATE);

					uint8_t *write_ptr;

					{ // Map.
						void *data_ptr = nullptr;
						HRESULT res = staging_buffer_blocks[staging_buffer_current].resource->Map(0, &VOID_RANGE, &data_ptr);
						ERR_FAIL_COND_V_MSG(res, ERR_CANT_CREATE, "Map failed with error " + vformat("0x%08x", res) + ".");
						write_ptr = (uint8_t *)data_ptr;
						write_ptr += alloc_offset;
					}

					ERR_FAIL_COND_V(region_w % block_w, ERR_BUG);
					ERR_FAIL_COND_V(region_pitch % block_w, ERR_BUG);
					ERR_FAIL_COND_V(region_h % block_h, ERR_BUG);

					if (block_w != 1 || block_h != 1) {
						// Compressed image (functions).
						// Must copy a block region.

						uint32_t block_size = get_compressed_image_format_block_byte_size(p_texture->format);
						// Re-create current variables in blocky format.
						uint32_t xb = x / block_w;
						uint32_t yb = y / block_h;
						uint32_t wb = width / block_w;
						// Uint32_t hb = height / block_h;.
						uint32_t region_wb = region_w / block_w;
						uint32_t region_hb = region_h / block_h;
						_copy_region(read_ptr, write_ptr, xb, yb, region_wb, region_hb, wb, region_pitch, block_size);
					} else {
						// Regular image (pixels).
						// Must copy a pixel region.
						_copy_region(read_ptr, write_ptr, x, y, region_w, region_h, width, region_pitch, pixel_size);
					}

					{ // Unmap.
						staging_buffer_blocks[staging_buffer_current].resource->Unmap(0, &VOID_RANGE);
					}

					D3D12_PLACED_SUBRESOURCE_FOOTPRINT src_footprint = {};
					src_footprint.Offset = alloc_offset;
					src_footprint.Footprint = CD3DX12_SUBRESOURCE_FOOTPRINT(
							d3d12_formats[p_texture->format].family,
							region_w,
							region_h,
							1,
							region_pitch);
					CD3DX12_TEXTURE_COPY_LOCATION copy_src(staging_buffer_blocks[staging_buffer_current].resource, src_footprint);

					CD3DX12_BOX src_box(0, 0, region_w, region_h);
					p_command_list->CopyTextureRegion(&copy_dst, x, y, z, &copy_src, &src_box);

					staging_buffer_blocks.write[staging_buffer_current].fill_amount = alloc_offset + alloc_size;
				}
			}
		}

		mipmap_offset = image_total;
		logic_width = MAX(1u, logic_width >> 1);
		logic_height = MAX(1u, logic_height >> 1);
	}

	return OK;
}

Vector<uint8_t> RenderingDeviceD3D12::_texture_get_data_from_image(Texture *tex, uint32_t p_layer, bool p_2d) {
	uint32_t width, height, depth;
	uint32_t image_size = get_image_format_required_size(tex->format, tex->width, tex->height, p_2d ? 1 : tex->depth, tex->mipmaps, &width, &height, &depth);

	Vector<uint8_t> image_data;
	image_data.resize(image_size);

	D3D12_RESOURCE_DESC res_desc = tex->resource->GetDesc();

	uint32_t blockw, blockh;
	get_compressed_image_format_block_dimensions(tex->format, blockw, blockh);
	uint32_t block_size = get_compressed_image_format_block_byte_size(tex->format);
	uint32_t pixel_size = get_image_format_pixel_size(tex->format);

	{
		uint8_t *w = image_data.ptrw();

		uint32_t mipmap_offset = 0;
		for (uint32_t mm_i = 0; mm_i < tex->mipmaps; mm_i++) {
			uint32_t image_total = get_image_format_required_size(tex->format, tex->width, tex->height, p_2d ? 1 : tex->depth, mm_i + 1, &width, &height, &depth);

			uint8_t *write_ptr_mipmap = w + mipmap_offset;
			image_size = image_total - mipmap_offset;

			UINT subresource = 0;

			uint64_t image_total_src = 0;
			D3D12_PLACED_SUBRESOURCE_FOOTPRINT layout = {};
			device->GetCopyableFootprints(
					&res_desc,
					subresource,
					1,
					0,
					&layout,
					nullptr,
					nullptr,
					&image_total_src);

			void *img_mem;
			HRESULT res = tex->resource->Map(subresource, nullptr, &img_mem);
			ERR_FAIL_COND_V_MSG(res, Vector<uint8_t>(), "Map failed with error " + vformat("0x%08x", res) + ".");

			for (uint32_t z = 0; z < depth; z++) {
				uint8_t *write_ptr = write_ptr_mipmap + z * image_size / depth;
				const uint8_t *slice_read_ptr = ((uint8_t *)img_mem) + layout.Offset + z * image_total_src / depth;

				if (block_size > 1) {
					// Compressed.
					uint32_t line_width = (block_size * (width / blockw));
					for (uint32_t y = 0; y < height / blockh; y++) {
						const uint8_t *rptr = slice_read_ptr + y * layout.Footprint.RowPitch;
						uint8_t *wptr = write_ptr + y * line_width;

						memcpy(wptr, rptr, line_width);
					}

				} else {
					// Uncompressed.
					for (uint32_t y = 0; y < height; y++) {
						const uint8_t *rptr = slice_read_ptr + y * layout.Footprint.RowPitch;
						uint8_t *wptr = write_ptr + y * pixel_size * width;
						memcpy(wptr, rptr, (uint64_t)pixel_size * width);
					}
				}
			}

			tex->resource->Unmap(subresource, nullptr);

			mipmap_offset = image_total;
		}
	}

	return image_data;
}

Vector<uint8_t> RenderingDeviceD3D12::texture_get_data(RID p_texture, uint32_t p_layer) {
	_THREAD_SAFE_METHOD_

	Texture *tex = texture_owner.get_or_null(p_texture);
	ERR_FAIL_COND_V(!tex, Vector<uint8_t>());

	ERR_FAIL_COND_V_MSG(tex->bound, Vector<uint8_t>(),
			"Texture can't be retrieved while a render pass that uses it is being created. Ensure render pass is finalized (and that it was created with RENDER_PASS_CONTENTS_FINISH) to unbind this texture.");
	ERR_FAIL_COND_V_MSG(!(tex->usage_flags & TEXTURE_USAGE_CAN_COPY_FROM_BIT), Vector<uint8_t>(),
			"Texture requires the TEXTURE_USAGE_CAN_COPY_FROM_BIT in order to be retrieved.");

	uint32_t layer_count = tex->layers;
	if (tex->type == TEXTURE_TYPE_CUBE || tex->type == TEXTURE_TYPE_CUBE_ARRAY) {
		layer_count *= 6;
	}
	ERR_FAIL_COND_V(p_layer >= layer_count, Vector<uint8_t>());

	if (tex->usage_flags & TEXTURE_USAGE_CPU_READ_BIT) {
		// Does not need anything fancy, map and read.
		return _texture_get_data_from_image(tex, p_layer);
	} else {
		// Compute total image size.
		uint32_t width, height, depth;
		uint32_t final_buffer_size = get_image_format_required_size(tex->format, tex->width, tex->height, tex->depth, tex->mipmaps, &width, &height, &depth);

		uint32_t block_w, block_h;
		get_compressed_image_format_block_dimensions(tex->format, block_w, block_h);
		uint32_t alignment = D3D12_TEXTURE_DATA_PITCH_ALIGNMENT;

		// We'll use a potentially bigger buffer to account for mip sizes in which we need to use a bigger pitch to keep D3D12 happy.
		uint32_t buffer_size = 0;
		{
			uint32_t computed_h = tex->height;
			uint32_t computed_d = tex->depth;

			uint32_t prev_size = 0;
			for (uint32_t i = 0; i < tex->mipmaps; i++) {
				uint32_t image_size = get_image_format_required_size(tex->format, tex->width, tex->height, tex->depth, i + 1);
				uint32_t inferred_row_pitch = image_size / (computed_h * computed_d) * block_h;
				uint32_t adjusted_row_pitch = ALIGN(inferred_row_pitch, alignment);
				uint32_t adjusted_image_size = adjusted_row_pitch / block_h * computed_h * tex->depth;
				uint32_t size = adjusted_image_size - prev_size;
				prev_size = image_size;

				buffer_size = ALIGN(buffer_size + size, D3D12_TEXTURE_DATA_PLACEMENT_ALIGNMENT);

				computed_h = MAX(1u, computed_h >> 1);
				computed_d = MAX(1u, computed_d >> 1);
			}
		}

		// Allocate buffer.
		ID3D12GraphicsCommandList *command_list = frames[frame].draw_command_list.Get(); // Makes more sense to retrieve.

		Buffer tmp_buffer;
		Error err = _buffer_allocate(&tmp_buffer, buffer_size, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_HEAP_TYPE_READBACK);
		ERR_FAIL_COND_V(err != OK, Vector<uint8_t>());

		for (uint32_t i = 0; i < tex->mipmaps; i++) {
			uint32_t subresource = D3D12CalcSubresource(i, p_layer, 0, tex->owner_mipmaps, tex->owner_layers);
			_resource_transition_batch(tex, subresource, tex->planes, D3D12_RESOURCE_STATE_COPY_SOURCE);
		}
		_resource_transitions_flush(command_list);

		uint32_t computed_w = tex->width;
		uint32_t computed_h = tex->height;
		uint32_t computed_d = tex->depth;

		uint32_t prev_size = 0;
		uint32_t offset = 0;
		for (uint32_t i = 0; i < tex->mipmaps; i++) {
			uint32_t image_size = get_image_format_required_size(tex->format, tex->width, tex->height, tex->depth, i + 1);
			uint32_t size = image_size - prev_size;
			prev_size = image_size;

			D3D12_PLACED_SUBRESOURCE_FOOTPRINT dst_footprint = {};
			dst_footprint.Offset = offset;
			dst_footprint.Footprint.Width = MAX(block_w, computed_w);
			dst_footprint.Footprint.Height = MAX(block_h, computed_h);
			dst_footprint.Footprint.Depth = computed_d;
			uint32_t inferred_row_pitch = size / (dst_footprint.Footprint.Height * computed_d) * block_h;
			dst_footprint.Footprint.RowPitch = inferred_row_pitch;
			dst_footprint.Footprint.Format = d3d12_formats[tex->format].family;
			CD3DX12_TEXTURE_COPY_LOCATION copy_dst(tmp_buffer.resource, dst_footprint);

			UINT src_subresource = D3D12CalcSubresource(i, p_layer, 0, tex->owner_mipmaps, tex->owner_layers);
			CD3DX12_TEXTURE_COPY_LOCATION copy_src(tex->resource, src_subresource);

			if (dst_footprint.Footprint.RowPitch % alignment) {
				// Dammit! Now we must copy with an imposed pitch and then adjust row by row.
				copy_dst.PlacedFootprint.Offset = ALIGN(offset, D3D12_TEXTURE_DATA_PLACEMENT_ALIGNMENT);

				uint32_t adjusted_row_pitch = ALIGN(inferred_row_pitch, alignment);
				copy_dst.PlacedFootprint.Footprint.RowPitch = adjusted_row_pitch;
				command_list->CopyTextureRegion(&copy_dst, 0, 0, 0, &copy_src, nullptr);
				_flush(true);

				void *buffer_mem;
				uint32_t adjusted_size = adjusted_row_pitch / block_h * dst_footprint.Footprint.Height * computed_d;
				CD3DX12_RANGE range(offset, copy_dst.PlacedFootprint.Offset + adjusted_size);
				HRESULT res = tmp_buffer.resource->Map(0, &range, &buffer_mem);
				ERR_FAIL_COND_V_MSG(res, Vector<uint8_t>(), "Map failed with error " + vformat("0x%08x", res) + ".");

				for (uint32_t j = 0; j < dst_footprint.Footprint.Height / block_h * computed_d; j++) {
					memmove((uint8_t *)buffer_mem + offset + j * inferred_row_pitch, (uint8_t *)buffer_mem + copy_dst.PlacedFootprint.Offset + j * adjusted_row_pitch, inferred_row_pitch);
				}

				tmp_buffer.resource->Unmap(0, nullptr);
			} else if (offset % D3D12_TEXTURE_DATA_PLACEMENT_ALIGNMENT) {
				// Row pitch is fine, but offset alignment is not good.
				copy_dst.PlacedFootprint.Offset = ALIGN(offset, D3D12_TEXTURE_DATA_PLACEMENT_ALIGNMENT);

				command_list->CopyTextureRegion(&copy_dst, 0, 0, 0, &copy_src, nullptr);
				_flush(true);

				void *buffer_mem;
				CD3DX12_RANGE range(copy_dst.PlacedFootprint.Offset, size);
				HRESULT res = tmp_buffer.resource->Map(0, &range, &buffer_mem);
				ERR_FAIL_COND_V_MSG(res, Vector<uint8_t>(), "Map failed with error " + vformat("0x%08x", res) + ".");

				memmove((uint8_t *)buffer_mem + offset, (uint8_t *)buffer_mem + copy_dst.PlacedFootprint.Offset, size);

				tmp_buffer.resource->Unmap(0, nullptr);
			} else {
				command_list->CopyTextureRegion(&copy_dst, 0, 0, 0, &copy_src, nullptr);
			}

			computed_w = MAX(1u, computed_w >> 1);
			computed_h = MAX(1u, computed_h >> 1);
			computed_d = MAX(1u, computed_d >> 1);
			offset += size;
		}

		_flush(true);

		void *buffer_mem;
		CD3DX12_RANGE range(0, final_buffer_size);
		HRESULT res = tmp_buffer.resource->Map(0, &range, &buffer_mem);
		ERR_FAIL_COND_V_MSG(res, Vector<uint8_t>(), "Map failed with error " + vformat("0x%08x", res) + ".");

		Vector<uint8_t> buffer_data;
		buffer_data.resize(final_buffer_size);
		{
			uint8_t *w = buffer_data.ptrw();
			memcpy(w, buffer_mem, final_buffer_size);
		}

		tmp_buffer.resource->Unmap(0, nullptr);

		_buffer_free(&tmp_buffer);

		return buffer_data;
	}
}

bool RenderingDeviceD3D12::texture_is_shared(RID p_texture) {
	_THREAD_SAFE_METHOD_

	Texture *tex = texture_owner.get_or_null(p_texture);
	ERR_FAIL_COND_V(!tex, false);
	return tex->owner.is_valid();
}

bool RenderingDeviceD3D12::texture_is_valid(RID p_texture) {
	return texture_owner.owns(p_texture);
}

Size2i RenderingDeviceD3D12::texture_size(RID p_texture) {
	_THREAD_SAFE_METHOD_

	Texture *tex = texture_owner.get_or_null(p_texture);
	ERR_FAIL_COND_V(!tex, Size2i());
	return Size2i(tex->width, tex->height);
}

Error RenderingDeviceD3D12::texture_copy(RID p_from_texture, RID p_to_texture, const Vector3 &p_from, const Vector3 &p_to, const Vector3 &p_size, uint32_t p_src_mipmap, uint32_t p_dst_mipmap, uint32_t p_src_layer, uint32_t p_dst_layer, BitField<BarrierMask> p_post_barrier) {
	_THREAD_SAFE_METHOD_

	Texture *src_tex = texture_owner.get_or_null(p_from_texture);
	ERR_FAIL_COND_V(!src_tex, ERR_INVALID_PARAMETER);

	ERR_FAIL_COND_V_MSG(src_tex->bound, ERR_INVALID_PARAMETER,
			"Source texture can't be copied while a render pass that uses it is being created. Ensure render pass is finalized (and that it was created with RENDER_PASS_CONTENTS_FINISH) to unbind this texture.");
	ERR_FAIL_COND_V_MSG(!(src_tex->usage_flags & TEXTURE_USAGE_CAN_COPY_FROM_BIT), ERR_INVALID_PARAMETER,
			"Source texture requires the TEXTURE_USAGE_CAN_COPY_FROM_BIT in order to be retrieved.");

	uint32_t src_layer_count = src_tex->layers;
	uint32_t src_width, src_height, src_depth;
	get_image_format_required_size(src_tex->format, src_tex->width, src_tex->height, src_tex->depth, p_src_mipmap + 1, &src_width, &src_height, &src_depth);
	if (src_tex->type == TEXTURE_TYPE_CUBE || src_tex->type == TEXTURE_TYPE_CUBE_ARRAY) {
		src_layer_count *= 6;
	}

	ERR_FAIL_COND_V(p_from.x < 0 || p_from.x + p_size.x > src_width, ERR_INVALID_PARAMETER);
	ERR_FAIL_COND_V(p_from.y < 0 || p_from.y + p_size.y > src_height, ERR_INVALID_PARAMETER);
	ERR_FAIL_COND_V(p_from.z < 0 || p_from.z + p_size.z > src_depth, ERR_INVALID_PARAMETER);
	ERR_FAIL_COND_V(p_src_mipmap >= src_tex->mipmaps, ERR_INVALID_PARAMETER);
	ERR_FAIL_COND_V(p_src_layer >= src_layer_count, ERR_INVALID_PARAMETER);

	Texture *dst_tex = texture_owner.get_or_null(p_to_texture);
	ERR_FAIL_COND_V(!dst_tex, ERR_INVALID_PARAMETER);

	ERR_FAIL_COND_V_MSG(dst_tex->bound, ERR_INVALID_PARAMETER,
			"Destination texture can't be copied while a render pass that uses it is being created. Ensure render pass is finalized (and that it was created with RENDER_PASS_CONTENTS_FINISH) to unbind this texture.");
	ERR_FAIL_COND_V_MSG(!(dst_tex->usage_flags & TEXTURE_USAGE_CAN_COPY_TO_BIT), ERR_INVALID_PARAMETER,
			"Destination texture requires the TEXTURE_USAGE_CAN_COPY_TO_BIT in order to be retrieved.");

	uint32_t dst_layer_count = dst_tex->layers;
	uint32_t dst_width, dst_height, dst_depth;
	get_image_format_required_size(dst_tex->format, dst_tex->width, dst_tex->height, dst_tex->depth, p_dst_mipmap + 1, &dst_width, &dst_height, &dst_depth);
	if (dst_tex->type == TEXTURE_TYPE_CUBE || dst_tex->type == TEXTURE_TYPE_CUBE_ARRAY) {
		dst_layer_count *= 6;
	}

	ERR_FAIL_COND_V(p_to.x < 0 || p_to.x + p_size.x > dst_width, ERR_INVALID_PARAMETER);
	ERR_FAIL_COND_V(p_to.y < 0 || p_to.y + p_size.y > dst_height, ERR_INVALID_PARAMETER);
	ERR_FAIL_COND_V(p_to.z < 0 || p_to.z + p_size.z > dst_depth, ERR_INVALID_PARAMETER);
	ERR_FAIL_COND_V(p_dst_mipmap >= dst_tex->mipmaps, ERR_INVALID_PARAMETER);
	ERR_FAIL_COND_V(p_dst_layer >= dst_layer_count, ERR_INVALID_PARAMETER);

	ERR_FAIL_COND_V_MSG((src_tex->usage_flags & TEXTURE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT) != (dst_tex->usage_flags & TEXTURE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT), ERR_INVALID_PARAMETER,
			"Source and destination texture must be of the same type (color or depth).");

	ID3D12GraphicsCommandList *command_list = frames[frame].draw_command_list.Get();

	uint32_t src_subresource = D3D12CalcSubresource(p_src_mipmap, p_src_layer, 0, src_tex->owner_mipmaps, src_tex->owner_layers);
	_resource_transition_batch(src_tex, src_subresource, src_tex->planes, D3D12_RESOURCE_STATE_COPY_SOURCE);

	uint32_t dst_subresource = D3D12CalcSubresource(p_dst_mipmap, p_dst_layer, 0, dst_tex->owner_mipmaps, dst_tex->owner_layers);
	_resource_transition_batch(dst_tex, dst_subresource, dst_tex->planes, D3D12_RESOURCE_STATE_COPY_DEST);

	_resource_transitions_flush(command_list);

	{
		CD3DX12_TEXTURE_COPY_LOCATION src_location(src_tex->resource, src_subresource);
		CD3DX12_BOX src_box(p_from.x, p_from.y, p_from.z, p_from.x + p_size.x, p_from.y + p_size.y, p_from.z + p_size.z);
		CD3DX12_TEXTURE_COPY_LOCATION dst_location(dst_tex->resource, dst_subresource);
		command_list->CopyTextureRegion(
				&dst_location,
				p_to.x, p_to.y, p_to.z,
				&src_location,
				&src_box);
	}

	return OK;
}

Error RenderingDeviceD3D12::texture_resolve_multisample(RID p_from_texture, RID p_to_texture, BitField<BarrierMask> p_post_barrier) {
	_THREAD_SAFE_METHOD_

	Texture *src_tex = texture_owner.get_or_null(p_from_texture);
	ERR_FAIL_COND_V(!src_tex, ERR_INVALID_PARAMETER);

	ERR_FAIL_COND_V_MSG(src_tex->bound, ERR_INVALID_PARAMETER,
			"Source texture can't be copied while a render pass that uses it is being created. Ensure render pass is finalized (and that it was created with RENDER_PASS_CONTENTS_FINISH) to unbind this texture.");
	ERR_FAIL_COND_V_MSG(!(src_tex->usage_flags & TEXTURE_USAGE_CAN_COPY_FROM_BIT), ERR_INVALID_PARAMETER,
			"Source texture requires the TEXTURE_USAGE_CAN_COPY_FROM_BIT in order to be retrieved.");

	ERR_FAIL_COND_V_MSG(src_tex->type != TEXTURE_TYPE_2D, ERR_INVALID_PARAMETER, "Source texture must be 2D (or a slice of a 3D/Cube texture)");
	ERR_FAIL_COND_V_MSG(src_tex->samples == TEXTURE_SAMPLES_1, ERR_INVALID_PARAMETER, "Source texture must be multisampled.");

	Texture *dst_tex = texture_owner.get_or_null(p_to_texture);
	ERR_FAIL_COND_V(!dst_tex, ERR_INVALID_PARAMETER);

	ERR_FAIL_COND_V_MSG(dst_tex->bound, ERR_INVALID_PARAMETER,
			"Destination texture can't be copied while a render pass that uses it is being created. Ensure render pass is finalized (and that it was created with RENDER_PASS_CONTENTS_FINISH) to unbind this texture.");
	ERR_FAIL_COND_V_MSG(!(dst_tex->usage_flags & TEXTURE_USAGE_CAN_COPY_TO_BIT), ERR_INVALID_PARAMETER,
			"Destination texture requires the TEXTURE_USAGE_CAN_COPY_TO_BIT in order to be retrieved.");

	ERR_FAIL_COND_V_MSG(dst_tex->type != TEXTURE_TYPE_2D, ERR_INVALID_PARAMETER, "Destination texture must be 2D (or a slice of a 3D/Cube texture).");
	ERR_FAIL_COND_V_MSG(dst_tex->samples != TEXTURE_SAMPLES_1, ERR_INVALID_PARAMETER, "Destination texture must not be multisampled.");

	ERR_FAIL_COND_V_MSG(src_tex->format != dst_tex->format, ERR_INVALID_PARAMETER, "Source and Destination textures must be the same format.");
	ERR_FAIL_COND_V_MSG(src_tex->width != dst_tex->width && src_tex->height != dst_tex->height && src_tex->depth != dst_tex->depth, ERR_INVALID_PARAMETER, "Source and Destination textures must have the same dimensions.");

	ERR_FAIL_COND_V_MSG((src_tex->usage_flags & TEXTURE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT) != (dst_tex->usage_flags & TEXTURE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT), ERR_INVALID_PARAMETER,
			"Source and destination texture must be of the same type (color or depth).");

	ID3D12GraphicsCommandList *command_list = frames[frame].draw_command_list.Get();

	uint32_t src_subresource = D3D12CalcSubresource(src_tex->base_mipmap, src_tex->base_layer, 0, src_tex->owner_mipmaps, src_tex->owner_layers);
	_resource_transition_batch(src_tex, src_subresource, src_tex->planes, D3D12_RESOURCE_STATE_RESOLVE_SOURCE);

	uint32_t dst_subresource = D3D12CalcSubresource(dst_tex->base_mipmap, dst_tex->base_layer, 0, dst_tex->owner_mipmaps, dst_tex->owner_layers);
	_resource_transition_batch(dst_tex, dst_subresource, dst_tex->planes, D3D12_RESOURCE_STATE_RESOLVE_DEST);

	_resource_transitions_flush(command_list);

	command_list->ResolveSubresource(dst_tex->resource, dst_subresource, src_tex->resource, src_subresource, d3d12_formats[src_tex->format].general_format);

	return OK;
}

Error RenderingDeviceD3D12::texture_clear(RID p_texture, const Color &p_color, uint32_t p_base_mipmap, uint32_t p_mipmaps, uint32_t p_base_layer, uint32_t p_layers, BitField<BarrierMask> p_post_barrier) {
	_THREAD_SAFE_METHOD_

	Texture *src_tex = texture_owner.get_or_null(p_texture);
	ERR_FAIL_COND_V(!src_tex, ERR_INVALID_PARAMETER);

	ERR_FAIL_COND_V_MSG(src_tex->bound, ERR_INVALID_PARAMETER,
			"Source texture can't be cleared while a render pass that uses it is being created. Ensure render pass is finalized (and that it was created with RENDER_PASS_CONTENTS_FINISH) to unbind this texture.");

	ERR_FAIL_COND_V(p_layers == 0, ERR_INVALID_PARAMETER);
	ERR_FAIL_COND_V(p_mipmaps == 0, ERR_INVALID_PARAMETER);

	ERR_FAIL_COND_V_MSG(!(src_tex->usage_flags & TEXTURE_USAGE_CAN_COPY_TO_BIT), ERR_INVALID_PARAMETER,
			"Source texture requires the TEXTURE_USAGE_CAN_COPY_TO_BIT in order to be cleared.");

	uint32_t src_layer_count = src_tex->layers;
	if (src_tex->type == TEXTURE_TYPE_CUBE || src_tex->type == TEXTURE_TYPE_CUBE_ARRAY) {
		src_layer_count *= 6;
	}

	ERR_FAIL_COND_V(p_base_mipmap + p_mipmaps > src_tex->mipmaps, ERR_INVALID_PARAMETER);
	ERR_FAIL_COND_V(p_base_layer + p_layers > src_layer_count, ERR_INVALID_PARAMETER);

	if ((src_tex->usage_flags & TEXTURE_USAGE_COLOR_ATTACHMENT_BIT)) {
		// Clear via RTV.

		if (frames[frame].desc_heap_walkers.rtv.is_at_eof()) {
			if (!frames[frame].desc_heaps_exhausted_reported.rtv) {
				frames[frame].desc_heaps_exhausted_reported.rtv = true;
				ERR_FAIL_V_MSG(ERR_BUSY,
						"Cannot clear texture because there's no enough room in current frame's RENDER TARGET desciptors heap.\n"
						"Please increase the value of the rendering/rendering_device/d3d12/max_misc_descriptors_per_frame project setting.");
			} else {
				return ERR_BUSY;
			}
		}

		D3D12_RENDER_TARGET_VIEW_DESC rtv_desc = _make_rtv_for_texture(src_tex, p_base_mipmap, p_base_layer, p_layers);
		rtv_desc.Format = src_tex->owner_uav_desc.Format;

		ID3D12GraphicsCommandList *command_list = frames[frame].draw_command_list.Get();

		for (uint32_t i = 0; i < p_layers; i++) {
			for (uint32_t j = 0; j < p_mipmaps; j++) {
				uint32_t subresource = D3D12CalcSubresource(src_tex->base_mipmap + p_base_mipmap + j, src_tex->base_layer + p_base_layer + i, 0, src_tex->owner_mipmaps, src_tex->owner_layers);
				_resource_transition_batch(src_tex, subresource, src_tex->planes, D3D12_RESOURCE_STATE_RENDER_TARGET, src_tex->owner_resource);
			}
		}
		_resource_transitions_flush(command_list);

		device->CreateRenderTargetView(
				src_tex->owner_resource,
				&rtv_desc,
				frames[frame].desc_heap_walkers.rtv.get_curr_cpu_handle());
		command_list->ClearRenderTargetView(
				frames[frame].desc_heap_walkers.rtv.get_curr_cpu_handle(),
				p_color.components,
				0,
				nullptr);
		frames[frame].desc_heap_walkers.rtv.advance();
	} else {
		// Clear via UAV.

		if (frames[frame].desc_heap_walkers.resources.is_at_eof()) {
			if (!frames[frame].desc_heaps_exhausted_reported.resources) {
				frames[frame].desc_heaps_exhausted_reported.resources = true;
				ERR_FAIL_V_MSG(ERR_BUSY,
						"Cannot clear texture because there's no enough room in current frame's RESOURCE desciptors heap.\n"
						"Please increase the value of the rendering/rendering_device/d3d12/max_resource_descriptors_per_frame project setting.");
			} else {
				return ERR_BUSY;
			}
		}
		if (frames[frame].desc_heap_walkers.aux.is_at_eof()) {
			if (!frames[frame].desc_heaps_exhausted_reported.aux) {
				frames[frame].desc_heaps_exhausted_reported.aux = true;
				ERR_FAIL_V_MSG(ERR_BUSY,
						"Cannot clear texture because there's no enough room in current frame's AUX desciptors heap.\n"
						"Please increase the value of the rendering/rendering_device/d3d12/max_misc_descriptors_per_frame project setting.");
			} else {
				return ERR_BUSY;
			}
		}

		ID3D12GraphicsCommandList *command_list = frames[frame].draw_command_list.Get();

		for (uint32_t i = 0; i < p_layers; i++) {
			for (uint32_t j = 0; j < p_mipmaps; j++) {
				uint32_t subresource = D3D12CalcSubresource(src_tex->base_mipmap + p_base_mipmap + j, src_tex->base_layer + p_base_layer + i, 0, src_tex->owner_mipmaps, src_tex->owner_layers);
				_resource_transition_batch(src_tex, subresource, src_tex->planes, D3D12_RESOURCE_STATE_UNORDERED_ACCESS, src_tex->owner_resource);
			}
		}
		_resource_transitions_flush(command_list);

		device->CreateUnorderedAccessView(
				src_tex->owner_resource,
				nullptr,
				&src_tex->owner_uav_desc,
				frames[frame].desc_heap_walkers.aux.get_curr_cpu_handle());

		device->CopyDescriptorsSimple(
				1,
				frames[frame].desc_heap_walkers.resources.get_curr_cpu_handle(),
				frames[frame].desc_heap_walkers.aux.get_curr_cpu_handle(),
				D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV);

		UINT values[4] = {
			(UINT)p_color.get_r8(),
			(UINT)p_color.get_g8(),
			(UINT)p_color.get_b8(),
			(UINT)p_color.get_a8(),
		};
		command_list->ClearUnorderedAccessViewUint(
				frames[frame].desc_heap_walkers.resources.get_curr_gpu_handle(),
				frames[frame].desc_heap_walkers.aux.get_curr_cpu_handle(),
				src_tex->owner_resource,
				values,
				0,
				nullptr);

		frames[frame].desc_heap_walkers.resources.advance();
		frames[frame].desc_heap_walkers.aux.advance();
	}

	return OK;
}

bool RenderingDeviceD3D12::texture_is_format_supported_for_usage(DataFormat p_format, BitField<RenderingDevice::TextureUsageBits> p_usage) const {
	ERR_FAIL_INDEX_V(p_format, DATA_FORMAT_MAX, false);

	_THREAD_SAFE_METHOD_

	D3D12_FEATURE_DATA_FORMAT_SUPPORT srv_rtv_support = {};
	srv_rtv_support.Format = d3d12_formats[p_format].general_format;
	HRESULT res = device->CheckFeatureSupport(D3D12_FEATURE_FORMAT_SUPPORT, &srv_rtv_support, sizeof(srv_rtv_support));
	ERR_FAIL_COND_V_MSG(res, false, "CheckFeatureSupport failed with error " + vformat("0x%08x", res) + ".");

	D3D12_FEATURE_DATA_FORMAT_SUPPORT &uav_support = srv_rtv_support; // Fine for now.

	D3D12_FEATURE_DATA_FORMAT_SUPPORT dsv_support = {};
	dsv_support.Format = d3d12_formats[p_format].dsv_format;
	res = device->CheckFeatureSupport(D3D12_FEATURE_FORMAT_SUPPORT, &dsv_support, sizeof(dsv_support));
	ERR_FAIL_COND_V_MSG(res, false, "CheckFeatureSupport failed with error " + vformat("0x%08x", res) + ".");

	if ((p_usage & TEXTURE_USAGE_SAMPLING_BIT) && !(srv_rtv_support.Support1 & (D3D12_FORMAT_SUPPORT1_SHADER_LOAD | D3D12_FORMAT_SUPPORT1_SHADER_SAMPLE))) {
		return false;
	}

	if ((p_usage & TEXTURE_USAGE_COLOR_ATTACHMENT_BIT) && !(srv_rtv_support.Support1 & D3D12_FORMAT_SUPPORT1_RENDER_TARGET)) {
		return false;
	}

	if ((p_usage & TEXTURE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT) && !(dsv_support.Support1 & D3D12_FORMAT_SUPPORT1_DEPTH_STENCIL)) {
		printf("dxgiformat: %x\n", d3d12_formats[p_format].dsv_format);
		return false;
	}

	if ((p_usage & TEXTURE_USAGE_STORAGE_BIT) && !(uav_support.Support1 & D3D12_FORMAT_SUPPORT1_TYPED_UNORDERED_ACCESS_VIEW)) { // Maybe check LOAD/STORE, too?
		return false;
	}

	if ((p_usage & TEXTURE_USAGE_STORAGE_ATOMIC_BIT) && !(uav_support.Support2 & D3D12_FORMAT_SUPPORT2_UAV_ATOMIC_ADD)) { // Check a basic atomic at least.
		return false;
	}

	if ((p_usage & TEXTURE_USAGE_VRS_ATTACHMENT_BIT) && d3d12_formats[p_format].general_format != DXGI_FORMAT_R8_UINT) {
		return false;
	}

	return true;
}

/********************/
/**** ATTACHMENT ****/
/********************/

bool RenderingDeviceD3D12::_framebuffer_format_preprocess(FramebufferFormat *p_fb_format, uint32_t p_view_count) {
	const Vector<AttachmentFormat> &attachments = p_fb_format->attachments;

	LocalVector<int32_t> attachment_last_pass;
	attachment_last_pass.resize(attachments.size());

	if (p_view_count > 1) {
		const D3D12Context::MultiviewCapabilities &capabilities = context->get_multiview_capabilities();

		// This only works with multiview!
		ERR_FAIL_COND_V_MSG(!capabilities.is_supported, false, "Multiview not supported");

		// Make sure we limit this to the number of views we support.
		ERR_FAIL_COND_V_MSG(p_view_count > capabilities.max_view_count, false, "Hardware does not support requested number of views for Multiview render pass");
	}

	int attachment_count = 0;
	HashSet<DXGI_FORMAT> ms_attachment_formats;
	for (int i = 0; i < attachments.size(); i++) {
		if (attachments[i].usage_flags == AttachmentFormat::UNUSED_ATTACHMENT) {
			continue;
		}

		ERR_FAIL_INDEX_V(attachments[i].format, DATA_FORMAT_MAX, false);
		ERR_FAIL_INDEX_V(attachments[i].samples, TEXTURE_SAMPLES_MAX, false);
		ERR_FAIL_COND_V_MSG(!(attachments[i].usage_flags & (TEXTURE_USAGE_COLOR_ATTACHMENT_BIT | TEXTURE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT | TEXTURE_USAGE_INPUT_ATTACHMENT_BIT | TEXTURE_USAGE_VRS_ATTACHMENT_BIT)),
				ERR_INVALID_PARAMETER, "Texture format for index (" + itos(i) + ") requires an attachment (color, depth-stencil, input or VRS) bit set.");

		attachment_last_pass[i] = -1;
		attachment_count++;

		if (attachments[i].samples != TEXTURE_SAMPLES_1) {
			if ((attachments[i].usage_flags & TEXTURE_USAGE_COLOR_ATTACHMENT_BIT)) {
				ms_attachment_formats.insert(d3d12_formats[attachments[i].format].general_format);
			} else if ((attachments[i].usage_flags & TEXTURE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT)) {
				ms_attachment_formats.insert(d3d12_formats[attachments[i].format].dsv_format);
			}
		}
	}

	Vector<FramebufferPass> &passes = p_fb_format->passes;
	for (int i = 0; i < passes.size(); i++) {
		FramebufferPass *pass = &passes.write[i];

		TextureSamples texture_samples = TEXTURE_SAMPLES_1;
		bool is_multisample_first = true;

		ERR_FAIL_COND_V(pass->color_attachments.size() > D3D12_SIMULTANEOUS_RENDER_TARGET_COUNT, false);
		for (int j = 0; j < pass->color_attachments.size(); j++) {
			int32_t attachment = pass->color_attachments[j];
			if (attachment != FramebufferPass::ATTACHMENT_UNUSED) {
				ERR_FAIL_INDEX_V_MSG(attachment, attachments.size(), false, "Invalid framebuffer format attachment(" + itos(attachment) + "), in pass (" + itos(i) + "), color attachment (" + itos(j) + ").");
				ERR_FAIL_COND_V_MSG(!(attachments[attachment].usage_flags & TEXTURE_USAGE_COLOR_ATTACHMENT_BIT), false, "Invalid framebuffer format attachment(" + itos(attachment) + "), in pass (" + itos(i) + "), it's marked as depth, but it's not usable as color attachment.");
				ERR_FAIL_COND_V_MSG(attachment_last_pass[attachment] == i, false, "Invalid framebuffer format attachment(" + itos(attachment) + "), in pass (" + itos(i) + "), it already was used for something else before in this pass.");

				if (is_multisample_first) {
					texture_samples = attachments[attachment].samples;
					is_multisample_first = false;
				} else {
					ERR_FAIL_COND_V_MSG(texture_samples != attachments[attachment].samples, false, "Invalid framebuffer format attachment(" + itos(attachment) + "), in pass (" + itos(i) + "), if an attachment is marked as multisample, all of them should be multisample and use the same number of samples.");
				}
				attachment_last_pass[attachment] = i;
			}
		}

		for (int j = 0; j < pass->input_attachments.size(); j++) {
			int32_t attachment = pass->input_attachments[j];
			if (attachment != FramebufferPass::ATTACHMENT_UNUSED) {
				ERR_FAIL_INDEX_V_MSG(attachment, attachments.size(), false, "Invalid framebuffer format attachment(" + itos(attachment) + "), in pass (" + itos(i) + "), input attachment (" + itos(j) + ").");
				ERR_FAIL_COND_V_MSG(!(attachments[attachment].usage_flags & TEXTURE_USAGE_INPUT_ATTACHMENT_BIT), false, "Invalid framebuffer format attachment(" + itos(attachment) + "), in pass (" + itos(i) + "), it isn't marked as an input texture.");
				ERR_FAIL_COND_V_MSG(attachment_last_pass[attachment] == i, false, "Invalid framebuffer format attachment(" + itos(attachment) + "), in pass (" + itos(i) + "), it already was used for something else before in this pass.");

				if ((attachments[attachment].usage_flags & TEXTURE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT)) {
					ERR_FAIL_V_MSG(false, "Invalid framebuffer format attachment(" + itos(attachment) + "), in pass (" + itos(i) + "), the D3D12 driver doesn't yet support using depth-stencil targets as input attachments.");
				}

				attachment_last_pass[attachment] = i;
			}
		}

		if (pass->resolve_attachments.size() > 0) {
			ERR_FAIL_COND_V_MSG(pass->resolve_attachments.size() != pass->color_attachments.size(), false, "The amount of resolve attachments (" + itos(pass->resolve_attachments.size()) + ") must match the number of color attachments (" + itos(pass->color_attachments.size()) + ").");
			ERR_FAIL_COND_V_MSG(texture_samples == TEXTURE_SAMPLES_1, false, "Resolve attachments specified, but color attachments are not multisample.");
		}
		for (int j = 0; j < pass->resolve_attachments.size(); j++) {
			int32_t attachment = pass->resolve_attachments[j];
			if (attachment != FramebufferPass::ATTACHMENT_UNUSED) {
				ERR_FAIL_INDEX_V_MSG(attachment, attachments.size(), false, "Invalid framebuffer format attachment(" + itos(attachment) + "), in pass (" + itos(i) + "), resolve attachment (" + itos(j) + ").");
				ERR_FAIL_COND_V_MSG(pass->color_attachments[j] == FramebufferPass::ATTACHMENT_UNUSED, false, "Invalid framebuffer format attachment(" + itos(attachment) + "), in pass (" + itos(i) + "), resolve attachment (" + itos(j) + "), the respective color attachment is marked as unused.");
				ERR_FAIL_COND_V_MSG(!(attachments[attachment].usage_flags & TEXTURE_USAGE_COLOR_ATTACHMENT_BIT), false, "Invalid framebuffer format attachment(" + itos(attachment) + "), in pass (" + itos(i) + "), resolve attachment, it isn't marked as a color texture.");
				ERR_FAIL_COND_V_MSG(attachment_last_pass[attachment] == i, false, "Invalid framebuffer format attachment(" + itos(attachment) + "), in pass (" + itos(i) + "), it already was used for something else before in this pass.");
				bool multisample = attachments[attachment].samples > TEXTURE_SAMPLES_1;
				ERR_FAIL_COND_V_MSG(multisample, false, "Invalid framebuffer format attachment(" + itos(attachment) + "), in pass (" + itos(i) + "), resolve attachments can't be multisample.");
				attachment_last_pass[attachment] = i;
			}
		}

		if (pass->depth_attachment != FramebufferPass::ATTACHMENT_UNUSED) {
			int32_t attachment = pass->depth_attachment;
			ERR_FAIL_INDEX_V_MSG(attachment, attachments.size(), false, "Invalid framebuffer depth format attachment(" + itos(attachment) + "), in pass (" + itos(i) + "), depth attachment.");
			ERR_FAIL_COND_V_MSG(!(attachments[attachment].usage_flags & TEXTURE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT), false, "Invalid framebuffer depth format attachment(" + itos(attachment) + "), in pass (" + itos(i) + "), it's marked as depth, but it's not a depth attachment.");
			ERR_FAIL_COND_V_MSG(attachment_last_pass[attachment] == i, false, "Invalid framebuffer depth format attachment(" + itos(attachment) + "), in pass (" + itos(i) + "), it already was used for something else before in this pass.");
			attachment_last_pass[attachment] = i;

			if (is_multisample_first) {
				texture_samples = attachments[attachment].samples;
				is_multisample_first = false;
			} else {
				ERR_FAIL_COND_V_MSG(texture_samples != attachments[attachment].samples, false, "Invalid framebuffer depth format attachment(" + itos(attachment) + "), in pass (" + itos(i) + "), if an attachment is marked as multisample, all of them should be multisample and use the same number of samples including the depth.");
			}
		}

		if (context->get_vrs_capabilities().ss_image_supported && pass->vrs_attachment != FramebufferPass::ATTACHMENT_UNUSED) {
			int32_t attachment = pass->vrs_attachment;
			ERR_FAIL_INDEX_V_MSG(attachment, attachments.size(), false, "Invalid framebuffer VRS format attachment(" + itos(attachment) + "), in pass (" + itos(i) + "), VRS attachment.");
			ERR_FAIL_COND_V_MSG(!(attachments[attachment].usage_flags & TEXTURE_USAGE_VRS_ATTACHMENT_BIT), false, "Invalid framebuffer VRS format attachment(" + itos(attachment) + "), in pass (" + itos(i) + "), it's marked as VRS, but it's not a VRS attachment.");
			ERR_FAIL_COND_V_MSG(attachment_last_pass[attachment] == i, false, "Invalid framebuffer VRS attachment(" + itos(attachment) + "), in pass (" + itos(i) + "), it already was used for something else before in this pass.");
			attachment_last_pass[attachment] = i;
		}

		for (int j = 0; j < pass->preserve_attachments.size(); j++) {
			int32_t attachment = pass->preserve_attachments[j];

			ERR_FAIL_COND_V_MSG(attachment == FramebufferPass::ATTACHMENT_UNUSED, false, "Invalid framebuffer format attachment(" + itos(attachment) + "), in pass (" + itos(i) + "), preserve attachment (" + itos(j) + "). Preserve attachments can't be unused.");

			ERR_FAIL_INDEX_V_MSG(attachment, attachments.size(), false, "Invalid framebuffer format attachment(" + itos(attachment) + "), in pass (" + itos(i) + "), preserve attachment (" + itos(j) + ").");

			if (attachment_last_pass[attachment] != i) {
				// Preserve can still be used to keep depth or color from being discarded after use.
				attachment_last_pass[attachment] = i;
			}
		}

		p_fb_format->pass_samples.push_back(texture_samples);
	}

	if (p_fb_format->view_count > 1) {
		const D3D12Context::MultiviewCapabilities capabilities = context->get_multiview_capabilities();

		// For now this only works with multiview!
		ERR_FAIL_COND_V_MSG(!capabilities.is_supported, ERR_UNAVAILABLE, "Multiview not supported");

		// Make sure we limit this to the number of views we support.
		ERR_FAIL_COND_V_MSG(p_fb_format->view_count > capabilities.max_view_count, ERR_UNAVAILABLE, "Hardware does not support requested number of views for Multiview render pass");
	}

	if (!ms_attachment_formats.is_empty()) {
		LocalVector<DXGI_FORMAT> formats;
		for (DXGI_FORMAT f : ms_attachment_formats) {
			formats.push_back(f);
		}
		p_fb_format->max_supported_sample_count = _find_max_common_supported_sample_count(formats.ptr(), formats.size());
	}

	return true;
}

uint32_t RenderingDeviceD3D12::_find_max_common_supported_sample_count(const DXGI_FORMAT *p_formats, uint32_t p_num_formats) {
	uint32_t common = UINT32_MAX;

	for (uint32_t i = 0; i < p_num_formats; i++) {
		if (format_sample_counts_mask_cache.has(p_formats[i])) {
			common &= format_sample_counts_mask_cache[p_formats[i]];
		} else {
			D3D12_FEATURE_DATA_MULTISAMPLE_QUALITY_LEVELS msql = {};
			msql.Format = p_formats[i];
			uint32_t mask = 0;
			for (int samples = 1 << (TEXTURE_SAMPLES_MAX - 1); samples >= 1; samples /= 2) {
				msql.SampleCount = (UINT)samples;
				HRESULT res = device->CheckFeatureSupport(D3D12_FEATURE_MULTISAMPLE_QUALITY_LEVELS, &msql, sizeof(msql));
				if (SUCCEEDED(res) && msql.NumQualityLevels) {
					int bit = get_shift_from_power_of_2(samples);
					ERR_FAIL_COND_V(bit == -1, 1);
					mask |= (uint32_t)(1 << bit);
				}
			}
			format_sample_counts_mask_cache.insert(p_formats[i], mask);
			common &= mask;
		}
	}
	if (common == UINT32_MAX) {
		return 1;
	} else {
		return (uint32_t)1 << nearest_shift(common);
	}
}

RenderingDevice::FramebufferFormatID RenderingDeviceD3D12::framebuffer_format_create(const Vector<AttachmentFormat> &p_format, uint32_t p_view_count) {
	FramebufferPass pass;
	for (int i = 0; i < p_format.size(); i++) {
		if (p_format[i].usage_flags & TEXTURE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT) {
			pass.depth_attachment = i;
		} else {
			pass.color_attachments.push_back(i);
		}
	}

	Vector<FramebufferPass> passes;
	passes.push_back(pass);
	return framebuffer_format_create_multipass(p_format, passes, p_view_count);
}

RenderingDevice::FramebufferFormatID RenderingDeviceD3D12::framebuffer_format_create_multipass(const Vector<AttachmentFormat> &p_attachments, const Vector<FramebufferPass> &p_passes, uint32_t p_view_count) {
	_THREAD_SAFE_METHOD_

	FramebufferFormat fb_format;
	fb_format.attachments = p_attachments;
	fb_format.passes = p_passes;
	fb_format.view_count = p_view_count;
	if (!_framebuffer_format_preprocess(&fb_format, p_view_count)) {
		return INVALID_ID;
	}

	FramebufferFormatID id = FramebufferFormatID(framebuffer_formats.size()) | (FramebufferFormatID(ID_TYPE_FRAMEBUFFER_FORMAT) << FramebufferFormatID(ID_BASE_SHIFT));
	framebuffer_formats[id] = fb_format;
	return id;
}

RenderingDevice::FramebufferFormatID RenderingDeviceD3D12::framebuffer_format_create_empty(TextureSamples p_samples) {
	_THREAD_SAFE_METHOD_

	FramebufferFormat fb_format;
	fb_format.passes.push_back(FramebufferPass());
	fb_format.pass_samples.push_back(p_samples);

	FramebufferFormatID id = FramebufferFormatID(framebuffer_formats.size()) | (FramebufferFormatID(ID_TYPE_FRAMEBUFFER_FORMAT) << FramebufferFormatID(ID_BASE_SHIFT));
	framebuffer_formats[id] = fb_format;
	return id;
}

RenderingDevice::TextureSamples RenderingDeviceD3D12::framebuffer_format_get_texture_samples(FramebufferFormatID p_format, uint32_t p_pass) {
	HashMap<FramebufferFormatID, FramebufferFormat>::Iterator E = framebuffer_formats.find(p_format);
	ERR_FAIL_COND_V(!E, TEXTURE_SAMPLES_1);
	ERR_FAIL_COND_V(p_pass >= uint32_t(E->value.pass_samples.size()), TEXTURE_SAMPLES_1);

	return E->value.pass_samples[p_pass];
}

/***********************/
/**** RENDER TARGET ****/
/***********************/

RID RenderingDeviceD3D12::framebuffer_create_empty(const Size2i &p_size, TextureSamples p_samples, FramebufferFormatID p_format_check) {
	_THREAD_SAFE_METHOD_
	Framebuffer framebuffer;
	framebuffer.format_id = framebuffer_format_create_empty(p_samples);
	ERR_FAIL_COND_V(p_format_check != INVALID_FORMAT_ID && framebuffer.format_id != p_format_check, RID());
	framebuffer.size = p_size;

	return framebuffer_owner.make_rid(framebuffer);
}

RID RenderingDeviceD3D12::framebuffer_create(const Vector<RID> &p_texture_attachments, FramebufferFormatID p_format_check, uint32_t p_view_count) {
	_THREAD_SAFE_METHOD_

	FramebufferPass pass;

	for (int i = 0; i < p_texture_attachments.size(); i++) {
		Texture *texture = texture_owner.get_or_null(p_texture_attachments[i]);

		ERR_FAIL_COND_V_MSG(texture && texture->layers != p_view_count, RID(), "Layers of our texture doesn't match view count for this framebuffer");

		if (texture && texture->usage_flags & TEXTURE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT) {
			pass.depth_attachment = i;
		} else if (texture && texture->usage_flags & TEXTURE_USAGE_VRS_ATTACHMENT_BIT) {
			pass.vrs_attachment = i;
		} else {
			if (texture && texture->is_resolve_buffer) {
				pass.resolve_attachments.push_back(i);
			} else {
				pass.color_attachments.push_back(texture ? i : FramebufferPass::ATTACHMENT_UNUSED);
			}
		}
	}

	Vector<FramebufferPass> passes;
	passes.push_back(pass);

	return framebuffer_create_multipass(p_texture_attachments, passes, p_format_check, p_view_count);
}

D3D12_RENDER_TARGET_VIEW_DESC RenderingDeviceD3D12::_make_rtv_for_texture(const RenderingDeviceD3D12::Texture *p_texture, uint32_t p_mipmap_offset, uint32_t p_layer_offset, uint32_t p_layers) {
	D3D12_RENDER_TARGET_VIEW_DESC rtv_desc = {};
	rtv_desc.Format = p_texture->srv_desc.Format;

	switch (p_texture->srv_desc.ViewDimension) {
		case D3D12_SRV_DIMENSION_TEXTURE1D: {
			rtv_desc.ViewDimension = D3D12_RTV_DIMENSION_TEXTURE1D;
			rtv_desc.Texture1D.MipSlice = p_texture->srv_desc.Texture1D.MostDetailedMip + p_mipmap_offset;
		} break;
		case D3D12_SRV_DIMENSION_TEXTURE1DARRAY: {
			rtv_desc.ViewDimension = D3D12_RTV_DIMENSION_TEXTURE1DARRAY;
			rtv_desc.Texture1DArray.MipSlice = p_texture->srv_desc.Texture1DArray.MostDetailedMip + p_mipmap_offset;
			rtv_desc.Texture1DArray.FirstArraySlice = p_texture->srv_desc.Texture1DArray.FirstArraySlice + p_layer_offset;
			rtv_desc.Texture1DArray.ArraySize = p_layers == UINT32_MAX ? p_texture->srv_desc.Texture1DArray.ArraySize : p_layers;
		} break;
		case D3D12_SRV_DIMENSION_TEXTURE2D: {
			rtv_desc.ViewDimension = D3D12_RTV_DIMENSION_TEXTURE2D;
			rtv_desc.Texture2D.MipSlice = p_texture->srv_desc.Texture2D.MostDetailedMip + p_mipmap_offset;
			rtv_desc.Texture2D.PlaneSlice = p_texture->srv_desc.Texture2D.PlaneSlice;
		} break;
		case D3D12_SRV_DIMENSION_TEXTURE2DARRAY: {
			rtv_desc.ViewDimension = D3D12_RTV_DIMENSION_TEXTURE2DARRAY;
			rtv_desc.Texture2DArray.MipSlice = p_texture->srv_desc.Texture2DArray.MostDetailedMip + p_mipmap_offset;
			rtv_desc.Texture2DArray.FirstArraySlice = p_texture->srv_desc.Texture2DArray.FirstArraySlice + p_layer_offset;
			rtv_desc.Texture2DArray.ArraySize = p_layers == UINT32_MAX ? p_texture->srv_desc.Texture2DArray.ArraySize : p_layers;
			rtv_desc.Texture2DArray.PlaneSlice = p_texture->srv_desc.Texture2DArray.PlaneSlice;
		} break;
		case D3D12_SRV_DIMENSION_TEXTURE2DMS: {
			rtv_desc.ViewDimension = D3D12_RTV_DIMENSION_TEXTURE2DMS;
		} break;
		case D3D12_SRV_DIMENSION_TEXTURE2DMSARRAY: {
			rtv_desc.ViewDimension = D3D12_RTV_DIMENSION_TEXTURE2DMSARRAY;
			rtv_desc.Texture2DMSArray.FirstArraySlice = p_texture->srv_desc.Texture2DMSArray.FirstArraySlice + p_layer_offset;
			rtv_desc.Texture2DMSArray.ArraySize = p_layers == UINT32_MAX ? p_texture->srv_desc.Texture2DMSArray.ArraySize : p_layers;
		} break;
		case D3D12_SRV_DIMENSION_TEXTURE3D: {
			rtv_desc.ViewDimension = D3D12_RTV_DIMENSION_TEXTURE3D;
			rtv_desc.Texture3D.MipSlice = p_texture->srv_desc.Texture3D.MostDetailedMip + p_mipmap_offset;
			rtv_desc.Texture3D.FirstWSlice = 0;
			rtv_desc.Texture3D.WSize = p_texture->depth;
		} break;
		default: {
			ERR_FAIL_V_MSG(D3D12_RENDER_TARGET_VIEW_DESC(), "Can't create an RTV from an SRV whose view dimension is " + itos(p_texture->srv_desc.ViewDimension) + ".");
		}
	}

	return rtv_desc;
}

D3D12_DEPTH_STENCIL_VIEW_DESC RenderingDeviceD3D12::_make_dsv_for_texture(const RenderingDeviceD3D12::Texture *p_texture) {
	D3D12_DEPTH_STENCIL_VIEW_DESC dsv_desc = {};
	dsv_desc.Format = d3d12_formats[p_texture->format].dsv_format;
	dsv_desc.Flags = D3D12_DSV_FLAG_NONE;

	switch (p_texture->srv_desc.ViewDimension) {
		case D3D12_SRV_DIMENSION_TEXTURE1D: {
			dsv_desc.ViewDimension = D3D12_DSV_DIMENSION_TEXTURE1D;
			dsv_desc.Texture1D.MipSlice = p_texture->srv_desc.Texture1D.MostDetailedMip;
		} break;
		case D3D12_SRV_DIMENSION_TEXTURE1DARRAY: {
			dsv_desc.ViewDimension = D3D12_DSV_DIMENSION_TEXTURE1DARRAY;
			dsv_desc.Texture1DArray.MipSlice = p_texture->srv_desc.Texture1DArray.MostDetailedMip;
			dsv_desc.Texture1DArray.FirstArraySlice = p_texture->srv_desc.Texture1DArray.FirstArraySlice;
			dsv_desc.Texture1DArray.ArraySize = p_texture->srv_desc.Texture1DArray.ArraySize;
		} break;
		case D3D12_SRV_DIMENSION_TEXTURE2D: {
			dsv_desc.ViewDimension = D3D12_DSV_DIMENSION_TEXTURE2D;
			dsv_desc.Texture2D.MipSlice = p_texture->srv_desc.Texture2D.MostDetailedMip;
		} break;
		case D3D12_SRV_DIMENSION_TEXTURE2DARRAY: {
			dsv_desc.ViewDimension = D3D12_DSV_DIMENSION_TEXTURE2DARRAY;
			dsv_desc.Texture2DArray.MipSlice = p_texture->srv_desc.Texture2DArray.MostDetailedMip;
			dsv_desc.Texture2DArray.FirstArraySlice = p_texture->srv_desc.Texture2DArray.FirstArraySlice;
			dsv_desc.Texture2DArray.ArraySize = p_texture->srv_desc.Texture2DArray.ArraySize;
		} break;
		case D3D12_SRV_DIMENSION_TEXTURE2DMS: {
			dsv_desc.ViewDimension = D3D12_DSV_DIMENSION_TEXTURE2DMS;
			dsv_desc.Texture2DMS.UnusedField_NothingToDefine = p_texture->srv_desc.Texture2DMS.UnusedField_NothingToDefine;
		} break;
		case D3D12_SRV_DIMENSION_TEXTURE2DMSARRAY: {
			dsv_desc.ViewDimension = D3D12_DSV_DIMENSION_TEXTURE2DMSARRAY;
			dsv_desc.Texture2DMSArray.FirstArraySlice = p_texture->srv_desc.Texture2DMSArray.FirstArraySlice;
			dsv_desc.Texture2DMSArray.ArraySize = p_texture->srv_desc.Texture2DMSArray.ArraySize;
		} break;
		default: {
			ERR_FAIL_V_MSG(D3D12_DEPTH_STENCIL_VIEW_DESC(), "Can't create an RTV from an SRV whose view dimension is " + itos(p_texture->srv_desc.ViewDimension) + ".");
		}
	}

	return dsv_desc;
}

RID RenderingDeviceD3D12::framebuffer_create_multipass(const Vector<RID> &p_texture_attachments, const Vector<FramebufferPass> &p_passes, FramebufferFormatID p_format_check, uint32_t p_view_count) {
	_THREAD_SAFE_METHOD_

	Vector<AttachmentFormat> attachments;
	attachments.resize(p_texture_attachments.size());
	Vector<uint32_t> attachments_handle_inds;
	attachments_handle_inds.resize(p_texture_attachments.size());
	Size2i size;
	bool size_set = false;
	int num_color = 0;
	int num_depth = 0;
	for (int i = 0; i < p_texture_attachments.size(); i++) {
		AttachmentFormat af;
		Texture *texture = texture_owner.get_or_null(p_texture_attachments[i]);
		if (!texture) {
			af.usage_flags = AttachmentFormat::UNUSED_ATTACHMENT;
			attachments_handle_inds.write[i] = UINT32_MAX;
		} else {
			ERR_FAIL_COND_V_MSG(texture->layers != p_view_count, RID(), "Layers of our texture doesn't match view count for this framebuffer");

			if (!size_set) {
				size.width = texture->width;
				size.height = texture->height;
				size_set = true;
			} else if (texture->usage_flags & TEXTURE_USAGE_VRS_ATTACHMENT_BIT) {
				// If this is not the first attachement we assume this is used as the VRS attachment.
				// In this case this texture will be 1/16th the size of the color attachement.
				// So we skip the size check.
			} else {
				ERR_FAIL_COND_V_MSG((uint32_t)size.width != texture->width || (uint32_t)size.height != texture->height, RID(),
						"All textures in a framebuffer should be the same size.");
			}

			af.format = texture->format;
			af.samples = texture->samples;
			af.usage_flags = texture->usage_flags;

			bool is_vrs = texture->usage_flags & TEXTURE_USAGE_VRS_ATTACHMENT_BIT && i == p_passes[0].vrs_attachment;
			if (is_vrs) {
			} else if ((texture->usage_flags & TEXTURE_USAGE_COLOR_ATTACHMENT_BIT)) {
				attachments_handle_inds.write[i] = num_color;
				num_color++;
			} else if ((texture->usage_flags & TEXTURE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT)) {
				attachments_handle_inds.write[i] = num_depth;
				num_depth++;
			} else {
				attachments_handle_inds.write[i] = UINT32_MAX;
			}
		}
		attachments.write[i] = af;
	}

	ERR_FAIL_COND_V_MSG(!size_set, RID(), "All attachments unused.");

	FramebufferFormatID format_id = framebuffer_format_create_multipass(attachments, p_passes, p_view_count);
	if (format_id == INVALID_ID) {
		return RID();
	}

	ERR_FAIL_COND_V_MSG(p_format_check != INVALID_ID && format_id != p_format_check, RID(),
			"The format used to check this framebuffer differs from the intended framebuffer format.");

	Framebuffer framebuffer;
	framebuffer.format_id = format_id;
	framebuffer.texture_ids = p_texture_attachments;
	framebuffer.attachments_handle_inds = attachments_handle_inds;
	framebuffer.size = size;
	framebuffer.view_count = p_view_count;

	{
		if (num_color) {
			Error err = framebuffer.rtv_heap.allocate(device.Get(), D3D12_DESCRIPTOR_HEAP_TYPE_RTV, num_color, false);
			ERR_FAIL_COND_V(err, RID());
		}
		DescriptorsHeap::Walker rtv_heap_walker = framebuffer.rtv_heap.make_walker();

		if (num_depth) {
			Error err = framebuffer.dsv_heap.allocate(device.Get(), D3D12_DESCRIPTOR_HEAP_TYPE_DSV, num_depth, false);
			ERR_FAIL_COND_V(err, RID());
		}
		DescriptorsHeap::Walker dsv_heap_walker = framebuffer.dsv_heap.make_walker();

		for (int i = 0; i < p_texture_attachments.size(); i++) {
			Texture *texture = texture_owner.get_or_null(p_texture_attachments[i]);
			if (!texture) {
				continue;
			}

			bool is_vrs = texture->usage_flags & TEXTURE_USAGE_VRS_ATTACHMENT_BIT && i == p_passes[0].vrs_attachment;
			if (is_vrs) {
			} else if ((texture->usage_flags & TEXTURE_USAGE_COLOR_ATTACHMENT_BIT)) {
				D3D12_RENDER_TARGET_VIEW_DESC rtv_desc = _make_rtv_for_texture(texture);
				device->CreateRenderTargetView(texture->resource, &rtv_desc, rtv_heap_walker.get_curr_cpu_handle());
				rtv_heap_walker.advance();
			} else if ((texture->usage_flags & TEXTURE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT)) {
				D3D12_DEPTH_STENCIL_VIEW_DESC dsv_desc = _make_dsv_for_texture(texture);
				device->CreateDepthStencilView(texture->resource, &dsv_desc, dsv_heap_walker.get_curr_cpu_handle());
				dsv_heap_walker.advance();
			}
		}

		DEV_ASSERT(rtv_heap_walker.is_at_eof());
		DEV_ASSERT(dsv_heap_walker.is_at_eof());
	}

	RID id = framebuffer_owner.make_rid(framebuffer);

	for (int i = 0; i < p_texture_attachments.size(); i++) {
		if (p_texture_attachments[i].is_valid()) {
			_add_dependency(id, p_texture_attachments[i]);
		}
	}

	return id;
}

RenderingDevice::FramebufferFormatID RenderingDeviceD3D12::framebuffer_get_format(RID p_framebuffer) {
	_THREAD_SAFE_METHOD_

	Framebuffer *framebuffer = framebuffer_owner.get_or_null(p_framebuffer);
	ERR_FAIL_COND_V(!framebuffer, INVALID_ID);

	return framebuffer->format_id;
}

bool RenderingDeviceD3D12::framebuffer_is_valid(RID p_framebuffer) const {
	_THREAD_SAFE_METHOD_

	return framebuffer_owner.owns(p_framebuffer);
}

void RenderingDeviceD3D12::framebuffer_set_invalidation_callback(RID p_framebuffer, InvalidationCallback p_callback, void *p_userdata) {
	_THREAD_SAFE_METHOD_

	Framebuffer *framebuffer = framebuffer_owner.get_or_null(p_framebuffer);
	ERR_FAIL_COND(!framebuffer);

	framebuffer->invalidated_callback = p_callback;
	framebuffer->invalidated_callback_userdata = p_userdata;
}

/*****************/
/**** SAMPLER ****/
/*****************/

RID RenderingDeviceD3D12::sampler_create(const SamplerState &p_state) {
	_THREAD_SAFE_METHOD_

	D3D12_SAMPLER_DESC sampler_desc = {};

	if (p_state.use_anisotropy) {
		sampler_desc.Filter = D3D12_ENCODE_ANISOTROPIC_FILTER(D3D12_FILTER_REDUCTION_TYPE_STANDARD);
		sampler_desc.MaxAnisotropy = p_state.anisotropy_max;
	} else {
		static const D3D12_FILTER_TYPE d3d12_filter_types[] = {
			D3D12_FILTER_TYPE_POINT, // SAMPLER_FILTER_NEAREST.
			D3D12_FILTER_TYPE_LINEAR, // SAMPLER_FILTER_LINEAR.
		};
		sampler_desc.Filter = D3D12_ENCODE_BASIC_FILTER(
				d3d12_filter_types[p_state.min_filter],
				d3d12_filter_types[p_state.mag_filter],
				d3d12_filter_types[p_state.mip_filter],
				p_state.enable_compare ? D3D12_FILTER_REDUCTION_TYPE_COMPARISON : D3D12_FILTER_REDUCTION_TYPE_STANDARD);
	}

	ERR_FAIL_INDEX_V(p_state.repeat_u, SAMPLER_REPEAT_MODE_MAX, RID());
	sampler_desc.AddressU = address_modes[p_state.repeat_u];
	ERR_FAIL_INDEX_V(p_state.repeat_v, SAMPLER_REPEAT_MODE_MAX, RID());
	sampler_desc.AddressV = address_modes[p_state.repeat_v];
	ERR_FAIL_INDEX_V(p_state.repeat_w, SAMPLER_REPEAT_MODE_MAX, RID());
	sampler_desc.AddressW = address_modes[p_state.repeat_w];

	ERR_FAIL_INDEX_V(p_state.border_color, SAMPLER_BORDER_COLOR_MAX, RID());
	for (int i = 0; i < 4; i++) {
		sampler_desc.BorderColor[i] = sampler_border_colors[p_state.border_color][i];
	}

	sampler_desc.MinLOD = p_state.min_lod;
	sampler_desc.MaxLOD = p_state.max_lod;
	sampler_desc.MipLODBias = p_state.lod_bias;

	ERR_FAIL_INDEX_V(p_state.compare_op, COMPARE_OP_MAX, RID());
	sampler_desc.ComparisonFunc = compare_operators[p_state.compare_op];

	// TODO: Emulate somehow?
	if (p_state.unnormalized_uvw) {
		WARN_PRINT("Creating a sampler with unnormalized UVW, which is not supported.");
	}

	return sampler_owner.make_rid(sampler_desc);
}

/**********************/
/**** VERTEX ARRAY ****/
/**********************/

RID RenderingDeviceD3D12::vertex_buffer_create(uint32_t p_size_bytes, const Vector<uint8_t> &p_data, bool p_use_as_storage) {
	_THREAD_SAFE_METHOD_

	ERR_FAIL_COND_V(p_data.size() && (uint32_t)p_data.size() != p_size_bytes, RID());
	ERR_FAIL_COND_V_MSG(draw_list != nullptr && p_data.size(), RID(),
			"Creating buffers with data is forbidden during creation of a draw list");
	ERR_FAIL_COND_V_MSG(compute_list != nullptr && p_data.size(), RID(),
			"Creating buffers with data is forbidden during creation of a draw list");

	Buffer buffer;
	Error err = _buffer_allocate(&buffer, p_size_bytes, D3D12_RESOURCE_STATE_VERTEX_AND_CONSTANT_BUFFER, D3D12_HEAP_TYPE_DEFAULT);
	ERR_FAIL_COND_V(err != OK, RID());

	if (p_data.size()) {
		uint64_t data_size = p_data.size();
		const uint8_t *r = p_data.ptr();
		_buffer_update(&buffer, 0, r, data_size);
	}

	RID id = vertex_buffer_owner.make_rid(buffer);
#ifdef DEV_ENABLED
	set_resource_name(id, "RID:" + itos(id.get_id()));
#endif
	return id;
}

// Internally reference counted, this ID is warranted to be unique for the same description, but needs to be freed as many times as it was allocated.
RenderingDevice::VertexFormatID RenderingDeviceD3D12::vertex_format_create(const Vector<VertexAttribute> &p_vertex_formats) {
	_THREAD_SAFE_METHOD_

	VertexDescriptionKey key;
	key.vertex_formats = p_vertex_formats;

	VertexFormatID *idptr = vertex_format_cache.getptr(key);
	if (idptr) {
		return *idptr;
	}

	// Does not exist, create one and cache it.
	VertexDescriptionCache vdcache;
	vdcache.elements_desc.resize(p_vertex_formats.size());

	HashSet<int> used_locations;
	for (int i = 0; i < p_vertex_formats.size(); i++) {
		ERR_CONTINUE(p_vertex_formats[i].format >= DATA_FORMAT_MAX);
		ERR_FAIL_COND_V(used_locations.has(p_vertex_formats[i].location), INVALID_ID);

		ERR_FAIL_COND_V_MSG(get_format_vertex_size(p_vertex_formats[i].format) == 0, INVALID_ID,
				"Data format for attachment (" + itos(i) + "), '" + named_formats[p_vertex_formats[i].format] + "', is not valid for a vertex array.");

		// SPIRV-Cross maps `layout(location = <N>) in` to `TEXCOORD<N>`.
		vdcache.elements_desc.write[i].SemanticName = "TEXCOORD"; // SPIRV-Cross will apply TEXCOORD semantic to vertex attributes.
		vdcache.elements_desc.write[i].SemanticIndex = p_vertex_formats[i].location;
		vdcache.elements_desc.write[i].Format = d3d12_formats[p_vertex_formats[i].format].general_format;
		vdcache.elements_desc.write[i].InputSlot = i; // TODO: Can the same slot be used if data comes from the same buffer (regardless format)?
		vdcache.elements_desc.write[i].AlignedByteOffset = p_vertex_formats[i].offset;
		if (p_vertex_formats[i].frequency == VERTEX_FREQUENCY_INSTANCE) {
			vdcache.elements_desc.write[i].InputSlotClass = D3D12_INPUT_CLASSIFICATION_PER_INSTANCE_DATA;
			vdcache.elements_desc.write[i].InstanceDataStepRate = 1;
		} else {
			vdcache.elements_desc.write[i].InputSlotClass = D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA;
			vdcache.elements_desc.write[i].InstanceDataStepRate = 0;
		}
		used_locations.insert(p_vertex_formats[i].location);
	}

	vdcache.vertex_formats = p_vertex_formats;

	VertexFormatID id = VertexFormatID(vertex_format_cache.size()) | (VertexFormatID(ID_TYPE_VERTEX_FORMAT) << ID_BASE_SHIFT);
	vertex_format_cache[key] = id;
	vertex_formats[id] = vdcache;
	return id;
}

RID RenderingDeviceD3D12::vertex_array_create(uint32_t p_vertex_count, VertexFormatID p_vertex_format, const Vector<RID> &p_src_buffers, const Vector<uint64_t> &p_offsets) {
	_THREAD_SAFE_METHOD_

	ERR_FAIL_COND_V(!vertex_formats.has(p_vertex_format), RID());
	const VertexDescriptionCache &vd = vertex_formats[p_vertex_format];

	ERR_FAIL_COND_V(vd.vertex_formats.size() != p_src_buffers.size(), RID());

	for (int i = 0; i < p_src_buffers.size(); i++) {
		ERR_FAIL_COND_V(!vertex_buffer_owner.owns(p_src_buffers[i]), RID());
	}

	VertexArray vertex_array;

	vertex_array.vertex_count = p_vertex_count;
	vertex_array.description = p_vertex_format;
	vertex_array.max_instances_allowed = 0xFFFFFFFF; // By default as many as you want.
	HashSet<Buffer *> unique_buffers;
	for (int i = 0; i < p_src_buffers.size(); i++) {
		Buffer *buffer = vertex_buffer_owner.get_or_null(p_src_buffers[i]);

		const VertexAttribute &atf = vd.vertex_formats[i];

		// Validate with buffer.
		{
			uint32_t element_size = get_format_vertex_size(atf.format);
			ERR_FAIL_COND_V(element_size == 0, RID()); // Should never happens since this was prevalidated.

			if (atf.frequency == VERTEX_FREQUENCY_VERTEX) {
				// Validate size for regular drawing.
				uint64_t total_size = uint64_t(atf.stride) * (p_vertex_count - 1) + atf.offset + element_size;
				ERR_FAIL_COND_V_MSG(total_size > buffer->size, RID(),
						"Attachment (" + itos(i) + ") will read past the end of the buffer.");

			} else {
				// Validate size for instances drawing.
				uint64_t available = buffer->size - atf.offset;
				ERR_FAIL_COND_V_MSG(available < element_size, RID(),
						"Attachment (" + itos(i) + ") uses instancing, but it's just too small.");

				uint32_t instances_allowed = available / atf.stride;
				vertex_array.max_instances_allowed = MIN(instances_allowed, vertex_array.max_instances_allowed);
			}
		}

		unique_buffers.insert(buffer);

		D3D12_VERTEX_BUFFER_VIEW view = {};
		view.BufferLocation = buffer->resource->GetGPUVirtualAddress();
		view.SizeInBytes = buffer->size;
		view.StrideInBytes = atf.stride;
		vertex_array.views.push_back(view);
	}

	for (Buffer *buffer : unique_buffers) {
		vertex_array.unique_buffers.push_back(buffer);
	}

	RID id = vertex_array_owner.make_rid(vertex_array);
	for (int i = 0; i < p_src_buffers.size(); i++) {
		_add_dependency(id, p_src_buffers[i]);
	}

	return id;
}

RID RenderingDeviceD3D12::index_buffer_create(uint32_t p_index_count, IndexBufferFormat p_format, const Vector<uint8_t> &p_data, bool p_use_restart_indices) {
	_THREAD_SAFE_METHOD_
	ERR_FAIL_COND_V_MSG(draw_list != nullptr && p_data.size(), RID(),
			"Creating buffers with data is forbidden during creation of a draw list");
	ERR_FAIL_COND_V_MSG(compute_list != nullptr && p_data.size(), RID(),
			"Creating buffers with data is forbidden during creation of a draw list");

	ERR_FAIL_COND_V(p_index_count == 0, RID());

	IndexBuffer index_buffer;
	index_buffer.index_format = (p_format == INDEX_BUFFER_FORMAT_UINT16) ? DXGI_FORMAT_R16_UINT : DXGI_FORMAT_R32_UINT;
	index_buffer.supports_restart_indices = p_use_restart_indices;
	index_buffer.index_count = p_index_count;
	uint32_t size_bytes = p_index_count * ((p_format == INDEX_BUFFER_FORMAT_UINT16) ? 2 : 4);
#ifdef DEBUG_ENABLED
	if (p_data.size()) {
		index_buffer.max_index = 0;
		ERR_FAIL_COND_V_MSG((uint32_t)p_data.size() != size_bytes, RID(),
				"Default index buffer initializer array size (" + itos(p_data.size()) + ") does not match format required size (" + itos(size_bytes) + ").");
		const uint8_t *r = p_data.ptr();
		if (p_format == INDEX_BUFFER_FORMAT_UINT16) {
			const uint16_t *index16 = (const uint16_t *)r;
			for (uint32_t i = 0; i < p_index_count; i++) {
				if (p_use_restart_indices && index16[i] == 0xFFFF) {
					continue; // Restart index, ignore.
				}
				index_buffer.max_index = MAX(index16[i], index_buffer.max_index);
			}
		} else {
			const uint32_t *index32 = (const uint32_t *)r;
			for (uint32_t i = 0; i < p_index_count; i++) {
				if (p_use_restart_indices && index32[i] == 0xFFFFFFFF) {
					continue; // Restart index, ignore.
				}
				index_buffer.max_index = MAX(index32[i], index_buffer.max_index);
			}
		}
	} else {
		index_buffer.max_index = 0xFFFFFFFF;
	}
#else
	index_buffer.max_index = 0xFFFFFFFF;
#endif
	Error err = _buffer_allocate(&index_buffer, size_bytes, D3D12_RESOURCE_STATE_INDEX_BUFFER, D3D12_HEAP_TYPE_DEFAULT);
	ERR_FAIL_COND_V(err != OK, RID());

	if (p_data.size()) {
		uint64_t data_size = p_data.size();
		const uint8_t *r = p_data.ptr();
		_buffer_update(&index_buffer, 0, r, data_size);
	}
	RID id = index_buffer_owner.make_rid(index_buffer);
#ifdef DEV_ENABLED
	set_resource_name(id, "RID:" + itos(id.get_id()));
#endif
	return id;
}

RID RenderingDeviceD3D12::index_array_create(RID p_index_buffer, uint32_t p_index_offset, uint32_t p_index_count) {
	_THREAD_SAFE_METHOD_

	ERR_FAIL_COND_V(!index_buffer_owner.owns(p_index_buffer), RID());

	IndexBuffer *index_buffer = index_buffer_owner.get_or_null(p_index_buffer);

	ERR_FAIL_COND_V(p_index_count == 0, RID());
	ERR_FAIL_COND_V(p_index_offset + p_index_count > index_buffer->index_count, RID());

	IndexArray index_array;
	index_array.buffer = index_buffer;
	index_array.max_index = index_buffer->max_index;
	index_array.offset = p_index_offset;
	index_array.indices = p_index_count;
	index_array.supports_restart_indices = index_buffer->supports_restart_indices;
	index_array.view.BufferLocation = index_buffer->resource->GetGPUVirtualAddress();
	index_array.view.SizeInBytes = p_index_count * (index_buffer->index_format == DXGI_FORMAT_R16_UINT ? 2 : 4);
	index_array.view.Format = index_buffer->index_format;

	RID id = index_array_owner.make_rid(index_array);
	_add_dependency(id, p_index_buffer);
	return id;
}

/****************/
/**** SHADER ****/
/****************/

static const char *shader_uniform_names[RenderingDevice::UNIFORM_TYPE_MAX + 1] = {
	"Sampler", "CombinedSampler", "Texture", "Image", "TextureBuffer", "SamplerTextureBuffer", "ImageBuffer", "UniformBuffer", "StorageBuffer", "InputAttachment", "N/A"
};

static uint32_t shader_stage_sc_offset_indices[RenderingDevice::SHADER_STAGE_MAX] = {
	/* SHADER_STAGE_VERTEX */ 0,
	/* SHADER_STAGE_FRAGMENT */ 1,
	/* SHADER_STAGE_TESSELATION_CONTROL */ UINT32_MAX,
	/* SHADER_STAGE_TESSELATION_EVALUATION */ UINT32_MAX,
	/* SHADER_STAGE_COMPUTE */ 2,
};

String RenderingDeviceD3D12::_shader_uniform_debug(RID p_shader, int p_set) {
	String ret;
	const Shader *shader = shader_owner.get_or_null(p_shader);
	ERR_FAIL_COND_V(!shader, String());
	for (int i = 0; i < shader->sets.size(); i++) {
		if (p_set >= 0 && i != p_set) {
			continue;
		}
		for (int j = 0; j < shader->sets[i].uniforms.size(); j++) {
			const UniformInfo &ui = shader->sets[i].uniforms[j].info;
			if (!ret.is_empty()) {
				ret += "\n";
			}
			ret += "Set: " + itos(i) + " Binding: " + itos(ui.binding) + " Type: " + shader_uniform_names[ui.type] + " Writable: " + (ui.writable ? "Y" : "N") + " Length: " + itos(ui.length);
		}
	}
	return ret;
}

uint32_t RenderingDeviceD3D12::_shader_patch_dxil_specialization_constant(
		PipelineSpecializationConstantType p_type,
		const void *p_value,
		const uint64_t (&p_stages_bit_offsets)[D3D12_SPEC_CONSTANTS_NUM_STAGES],
		HashMap<ShaderStage, Vector<uint8_t>> &r_stages_bytecodes,
		bool p_is_first_patch) {
	uint8_t patch_val = 0;
	switch (p_type) {
		case PIPELINE_SPECIALIZATION_CONSTANT_TYPE_INT: {
			// Current patching hack is limited to 7 bits.
			uint32_t int_value = *((const int *)p_value);
			ERR_FAIL_COND_V(int_value > 0b1111111, 0);
			patch_val = int_value;
		} break;
		case PIPELINE_SPECIALIZATION_CONSTANT_TYPE_BOOL: {
			bool bool_value = *((const bool *)p_value);
			patch_val = bool_value;
		} break;
		case PIPELINE_SPECIALIZATION_CONSTANT_TYPE_FLOAT: {
			// [[FLOAT_SPEC_CONSTANT]].
			float float_value = *((const float *)p_value);
			uint32_t fixed = (uint32_t)(float_value / FLOAT_SC_STEP);
			ERR_FAIL_COND_V(fixed > 0b1111111, 0);
			patch_val = fixed;
		} break;
	}

	auto tamper_bits = [](uint8_t *p_start, uint64_t p_bit_offset, uint64_t p_value, uint32_t p_bit_count) -> uint64_t {
		uint64_t original = 0;
		uint32_t curr_byte = p_bit_offset / 8;
		uint32_t curr_bit = p_bit_offset % 8;
		uint32_t curr_val_bit = 0;
		uint32_t rem_bits = p_bit_count;
		while (rem_bits) {
			uint32_t min = curr_bit;
			uint32_t max = MIN(8u, min + rem_bits) - 1u;
			DEV_ASSERT(max >= min);

			uint8_t mask = 0;
			for (uint32_t i = min; i <= max; i++) {
				mask |= (1 << i);
			}

			original |= ((p_start[curr_byte] & mask) >> min) << curr_val_bit;
			// Clear.
			p_start[curr_byte] &= ~mask;
			// Set.
			p_start[curr_byte] |= ((p_value >> curr_val_bit) << min);

			curr_byte++;
			curr_bit = 0;
			rem_bits -= max - min + 1;
			curr_val_bit += max - min + 1;
		}
		return original;
	};

	uint32_t stages_patched_mask = 0;
	for (int stage = 0; stage < SHADER_STAGE_MAX; stage++) {
		if (!r_stages_bytecodes.has((ShaderStage)stage)) {
			continue;
		}

		uint64_t offset = p_stages_bit_offsets[shader_stage_sc_offset_indices[stage]];
		if (offset == 0) {
			// This constant does not appear at this stage.
			continue;
		}

		Vector<uint8_t> &bytecode = r_stages_bytecodes[(ShaderStage)stage];
#ifdef DEV_ENABLED
		uint8_t orig_patch_val = tamper_bits(bytecode.ptrw(), offset, patch_val, 7);
		DEV_ASSERT(!p_is_first_patch || orig_patch_val == 0b1000001); // Checking against the same value the DXC patch should have set.
		uint8_t readback_patch_val = tamper_bits(bytecode.ptrw(), offset, patch_val, 7);
		DEV_ASSERT(readback_patch_val == patch_val);
#else
		tamper_bits(bytecode.ptrw(), offset, patch_val, 7);
#endif

		stages_patched_mask |= (1 << stage);
	}
	return stages_patched_mask;
}

bool RenderingDeviceD3D12::_shader_sign_dxil_bytecode(ShaderStage p_stage, Vector<uint8_t> &r_dxil_blob) {
	const DxcObjects &dxc = get_dxc_objects_for_current_thread();

	ComPtr<IDxcBlobEncoding> dxil_dxc_blob;
	HRESULT res = dxc.utils->CreateBlobFromPinned(r_dxil_blob.ptr(), r_dxil_blob.size(), CP_NONE, dxil_dxc_blob.GetAddressOf());
	ERR_FAIL_COND_V_MSG(res, false, "CreateBlobFromPinned failed with error " + vformat("0x%08x", res) + ".");
	ComPtr<IDxcOperationResult> result;
	res = dxc.validator->Validate(dxil_dxc_blob.Get(), DxcValidatorFlags_InPlaceEdit, result.GetAddressOf());
	ERR_FAIL_COND_V_MSG(res, false, "Shader signing invocation at stage " + String(shader_stage_names[p_stage]) + " failed with error " + vformat("0x%08x", res) + ".");
	HRESULT dxc_res = 0;
	res = result->GetStatus(&dxc_res);
	ERR_FAIL_COND_V_MSG(res, false, "GetStatus failed with error " + vformat("0x%08x", res) + ".");
	if (!SUCCEEDED(dxc_res)) {
		ComPtr<IDxcBlobEncoding> errors;
		res = result->GetErrorBuffer(errors.GetAddressOf());
		ERR_FAIL_COND_V_MSG(res, false, "Shader signing failed, as obtaining detailed error info did.");
		ComPtr<IDxcBlobUtf8> errors_utf8;
		res = dxc.utils->GetBlobAsUtf8(errors.Get(), errors_utf8.GetAddressOf());
		ERR_FAIL_COND_V_MSG(res, false, "Shader signing failed, as encoding detailed error info did.");
		ERR_PRINT("Shader signing at stage " + String(shader_stage_names[p_stage]) + " failed:\n" + String((const char *)errors_utf8->GetBufferPointer(), errors_utf8->GetBufferSize()));
		return false;
	}

	return true;
}

// Version 1: Initial.

#define SHADER_BINARY_VERSION 1

String RenderingDeviceD3D12::shader_get_binary_cache_key() const {
	return "D3D12-SV" + itos(SHADER_BINARY_VERSION) + "-" + String(VERSION_NUMBER) + "-" + String(VERSION_HASH);
}

enum RootSignatureLocationType {
	RS_LOC_TYPE_RESOURCE,
	RS_LOC_TYPE_SAMPLER,
};

struct RenderingDeviceD3D12ShaderBinaryDataBinding {
	// - Uniform info.
	uint32_t type;
	uint32_t binding;
	uint32_t length; // Size of arrays (in total elements), or ubos (in bytes * total elements).
	// - Binding info.
	uint32_t writable;
	uint32_t stages;
	struct RootSignatureLocation {
		uint32_t root_param_idx; // UINT32_MAX if unused.
		uint32_t range_idx; // UINT32_MAX if unused.
	};
	// Dim 1: RootSignatureLocationType.
	// Dim 2: up to two locations each, if shader visibility is split.
	RootSignatureLocation root_sig_locations[2][2];

	// We need to sort these to fill the root signature locations properly.
	bool operator<(const RenderingDeviceD3D12ShaderBinaryDataBinding &p_other) const {
		return binding < p_other.binding;
	}
};

struct RenderingDeviceD3D12ShaderBinarySpecializationConstant {
	uint32_t type;
	uint32_t constant_id;
	union {
		uint32_t int_value;
		float float_value;
		bool bool_value;
	};
	uint64_t stages_bit_offsets[D3D12_SPEC_CONSTANTS_NUM_STAGES];
};

struct RenderingDeviceD3D12ShaderBinaryData {
	uint32_t vertex_input_mask;
	uint32_t fragment_output_mask;
	uint32_t specialization_constant_count;
	uint32_t spirv_specialization_constants_ids_mask;
	uint32_t is_compute;
	uint32_t compute_local_size[3];
	uint32_t set_count;
	uint32_t spirv_push_constant_size;
	uint32_t dxil_push_constant_size;
	uint32_t stage_count;
	uint32_t shader_name_len;
	uint32_t root_signature_len;
	uint32_t root_signature_crc;
};

// Will be filled by a LLVM patch.
thread_local std::vector<uint64_t> sc_sentinel_offsets;

Vector<uint8_t> RenderingDeviceD3D12::shader_compile_binary_from_spirv(const Vector<ShaderStageSPIRVData> &p_spirv, const String &p_shader_name) {
#ifdef DEV_ENABLED
#define DEBUG_SHADER_NAME "" // Empty means all.
	//#define DEBUG_COMPILE_IN_DEBUG_MODE
	//#define DEBUG_PRINT_SPEC_CONSTANTS_FOUND_IN_HLSL
	//#define DEBUG_SAVE_HLSL_LISTINGS
	//#define DEBUG_SAVE_DXIL_ASSEMBLY_LISTINGS
	//#define DEBUG_PRINT_AFFECTED_IR_INSTRS
	//#define DEBUG_SAVE_SPIRV_BINARY
	//#define DEBUG_SAVE_DXIL_BINARIES
	//#define DEBUG_PRINT_BINDINGS

	bool debug = DEBUG_SHADER_NAME[0] == '\0' || p_shader_name == DEBUG_SHADER_NAME;
	debug; // Avoid warning about unused variable this way since there are too many situations to test for it needing to be defined.
#endif
	RenderingDeviceD3D12ShaderBinaryData binary_data = {};

	const DxcObjects &dxc = get_dxc_objects_for_current_thread();
	LocalVector<LPCWSTR> dxc_extra_args;
	String shader_model_str;
	spirv_cross::CompilerHLSL::Options spvx_hlsl_options;
	spirv_cross::CompilerGLSL::Options spvx_common_options;
	{
		int sm_num = context->get_shader_capabilities().shader_model;
		sm_num = (sm_num >> 4) * 10 + (sm_num & 0xf);

		shader_model_str = itos(sm_num / 10) + "_" + itos(sm_num % 10);

		spvx_hlsl_options.point_size_compat = true; // TODO: Do we need point size? If so, do something better than this.
		spvx_hlsl_options.point_coord_compat = true; // TODO: Do we need point coord? If so, do something better than this.
		spvx_hlsl_options.shader_model = sm_num;
		spvx_hlsl_options.nonwritable_uav_texture_as_srv = true;

		dxc_extra_args.push_back(L"-all-resources-bound");

		if (context->get_shader_capabilities().native_16bit_ops) {
			spvx_hlsl_options.enable_16bit_types = true;
			dxc_extra_args.push_back(L"-enable-16bit-types");
		}

#ifdef DEBUG_COMPILE_IN_DEBUG_MODE
		if (debug) {
			dxc_extra_args.push_back(L"-Qembed_debug");
			dxc_extra_args.push_back(L"-Zi");
			dxc_extra_args.push_back(L"-Od");
			dxc_extra_args.push_back(L"-O0");
		}
#endif

		// TODO: Don't be lazy and so stop forcing SPIRV-Cross to add computations to shaders; OK by now, though.
		spvx_common_options.vertex.flip_vert_y = true;
	}

	Vector<Vector<RenderingDeviceD3D12ShaderBinaryDataBinding>> uniform_info; // Set bindings.
	Vector<RenderingDeviceD3D12ShaderBinarySpecializationConstant> specialization_constants;
	HashMap<ShaderStage, Vector<uint8_t>> dxil_blobs;

	// These are used below for patching HLSL for emulation of specialization constants.
	// E.g.: static const uint sc_directional_soft_shadow_samples = SPIRV_CROSS_CONSTANT_ID_8;
	RegEx regex_sc_var;
	Error err = regex_sc_var.compile(R"(static const (\S+) (sc_\S+) = .+?\n)");
	CRASH_COND(err);
	// E.g.: #define SPIRV_CROSS_CONSTANT_ID_8 4u
	RegEx regex_sc_value;
	err = regex_sc_value.compile(R"(#define SPIRV_CROSS_CONSTANT_ID_(\d+) (.+?)\n)");
	CRASH_COND(err);
	// E.g.: static const bool _426 = (sc_directional_soft_shadow_samples == 0u);
	RegEx regex_sc_pred;
	err = regex_sc_pred.compile(R"(static const bool (_\d+) = (.+?);\n)");
	CRASH_COND(err);

	uint32_t stages_processed = 0;
	uint32_t push_constants_stages = 0;
	uint32_t spirv_push_constant_size = 0;
	uint32_t dxil_push_constant_size = 0;
	uint32_t spirv_specialization_constants_ids_mask = 0;

	struct DxilBindingInfo {
		D3D_SHADER_INPUT_TYPE type;
		D3D_SRV_DIMENSION dimension;
		struct Location {
			uint32_t stages_mask;
			union {
				struct {
					uint32_t bind_point;
					uint32_t space;
				};
				uint64_t key;
			};
		};
		struct {
			LocalVector<Location> resource;
			LocalVector<Location> sampler;
		} locations;

		void merge_from(const DxilBindingInfo &p_other) {
			_merge_locations(locations.resource, p_other.locations.resource);
			_merge_locations(locations.sampler, p_other.locations.sampler);
		}

	private:
		static void _merge_locations(LocalVector<Location> &r_dst, const LocalVector<Location> &p_src) {
			for (uint32_t i = 0; i < p_src.size(); i++) {
				bool merged = false;
				for (uint32_t j = 0; j < r_dst.size(); j++) {
					// If we've reached here, this should be true.
					DEV_ASSERT(r_dst[j].stages_mask != p_src[j].stages_mask);
					if (r_dst[j].key == p_src[i].key) {
						r_dst[j].stages_mask |= p_src[i].stages_mask;
						merged = true;
						break;
					}
				}
				if (!merged) {
					r_dst.push_back(p_src[i]);
				}
			}
		}
	};
	HashMap<uint32_t, DxilBindingInfo> dxil_binding_info; // Key: (set << 16) | binding.

	for (int i = 0; i < p_spirv.size(); i++) {
		uint32_t stage = p_spirv[i].shader_stage;

		if (stage == SHADER_STAGE_COMPUTE) {
			binary_data.is_compute = true;
			ERR_FAIL_COND_V_MSG(p_spirv.size() != 1, Vector<uint8_t>(),
					"Compute shaders can only receive one stage, dedicated to compute.");
		}
		ERR_FAIL_COND_V_MSG(stages_processed & (1 << stage), Vector<uint8_t>(),
				"Stage " + String(shader_stage_names[stage]) + " submitted more than once.");

		spirv_cross::CompilerHLSL *spirv_cross = (spirv_cross::CompilerHLSL *)alloca(sizeof(spirv_cross::CompilerHLSL));
		String hlsl_string;

		// From SPIR-V to HLSL.
		{
			std::vector<uint32_t> spirv_binary;
			spirv_binary.resize((p_spirv[i].spir_v.size() + 3) / 4);
			memcpy(spirv_binary.data(), p_spirv[i].spir_v.ptr(), p_spirv[i].spir_v.size());

#ifdef DEBUG_SAVE_SPIRV_BINARY
			if (debug) {
				Ref<FileAccess> fa = FileAccess::open("spirv", FileAccess::WRITE);
				fa->store_buffer(p_spirv[i].spir_v.ptr(), p_spirv[i].spir_v.size());
			}
#endif

			new (spirv_cross) spirv_cross::CompilerHLSL(std::move(spirv_binary));
			spirv_cross->set_common_options(spvx_common_options);
			spirv_cross->set_hlsl_options(spvx_hlsl_options);
			// We are forcing the location of the push constants only. Every other binding will be
			// assigned by the compiler. That avoids errors about overlapping bindings, because array
			// bindings in DXIL take as many registers as elements, whereas they take only one in SPIR-V.
			spirv_cross->set_resource_binding_flags(spirv_cross::HLSL_BINDING_AUTO_ALL & ~spirv_cross::HLSL_BINDING_AUTO_PUSH_CONSTANT_BIT);
			spirv_cross->set_root_constant_layouts({ spirv_cross::RootConstants{ 0, 128, ROOT_CONSTANTS_REGISTER, ROOT_CONSTANTS_SPACE } });

			std::string hlsl_std_string = spirv_cross->compile();
			hlsl_string = String(hlsl_std_string.data(), hlsl_std_string.size());

			// Unexpected: 'volatile' is used in the HLSL code; we should be the only ones adding volatile stuff (for SC patching).
			DEV_ASSERT(hlsl_string.find("volatile") == -1);

#ifdef DEBUG_SAVE_HLSL_LISTINGS
			if (debug) {
				Ref<FileAccess> fa = FileAccess::open("hlsl.txt", FileAccess::WRITE);
				CharString utf8_str = hlsl_string.utf8();
				fa->store_buffer((const uint8_t *)utf8_str.ptr(), utf8_str.length());
			}
#endif
		}

		// Patch specialization constants in HLSL.
		struct HlslSpecConstant {
			String type_str;
			uint32_t id;
			String value_str;
		};
		LocalVector<HlslSpecConstant> hlsl_spec_constants;
		{
			// Find these first; if none found, there's no need for any patching.
			Array matches_var = regex_sc_var.search_all(hlsl_string);
			if (matches_var.size()) {
				DEV_ASSERT(shader_stage_sc_offset_indices[stage] != UINT32_MAX);
				// Pass 1: replace predicate vars by their expressions.
				// TODO: Maybe patch SPIRV-Cross so it just doesn't generate these that way.
				Array matches_pred = regex_sc_pred.search_all(hlsl_string);
				if (matches_pred.size()) {
					// Remove all predicate declarations now.
					hlsl_string = regex_sc_pred.sub(hlsl_string, "", true);

					for (int j = 0; j < matches_pred.size(); j++) {
						RegExMatch *m = (RegExMatch *)((Object *)matches_pred[j]);
						String sc_name = m->get_strings()[1];
						String sc_expr = m->get_strings()[2];
#ifdef DEBUG_PRINT_SPEC_CONSTANTS_FOUND_IN_HLSL
						if (debug) {
							print_verbose("Predicate SC: " + sc_name + " := " + sc_expr);
						}
#endif
						RegEx re;
						err = re.compile(R"(([^\w]))" + sc_name + R"(([^\w]))");
						CRASH_COND(err);
						hlsl_string = re.sub(hlsl_string, "$1" + sc_expr + "$2", true);
					}
				}

				// Pass 2: patch usages of `sc_`-prefixed variables with an HLSL expression.
				// That can't be reordered or optimized in each block (function).
				Vector<String> functions = hlsl_string.split(")\n{\n");
				// Remove all variable declarations, known to be in the "prolog" section.
				functions.write[0] = regex_sc_var.sub(functions[0], "", true);

				hlsl_spec_constants.reserve(matches_var.size());
				Array matches_val = regex_sc_value.search_all(functions[0]);
				CRASH_COND(matches_val.size() != matches_var.size());
				for (int j = 0; j < matches_var.size(); j++) {
					RegExMatch *m = (RegExMatch *)((Object *)matches_var[j]);
					String sc_type = m->get_strings()[1];
					String sc_id_str = ((RegExMatch *)((Object *)matches_val[j]))->get_strings()[1];
					uint32_t sc_id = sc_id_str.to_int();
					String sc_name = m->get_strings()[2];
					ERR_FAIL_COND_V_MSG(sc_type != "uint" && sc_type != "bool" && sc_type != "float", Vector<uint8_t>(),
							"Specialization constant " + sc_name + " (id " + sc_id_str + ") of shader variant " + p_shader_name + " is neither uint, bool nor float.");
#ifdef DEBUG_PRINT_SPEC_CONSTANTS_FOUND_IN_HLSL
					if (debug) {
						print_verbose("Variable SC: (" + sc_type + ") " + sc_name);
					}
#endif
					RegEx re;
					err = re.compile(R"(([^\w]))" + sc_name + R"(([^\w]))");
					CRASH_COND(err);

					int sc_idx = hlsl_spec_constants.size();
					String dummy_var_name = "_sc" + itos(sc_idx);
					bool sc_used = false;
					for (int k = 1; k < functions.size(); k++) { // Skip first one, which is the "prolog", not a function.
						int old_length = functions[k].length();
						if (sc_type == "float") {
							// [[FLOAT_SPEC_CONSTANT]].
							functions.write[k] = re.sub(functions[k], "$1((float)" + dummy_var_name + " * " + rtos(FLOAT_SC_STEP) + "f)$2", true);
						} else {
							functions.write[k] = re.sub(functions[k], "$1" + dummy_var_name + "$2", true);
						}
						if (functions[k].length() != old_length) { // Some SC found?
							functions.write[k] = "volatile int " + dummy_var_name + " = " + itos(sc_idx) + ";\n" + functions[k];
							sc_used = true;
						}
					}
					if (sc_used) {
						HlslSpecConstant sc;
						sc.type_str = sc_type;
						sc.id = sc_id;
						sc.value_str = ((RegExMatch *)((Object *)matches_val[j]))->get_strings()[2];
						hlsl_spec_constants.push_back(sc);
					}
				}

				hlsl_string = String(")\n{\n").join(functions);
			}

#ifdef DEBUG_SAVE_HLSL_LISTINGS
			if (debug) {
				Ref<FileAccess> fa = FileAccess::open("hlsl_patched.txt", FileAccess::WRITE);
				CharString utf8_str = hlsl_string.utf8();
				fa->store_buffer((const uint8_t *)utf8_str.ptr(), utf8_str.length());
			}
#endif
		}

		// HLSL to DXIL.
		{
			ComPtr<IDxcBlobEncoding> hlsl_blob;
			Vector<uint8_t> hlsl_utf8 = hlsl_string.to_utf8_buffer();
			HRESULT res = dxc.utils->CreateBlobFromPinned(hlsl_utf8.ptr(), hlsl_utf8.size(), CP_UTF8, &hlsl_blob);
			ERR_FAIL_COND_V_MSG(res, Vector<uint8_t>(), "CreateBlobFromPinned failed with error " + vformat("0x%08x", res) + ".");

			String target;
			switch (stage) {
				case SHADER_STAGE_VERTEX: {
					target = "vs";
				} break;
				case SHADER_STAGE_FRAGMENT: {
					target = "ps";
				} break;
				case SHADER_STAGE_COMPUTE: {
					target = "cs";
				} break;
				default: {
					ERR_FAIL_COND_V_MSG(res, Vector<uint8_t>(), "Shader stage " + String(shader_stage_names[stage]) + " is not supported.");
				}
			}
			target += "_" + shader_model_str;

			ComPtr<IDxcOperationResult> result;
			res = dxc.compiler->Compile(
					hlsl_blob.Get(),
					nullptr, // (const wchar_t *)p_shader_name.utf16().get_data(), // Giving a name makes DXC -sometimes (!?)- believe it has to read a file with that name, which fails, of course.
					L"main",
					(const wchar_t *)target.utf16().get_data(),
					dxc_extra_args.ptr(),
					dxc_extra_args.size(),
					nullptr,
					0,
					nullptr,
					result.GetAddressOf());
			ERR_FAIL_COND_V_MSG(res, Vector<uint8_t>(), "Shader compiler invocation at stage " + String(shader_stage_names[stage]) + " failed with error " + vformat("0x%08x", res) + ".");
			HRESULT dxc_res = 0;
			res = result->GetStatus(&dxc_res);
			ERR_FAIL_COND_V_MSG(res, Vector<uint8_t>(), "GetStatus failed with error " + vformat("0x%08x", res) + ".");
			if (!SUCCEEDED(dxc_res)) {
				ComPtr<IDxcBlobEncoding> errors;
				res = result->GetErrorBuffer(errors.GetAddressOf());
				ERR_FAIL_COND_V_MSG(res, Vector<uint8_t>(), "Shader compilation failed, as obtaining detailed error info did.");
				ComPtr<IDxcBlobUtf8> errors_utf8;
				res = dxc.utils->GetBlobAsUtf8(errors.Get(), errors_utf8.GetAddressOf());
				ERR_FAIL_COND_V_MSG(res, Vector<uint8_t>(), "Shader compilation failed, as encoding detailed error info did.");
				ERR_PRINT("Shader compilation at stage " + String(shader_stage_names[stage]) + " failed:\n" + String((const char *)errors_utf8->GetBufferPointer(), errors_utf8->GetBufferSize()));
				return Vector<uint8_t>();
			}

			ComPtr<IDxcBlob> dxc_result;
			res = result->GetResult(&dxc_result);
			ERR_FAIL_COND_V_MSG(res, Vector<uint8_t>(), "GetResult failed with error " + vformat("0x%08x", res) + ".");
			Vector<uint8_t> dxil_blob;
			dxil_blob.resize(dxc_result->GetBufferSize());
			memcpy(dxil_blob.ptrw(), dxc_result->GetBufferPointer(), dxc_result->GetBufferSize());
			dxil_blobs.insert((ShaderStage)stage, dxil_blob);

#ifdef DEBUG_SAVE_DXIL_BINARIES
			if (debug) {
				Ref<FileAccess> fa = FileAccess::open("dxil.bin", FileAccess::WRITE);
				fa->store_buffer(dxil_blob.ptr(), dxil_blob.size());
			}
#endif
		}

		// Reflection on DXIL (with a little help from SPIRV-Cross).
		{
			DxcBuffer dxil_buf = {};
			dxil_buf.Ptr = dxil_blobs[(ShaderStage)stage].ptr();
			dxil_buf.Size = dxil_blobs[(ShaderStage)stage].size();
			dxil_buf.Encoding = 0;
			ComPtr<ID3D12ShaderReflection> dxil_refl;
			HRESULT res = dxc.utils->CreateReflection(&dxil_buf, IID_PPV_ARGS(dxil_refl.GetAddressOf()));
			ERR_FAIL_COND_V_MSG(res, Vector<uint8_t>(),
					"Reflection of DXIL shader stage '" + String(shader_stage_names[stage]) + "' failed with error " + vformat("0x%08x", res) + ".");

			D3D12_SHADER_DESC dxil_desc = {};
			dxil_refl->GetDesc(&dxil_desc);
			spirv_cross::ShaderResources spirv_refl = spirv_cross->get_shader_resources();

			if (binary_data.is_compute) {
				UINT x, y, z;
				dxil_refl->GetThreadGroupSize(&x, &y, &z);
				binary_data.compute_local_size[0] = x;
				binary_data.compute_local_size[1] = y;
				binary_data.compute_local_size[2] = z;
			}

			// Bindings.
			{
				// Collect existing bindings from SPIR-V.

				// This is needed to have as many slots and sets in RD as in the Vulkan shaders,
				// despite any bindings that may have been optimized out in DXIL. Later, we'll accept anything
				// that is passed to the unused bindings, which reliefs the need to extract types and sizes now.

				{
					auto collect_binding = [spirv_cross, stage, &uniform_info](const spirv_cross::Resource &p_spirv_res, UniformType p_type, bool p_is_block_sized) -> bool {
						ERR_FAIL_COND_V_MSG(!spirv_cross->has_decoration(p_spirv_res.id, spv::DecorationDescriptorSet), false,
								"At shader stage '" + String(shader_stage_names[stage]) + "', SPIR-V resource '" + String(p_spirv_res.name.c_str()) + "' has no 'set' decoration.");
						ERR_FAIL_COND_V_MSG(!spirv_cross->has_decoration(p_spirv_res.id, spv::DecorationBinding), false,
								"At shader stage '" + String(shader_stage_names[stage]) + "', SPIR-V resource '" + String(p_spirv_res.name.c_str()) + "' has no 'binding' decoration.");

						uint32_t set = spirv_cross->get_decoration(p_spirv_res.id, spv::DecorationDescriptorSet);
						uint32_t binding = spirv_cross->get_decoration(p_spirv_res.id, spv::DecorationBinding);

						uint32_t length = 0;
						if (p_is_block_sized) {
							const spirv_cross::SPIRType &type = spirv_cross->get_type(p_spirv_res.type_id);
							length = spirv_cross->get_declared_struct_size(type);

							// Match DXIL philosohpy.
							if (p_type == UNIFORM_TYPE_STORAGE_BUFFER) {
								length = 0;
							} else {
								// Match DXIL register size.
								length = ALIGN(length, 16);
							}
						} else {
							// Array, then.
							length = 1;
							for (const uint32_t dim : spirv_cross->get_type(p_spirv_res.type_id).array) {
								length *= dim;
							}
						}

						bool writable = false;
						if (p_type == UNIFORM_TYPE_STORAGE_BUFFER || p_type == UNIFORM_TYPE_IMAGE) {
							if (spirv_cross->get_type(p_spirv_res.base_type_id).basetype == spirv_cross::SPIRType::Struct) {
								writable = !(spirv_cross->get_buffer_block_flags(p_spirv_res.id).get(spv::DecorationNonWritable));
							} else {
								writable = !(spirv_cross->get_decoration_bitset(p_spirv_res.id).get(spv::DecorationNonWritable));
							}
						}

						bool exists = false;
						if (set < (uint32_t)uniform_info.size()) {
							for (int i = 0; i < uniform_info[set].size(); i++) {
								if (uniform_info[set][i].binding == binding) {
									// Already exists, verify that it's the same type.
									ERR_FAIL_COND_V_MSG(uniform_info[set][i].type != (uint32_t)p_type, false,
											"On shader stage '" + String(shader_stage_names[stage]) + "', uniform '" + String(spirv_cross->get_name(p_spirv_res.id).c_str()) + "' trying to re-use location for set=" + itos(set) + ", binding=" + itos(binding) + " with different uniform type.");

									// Also, verify that it's the same size.
									ERR_FAIL_COND_V_MSG(uniform_info[set][i].length != length, false,
											"On shader stage '" + String(shader_stage_names[stage]) + "', uniform '" + String(spirv_cross->get_name(p_spirv_res.id).c_str()) + "' trying to re-use location for set=" + itos(set) + ", binding=" + itos(binding) + " with different uniform size.");

									// Also, verify that it has the same writability.
									ERR_FAIL_COND_V_MSG((bool)uniform_info[set][i].writable != writable, false,
											"On shader stage '" + String(shader_stage_names[stage]) + "', uniform '" + String(spirv_cross->get_name(p_spirv_res.id).c_str()) + "' trying to re-use location for set=" + itos(set) + ", binding=" + itos(binding) + " with different writability.");

									exists = true;
									break;
								}
							}
						}

						if (!exists) {
							if (set >= (uint32_t)uniform_info.size()) {
								uniform_info.resize(set + 1);
							}

							ERR_FAIL_COND_V_MSG(uniform_info[set].size() == UniformSet::StateRequirement::UNIFORM_IDX_MASK_BITS, ERR_BUSY, "There can be 64 uniforms as much on a given uniform set.");

							RenderingDeviceD3D12ShaderBinaryDataBinding info = {};
							info.type = p_type;
							info.binding = binding;
							info.length = length;
							info.writable = writable;
							memset(&info.root_sig_locations, 0xff, sizeof(RenderingDeviceD3D12ShaderBinaryDataBinding::root_sig_locations));
							uniform_info.write[set].push_back(info);
						}

						return true;
					};

					for (const spirv_cross::Resource &spirv_res : spirv_refl.uniform_buffers) {
						bool ok = collect_binding(spirv_res, UNIFORM_TYPE_UNIFORM_BUFFER, true);
						ERR_FAIL_COND_V(!ok, Vector<uint8_t>());
					}
					for (const spirv_cross::Resource &spirv_res : spirv_refl.storage_buffers) {
						bool ok = collect_binding(spirv_res, UNIFORM_TYPE_STORAGE_BUFFER, true);
						ERR_FAIL_COND_V(!ok, Vector<uint8_t>());
					}
					for (const spirv_cross::Resource &spirv_res : spirv_refl.subpass_inputs) {
						bool ok = collect_binding(spirv_res, UNIFORM_TYPE_INPUT_ATTACHMENT, false);
						ERR_FAIL_COND_V(!ok, Vector<uint8_t>());
					}
					for (const spirv_cross::Resource &spirv_res : spirv_refl.storage_images) {
						bool ok = collect_binding(spirv_res, UNIFORM_TYPE_IMAGE, false);
						ERR_FAIL_COND_V(!ok, Vector<uint8_t>());
					}
					for (const spirv_cross::Resource &spirv_res : spirv_refl.sampled_images) {
						bool ok = collect_binding(spirv_res, UNIFORM_TYPE_SAMPLER_WITH_TEXTURE, false);
						ERR_FAIL_COND_V(!ok, Vector<uint8_t>());
					}
					for (const spirv_cross::Resource &spirv_res : spirv_refl.separate_images) {
						bool ok = collect_binding(spirv_res, UNIFORM_TYPE_TEXTURE, false);
						ERR_FAIL_COND_V(!ok, Vector<uint8_t>());
					}
					for (const spirv_cross::Resource &spirv_res : spirv_refl.separate_samplers) {
						bool ok = collect_binding(spirv_res, UNIFORM_TYPE_SAMPLER, false);
						ERR_FAIL_COND_V(!ok, Vector<uint8_t>());
					}
				}

				// Collect binding info from DXIL.

#ifdef DEBUG_PRINT_BINDINGS
				auto dump_spirv_res_vector = [spirv_cross](const String &p_kind, const spirv_cross::SmallVector<spirv_cross::Resource> &p_resources) -> void {
					for (const spirv_cross::Resource &r : p_resources) {
						std::string res_name_std = spirv_cross->get_name(r.id);
						print_verbose("\t" + p_kind + ": " + String(res_name_std.data(), res_name_std.size()) + " (" + String(r.name.data(), r.name.size()) + ")");
					}
				};

				if (debug) {
					print_verbose("SPIR-V BINDINGS");
					dump_spirv_res_vector("image", spirv_refl.separate_images);
					dump_spirv_res_vector("sampler", spirv_refl.separate_samplers);
					dump_spirv_res_vector("sampled image", spirv_refl.sampled_images);
					dump_spirv_res_vector("storage buffer", spirv_refl.storage_buffers);
					dump_spirv_res_vector("storage image", spirv_refl.storage_images);
					dump_spirv_res_vector("uniform buffer", spirv_refl.uniform_buffers);
				}
#endif

#ifdef DEBUG_PRINT_BINDINGS
				if (debug) {
					print_verbose("DXIL BINDINGS");
				}
#endif
				LocalVector<D3D12_SHADER_INPUT_BIND_DESC> dxil_bindings;
				dxil_bindings.resize(dxil_desc.BoundResources);
				for (uint32_t j = 0; j < dxil_desc.BoundResources; j++) {
					res = dxil_refl->GetResourceBindingDesc(j, &dxil_bindings[j]);
					ERR_FAIL_COND_V_MSG(res, Vector<uint8_t>(),
							"GetResourceBindingDesc() at shader stage '" + String(shader_stage_names[stage]) + "' failed with error " + vformat("0x%08x", res) + ".");
#ifdef DEBUG_PRINT_BINDINGS
					if (debug) {
						print_verbose(String("\tresource: ") + dxil_bindings[j].Name);
					}
#endif
				}

				// Match DXIL to their SPIR-V counterparts.

				struct BindingMatch {
					const D3D12_SHADER_INPUT_BIND_DESC *dxil;
					const D3D12_SHADER_INPUT_BIND_DESC *dxil_sampler;
					const spirv_cross::Resource *spirv;
					bool is_storage = false;
				};
				LocalVector<BindingMatch> matched_bindings;

				for (uint32_t j = 0; j < dxil_bindings.size(); j++) {
					bool found = false;
					switch (dxil_bindings[j].Type) {
						case D3D_SIT_CBUFFER: {
							// SPIRV-Cross is kind enough to add a known prefix to the names of push constants.
							if (strstr(dxil_bindings[j].Name, "SPIRV_CROSS_RootConstant_") == dxil_bindings[j].Name) {
								found = true;
							} else {
								for (const spirv_cross::Resource &spirv_res : spirv_refl.uniform_buffers) {
									if (strcmp(spirv_res.name.c_str(), dxil_bindings[j].Name) == 0 || strcmp(spirv_cross->get_name(spirv_res.id).c_str(), dxil_bindings[j].Name) == 0) {
										matched_bindings.push_back({ &dxil_bindings[j], nullptr, &spirv_res });
										found = true;
										break;
									}
								}
							}
						} break;
						case D3D_SIT_TEXTURE: {
							struct ResourceHaystack { // The resource to match is the needle.
								const spirv_cross::SmallVector<spirv_cross::Resource> &resources;
								bool is_storage = false;
							} res_haystacks[3] = {
								{ spirv_refl.separate_images },
								{ spirv_refl.subpass_inputs },
								{ spirv_refl.storage_images, true },
							};
							for (uint32_t k = 0; k < ARRAY_SIZE(res_haystacks); k++) {
								for (const spirv_cross::Resource &spirv_res : res_haystacks[k].resources) {
									if (strcmp(spirv_res.name.c_str(), dxil_bindings[j].Name) == 0 || strcmp(spirv_cross->get_name(spirv_res.id).c_str(), dxil_bindings[j].Name) == 0) {
										matched_bindings.push_back({ &dxil_bindings[j], nullptr, &spirv_res, res_haystacks[k].is_storage });
										found = true;
										break;
									}
								}
							}
							if (found) {
								continue;
							}
							for (const spirv_cross::Resource &spirv_res : spirv_refl.sampled_images) {
								if (strcmp(spirv_res.name.c_str(), dxil_bindings[j].Name) == 0 || strcmp(spirv_cross->get_name(spirv_res.id).c_str(), dxil_bindings[j].Name) == 0) {
									// It's a combined texture-sampler, which will be handled in the D3D_SIT_SAMPLER case;
									// however, if the sampler has been optimized out in DXIL, we must still collect the
									// texture binding now.
									bool sampler_found = false;
									std::string generated_sampler_name = std::string("_") + spirv_res.name + "_sampler";
									for (uint32_t k = 0; k < dxil_bindings.size(); k++) {
										if (dxil_bindings[k].Type == D3D_SIT_SAMPLER && dxil_bindings[k].Name == generated_sampler_name) {
											sampler_found = true;
											break;
										}
									}
									if (!sampler_found) {
										matched_bindings.push_back({ &dxil_bindings[j], nullptr, &spirv_res });
									}
									found = true;
									break;
								}
							}
						} break;
						case D3D_SIT_SAMPLER: {
							for (const spirv_cross::Resource &spirv_res : spirv_refl.separate_samplers) {
								if (strcmp(spirv_res.name.c_str(), dxil_bindings[j].Name) == 0 || strcmp(spirv_cross->get_name(spirv_res.id).c_str(), dxil_bindings[j].Name) == 0) {
									matched_bindings.push_back({ &dxil_bindings[j], nullptr, &spirv_res });
									found = true;
									break;
								}
							}
							if (found) {
								continue;
							}
							// Combined image-samplers are broken by SPIRV-Cross into an image and a sampler called '_<image_name>_sampler'.
							for (const spirv_cross::Resource &spirv_res : spirv_refl.sampled_images) {
								std::string generated_sampler_name = std::string("_") + spirv_res.name + "_sampler";
								if (dxil_bindings[j].Name == generated_sampler_name) {
									for (uint32_t k = 0; k < dxil_bindings.size(); k++) {
										if (dxil_bindings[k].Type == D3D_SIT_TEXTURE && dxil_bindings[k].Name == spirv_res.name) {
											// j -> sampler, k -> texture.
											matched_bindings.push_back({ &dxil_bindings[k], &dxil_bindings[j], &spirv_res });
											found = true;
											break;
										}
									}
									ERR_FAIL_COND_V_MSG(!found, Vector<uint8_t>(),
											"At shader stage '" + String(shader_stage_names[stage]) + "', sampled image corresponding to sampler " + String(spirv_res.name.data(), spirv_res.name.size()) + " has not been found.");
									break;
								}
							}
						} break;
						case D3D_SIT_UAV_RWTYPED: {
							for (const spirv_cross::Resource &spirv_res : spirv_refl.storage_images) {
								if (strcmp(spirv_res.name.c_str(), dxil_bindings[j].Name) == 0 || strcmp(spirv_cross->get_name(spirv_res.id).c_str(), dxil_bindings[j].Name) == 0) {
									matched_bindings.push_back({ &dxil_bindings[j], nullptr, &spirv_res });
									found = true;
									break;
								}
							}
						} break;
						case D3D_SIT_BYTEADDRESS:
						case D3D_SIT_UAV_RWBYTEADDRESS: {
							for (const spirv_cross::Resource &spirv_res : spirv_refl.storage_buffers) {
								if (strcmp(spirv_res.name.c_str(), dxil_bindings[j].Name) == 0 || strcmp(spirv_cross->get_name(spirv_res.id).c_str(), dxil_bindings[j].Name) == 0) {
									matched_bindings.push_back({ &dxil_bindings[j], nullptr, &spirv_res });
									found = true;
									break;
								}
							}
						} break;
						default: {
							// Other types may be easy to support, but not needed so far, so let's just whine.
							ERR_FAIL_V_MSG(Vector<uint8_t>(),
									"DXIL at shader stage '" + String(shader_stage_names[stage]) + "' uses unsupported binding type " + itos(dxil_bindings[j].Type) + ".");
						}
					}

					ERR_FAIL_COND_V_MSG(!found, Vector<uint8_t>(),
							"At shader stage '" + String(shader_stage_names[stage]) + "', SPIR-V resource matching DXIL resource '" + String(dxil_bindings[j].Name) + "' has not been found.");
				}
				DEV_ASSERT(matched_bindings.size() <= dxil_bindings.size());

				// Collect bindings into descriptor sets binary data.

				for (uint32_t j = 0; j < matched_bindings.size(); j++) {
					const BindingMatch &match = matched_bindings[j];

					ERR_FAIL_COND_V_MSG(!spirv_cross->has_decoration(match.spirv->id, spv::DecorationDescriptorSet), Vector<uint8_t>(),
							"At shader stage '" + String(shader_stage_names[stage]) + "', SPIR-V resource matching DXIL resource '" + String(dxil_bindings[j].Name) + "' has no 'set' decoration.");
					ERR_FAIL_COND_V_MSG(!spirv_cross->has_decoration(match.spirv->id, spv::DecorationBinding), Vector<uint8_t>(),
							"At shader stage '" + String(shader_stage_names[stage]) + "', SPIR-V resource matching DXIL resource '" + String(dxil_bindings[j].Name) + "' has no 'binding' decoration.");

					uint32_t set = spirv_cross->get_decoration(match.spirv->id, spv::DecorationDescriptorSet);
					uint32_t binding = spirv_cross->get_decoration(match.spirv->id, spv::DecorationBinding);

					UniformType type = UNIFORM_TYPE_MAX;
					uint32_t length = 0;
					bool writable = false;

					DxilBindingInfo new_dxil_info;
					new_dxil_info.type = match.dxil->Type;
					new_dxil_info.dimension = match.dxil->Dimension;
					new_dxil_info.locations.resource.resize(1);
					new_dxil_info.locations.resource[0].stages_mask = (1 << stage);
					new_dxil_info.locations.resource[0].bind_point = match.dxil->BindPoint;
					new_dxil_info.locations.resource[0].space = match.dxil->Space;

					bool need_array_dimensions = false;
					bool need_block_size = false;

					switch (match.dxil->Type) {
						case D3D_SIT_CBUFFER: {
							type = UNIFORM_TYPE_UNIFORM_BUFFER;
							need_block_size = true;
						} break;
						case D3D_SIT_TEXTURE: {
							if (!match.dxil_sampler) {
								type = match.is_storage ? UNIFORM_TYPE_IMAGE : UNIFORM_TYPE_TEXTURE;
							} else {
								type = UNIFORM_TYPE_SAMPLER_WITH_TEXTURE;
								new_dxil_info.locations.sampler.resize(1);
								new_dxil_info.locations.sampler[0].stages_mask = (1 << stage);
								new_dxil_info.locations.sampler[0].bind_point = match.dxil_sampler->BindPoint;
								new_dxil_info.locations.sampler[0].space = match.dxil_sampler->Space;
							}
							need_array_dimensions = true;
						} break;
						case D3D_SIT_SAMPLER: {
							type = UNIFORM_TYPE_SAMPLER;
							need_array_dimensions = true;
							SWAP(new_dxil_info.locations.resource, new_dxil_info.locations.sampler);
						} break;
						case D3D_SIT_UAV_RWTYPED: {
							type = UNIFORM_TYPE_IMAGE;
							writable = true;
							need_array_dimensions = true;
						} break;
						case D3D_SIT_BYTEADDRESS:
						case D3D_SIT_UAV_RWBYTEADDRESS: {
							type = UNIFORM_TYPE_STORAGE_BUFFER;
							writable = match.dxil->Type == D3D_SIT_UAV_RWBYTEADDRESS;
							need_block_size = true;
						} break;
						default: {
							CRASH_NOW(); // Should be unreachable.
						}
					}

					if (need_array_dimensions) {
						length = match.dxil->BindCount;
					} else if (need_block_size) {
						ID3D12ShaderReflectionConstantBuffer *buffer_refl = dxil_refl->GetConstantBufferByName(match.dxil->Name);
						ERR_FAIL_COND_V_MSG(!buffer_refl, Vector<uint8_t>(),
								"DXIL at shader stage '" + String(shader_stage_names[stage]) + "' doesn't have a buffer that matches the '" + String(match.dxil->Name) + "' binding.");
						D3D12_SHADER_BUFFER_DESC sbd = {};
						ERR_FAIL_COND_V_MSG(!buffer_refl, Vector<uint8_t>(),
								"Failed getting buffer descriptions at shader stage '" + String(shader_stage_names[stage]) + "', corresponding to the '" + String(match.dxil->Name) + "' binding.");
						res = buffer_refl->GetDesc(&sbd);
						length = sbd.Size;
					} else {
						length = 0;
					}

					ERR_FAIL_COND_V_MSG(set >= MAX_UNIFORM_SETS, Vector<uint8_t>(),
							"On shader stage '" + String(shader_stage_names[stage]) + "', uniform '" + String(match.dxil->Name) + "' uses a set (" + itos(set) + ") index larger than what is supported (" + itos(MAX_UNIFORM_SETS) + ").");

					for (int k = 0; k < uniform_info[set].size(); k++) {
						if (uniform_info[set][k].binding == binding) {
							// Check type and size inferred from DXIL matches what was gotten from SPIR-V.
							// Certain exceptions allowed:
							// - A sampler that has been optimzed out in DXIL from a texture-sampler uniform.
							if (uniform_info[set][k].type == UNIFORM_TYPE_SAMPLER_WITH_TEXTURE && type == UNIFORM_TYPE_TEXTURE) {
								type = UNIFORM_TYPE_SAMPLER_WITH_TEXTURE;
								// - A texture that was an input attachment originally.
							} else if (uniform_info[set][k].type == UNIFORM_TYPE_INPUT_ATTACHMENT && type == UNIFORM_TYPE_TEXTURE) {
								type = UNIFORM_TYPE_INPUT_ATTACHMENT;
							}
							ERR_FAIL_COND_V_MSG(uniform_info[set][k].type != (uint32_t)type, Vector<uint8_t>(),
									"On shader stage '" + String(shader_stage_names[stage]) + "', DXIL uniform '" + String(match.dxil->Name) + "' trying to match SPIR-V set=" + itos(set) + ", binding=" + itos(binding) + " with different uniform type.");
							ERR_FAIL_COND_V_MSG(uniform_info[set][k].length != length, Vector<uint8_t>(),
									"On shader stage '" + String(shader_stage_names[stage]) + "', DXIL uniform '" + String(match.dxil->Name) + "' trying to match SPIR-V set=" + itos(set) + ", binding=" + itos(binding) + " with different uniform size.");
							ERR_FAIL_COND_V_MSG((bool)uniform_info[set][k].writable != writable, Vector<uint8_t>(),
									"On shader stage '" + String(shader_stage_names[stage]) + "', DXIL uniform '" + String(match.dxil->Name) + "' trying to match SPIR-V set=" + itos(set) + ", binding=" + itos(binding) + " with different writability.");

							uniform_info.write[set].write[k].stages |= (1 << stage);

							break;
						}
					}

					if (dxil_binding_info.has((set << 16) | binding)) {
						DxilBindingInfo &curr_dxil_info = dxil_binding_info[(set << 16) | binding];
						ERR_FAIL_COND_V_MSG(curr_dxil_info.type != new_dxil_info.type, Vector<uint8_t>(),
								"On shader stage '" + String(shader_stage_names[stage]) + "', uniform '" + String(match.dxil->Name) + "' trying to re-use location for set=" + itos(set) + ", binding=" + itos(binding) + " with different D3D12 binding type.");
						ERR_FAIL_COND_V_MSG(curr_dxil_info.dimension != new_dxil_info.dimension, Vector<uint8_t>(),
								"On shader stage '" + String(shader_stage_names[stage]) + "', uniform '" + String(match.dxil->Name) + "' trying to re-use location for set=" + itos(set) + ", binding=" + itos(binding) + " with different D3D12 dimension.");

						curr_dxil_info.merge_from(new_dxil_info);
					} else {
						dxil_binding_info[(set << 16) | binding] = new_dxil_info;
					}
				}
			}

			if (stage == SHADER_STAGE_VERTEX) {
				for (uint32_t j = 0; j < dxil_desc.InputParameters; j++) {
					D3D12_SIGNATURE_PARAMETER_DESC dxil_input = {};
					res = dxil_refl->GetInputParameterDesc(j, &dxil_input);
					ERR_FAIL_COND_V_MSG(res, Vector<uint8_t>(),
							"Reflection of DXIL shader stage '" + String(shader_stage_names[stage]) + "' failed obtaining input parameter, with error " + vformat("0x%08x", res) + ".");

					// SPIRV-Cross maps `layout(location = <N>) in` to `TEXCOORD<N>`.
					if (strcmp(dxil_input.SemanticName, "TEXCOORD") == 0) {
						bool found = false;
						for (const spirv_cross::Resource &spirv_input : spirv_refl.stage_inputs) {
							uint32_t spirv_location = spirv_cross->get_decoration(spirv_input.id, spv::Decoration::DecorationLocation);
							if (spirv_location == dxil_input.SemanticIndex) {
								found = true;
								break;
							}
						}
						ERR_FAIL_COND_V_MSG(!found, Vector<uint8_t>(),
								"At shader stage '" + String(shader_stage_names[stage]) + "', SPIR-V input matching DXIL's '" + String(dxil_input.SemanticName) + itos(dxil_input.SemanticIndex) + "' has not been found.");

						binary_data.vertex_input_mask |= (1 << dxil_input.SemanticIndex);
					}
				}
			}

			if (stage == SHADER_STAGE_FRAGMENT) {
				for (uint32_t j = 0; j < dxil_desc.OutputParameters; j++) {
					D3D12_SIGNATURE_PARAMETER_DESC dxil_output = {};
					res = dxil_refl->GetOutputParameterDesc(j, &dxil_output);
					ERR_FAIL_COND_V_MSG(res, Vector<uint8_t>(),
							"Reflection of DXIL shader stage '" + String(shader_stage_names[stage]) + "' failed obtaining output parameter, with error " + vformat("0x%08x", res) + ".");

					// SPIRV-Cross maps `layout(location = <N>) out` to `SV_TARGET<N>`.
					if (strcmp(dxil_output.SemanticName, "SV_TARGET") == 0) { // dxil_output.SystemValueType == D3D_NAME_TARGET may be as good.
						bool found = false;
						for (const spirv_cross::Resource &spirv_output : spirv_refl.stage_outputs) {
							uint32_t spirv_location = spirv_cross->get_decoration(spirv_output.id, spv::Decoration::DecorationLocation);
							if (spirv_location == dxil_output.SemanticIndex) {
								found = true;
								break;
							}
						}
						ERR_FAIL_COND_V_MSG(!found, Vector<uint8_t>(),
								"At shader stage '" + String(shader_stage_names[stage]) + "', SPIR-V output matching DXIL's '" + String(dxil_output.SemanticName) + itos(dxil_output.SemanticIndex) + "' has not been found.");

						binary_data.fragment_output_mask |= (1 << dxil_output.SemanticIndex);
					}
				}
			}

			LocalVector<D3D12_SHADER_BUFFER_DESC> dxil_push_contants;
			for (uint32_t j = 0; j < dxil_desc.ConstantBuffers; j++) {
				ID3D12ShaderReflectionConstantBuffer *cbuffer = dxil_refl->GetConstantBufferByIndex(j);
				D3D12_SHADER_BUFFER_DESC cbuffer_desc = {};
				res = cbuffer->GetDesc(&cbuffer_desc);
				ERR_FAIL_COND_V_MSG(res, Vector<uint8_t>(),
						"Reflection of DXIL shader stage '" + String(shader_stage_names[stage]) + "' failed obtaining push constant, with error " + vformat("0x%08x", res) + ".");

				if (strstr(cbuffer_desc.Name, "SPIRV_CROSS_RootConstant_") == cbuffer_desc.Name) {
					dxil_push_contants.push_back(cbuffer_desc);
				}
			}
			if (dxil_push_contants.size()) {
				ERR_FAIL_COND_V_MSG(dxil_push_contants.size() > 1, Vector<uint8_t>(),
						"Reflection of DXIL shader stage '" + String(shader_stage_names[stage]) + "': Only one push constant is supported, which should be the same across shader stages.");

				ERR_FAIL_COND_V_MSG(dxil_push_constant_size && dxil_push_constant_size != dxil_push_contants[0].Size, Vector<uint8_t>(),
						"Reflection of DXIL shader stage '" + String(shader_stage_names[stage]) + "': Push constant block must be the same across shader stages.");

				dxil_push_constant_size = dxil_push_contants[0].Size;
				push_constants_stages |= (1 << stage);

				//print_line("Stage: " + String(shader_stage_names[stage]) + " push constant of size=" + itos(dxil_push_constant_size));
			}

			// Since specialization constants and push constants can be optimized out from DXIL,
			// we want to at least keep awareness of which exist in the original SPIR-V, for sanity checks.
			{
				for (const spirv_cross::SpecializationConstant &sc : spirv_cross->get_specialization_constants()) {
					spirv_specialization_constants_ids_mask |= (1 << sc.constant_id);
				}

				if (spirv_refl.push_constant_buffers.size()) {
					ERR_FAIL_COND_V_MSG(spirv_refl.push_constant_buffers.size() > 1, Vector<uint8_t>(),
							"Reflection of SPIR-V shader stage '" + String(shader_stage_names[stage]) + "': Only one push constant is supported, which should be the same across shader stages.");

					const spirv_cross::SPIRType &type = spirv_cross->get_type(spirv_refl.push_constant_buffers[0].type_id);
					uint32_t pc_size = spirv_cross->get_declared_struct_size(type);
					pc_size = ALIGN(pc_size, 16); // Not sure why, but works with every shader so far.

					ERR_FAIL_COND_V_MSG(spirv_push_constant_size && spirv_push_constant_size != pc_size, Vector<uint8_t>(),
							"Reflection of SPIR-V shader stage '" + String(shader_stage_names[stage]) + "': Push constant block must be the same across shader stages.");

					spirv_push_constant_size = pc_size;
				}
			}
		}

		// Injection of specialization constants.
		if (hlsl_spec_constants.size()) {
			Vector<uint8_t> &dxil_blob = dxil_blobs[(ShaderStage)stage];
			uint64_t dxil_dxil_part_offset = 0;

			try {
				hlsl::DxilContainerReader dxil_reader;
				HRESULT res = dxil_reader.Load(dxil_blob.ptr(), dxil_blob.size());
				ERR_FAIL_COND_V_MSG(res, Vector<uint8_t>(),
						"DxilContainerReader::Load() at shader stage '" + String(shader_stage_names[stage]) + "' failed with error " + vformat("0x%08x", res) + ".");

				uint32_t part_count = 0;
				res = dxil_reader.GetPartCount(&part_count);
				ERR_FAIL_COND_V_MSG(res, Vector<uint8_t>(),
						"DxilContainerReader::GetPartCount() at shader stage '" + String(shader_stage_names[stage]) + "' failed with error " + vformat("0x%08x", res) + ".");

				std::unique_ptr<hlsl::DxilContainerWriter> dxil_writer(hlsl::NewDxilContainerWriter());
				ComPtr<hlsl::AbstractMemoryStream> patched_dxil_bc_part;

				for (uint32_t j = 0; j < part_count; j++) {
					uint32_t four_cc = 0;
					res = dxil_reader.GetPartFourCC(j, &four_cc);
					ERR_FAIL_COND_V_MSG(res, Vector<uint8_t>(),
							"DxilContainerReader::GetPartFourCC() at shader stage '" + String(shader_stage_names[stage]) + "' failed with error " + vformat("0x%08x", res) + ".");

					const uint8_t *dxil_part_start = nullptr;
					uint32_t dxil_part_size = 0;
					res = dxil_reader.GetPartContent(j, (const void **)&dxil_part_start, &dxil_part_size);
					ERR_FAIL_COND_V_MSG(res, Vector<uint8_t>(),
							"DxilContainerReader::GetPartContent() at shader stage '" + String(shader_stage_names[stage]) + "' failed with error " + vformat("0x%08x", res) + ".");

					if (four_cc == hlsl::DFCC_DXIL) {
						const hlsl::DxilProgramHeader *dxil_header = (const hlsl::DxilProgramHeader *)dxil_part_start;
						const char *bitcode_ptr = hlsl::GetDxilBitcodeData(dxil_header);
						uint32_t bitcode_size = hlsl::GetDxilBitcodeSize(dxil_header);

						llvm::StringRef bitcode_buffer(bitcode_ptr, bitcode_size);
						llvm::LLVMContext llvm_context;
						llvm::ErrorOr<std::unique_ptr<llvm::Module>> bitcode_parsed = llvm::parseBitcodeFile(llvm::MemoryBufferRef(bitcode_buffer, ""), llvm_context);
						ERR_FAIL_COND_V_MSG(bitcode_parsed.getError(), Vector<uint8_t>(),
								"parseBitcodeFile() at shader stage '" + String(shader_stage_names[stage]) + "' failed with error " + itos(bitcode_parsed.getError().value()) + ".");

						llvm::Module &llvm_module = *bitcode_parsed->get();

						// Patch the LLVM IR.
						{
#ifdef DEBUG_SAVE_DXIL_ASSEMBLY_LISTINGS
							class file_ostream : public llvm::raw_ostream {
								FileAccess *file;
								void write_impl(const char *Ptr, size_t Size) override {
									for (size_t i = 0; i < Size; i++) {
										file->store_8(Ptr[i]);
									}
								}
								uint64_t current_pos() const override { return -1; }

							public:
								file_ostream(const String &p_filename) :
										file(FileAccess::open(p_filename, FileAccess::WRITE)) {}
								~file_ostream() {
									memdelete(file);
								}
							};

							if (debug) {
								llvm_module.print(file_ostream("dxil.txt"), nullptr);
							}
#endif

							// Pass 1:
							// Make a database of the 'alloca's, based on the volatile stores.
							// %63 = bitcast i32* %59 to i8*
							// call void @llvm.lifetime.start(i64 4, i8* %63)
							// store volatile i32 9, i32* %59, align 4      <---- Locate this

							HashMap<llvm::AllocaInst *, uint32_t> alloca_sc_inds;

							for (llvm::Function &F : llvm_module.getFunctionList()) {
								if (F.isDeclaration()) {
									continue;
								}
								for (llvm::BasicBlock &B : F) {
									for (llvm::Instruction &I : B) {
										if (llvm::isa<llvm::StoreInst>(I) && llvm::cast<llvm::StoreInst>(I).isVolatile()) {
											llvm::StoreInst &store = llvm::cast<llvm::StoreInst>(I);
											uint32_t sc_index = llvm::dyn_cast<llvm::ConstantInt>(store.getValueOperand())->getZExtValue();
											CRASH_COND(sc_index >= hlsl_spec_constants.size());
											llvm::AllocaInst *alloca_inst = llvm::dyn_cast<llvm::AllocaInst>(store.getPointerOperand());
											alloca_sc_inds[alloca_inst] = sc_index;
										}
									}
								}
							}

							// Pass 2:
							// - Replace uses of the result of volatile loads by constants, like this:
							//   Original:
							//     %590 = load volatile i32, i32* %61, align 4
							//     %591 = icmp eq i32 %590, 0
							//   Changed:
							//     %586 = icmp eq i32 ???, 0
							// - Remove any other instructions using the slot the load happened from,
							//   which includes not only volatile stores but also any other instruction
							//   the compiler may have added on its own, such as 'bitcast' and
							//   lifetime control calls, as well as any other instruction that is
							//   invalid now due to the previously removed ones.
#ifdef DEBUG_PRINT_AFFECTED_IR_INSTRS
							class cout_ostream : public llvm::raw_ostream {
								void write_impl(const char *Ptr, size_t Size) override {
									print_verbose("\t" + String(Ptr, Size));
								}
								uint64_t current_pos() const override { return -1; }
							};

							cout_ostream instr_ostream;
							llvm::ModuleSlotTracker instr_slot_tracker(&llvm_module);
#endif

							LocalVector<llvm::Instruction *> instrs_to_remove;
							HashSet<llvm::Instruction *> instrs_to_remove_unique;

							HashMap<llvm::LoadInst *, uint32_t> loads_to_replace_to_sc_index;
#ifdef DEBUG_PRINT_AFFECTED_IR_INSTRS
							if (debug) {
								print_verbose("REPLACED INSTRUCTIONS:");
							}
#endif

							for (KeyValue<llvm::AllocaInst *, uint32_t> &E : alloca_sc_inds) {
								llvm::AllocaInst *alloca_inst = E.key;
								uint32_t sc_index = E.value;

								if (!instrs_to_remove_unique.has(alloca_inst)) {
									instrs_to_remove.push_back(alloca_inst);
									instrs_to_remove_unique.insert(alloca_inst);

									for (llvm::User *U : alloca_inst->users()) {
										if (llvm::isa<llvm::LoadInst>(U) && llvm::cast<llvm::LoadInst>(U)->isVolatile()) {
											llvm::LoadInst *LI = llvm::cast<llvm::LoadInst>(U);
											if (!loads_to_replace_to_sc_index.has(LI)) {
#ifdef DEBUG_PRINT_AFFECTED_IR_INSTRS
												if (debug) {
													LI->print(instr_ostream, instr_slot_tracker);
												}
#endif
												loads_to_replace_to_sc_index[LI] = sc_index;
											}
										}
									}
								}
							}

							for (KeyValue<llvm::LoadInst *, uint32_t> &E : loads_to_replace_to_sc_index) {
								llvm::LoadInst *I = E.key;
								uint32_t sc_index = E.value;
								// Using a magic value that the patched LLVM bitcode generator will replace with a
								// 7-bit number, which is the maximum we'll be able to patch reliably (given the VBR encoding
								// we can't assume we can patch an 32-bit number in the bitcode with an arbitrary integer).
								// An alternative would be to store 32 bits, MSB being 1, leaving 31 bits for the value and letting
								// the shader unset the MSB to get the actual value.
								llvm::Constant *sc_constant = llvm::ConstantInt::get(llvm::Type::getInt32Ty(llvm_context), 0x45678900 + sc_index);
								I->replaceAllUsesWith(sc_constant);
							}

#ifdef DEBUG_PRINT_AFFECTED_IR_INSTRS
							if (debug) {
								print_verbose("REMOVED INSTRUCTIONS:");
							}
#endif
							{
								uint32_t k = 0;
								while (k < instrs_to_remove.size()) {
#ifdef DEBUG_PRINT_AFFECTED_IR_INSTRS
									if (debug) {
										instrs_to_remove[k]->print(instr_ostream, instr_slot_tracker);
									}
#endif
									for (llvm::User *U : instrs_to_remove[k]->users()) {
										llvm::Instruction *I = llvm::cast<llvm::Instruction>(U);
										if (!instrs_to_remove_unique.has(I)) {
											instrs_to_remove.push_back(I);
											instrs_to_remove_unique.insert(I);
										}
									}
									k++;
								}
							}

							// Empirically found that doing this in passes avoids catastrophic errors.
							for (uint32_t k = 0; k < instrs_to_remove.size(); k++) {
								instrs_to_remove[k]->removeFromParent();
								instrs_to_remove[k]->dropAllReferences();
							}
							for (uint32_t k = 0; k < instrs_to_remove.size(); k++) {
								delete instrs_to_remove[k];
							}

#ifdef DEBUG_SAVE_DXIL_ASSEMBLY_LISTINGS
							if (debug) {
								llvm_module.print(file_ostream("dxil_patched.txt"), nullptr);
							}
#endif
						}

						// Now rebuild the DXIL part.
						{
							// Borrowed from DXC, to avoid some include hell.
							class raw_stream_ostream : public llvm::raw_ostream {
							private:
								CComPtr<hlsl::AbstractMemoryStream> m_pStream;
								void write_impl(const char *Ptr, size_t Size) override {
									ULONG cbWritten;
									IFT(m_pStream->Write(Ptr, Size, &cbWritten));
								}
								uint64_t current_pos() const override { return m_pStream->GetPosition(); }

							public:
								raw_stream_ostream(hlsl::AbstractMemoryStream *pStream) :
										m_pStream(pStream) {}
								~raw_stream_ostream() override {
									flush();
								}
							};

							res = hlsl::CreateMemoryStream(DxcGetThreadMallocNoRef(), &patched_dxil_bc_part);
							ERR_FAIL_COND_V_MSG(res, Vector<uint8_t>(),
									"CreateMemoryStream() at shader stage '" + String(shader_stage_names[stage]) + "' failed with error " + vformat("0x%08x", res) + ".");

							ULONG header_size = 0;
							res = patched_dxil_bc_part->Write(dxil_header, sizeof(hlsl::DxilProgramHeader), &header_size);
							ERR_FAIL_COND_V_MSG(res, Vector<uint8_t>(),
									"Write() at shader stage '" + String(shader_stage_names[stage]) + "' failed with error " + vformat("0x%08x", res) + ".");

							sc_sentinel_offsets.clear();
							sc_sentinel_offsets.resize(hlsl_spec_constants.size());
							ULONG bitcode_start = patched_dxil_bc_part->GetPtrSize();
							{
								raw_stream_ostream ostream(patched_dxil_bc_part.Get());
								llvm::WriteBitcodeToFile(&llvm_module, ostream);
							}
							ULONG bitcode_end = patched_dxil_bc_part->GetPtrSize();

							dxil_part_start = patched_dxil_bc_part->GetPtr();
							dxil_part_size = patched_dxil_bc_part->GetPtrSize();

							((hlsl::DxilProgramHeader *)dxil_part_start)->SizeInUint32 = bitcode_end / sizeof(uint32_t);
							((hlsl::DxilProgramHeader *)dxil_part_start)->BitcodeHeader.BitcodeSize = bitcode_end - bitcode_start;
						}
					}

					dxil_writer->AddPart(four_cc, dxil_part_size, [=, &dxil_dxil_part_offset](hlsl::AbstractMemoryStream *s) {
						if (four_cc == hlsl::DFCC_DXIL) {
							dxil_dxil_part_offset = s->GetPosition();
						}
						ULONG written = 0;
						s->Write(dxil_part_start, dxil_part_size, &written);
						CRASH_COND(written != dxil_part_size);
					});
				}

				// Rebuild DXIL container.
				{
					ComPtr<hlsl::AbstractMemoryStream> dxil_stream;
					dxil_blob.resize(dxil_writer->size());
					res = hlsl::CreateFixedSizeMemoryStream(dxil_blob.ptrw(), dxil_writer->size(), dxil_stream.GetAddressOf());
					ERR_FAIL_COND_V_MSG(res, Vector<uint8_t>(),
							"CreateFixedSizeMemoryStream() at shader stage '" + String(shader_stage_names[stage]) + "' failed with error " + vformat("0x%08x", res) + ".");
					dxil_writer->write(dxil_stream.Get());
					CRASH_COND(dxil_dxil_part_offset == 0);
#ifdef DEBUG_SAVE_DXIL_BINARIES
					if (debug) {
						Ref<FileAccess> fa = FileAccess::open("dxil_patched.bin", FileAccess::WRITE);
						fa->store_buffer(dxil_blob.ptr(), dxil_blob.size());
					}
#endif
				}
			} catch (const hlsl::Exception &e) {
				ERR_FAIL_V_MSG(Vector<uint8_t>(),
						"Exception caught at shader stage '" + String(shader_stage_names[stage]) + "', with error code " + itos(e.hr) + ".");
			}

			// Consolidate specialization constants data from HLSL and DXIL.
			for (uint32_t j = 0; j < hlsl_spec_constants.size(); j++) {
				RenderingDeviceD3D12ShaderBinarySpecializationConstant sconst = {};
				HlslSpecConstant &spc = hlsl_spec_constants[j];

				sconst.constant_id = spc.id;
				sconst.int_value = 0.0; // Clear previous value JIC.
				if (hlsl_spec_constants[j].type_str == "bool") {
					sconst.type = PIPELINE_SPECIALIZATION_CONSTANT_TYPE_BOOL;
					sconst.bool_value = spc.value_str.to_int() != 0;
				} else if (hlsl_spec_constants[j].type_str == "uint") {
					sconst.type = PIPELINE_SPECIALIZATION_CONSTANT_TYPE_INT;
					sconst.int_value = spc.value_str.to_int();
				} else if (hlsl_spec_constants[j].type_str == "float") {
					sconst.type = PIPELINE_SPECIALIZATION_CONSTANT_TYPE_FLOAT;
					sconst.float_value = spc.value_str.to_float();
				} else {
					CRASH_NOW();
				}

				uint64_t abs_sc_sentinel_bit_offset =
						dxil_dxil_part_offset * 8 +
						sizeof(hlsl::DxilProgramHeader) * 8 +
						sc_sentinel_offsets[j];
				sconst.stages_bit_offsets[shader_stage_sc_offset_indices[stage]] = abs_sc_sentinel_bit_offset;

				int32_t existing = -1;
				for (int k = 0; k < specialization_constants.size(); k++) {
					if (specialization_constants[k].constant_id == sconst.constant_id) {
						ERR_FAIL_COND_V_MSG(specialization_constants[k].type != sconst.type, Vector<uint8_t>(), "More than one specialization constant used for id (" + itos(sconst.constant_id) + "), but their types differ.");
						ERR_FAIL_COND_V_MSG(specialization_constants[k].int_value != sconst.int_value, Vector<uint8_t>(), "More than one specialization constant used for id (" + itos(sconst.constant_id) + "), but their default values differ.");
						existing = k;
						break;
					}
				}

				if (existing != -1) {
					specialization_constants.write[existing].stages_bit_offsets[shader_stage_sc_offset_indices[stage]] = abs_sc_sentinel_bit_offset;
				} else {
					specialization_constants.push_back(sconst);
				}
			}
		}

		stages_processed |= (1 << stage);

		spirv_cross->spirv_cross::CompilerHLSL::~CompilerHLSL();
	}

	// Patch with default values of specialization constants.
	if (specialization_constants.size()) {
		for (const RenderingDeviceD3D12ShaderBinarySpecializationConstant &sc : specialization_constants) {
			_shader_patch_dxil_specialization_constant((PipelineSpecializationConstantType)sc.type, &sc.int_value, sc.stages_bit_offsets, dxil_blobs, true);
		}
	}

	// Sign.
	for (KeyValue<ShaderStage, Vector<uint8_t>> &E : dxil_blobs) {
		ShaderStage stage = E.key;
		Vector<uint8_t> &dxil_blob = E.value;
		bool sign_ok = _shader_sign_dxil_bytecode(stage, dxil_blob);
		ERR_FAIL_COND_V(!sign_ok, Vector<uint8_t>());
	}

	// Build the root signature.
	ComPtr<ID3DBlob> root_sig_blob;
	{
		auto stages_to_d3d12_visibility = [](uint32_t p_stages_mask) -> D3D12_SHADER_VISIBILITY {
			switch (p_stages_mask) {
				case SHADER_STAGE_VERTEX_BIT: {
					return D3D12_SHADER_VISIBILITY_VERTEX;
				}
				case SHADER_STAGE_FRAGMENT_BIT: {
					return D3D12_SHADER_VISIBILITY_PIXEL;
				}
				default: {
					return D3D12_SHADER_VISIBILITY_ALL;
				}
			}
		};

		LocalVector<D3D12_ROOT_PARAMETER1> root_params;

		// Root (push) constants.
		if (dxil_push_constant_size) {
			CD3DX12_ROOT_PARAMETER1 root_constants;
			root_constants.InitAsConstants(
					dxil_push_constant_size / sizeof(uint32_t),
					ROOT_CONSTANTS_REGISTER,
					ROOT_CONSTANTS_SPACE,
					stages_to_d3d12_visibility(push_constants_stages));
			root_params.push_back(root_constants);
		}

		// Descriptor tables.
		// Strategy: split into descriptor tables by stages mask -a.k.a. stages visibility- and uniform set.

		// These have to stay around until serialization!
		struct TraceableDescriptorTable {
			Vector<D3D12_DESCRIPTOR_RANGE1> ranges;
			Vector<RenderingDeviceD3D12ShaderBinaryDataBinding::RootSignatureLocation *> root_sig_locations;
		};
		using TablesMap = HashMap<D3D12_SHADER_VISIBILITY, TraceableDescriptorTable>;
		Vector<TablesMap> resource_tables_maps;
		Vector<TablesMap> sampler_tables_maps;

		for (int set = 0; set < uniform_info.size(); set++) {
			bool first_resource_in_set = true;
			bool first_sampler_in_set = true;
			uniform_info.write[set].sort();
			for (int i = 0; i < uniform_info[set].size(); i++) {
				HashMap<uint32_t, DxilBindingInfo>::Iterator dxil_info = dxil_binding_info.find((set << 16) | uniform_info[set][i].binding);
				if (!dxil_info) {
					continue;
				}

				bool has_resource = false;
				D3D12_DESCRIPTOR_RANGE_TYPE resource_range_type = {};
				bool has_sampler = false;
				UINT num_descriptors = 1;

				switch (uniform_info[set][i].type) {
					case UNIFORM_TYPE_UNIFORM_BUFFER: {
						has_resource = true;
						resource_range_type = D3D12_DESCRIPTOR_RANGE_TYPE_CBV;
					} break;
					case UNIFORM_TYPE_IMAGE: {
						has_resource = true;
						resource_range_type = uniform_info[set][i].writable ? D3D12_DESCRIPTOR_RANGE_TYPE_UAV : D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
						num_descriptors = uniform_info[set][i].length;
					} break;
					case UNIFORM_TYPE_TEXTURE:
					case UNIFORM_TYPE_INPUT_ATTACHMENT: {
						has_resource = true;
						resource_range_type = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
						num_descriptors = uniform_info[set][i].length;
					} break;
					case UNIFORM_TYPE_SAMPLER_WITH_TEXTURE: {
						has_resource = true;
						resource_range_type = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
						has_sampler = dxil_info->value.locations.sampler.size(); // Not true for sure since DXC may have optimized out the sampler.
						num_descriptors = uniform_info[set][i].length;
					} break;
					case UNIFORM_TYPE_SAMPLER: {
						has_sampler = true;
						num_descriptors = uniform_info[set][i].length;
					} break;
					case UNIFORM_TYPE_STORAGE_BUFFER: {
						has_resource = true;
						if (uniform_info[set][i].writable) {
							resource_range_type = D3D12_DESCRIPTOR_RANGE_TYPE_UAV;
						} else {
							// TODO: Maybe it's possible to use CBV here if size < 64 Ki?
							resource_range_type = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
						}
					} break;
					default: {
						CRASH_NOW(); // Should be unreachable.
					}
				}

				CRASH_COND(has_resource != (bool)dxil_info->value.locations.resource.size());
				CRASH_COND(!has_sampler && (bool)dxil_info->value.locations.sampler.size()); // Sampler with no binding is still possible (due to optimization).

				auto insert_range_per_visibility = [&stages_to_d3d12_visibility](
														   D3D12_DESCRIPTOR_RANGE_TYPE p_range_type,
														   uint32_t p_num_descriptors,
														   const LocalVector<DxilBindingInfo::Location> &p_dxil_locations,
														   RenderingDeviceD3D12ShaderBinaryDataBinding::RootSignatureLocation(&p_root_sig_locations)[2],
														   Vector<TablesMap> &r_tables_maps,
														   bool &r_first_in_set) {
					if (r_first_in_set) {
						r_tables_maps.resize(r_tables_maps.size() + 1);
						r_first_in_set = false;
					}
					TablesMap &tables_by_vis = r_tables_maps.write[r_tables_maps.size() - 1];

					for (uint32_t vis_idx = 0; vis_idx < p_dxil_locations.size(); vis_idx++) {
						const DxilBindingInfo::Location &dxil_location = p_dxil_locations[vis_idx];

						D3D12_SHADER_VISIBILITY vis = stages_to_d3d12_visibility(dxil_location.stages_mask);
						CRASH_COND(p_dxil_locations.size() > 1 && vis == D3D12_SHADER_VISIBILITY_ALL);

						CD3DX12_DESCRIPTOR_RANGE1 range;
						// Due to the aliasing hack for SRV-UAV of different families,
						// we can be causing an unintended change of data (sometimes the validation layers catch it).
						D3D12_DESCRIPTOR_RANGE_FLAGS flags = D3D12_DESCRIPTOR_RANGE_FLAG_NONE;
						if (p_range_type == D3D12_DESCRIPTOR_RANGE_TYPE_SRV || p_range_type == D3D12_DESCRIPTOR_RANGE_TYPE_UAV) {
							flags = D3D12_DESCRIPTOR_RANGE_FLAG_DATA_VOLATILE;
						} else if (p_range_type == D3D12_DESCRIPTOR_RANGE_TYPE_CBV) {
							flags = D3D12_DESCRIPTOR_RANGE_FLAG_DATA_STATIC_WHILE_SET_AT_EXECUTE;
						}
						range.Init(p_range_type, p_num_descriptors, dxil_location.bind_point, dxil_location.space, flags);

						tables_by_vis[vis].ranges.push_back(range);

						// If multiple stages are relevant, fill the location array items that correspond,
						// instead of in order, to make it easier later to fill the frame descriptors heap;
						// (i.e., keep fragment at index 1, regardless there's a location for vertex).
						uint32_t rs_loc_idx = 0;
						if (vis == D3D12_SHADER_VISIBILITY_ALL || vis == D3D12_SHADER_VISIBILITY_VERTEX) {
							rs_loc_idx = 0;
						} else if (vis == D3D12_SHADER_VISIBILITY_PIXEL) {
							rs_loc_idx = 1;
						} else {
							CRASH_NOW();
						}
						tables_by_vis[vis].root_sig_locations.push_back(&p_root_sig_locations[rs_loc_idx]);
					}
				};

				if (has_resource) {
					insert_range_per_visibility(
							resource_range_type,
							num_descriptors,
							dxil_info->value.locations.resource,
							uniform_info.write[set].write[i].root_sig_locations[RS_LOC_TYPE_RESOURCE],
							resource_tables_maps,
							first_resource_in_set);
				}
				if (has_sampler) {
					insert_range_per_visibility(
							D3D12_DESCRIPTOR_RANGE_TYPE_SAMPLER,
							num_descriptors,
							dxil_info->value.locations.sampler,
							uniform_info.write[set].write[i].root_sig_locations[RS_LOC_TYPE_SAMPLER],
							sampler_tables_maps,
							first_sampler_in_set);
				}
			}
		}

		auto make_descriptor_tables = [&root_params](const Vector<TablesMap> &p_tables) {
			for (const TablesMap &ranges_per_vis : p_tables) {
				for (const KeyValue<D3D12_SHADER_VISIBILITY, TraceableDescriptorTable> &E : ranges_per_vis) {
					D3D12_SHADER_VISIBILITY visibility = E.key;
					const TraceableDescriptorTable &table = E.value;
					DEV_ASSERT(table.ranges.size() == table.root_sig_locations.size());
					for (int i = 0; i < table.ranges.size(); i++) {
						// By now we know very well which root signature location corresponds to the pointed uniform.
						table.root_sig_locations[i]->root_param_idx = root_params.size();
						table.root_sig_locations[i]->range_idx = i;
					}

					CD3DX12_ROOT_PARAMETER1 root_table;
					root_table.InitAsDescriptorTable(table.ranges.size(), table.ranges.ptr(), visibility);
					root_params.push_back(root_table);
				}
			}
		};

		make_descriptor_tables(resource_tables_maps);
		make_descriptor_tables(sampler_tables_maps);

		CD3DX12_VERSIONED_ROOT_SIGNATURE_DESC root_sig_desc = {};
		D3D12_ROOT_SIGNATURE_FLAGS root_sig_flags =
				D3D12_ROOT_SIGNATURE_FLAG_DENY_HULL_SHADER_ROOT_ACCESS |
				D3D12_ROOT_SIGNATURE_FLAG_DENY_DOMAIN_SHADER_ROOT_ACCESS |
				D3D12_ROOT_SIGNATURE_FLAG_DENY_GEOMETRY_SHADER_ROOT_ACCESS |
				D3D12_ROOT_SIGNATURE_FLAG_DENY_AMPLIFICATION_SHADER_ROOT_ACCESS |
				D3D12_ROOT_SIGNATURE_FLAG_DENY_MESH_SHADER_ROOT_ACCESS;
		if (!(stages_processed & SHADER_STAGE_VERTEX_BIT)) {
			root_sig_flags |= D3D12_ROOT_SIGNATURE_FLAG_DENY_VERTEX_SHADER_ROOT_ACCESS;
		}
		if (!(stages_processed & SHADER_STAGE_FRAGMENT_BIT)) {
			root_sig_flags |= D3D12_ROOT_SIGNATURE_FLAG_DENY_PIXEL_SHADER_ROOT_ACCESS;
		}
		if (binary_data.vertex_input_mask) {
			root_sig_flags |= D3D12_ROOT_SIGNATURE_FLAG_ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT;
		}
		root_sig_desc.Init_1_1(root_params.size(), root_params.ptr(), 0, nullptr, root_sig_flags);

		ComPtr<ID3DBlob> error_blob;
		HRESULT res = D3DX12SerializeVersionedRootSignature(&root_sig_desc, D3D_ROOT_SIGNATURE_VERSION_1_1, root_sig_blob.GetAddressOf(), error_blob.GetAddressOf());
		ERR_FAIL_COND_V_MSG(res, Vector<uint8_t>(),
				"Serialization of root signature failed with error " + vformat("0x%08x", res) + " and the following message:\n" + String((char *)error_blob->GetBufferPointer(), error_blob->GetBufferSize()));

		binary_data.root_signature_crc = crc32(0, (const Bytef *)root_sig_blob->GetBufferPointer(), root_sig_blob->GetBufferSize());
	}

	Vector<Vector<uint8_t>> compressed_stages;
	Vector<uint32_t> zstd_size;

	uint32_t stages_binary_size = 0;

	for (int i = 0; i < p_spirv.size(); i++) {
		Vector<uint8_t> zstd;
		Vector<uint8_t> &dxil_blob = dxil_blobs[p_spirv[i].shader_stage];
		zstd.resize(Compression::get_max_compressed_buffer_size(dxil_blob.size(), Compression::MODE_ZSTD));
		int dst_size = Compression::compress(zstd.ptrw(), dxil_blob.ptr(), dxil_blob.size(), Compression::MODE_ZSTD);

		zstd_size.push_back(dst_size);
		zstd.resize(dst_size);
		compressed_stages.push_back(zstd);

		uint32_t s = compressed_stages[i].size();
		if (s % 4 != 0) {
			s += 4 - (s % 4);
		}
		stages_binary_size += s;
	}

	binary_data.specialization_constant_count = specialization_constants.size();
	binary_data.spirv_specialization_constants_ids_mask = spirv_specialization_constants_ids_mask;
	binary_data.set_count = uniform_info.size();
	binary_data.spirv_push_constant_size = spirv_push_constant_size;
	binary_data.dxil_push_constant_size = dxil_push_constant_size;
	binary_data.stage_count = p_spirv.size();

	CharString shader_name_utf = p_shader_name.utf8();

	binary_data.shader_name_len = shader_name_utf.length();

	uint32_t total_size = sizeof(uint32_t) * 3; // Header + version + main datasize;.
	total_size += sizeof(RenderingDeviceD3D12ShaderBinaryData);

	total_size += binary_data.shader_name_len;
	if ((binary_data.shader_name_len % 4) != 0) { // Alignment rules are really strange.
		total_size += 4 - (binary_data.shader_name_len % 4);
	}

	for (int i = 0; i < uniform_info.size(); i++) {
		total_size += sizeof(uint32_t);
		total_size += uniform_info[i].size() * sizeof(RenderingDeviceD3D12ShaderBinaryDataBinding);
	}

	total_size += sizeof(RenderingDeviceD3D12ShaderBinarySpecializationConstant) * specialization_constants.size();

	total_size += compressed_stages.size() * sizeof(uint32_t) * 3; // Sizes.
	total_size += stages_binary_size;

	binary_data.root_signature_len = root_sig_blob->GetBufferSize();
	total_size += binary_data.root_signature_len;

	Vector<uint8_t> ret;
	ret.resize(total_size);
	{
		uint32_t offset = 0;
		uint8_t *binptr = ret.ptrw();
		binptr[0] = 'G';
		binptr[1] = 'S';
		binptr[2] = 'B';
		binptr[3] = 'D'; // Godot shader binary data.
		offset += 4;
		encode_uint32(SHADER_BINARY_VERSION, binptr + offset);
		offset += sizeof(uint32_t);
		encode_uint32(sizeof(RenderingDeviceD3D12ShaderBinaryData), binptr + offset);
		offset += sizeof(uint32_t);
		memcpy(binptr + offset, &binary_data, sizeof(RenderingDeviceD3D12ShaderBinaryData));
		offset += sizeof(RenderingDeviceD3D12ShaderBinaryData);
		memcpy(binptr + offset, shader_name_utf.ptr(), binary_data.shader_name_len);
		offset += binary_data.shader_name_len;

		if ((binary_data.shader_name_len % 4) != 0) { // Alignment rules are really strange.
			offset += 4 - (binary_data.shader_name_len % 4);
		}

		for (int i = 0; i < uniform_info.size(); i++) {
			int count = uniform_info[i].size();
			encode_uint32(count, binptr + offset);
			offset += sizeof(uint32_t);
			if (count > 0) {
				memcpy(binptr + offset, uniform_info[i].ptr(), sizeof(RenderingDeviceD3D12ShaderBinaryDataBinding) * count);
				offset += sizeof(RenderingDeviceD3D12ShaderBinaryDataBinding) * count;
			}
		}

		if (specialization_constants.size()) {
			memcpy(binptr + offset, specialization_constants.ptr(), sizeof(RenderingDeviceD3D12ShaderBinarySpecializationConstant) * specialization_constants.size());
			offset += sizeof(RenderingDeviceD3D12ShaderBinarySpecializationConstant) * specialization_constants.size();
		}

		for (int i = 0; i < compressed_stages.size(); i++) {
			encode_uint32(p_spirv[i].shader_stage, binptr + offset);
			offset += sizeof(uint32_t);
			encode_uint32(dxil_blobs[p_spirv[i].shader_stage].size(), binptr + offset);
			offset += sizeof(uint32_t);
			encode_uint32(zstd_size[i], binptr + offset);
			offset += sizeof(uint32_t);
			memcpy(binptr + offset, compressed_stages[i].ptr(), compressed_stages[i].size());

			uint32_t s = compressed_stages[i].size();

			if (s % 4 != 0) {
				s += 4 - (s % 4);
			}

			offset += s;
		}

		memcpy(binptr + offset, root_sig_blob->GetBufferPointer(), root_sig_blob->GetBufferSize());
		offset += root_sig_blob->GetBufferSize();

		ERR_FAIL_COND_V(offset != (uint32_t)ret.size(), Vector<uint8_t>());
	}

	return ret;
}

RID RenderingDeviceD3D12::shader_create_from_bytecode(const Vector<uint8_t> &p_shader_binary) {
	const uint8_t *binptr = p_shader_binary.ptr();
	uint32_t binsize = p_shader_binary.size();

	uint32_t read_offset = 0;
	// Consistency check.
	ERR_FAIL_COND_V(binsize < sizeof(uint32_t) * 3 + sizeof(RenderingDeviceD3D12ShaderBinaryData), RID());
	ERR_FAIL_COND_V(binptr[0] != 'G' || binptr[1] != 'S' || binptr[2] != 'B' || binptr[3] != 'D', RID());

	uint32_t bin_version = decode_uint32(binptr + 4);
	ERR_FAIL_COND_V(bin_version != SHADER_BINARY_VERSION, RID());

	uint32_t bin_data_size = decode_uint32(binptr + 8);

	const RenderingDeviceD3D12ShaderBinaryData &binary_data = *(reinterpret_cast<const RenderingDeviceD3D12ShaderBinaryData *>(binptr + 12));

	uint32_t vertex_input_mask = binary_data.vertex_input_mask;

	uint32_t fragment_output_mask = binary_data.fragment_output_mask;

	bool is_compute = binary_data.is_compute;

	const uint32_t compute_local_size[3] = { binary_data.compute_local_size[0], binary_data.compute_local_size[1], binary_data.compute_local_size[2] };

	read_offset += sizeof(uint32_t) * 3 + bin_data_size;

	String name;

	if (binary_data.shader_name_len) {
		name.parse_utf8((const char *)(binptr + read_offset), binary_data.shader_name_len);
		read_offset += binary_data.shader_name_len;
		if ((binary_data.shader_name_len % 4) != 0) { // Alignment rules are really strange.
			read_offset += 4 - (binary_data.shader_name_len % 4);
		}
	}

	Vector<Shader::Set> set_info;
	set_info.resize(binary_data.set_count);

	for (uint32_t i = 0; i < binary_data.set_count; i++) {
		ERR_FAIL_COND_V(read_offset + sizeof(uint32_t) >= binsize, RID());
		uint32_t set_count = decode_uint32(binptr + read_offset);
		read_offset += sizeof(uint32_t);
		const RenderingDeviceD3D12ShaderBinaryDataBinding *set_ptr = reinterpret_cast<const RenderingDeviceD3D12ShaderBinaryDataBinding *>(binptr + read_offset);
		uint32_t set_size = set_count * sizeof(RenderingDeviceD3D12ShaderBinaryDataBinding);
		ERR_FAIL_COND_V(read_offset + set_size >= binsize, RID());

		for (uint32_t j = 0; j < set_count; j++) {
			Shader::ShaderUniformInfo sui;

			sui.info.type = UniformType(set_ptr[j].type);
			sui.info.writable = set_ptr[j].writable;
			sui.info.length = set_ptr[j].length;
			sui.info.binding = set_ptr[j].binding;

			sui.binding.stages = set_ptr[j].stages;
			static_assert(sizeof(UniformBindingInfo::root_sig_locations) == sizeof(RenderingDeviceD3D12ShaderBinaryDataBinding::root_sig_locations));
			memcpy(&sui.binding.root_sig_locations, &set_ptr[j].root_sig_locations, sizeof(UniformBindingInfo::root_sig_locations));

			set_info.write[i].uniforms.push_back(sui);

			for (uint32_t k = 0; k < ARRAY_SIZE(sui.binding.root_sig_locations.resource); k++) {
				if (sui.binding.root_sig_locations.resource[k].root_param_idx != UINT32_MAX) {
					set_info.write[i].num_root_params.resources++;
				}
			}
			for (uint32_t k = 0; k < ARRAY_SIZE(sui.binding.root_sig_locations.sampler); k++) {
				if (sui.binding.root_sig_locations.sampler[k].root_param_idx != UINT32_MAX) {
					set_info.write[i].num_root_params.samplers++;
				}
			}
		}

		read_offset += set_size;
	}

	ERR_FAIL_COND_V(read_offset + binary_data.specialization_constant_count * sizeof(RenderingDeviceD3D12ShaderBinarySpecializationConstant) >= binsize, RID());

	Vector<Shader::SpecializationConstant> specialization_constants;

	for (uint32_t i = 0; i < binary_data.specialization_constant_count; i++) {
		const RenderingDeviceD3D12ShaderBinarySpecializationConstant &src_sc = *(reinterpret_cast<const RenderingDeviceD3D12ShaderBinarySpecializationConstant *>(binptr + read_offset));
		Shader::SpecializationConstant sc;
		sc.constant.int_value = src_sc.int_value;
		sc.constant.type = PipelineSpecializationConstantType(src_sc.type);
		sc.constant.constant_id = src_sc.constant_id;
		memcpy(sc.stages_bit_offsets, src_sc.stages_bit_offsets, sizeof(sc.stages_bit_offsets));
		specialization_constants.push_back(sc);

		read_offset += sizeof(RenderingDeviceD3D12ShaderBinarySpecializationConstant);
	}

	HashMap<ShaderStage, Vector<uint8_t>> stages_bytecode;

	for (uint32_t i = 0; i < binary_data.stage_count; i++) {
		ERR_FAIL_COND_V(read_offset + sizeof(uint32_t) * 3 >= binsize, RID());
		uint32_t stage = decode_uint32(binptr + read_offset);
		read_offset += sizeof(uint32_t);
		uint32_t dxil_size = decode_uint32(binptr + read_offset);
		read_offset += sizeof(uint32_t);
		uint32_t zstd_size = decode_uint32(binptr + read_offset);
		read_offset += sizeof(uint32_t);

		// Decompress.
		Vector<uint8_t> dxil;
		dxil.resize(dxil_size);
		int dec_dxil_size = Compression::decompress(dxil.ptrw(), dxil.size(), binptr + read_offset, zstd_size, Compression::MODE_ZSTD);
		ERR_FAIL_COND_V(dec_dxil_size != (int32_t)dxil_size, RID());
		stages_bytecode[ShaderStage(stage)] = dxil;

		if (zstd_size % 4 != 0) {
			zstd_size += 4 - (zstd_size % 4);
		}

		ERR_FAIL_COND_V(read_offset + zstd_size > binsize, RID());

		read_offset += zstd_size;
	}

	const uint8_t *root_sig_data_ptr = binptr + read_offset;

	ComPtr<ID3D12RootSignatureDeserializer> root_sig_deserializer;
	HRESULT res = D3D12CreateRootSignatureDeserializer(root_sig_data_ptr, binary_data.root_signature_len, IID_PPV_ARGS(root_sig_deserializer.GetAddressOf()));
	ERR_FAIL_COND_V_MSG(res, RID(), "D3D12CreateRootSignatureDeserializer failed with error " + vformat("0x%08x", res) + ".");
	read_offset += binary_data.root_signature_len;

	ERR_FAIL_COND_V(read_offset != binsize, RID());

	// TODO: Need to lock?
	_THREAD_SAFE_METHOD_

	ComPtr<ID3D12RootSignature> root_signature;
	res = device->CreateRootSignature(0, root_sig_data_ptr, binary_data.root_signature_len, IID_PPV_ARGS(root_signature.GetAddressOf()));
	ERR_FAIL_COND_V_MSG(res, RID(), "CreateRootSignature failed with error " + vformat("0x%08x", res) + ".");

	Shader shader;

	shader.vertex_input_mask = vertex_input_mask;
	shader.fragment_output_mask = fragment_output_mask;
	shader.spirv_push_constant_size = binary_data.spirv_push_constant_size;
	shader.dxil_push_constant_size = binary_data.dxil_push_constant_size;
	shader.is_compute = is_compute;
	shader.compute_local_size[0] = compute_local_size[0];
	shader.compute_local_size[1] = compute_local_size[1];
	shader.compute_local_size[2] = compute_local_size[2];
	shader.specialization_constants = specialization_constants;
	shader.spirv_specialization_constants_ids_mask = binary_data.spirv_specialization_constants_ids_mask;
	shader.name = name;
	shader.root_signature = root_signature;
	shader.root_signature_deserializer = root_sig_deserializer;
	shader.root_signature_desc = root_sig_deserializer->GetRootSignatureDesc();
	shader.root_signature_crc = binary_data.root_signature_crc;
	shader.stages_bytecode = stages_bytecode;

	// Proceed to create descriptor sets.
	for (uint32_t i = 0; i < binary_data.set_count; i++) {
		uint32_t format = 0; // No format, default.

		Shader::Set &set = set_info.write[i];
		if (set.uniforms.size()) {
			// Has data, needs an actual format;.
			UniformSetFormat usformat;
			usformat.uniform_info.resize(set.uniforms.size());
			for (int j = 0; j < set.uniforms.size(); j++) {
				usformat.uniform_info.write[j] = set.uniforms[j].info;
			}
			RBMap<UniformSetFormat, uint32_t>::Element *E = uniform_set_format_cache.find(usformat);
			if (E) {
				format = E->get();
			} else {
				format = uniform_set_format_cache.size() + 1;
				E = uniform_set_format_cache.insert(usformat, format);
				uniform_set_format_cache_reverse.push_back(E);
				DEV_ASSERT(uniform_set_format_cache_reverse.size() == uniform_set_format_cache.size());
			}
		}

		shader.sets.push_back(set);
		shader.set_formats.push_back(format);
	}

	RID id = shader_owner.make_rid(shader);
#ifdef DEV_ENABLED
	set_resource_name(id, "RID:" + itos(id.get_id()));
#endif
	return id;
}

uint32_t RenderingDeviceD3D12::shader_get_vertex_input_attribute_mask(RID p_shader) {
	_THREAD_SAFE_METHOD_

	const Shader *shader = shader_owner.get_or_null(p_shader);
	ERR_FAIL_COND_V(!shader, 0);
	return shader->vertex_input_mask;
}

/******************/
/**** UNIFORMS ****/
/******************/

RID RenderingDeviceD3D12::uniform_buffer_create(uint32_t p_size_bytes, const Vector<uint8_t> &p_data) {
	_THREAD_SAFE_METHOD_

	ERR_FAIL_COND_V(p_data.size() && (uint32_t)p_data.size() != p_size_bytes, RID());
	ERR_FAIL_COND_V_MSG(draw_list != nullptr && p_data.size(), RID(),
			"Creating buffers with data is forbidden during creation of a draw list");
	ERR_FAIL_COND_V_MSG(compute_list != nullptr && p_data.size(), RID(),
			"Creating buffers with data is forbidden during creation of a draw list");

	Buffer buffer;
	Error err = _buffer_allocate(&buffer, p_size_bytes, D3D12_RESOURCE_STATE_VERTEX_AND_CONSTANT_BUFFER, D3D12_HEAP_TYPE_DEFAULT);
	ERR_FAIL_COND_V(err != OK, RID());

	if (p_data.size()) {
		uint64_t data_size = p_data.size();
		const uint8_t *r = p_data.ptr();
		_buffer_update(&buffer, 0, r, data_size);
	}
	RID id = uniform_buffer_owner.make_rid(buffer);
#ifdef DEV_ENABLED
	set_resource_name(id, "RID:" + itos(id.get_id()));
#endif
	return id;
}

RID RenderingDeviceD3D12::storage_buffer_create(uint32_t p_size_bytes, const Vector<uint8_t> &p_data, BitField<StorageBufferUsage> p_usage) {
	_THREAD_SAFE_METHOD_
	ERR_FAIL_COND_V_MSG(draw_list != nullptr && p_data.size(), RID(),
			"Creating buffers with data is forbidden during creation of a draw list");
	ERR_FAIL_COND_V_MSG(compute_list != nullptr && p_data.size(), RID(),
			"Creating buffers with data is forbidden during creation of a draw list");

	ERR_FAIL_COND_V(p_data.size() && (uint32_t)p_data.size() != p_size_bytes, RID());

	Buffer buffer;
	D3D12_RESOURCE_STATES states = D3D12_RESOURCE_STATE_COPY_SOURCE | D3D12_RESOURCE_STATE_COPY_DEST | D3D12_RESOURCE_STATE_UNORDERED_ACCESS;
	if (p_usage.has_flag(STORAGE_BUFFER_USAGE_DISPATCH_INDIRECT)) {
		states |= D3D12_RESOURCE_STATE_INDIRECT_ARGUMENT;
	}
	Error err = _buffer_allocate(&buffer, p_size_bytes, states, D3D12_HEAP_TYPE_DEFAULT);
	ERR_FAIL_COND_V(err != OK, RID());

	if (p_data.size()) {
		uint64_t data_size = p_data.size();
		const uint8_t *r = p_data.ptr();
		_buffer_update(&buffer, 0, r, data_size);
	}
	return storage_buffer_owner.make_rid(buffer);
}

RID RenderingDeviceD3D12::texture_buffer_create(uint32_t p_size_elements, DataFormat p_format, const Vector<uint8_t> &p_data) {
	_THREAD_SAFE_METHOD_
	ERR_FAIL_COND_V_MSG(draw_list != nullptr && p_data.size(), RID(),
			"Creating buffers with data is forbidden during creation of a draw list");
	ERR_FAIL_COND_V_MSG(compute_list != nullptr && p_data.size(), RID(),
			"Creating buffers with data is forbidden during creation of a draw list");

	uint32_t element_size = get_format_vertex_size(p_format);
	ERR_FAIL_COND_V_MSG(element_size == 0, RID(), "Format requested is not supported for texture buffers");
	uint64_t size_bytes = uint64_t(element_size) * p_size_elements;

	ERR_FAIL_COND_V(p_data.size() && (uint32_t)p_data.size() != size_bytes, RID());

	TextureBuffer texture_buffer;
	Error err = _buffer_allocate(&texture_buffer.buffer, size_bytes, D3D12_RESOURCE_STATE_ALL_SHADER_RESOURCE, D3D12_HEAP_TYPE_DEFAULT);
	ERR_FAIL_COND_V(err != OK, RID());

	if (p_data.size()) {
		uint64_t data_size = p_data.size();
		const uint8_t *r = p_data.ptr();
		_buffer_update(&texture_buffer.buffer, 0, r, data_size);
	}

	// Allocate the view.
	RID id = texture_buffer_owner.make_rid(texture_buffer);
#ifdef DEV_ENABLED
	set_resource_name(id, "RID:" + itos(id.get_id()));
#endif
	return id;
}

Error RenderingDeviceD3D12::DescriptorsHeap::allocate(ID3D12Device *p_device, D3D12_DESCRIPTOR_HEAP_TYPE p_type, uint32_t p_descriptor_count, bool p_for_gpu) {
	ERR_FAIL_COND_V(heap, ERR_ALREADY_EXISTS);
	ERR_FAIL_COND_V(p_descriptor_count == 0, ERR_INVALID_PARAMETER);

	handle_size = p_device->GetDescriptorHandleIncrementSize(p_type);

	desc.Type = p_type;
	desc.NumDescriptors = p_descriptor_count;
	desc.Flags = p_for_gpu ? D3D12_DESCRIPTOR_HEAP_FLAG_SHADER_VISIBLE : D3D12_DESCRIPTOR_HEAP_FLAG_NONE;
	HRESULT res = p_device->CreateDescriptorHeap(&desc, IID_PPV_ARGS(heap.GetAddressOf()));
	ERR_FAIL_COND_V_MSG(res, ERR_CANT_CREATE, "CreateDescriptorHeap failed with error " + vformat("0x%08x", res) + ".");

	return OK;
}

RenderingDeviceD3D12::DescriptorsHeap::Walker RenderingDeviceD3D12::DescriptorsHeap::make_walker() const {
	Walker walker;
	walker.handle_size = handle_size;
	walker.handle_count = desc.NumDescriptors;
	if (heap) {
		walker.first_cpu_handle = heap->GetCPUDescriptorHandleForHeapStart();
		if ((desc.Flags & D3D12_DESCRIPTOR_HEAP_FLAG_SHADER_VISIBLE)) {
			walker.first_gpu_handle = heap->GetGPUDescriptorHandleForHeapStart();
		}
	}
	return walker;
}

void RenderingDeviceD3D12::DescriptorsHeap::Walker::advance(uint32_t p_count) {
	ERR_FAIL_COND_MSG(handle_index + p_count > handle_count, "Would advance past EOF.");
	handle_index += p_count;
}

D3D12_CPU_DESCRIPTOR_HANDLE RenderingDeviceD3D12::DescriptorsHeap::Walker::get_curr_cpu_handle() {
	ERR_FAIL_COND_V_MSG(is_at_eof(), D3D12_CPU_DESCRIPTOR_HANDLE(), "Heap walker is at EOF.");
	return D3D12_CPU_DESCRIPTOR_HANDLE{ first_cpu_handle.ptr + handle_index * handle_size };
}

D3D12_GPU_DESCRIPTOR_HANDLE RenderingDeviceD3D12::DescriptorsHeap::Walker::get_curr_gpu_handle() {
	ERR_FAIL_COND_V_MSG(!first_gpu_handle.ptr, D3D12_GPU_DESCRIPTOR_HANDLE(), "Can't provide a GPU handle from a non-GPU descriptors heap.");
	ERR_FAIL_COND_V_MSG(is_at_eof(), D3D12_GPU_DESCRIPTOR_HANDLE(), "Heap walker is at EOF.");
	return D3D12_GPU_DESCRIPTOR_HANDLE{ first_gpu_handle.ptr + handle_index * handle_size };
}

RID RenderingDeviceD3D12::uniform_set_create(const Vector<Uniform> &p_uniforms, RID p_shader, uint32_t p_shader_set) {
	_THREAD_SAFE_METHOD_

	ERR_FAIL_COND_V(p_uniforms.size() == 0, RID());

	Shader *shader = shader_owner.get_or_null(p_shader);
	ERR_FAIL_COND_V(!shader, RID());

	ERR_FAIL_COND_V_MSG(p_shader_set >= (uint32_t)shader->sets.size() || shader->sets[p_shader_set].uniforms.size() == 0, RID(),
			"Desired set (" + itos(p_shader_set) + ") not used by shader.");
	// See that all sets in shader are satisfied.

	const Shader::Set &set = shader->sets[p_shader_set];

	uint32_t uniform_count = p_uniforms.size();
	const Uniform *uniforms = p_uniforms.ptr();

	uint32_t set_uniform_count = set.uniforms.size();
	const Shader::ShaderUniformInfo *set_uniforms = set.uniforms.ptr();

	// Do a first pass to count resources and samplers, and error checking.
	uint32_t num_resource_descs = 0;
	uint32_t num_sampler_descs = 0;
	LocalVector<int> uniform_indices;
	uniform_indices.resize(set_uniform_count);
	for (uint32_t i = 0; i < set_uniform_count; i++) {
		const UniformInfo &set_uniform = set_uniforms[i].info;
		int uniform_idx = -1;
		for (int j = 0; j < (int)uniform_count; j++) {
			if (uniforms[j].binding == set_uniform.binding) {
				uniform_idx = j;
			}
		}
		ERR_FAIL_COND_V_MSG(uniform_idx == -1, RID(),
				"All the shader bindings for the given set must be covered by the uniforms provided. Binding (" + itos(set_uniform.binding) + "), set (" + itos(p_shader_set) + ") was not provided.");
		uniform_indices[i] = uniform_idx;

		const Uniform &uniform = uniforms[uniform_idx];
		ERR_FAIL_COND_V_MSG(uniform.uniform_type != set_uniform.type, RID(),
				"Mismatch uniform type for binding (" + itos(set_uniform.binding) + "), set (" + itos(p_shader_set) + "). Expected '" + shader_uniform_names[set_uniform.type] + "', supplied: '" + shader_uniform_names[uniform.uniform_type] + "'.");

		// Since the uniform set may be created for a shader different than the one that will be actually bound,
		// which may have a different set of uniforms optimized out, the stages mask we can check now is not reliable.
		// Therefore, we can't make any assumptions here about descriptors that we may not need to create,
		// pixel or vertex-only shader resource states, etc.

		switch (uniform.uniform_type) {
			case UNIFORM_TYPE_SAMPLER: {
				num_sampler_descs += uniform.get_id_count();
			} break;
			case UNIFORM_TYPE_SAMPLER_WITH_TEXTURE:
			case UNIFORM_TYPE_SAMPLER_WITH_TEXTURE_BUFFER: {
				num_sampler_descs += uniform.get_id_count() / 2;
				num_resource_descs += uniform.get_id_count() / 2;
			} break;
			case UNIFORM_TYPE_STORAGE_BUFFER:
			case UNIFORM_TYPE_IMAGE: {
				num_resource_descs += uniform.get_id_count();
			} break;
			default: {
				num_resource_descs += uniform.get_id_count();
			}
		}
	}

	struct {
		DescriptorsHeap resources;
		DescriptorsHeap samplers;
	} desc_heaps;
#ifdef DEV_ENABLED
	LocalVector<UniformSet::ResourceDescInfo> resources_desc_info;
#endif

	if (num_resource_descs) {
		Error err = desc_heaps.resources.allocate(device.Get(), D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV, num_resource_descs, false);
		ERR_FAIL_COND_V(err, RID());
	}
	if (num_sampler_descs) {
		Error err = desc_heaps.samplers.allocate(device.Get(), D3D12_DESCRIPTOR_HEAP_TYPE_SAMPLER, num_sampler_descs, false);
		ERR_FAIL_COND_V(err, RID());
	}
	struct {
		DescriptorsHeap::Walker resources;
		DescriptorsHeap::Walker samplers;
	} desc_heap_walkers;
	desc_heap_walkers.resources = desc_heaps.resources.make_walker();
	desc_heap_walkers.samplers = desc_heaps.samplers.make_walker();

	// Used for verification to make sure a uniform set does not use a framebuffer bound texture.
	LocalVector<UniformSet::AttachableTexture> attachable_textures;
	struct RIDState {
		bool is_buffer = false;
		uint64_t shader_uniform_idx_mask = 0;
		ResourceState state;
	};
	HashMap<Resource *, RIDState> resource_states;

	for (uint32_t i = 0; i < set_uniform_count; i++) {
		const Shader::ShaderUniformInfo &set_uniform = set_uniforms[i];
		const Uniform &uniform = uniforms[uniform_indices[i]];

		// Stages defined in the shader may be missing for a unfiform due to the optimizer,
		// but the opposite (extraneous stages present in the uniform stages mask) would be an error.
		DEV_ASSERT(!(shader->is_compute && (set_uniform.binding.stages & (SHADER_STAGE_VERTEX_BIT | SHADER_STAGE_FRAGMENT_BIT))));
		DEV_ASSERT(!(!shader->is_compute && (set_uniform.binding.stages & SHADER_STAGE_COMPUTE_BIT)));

		switch (uniform.uniform_type) {
			case UNIFORM_TYPE_SAMPLER: {
				if (uniform.get_id_count() != (uint32_t)set_uniform.info.length) {
					if (set_uniform.info.length > 1) {
						ERR_FAIL_V_MSG(RID(), "Sampler (binding: " + itos(uniform.binding) + ") is an array of (" + itos(set_uniform.info.length) + ") sampler elements, so it should be provided equal number of sampler IDs to satisfy it (IDs provided: " + itos(uniform.get_id_count()) + ").");
					} else {
						ERR_FAIL_V_MSG(RID(), "Sampler (binding: " + itos(uniform.binding) + ") should provide one ID referencing a sampler (IDs provided: " + itos(uniform.get_id_count()) + ").");
					}
				}

				for (uint32_t j = 0; j < uniform.get_id_count(); j++) {
					D3D12_SAMPLER_DESC *sampler_desc = sampler_owner.get_or_null(uniform.get_id(j));
					ERR_FAIL_COND_V_MSG(!sampler_desc, RID(), "Sampler (binding: " + itos(uniform.binding) + ", index " + itos(j) + ") is not a valid sampler.");

					device->CreateSampler(sampler_desc, desc_heap_walkers.samplers.get_curr_cpu_handle());
					desc_heap_walkers.samplers.advance();
				}
			} break;
			case UNIFORM_TYPE_SAMPLER_WITH_TEXTURE: {
				if (uniform.get_id_count() != (uint32_t)set_uniform.info.length * 2) {
					if (set_uniform.info.length > 1) {
						ERR_FAIL_V_MSG(RID(), "SamplerTexture (binding: " + itos(uniform.binding) + ") is an array of (" + itos(set_uniform.info.length) + ") sampler&texture elements, so it should provided twice the amount of IDs (sampler,texture pairs) to satisfy it (IDs provided: " + itos(uniform.get_id_count()) + ").");
					} else {
						ERR_FAIL_V_MSG(RID(), "SamplerTexture (binding: " + itos(uniform.binding) + ") should provide two IDs referencing a sampler and then a texture (IDs provided: " + itos(uniform.get_id_count()) + ").");
					}
				}

				for (uint32_t j = 0; j < uniform.get_id_count(); j += 2) {
					D3D12_SAMPLER_DESC *sampler_desc = sampler_owner.get_or_null(uniform.get_id(j));
					ERR_FAIL_COND_V_MSG(!sampler_desc, RID(), "SamplerTexture (binding: " + itos(uniform.binding) + ", index " + itos(j) + ") is not a valid sampler.");

					RID rid = uniform.get_id(j + 1);
					Texture *texture = texture_owner.get_or_null(rid);
					ERR_FAIL_COND_V_MSG(!texture, RID(), "SamplerTexture (binding: " + itos(uniform.binding) + ", index " + itos(j) + ") is not a valid texture.");

					ERR_FAIL_COND_V_MSG(!(texture->usage_flags & TEXTURE_USAGE_SAMPLING_BIT), RID(),
							"Texture (binding: " + itos(uniform.binding) + ", index " + itos(j) + ") needs the TEXTURE_USAGE_SAMPLING_BIT usage flag set in order to be used as uniform.");

					device->CreateSampler(sampler_desc, desc_heap_walkers.samplers.get_curr_cpu_handle());
					desc_heap_walkers.samplers.advance();
					device->CreateShaderResourceView(texture->resource, &texture->srv_desc, desc_heap_walkers.resources.get_curr_cpu_handle());
#ifdef DEV_ENABLED
					resources_desc_info.push_back({ D3D12_DESCRIPTOR_RANGE_TYPE_SRV, texture->srv_desc.ViewDimension });
#endif
					desc_heap_walkers.resources.advance();

					RIDState &rs = resource_states[texture];
					rs.shader_uniform_idx_mask |= ((uint64_t)1 << i);
					D3D12_RESOURCE_STATES states = D3D12_RESOURCE_STATE_ALL_SHADER_RESOURCE;
					if ((texture->usage_flags & TEXTURE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT)) {
						states |= D3D12_RESOURCE_STATE_DEPTH_READ;
					}
					rs.state.extend(states);

					if (texture->usage_flags & (TEXTURE_USAGE_COLOR_ATTACHMENT_BIT | TEXTURE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT | TEXTURE_USAGE_INPUT_ATTACHMENT_BIT)) {
						UniformSet::AttachableTexture attachable_texture;
						attachable_texture.bind = set_uniform.info.binding;
						attachable_texture.texture = texture->owner.is_valid() ? texture->owner : uniform.get_id(j + 1);
						attachable_textures.push_back(attachable_texture);
					}

					if (texture->owner.is_valid()) {
						texture = texture_owner.get_or_null(texture->owner);
						ERR_FAIL_COND_V(!texture, RID()); // Bug, should never happen.
					}
				}
			} break;
			case UNIFORM_TYPE_TEXTURE: {
				if (uniform.get_id_count() != (uint32_t)set_uniform.info.length) {
					if (set_uniform.info.length > 1) {
						ERR_FAIL_V_MSG(RID(), "Texture (binding: " + itos(uniform.binding) + ") is an array of (" + itos(set_uniform.info.length) + ") textures, so it should be provided equal number of texture IDs to satisfy it (IDs provided: " + itos(uniform.get_id_count()) + ").");
					} else {
						ERR_FAIL_V_MSG(RID(), "Texture (binding: " + itos(uniform.binding) + ") should provide one ID referencing a texture (IDs provided: " + itos(uniform.get_id_count()) + ").");
					}
				}

				for (uint32_t j = 0; j < uniform.get_id_count(); j++) {
					RID rid = uniform.get_id(j);
					Texture *texture = texture_owner.get_or_null(rid);
					ERR_FAIL_COND_V_MSG(!texture, RID(), "Texture (binding: " + itos(uniform.binding) + ", index " + itos(j) + ") is not a valid texture.");

					ERR_FAIL_COND_V_MSG(!(texture->usage_flags & TEXTURE_USAGE_SAMPLING_BIT), RID(),
							"Texture (binding: " + itos(uniform.binding) + ", index " + itos(j) + ") needs the TEXTURE_USAGE_SAMPLING_BIT usage flag set in order to be used as uniform.");

					device->CreateShaderResourceView(texture->resource, &texture->srv_desc, desc_heap_walkers.resources.get_curr_cpu_handle());
#ifdef DEV_ENABLED
					resources_desc_info.push_back({ D3D12_DESCRIPTOR_RANGE_TYPE_SRV, texture->srv_desc.ViewDimension });
#endif
					desc_heap_walkers.resources.advance();

					RIDState &rs = resource_states[texture];
					rs.shader_uniform_idx_mask |= ((uint64_t)1 << i);
					D3D12_RESOURCE_STATES states = D3D12_RESOURCE_STATE_ALL_SHADER_RESOURCE;
					if ((texture->usage_flags & TEXTURE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT)) {
						states |= D3D12_RESOURCE_STATE_DEPTH_READ;
					}
					rs.state.extend(states);

					if ((texture->usage_flags & (TEXTURE_USAGE_COLOR_ATTACHMENT_BIT | TEXTURE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT | TEXTURE_USAGE_INPUT_ATTACHMENT_BIT))) {
						UniformSet::AttachableTexture attachable_texture;
						attachable_texture.bind = set_uniform.info.binding;
						attachable_texture.texture = texture->owner.is_valid() ? texture->owner : uniform.get_id(j);
						attachable_textures.push_back(attachable_texture);
					}

					if (texture->owner.is_valid()) {
						texture = texture_owner.get_or_null(texture->owner);
						ERR_FAIL_COND_V(!texture, RID()); // Bug, should never happen.
					}
				}
			} break;
			case UNIFORM_TYPE_IMAGE: {
				if (uniform.get_id_count() != (uint32_t)set_uniform.info.length) {
					if (set_uniform.info.length > 1) {
						ERR_FAIL_V_MSG(RID(), "Image (binding: " + itos(uniform.binding) + ") is an array of (" + itos(set_uniform.info.length) + ") textures, so it should be provided equal number of texture IDs to satisfy it (IDs provided: " + itos(uniform.get_id_count()) + ").");
					} else {
						ERR_FAIL_V_MSG(RID(), "Image (binding: " + itos(uniform.binding) + ") should provide one ID referencing a texture (IDs provided: " + itos(uniform.get_id_count()) + ").");
					}
				}

				// All R/O in the array go first; then R/W.
				for (uint32_t j = 0; j < uniform.get_id_count(); j++) {
					RID rid = uniform.get_id(j);
					Texture *texture = texture_owner.get_or_null(rid);

					ERR_FAIL_COND_V_MSG(!texture, RID(),
							"Image (binding: " + itos(uniform.binding) + ", index " + itos(j) + ") is not a valid texture.");

					ERR_FAIL_COND_V_MSG(!(texture->usage_flags & TEXTURE_USAGE_STORAGE_BIT), RID(),
							"Image (binding: " + itos(uniform.binding) + ", index " + itos(j) + ") needs the TEXTURE_USAGE_STORAGE_BIT usage flag set in order to be used as uniform.");

					RIDState &rs = resource_states[texture];
					rs.shader_uniform_idx_mask |= ((uint64_t)1 << i);
					if (!set_uniform.info.writable) {
						device->CreateShaderResourceView(texture->resource, &texture->srv_desc, desc_heap_walkers.resources.get_curr_cpu_handle());
#ifdef DEV_ENABLED
						resources_desc_info.push_back({ D3D12_DESCRIPTOR_RANGE_TYPE_SRV, texture->srv_desc.ViewDimension });
#endif

						D3D12_RESOURCE_STATES states = D3D12_RESOURCE_STATE_ALL_SHADER_RESOURCE;
						if ((texture->usage_flags & TEXTURE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT)) {
							states |= D3D12_RESOURCE_STATE_DEPTH_READ;
						}
						rs.state.extend(states);
					} else {
						device->CreateUnorderedAccessView(texture->resource, nullptr, &texture->uav_desc, desc_heap_walkers.resources.get_curr_cpu_handle());
#ifdef DEV_ENABLED
						resources_desc_info.push_back({ D3D12_DESCRIPTOR_RANGE_TYPE_UAV, {} });
#endif

						rs.state.extend(D3D12_RESOURCE_STATE_UNORDERED_ACCESS);
					}
					desc_heap_walkers.resources.advance();

					if (texture->owner.is_valid()) {
						texture = texture_owner.get_or_null(texture->owner);
						ERR_FAIL_COND_V(!texture, RID()); // Bug, should never happen.
					}
				}
			} break;
			case UNIFORM_TYPE_TEXTURE_BUFFER: {
				if (uniform.get_id_count() != (uint32_t)set_uniform.info.length) {
					if (set_uniform.info.length > 1) {
						ERR_FAIL_V_MSG(RID(), "Buffer (binding: " + itos(uniform.binding) + ") is an array of (" + itos(set_uniform.info.length) + ") texture buffer elements, so it should be provided equal number of texture buffer IDs to satisfy it (IDs provided: " + itos(uniform.get_id_count()) + ").");
					} else {
						ERR_FAIL_V_MSG(RID(), "Buffer (binding: " + itos(uniform.binding) + ") should provide one ID referencing a texture buffer (IDs provided: " + itos(uniform.get_id_count()) + ").");
					}
				}

				for (uint32_t j = 0; j < uniform.get_id_count(); j++) {
					TextureBuffer *buffer = texture_buffer_owner.get_or_null(uniform.get_id(j));
					ERR_FAIL_COND_V_MSG(!buffer, RID(), "Texture Buffer (binding: " + itos(uniform.binding) + ", index " + itos(j) + ") is not a valid texture buffer.");

					CRASH_NOW_MSG("Unimplemented!");
				}
			} break;
			case UNIFORM_TYPE_SAMPLER_WITH_TEXTURE_BUFFER: {
				CRASH_NOW();
				if (uniform.get_id_count() != (uint32_t)set_uniform.info.length * 2) {
					if (set_uniform.info.length > 1) {
						ERR_FAIL_V_MSG(RID(), "SamplerBuffer (binding: " + itos(uniform.binding) + ") is an array of (" + itos(set_uniform.info.length) + ") sampler buffer elements, so it should provided twice the amount of IDs (sampler,buffer pairs) to satisfy it (IDs provided: " + itos(uniform.get_id_count()) + ").");
					} else {
						ERR_FAIL_V_MSG(RID(), "SamplerBuffer (binding: " + itos(uniform.binding) + ") should provide two IDs referencing a sampler and then a texture buffer (IDs provided: " + itos(uniform.get_id_count()) + ").");
					}
				}

				for (uint32_t j = 0; j < uniform.get_id_count(); j += 2) {
					D3D12_SAMPLER_DESC *sampler_desc = sampler_owner.get_or_null(uniform.get_id(j));
					ERR_FAIL_COND_V_MSG(!sampler_desc, RID(), "SamplerBuffer (binding: " + itos(uniform.binding) + ", index " + itos(j + 1) + ") is not a valid sampler.");

					TextureBuffer *buffer = texture_buffer_owner.get_or_null(uniform.get_id(j + 1));
					ERR_FAIL_COND_V_MSG(!buffer, RID(), "SamplerBuffer (binding: " + itos(uniform.binding) + ", index " + itos(j + 1) + ") is not a valid texture buffer.");

					device->CreateSampler(sampler_desc, desc_heap_walkers.samplers.get_curr_cpu_handle());
					desc_heap_walkers.samplers.advance();

					CRASH_NOW_MSG("Unimplemented!");
				}
			} break;
			case UNIFORM_TYPE_IMAGE_BUFFER: {
				// Todo.

			} break;
			case UNIFORM_TYPE_UNIFORM_BUFFER: {
				ERR_FAIL_COND_V_MSG(uniform.get_id_count() != 1, RID(),
						"Uniform buffer supplied (binding: " + itos(uniform.binding) + ") must provide one ID (" + itos(uniform.get_id_count()) + " provided).");

				RID rid = uniform.get_id(0);
				Buffer *buffer = uniform_buffer_owner.get_or_null(rid);
				ERR_FAIL_COND_V_MSG(!buffer, RID(), "Uniform buffer supplied (binding: " + itos(uniform.binding) + ") is invalid.");

				ERR_FAIL_COND_V_MSG(buffer->size != (uint32_t)set_uniform.info.length, RID(),
						"Uniform buffer supplied (binding: " + itos(uniform.binding) + ") size (" + itos(buffer->size) + " does not match size of shader uniform: (" + itos(set_uniform.info.length) + ").");

				D3D12_CONSTANT_BUFFER_VIEW_DESC cbv_desc = {};
				cbv_desc.BufferLocation = buffer->resource->GetGPUVirtualAddress();
				cbv_desc.SizeInBytes = ALIGN(buffer->size, 256);
				device->CreateConstantBufferView(&cbv_desc, desc_heap_walkers.resources.get_curr_cpu_handle());
				desc_heap_walkers.resources.advance();
#ifdef DEV_ENABLED
				resources_desc_info.push_back({ D3D12_DESCRIPTOR_RANGE_TYPE_CBV, {} });
#endif

				RIDState &rs = resource_states[buffer];
				rs.is_buffer = true;
				rs.shader_uniform_idx_mask |= ((uint64_t)1 << i);
				rs.state.extend(D3D12_RESOURCE_STATE_VERTEX_AND_CONSTANT_BUFFER);
			} break;
			case UNIFORM_TYPE_STORAGE_BUFFER: {
				ERR_FAIL_COND_V_MSG(uniform.get_id_count() != 1, RID(),
						"Storage buffer supplied (binding: " + itos(uniform.binding) + ") must provide one ID (" + itos(uniform.get_id_count()) + " provided).");

				RID rid = uniform.get_id(0);
				Buffer *buffer = nullptr;

				if (storage_buffer_owner.owns(rid)) {
					buffer = storage_buffer_owner.get_or_null(rid);
				} else if (vertex_buffer_owner.owns(rid)) {
					buffer = vertex_buffer_owner.get_or_null(rid);

					ERR_FAIL_COND_V_MSG(!(buffer->usage & D3D12_RESOURCE_STATE_UNORDERED_ACCESS), RID(), "Vertex buffer supplied (binding: " + itos(uniform.binding) + ") was not created with storage flag.");
				}
				ERR_FAIL_COND_V_MSG(!buffer, RID(), "Storage buffer supplied (binding: " + itos(uniform.binding) + ") is invalid.");

				// If 0, then it's sized on link time.
				ERR_FAIL_COND_V_MSG(set_uniform.info.length > 0 && buffer->size != (uint32_t)set_uniform.info.length, RID(),
						"Storage buffer supplied (binding: " + itos(uniform.binding) + ") size (" + itos(buffer->size) + " does not match size of shader uniform: (" + itos(set_uniform.info.length) + ").");

				RIDState &rs = resource_states[buffer];
				rs.shader_uniform_idx_mask |= ((uint64_t)1 << i);
				rs.is_buffer = true;
				if (!set_uniform.info.writable) {
					D3D12_SHADER_RESOURCE_VIEW_DESC srv_desc = {};
					srv_desc.Format = DXGI_FORMAT_R32_TYPELESS;
					srv_desc.ViewDimension = D3D12_SRV_DIMENSION_BUFFER;
					srv_desc.Shader4ComponentMapping = D3D12_DEFAULT_SHADER_4_COMPONENT_MAPPING;
					srv_desc.Buffer.FirstElement = 0;
					srv_desc.Buffer.NumElements = (buffer->size + 3) / 4;
					srv_desc.Buffer.StructureByteStride = 0;
					srv_desc.Buffer.Flags = D3D12_BUFFER_SRV_FLAG_RAW;
					device->CreateShaderResourceView(buffer->resource, &srv_desc, desc_heap_walkers.resources.get_curr_cpu_handle());
#ifdef DEV_ENABLED
					resources_desc_info.push_back({ D3D12_DESCRIPTOR_RANGE_TYPE_SRV, srv_desc.ViewDimension });
#endif

					D3D12_RESOURCE_STATES states = D3D12_RESOURCE_STATE_PIXEL_SHADER_RESOURCE | D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE;
					rs.state.extend(states);
				} else {
					D3D12_UNORDERED_ACCESS_VIEW_DESC uav_desc = {};
					uav_desc.Format = DXGI_FORMAT_R32_TYPELESS;
					uav_desc.ViewDimension = D3D12_UAV_DIMENSION_BUFFER;
					uav_desc.Buffer.FirstElement = 0;
					uav_desc.Buffer.NumElements = (buffer->size + 3) / 4;
					uav_desc.Buffer.StructureByteStride = 0;
					uav_desc.Buffer.CounterOffsetInBytes = 0;
					uav_desc.Buffer.Flags = D3D12_BUFFER_UAV_FLAG_RAW;
					device->CreateUnorderedAccessView(buffer->resource, nullptr, &uav_desc, desc_heap_walkers.resources.get_curr_cpu_handle());
#ifdef DEV_ENABLED
					resources_desc_info.push_back({ D3D12_DESCRIPTOR_RANGE_TYPE_UAV, {} });
#endif

					rs.state.extend(D3D12_RESOURCE_STATE_UNORDERED_ACCESS);
				}

				desc_heap_walkers.resources.advance();
			} break;
			case UNIFORM_TYPE_INPUT_ATTACHMENT: {
				ERR_FAIL_COND_V_MSG(shader->is_compute, RID(), "InputAttachment (binding: " + itos(uniform.binding) + ") supplied for compute shader (this is not allowed).");

				if (uniform.get_id_count() != (uint32_t)set_uniform.info.length) {
					if (set_uniform.info.length > 1) {
						ERR_FAIL_V_MSG(RID(), "InputAttachment (binding: " + itos(uniform.binding) + ") is an array of (" + itos(set_uniform.info.length) + ") textures, so it should be provided equal number of texture IDs to satisfy it (IDs provided: " + itos(uniform.get_id_count()) + ").");
					} else {
						ERR_FAIL_V_MSG(RID(), "InputAttachment (binding: " + itos(uniform.binding) + ") should provide one ID referencing a texture (IDs provided: " + itos(uniform.get_id_count()) + ").");
					}
				}

				for (uint32_t j = 0; j < uniform.get_id_count(); j++) {
					RID rid = uniform.get_id(j);
					Texture *texture = texture_owner.get_or_null(rid);
					ERR_FAIL_COND_V_MSG(!texture, RID(),
							"InputAttachment (binding: " + itos(uniform.binding) + ", index " + itos(j) + ") is not a valid texture.");

					ERR_FAIL_COND_V_MSG(!(texture->usage_flags & TEXTURE_USAGE_SAMPLING_BIT), RID(),
							"InputAttachment (binding: " + itos(uniform.binding) + ", index " + itos(j) + ") needs the TEXTURE_USAGE_SAMPLING_BIT usage flag set in order to be used as uniform.");

					device->CreateShaderResourceView(texture->resource, &texture->srv_desc, desc_heap_walkers.resources.get_curr_cpu_handle());
#ifdef DEV_ENABLED
					resources_desc_info.push_back({ D3D12_DESCRIPTOR_RANGE_TYPE_SRV, texture->srv_desc.ViewDimension });
#endif
					desc_heap_walkers.resources.advance();

					RIDState &rs = resource_states[texture];
					rs.shader_uniform_idx_mask |= ((uint64_t)1 << i);
					rs.state.extend(D3D12_RESOURCE_STATE_PIXEL_SHADER_RESOURCE);

					if (texture->owner.is_valid()) {
						texture = texture_owner.get_or_null(texture->owner);
						ERR_FAIL_COND_V(!texture, RID()); // Bug, should never happen.
					}
				}
			} break;
			default: {
			}
		}
	}

	DEV_ASSERT(desc_heap_walkers.resources.is_at_eof());
	DEV_ASSERT(desc_heap_walkers.samplers.is_at_eof());

	UniformSet uniform_set;
	uniform_set.desc_heaps.resources = desc_heaps.resources;
	uniform_set.desc_heaps.samplers = desc_heaps.samplers;
	uniform_set.format = shader->set_formats[p_shader_set];
	uniform_set.attachable_textures = attachable_textures;
	uniform_set.shader_set = p_shader_set;
	uniform_set.shader_id = p_shader;
#ifdef DEV_ENABLED
	uniform_set._resources_desc_info = resources_desc_info;
	uniform_set._shader = shader;
#endif

	{
		uniform_set.resource_states.resize(resource_states.size());
		uint32_t i = 0;
		for (const KeyValue<Resource *, RIDState> &E : resource_states) {
			UniformSet::StateRequirement sr;
			sr.resource = E.key;
			sr.is_buffer = E.value.is_buffer;
			sr.states = E.value.state.get_state_mask();
			sr.shader_uniform_idx_mask = E.value.shader_uniform_idx_mask;
			uniform_set.resource_states.write[i] = sr;
			i++;
		}
	}

	RID id = uniform_set_owner.make_rid(uniform_set);
	// Add dependencies.
	_add_dependency(id, p_shader);
	for (uint32_t i = 0; i < uniform_count; i++) {
		const Uniform &uniform = uniforms[i];
		int id_count = uniform.get_id_count();
		for (int j = 0; j < id_count; j++) {
			_add_dependency(id, uniform.get_id(j));
		}
	}

	return id;
}

bool RenderingDeviceD3D12::uniform_set_is_valid(RID p_uniform_set) {
	return uniform_set_owner.owns(p_uniform_set);
}

void RenderingDeviceD3D12::uniform_set_set_invalidation_callback(RID p_uniform_set, InvalidationCallback p_callback, void *p_userdata) {
	UniformSet *us = uniform_set_owner.get_or_null(p_uniform_set);
	ERR_FAIL_COND(!us);
	us->invalidated_callback = p_callback;
	us->invalidated_callback_userdata = p_userdata;
}

Error RenderingDeviceD3D12::buffer_update(RID p_buffer, uint32_t p_offset, uint32_t p_size, const void *p_data, BitField<BarrierMask> p_post_barrier) {
	_THREAD_SAFE_METHOD_

	ERR_FAIL_COND_V_MSG(draw_list, ERR_INVALID_PARAMETER,
			"Updating buffers is forbidden during creation of a draw list");
	ERR_FAIL_COND_V_MSG(compute_list, ERR_INVALID_PARAMETER,
			"Updating buffers is forbidden during creation of a compute list");

	Buffer *buffer = _get_buffer_from_owner(p_buffer);
	if (!buffer) {
		ERR_FAIL_V_MSG(ERR_INVALID_PARAMETER, "Buffer argument is not a valid buffer of any type.");
	}

	ERR_FAIL_COND_V_MSG(p_offset + p_size > buffer->size, ERR_INVALID_PARAMETER,
			"Attempted to write buffer (" + itos((p_offset + p_size) - buffer->size) + " bytes) past the end.");

	ID3D12GraphicsCommandList *command_list = frames[frame].draw_command_list.Get();

	_resource_transition_batch(buffer, 0, 1, D3D12_RESOURCE_STATE_COPY_DEST);
	_resource_transitions_flush(command_list);

	Error err = _buffer_update(buffer, p_offset, (uint8_t *)p_data, p_size, p_post_barrier);
	if (err) {
		return err;
	}

	return OK;
}

Error RenderingDeviceD3D12::buffer_clear(RID p_buffer, uint32_t p_offset, uint32_t p_size, BitField<BarrierMask> p_post_barrier) {
	_THREAD_SAFE_METHOD_

	ERR_FAIL_COND_V_MSG((p_size % 4) != 0, ERR_INVALID_PARAMETER,
			"Size must be a multiple of four");
	ERR_FAIL_COND_V_MSG(draw_list, ERR_INVALID_PARAMETER,
			"Updating buffers in is forbidden during creation of a draw list");
	ERR_FAIL_COND_V_MSG(compute_list, ERR_INVALID_PARAMETER,
			"Updating buffers is forbidden during creation of a compute list");

	Buffer *buffer = _get_buffer_from_owner(p_buffer);
	if (!buffer) {
		ERR_FAIL_V_MSG(ERR_INVALID_PARAMETER, "Buffer argument is not a valid buffer of any type.");
	}

	ERR_FAIL_COND_V_MSG(p_offset + p_size > buffer->size, ERR_INVALID_PARAMETER,
			"Attempted to write buffer (" + itos((p_offset + p_size) - buffer->size) + " bytes) past the end.");

	if (frames[frame].desc_heap_walkers.resources.is_at_eof()) {
		if (!frames[frame].desc_heaps_exhausted_reported.resources) {
			frames[frame].desc_heaps_exhausted_reported.resources = true;
			ERR_FAIL_V_MSG(ERR_BUSY,
					"Cannot clear buffer because there's no enough room in current frame's RESOURCE desciptors heap.\n"
					"Please increase the value of the rendering/rendering_device/d3d12/max_resource_descriptors_per_frame project setting.");
		} else {
			return ERR_BUSY;
		}
	}
	if (frames[frame].desc_heap_walkers.aux.is_at_eof()) {
		if (!frames[frame].desc_heaps_exhausted_reported.aux) {
			frames[frame].desc_heaps_exhausted_reported.aux = true;
			ERR_FAIL_V_MSG(ERR_BUSY,
					"Cannot clear buffer because there's no enough room in current frame's AUX desciptors heap.\n"
					"Please increase the value of the rendering/rendering_device/d3d12/max_misc_descriptors_per_frame project setting.");
		} else {
			return ERR_BUSY;
		}
	}

	ID3D12GraphicsCommandList *command_list = frames[frame].draw_command_list.Get();

	_resource_transition_batch(buffer, 0, 1, D3D12_RESOURCE_STATE_UNORDERED_ACCESS);
	_resource_transitions_flush(command_list);

	D3D12_UNORDERED_ACCESS_VIEW_DESC uav_desc = {};
	uav_desc.Format = DXGI_FORMAT_R32_TYPELESS;
	uav_desc.ViewDimension = D3D12_UAV_DIMENSION_BUFFER;
	uav_desc.Buffer.FirstElement = 0;
	uav_desc.Buffer.NumElements = (buffer->size + 3) / 4;
	uav_desc.Buffer.StructureByteStride = 0;
	uav_desc.Buffer.CounterOffsetInBytes = 0;
	uav_desc.Buffer.Flags = D3D12_BUFFER_UAV_FLAG_RAW;
	device->CreateUnorderedAccessView(
			buffer->resource,
			nullptr,
			&uav_desc,
			frames[frame].desc_heap_walkers.aux.get_curr_cpu_handle());

	device->CopyDescriptorsSimple(
			1,
			frames[frame].desc_heap_walkers.resources.get_curr_cpu_handle(),
			frames[frame].desc_heap_walkers.aux.get_curr_cpu_handle(),
			D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV);

	static const UINT values[4] = {};
	command_list->ClearUnorderedAccessViewUint(
			frames[frame].desc_heap_walkers.resources.get_curr_gpu_handle(),
			frames[frame].desc_heap_walkers.aux.get_curr_cpu_handle(),
			buffer->resource,
			values,
			0,
			nullptr);

	frames[frame].desc_heap_walkers.resources.advance();
	frames[frame].desc_heap_walkers.aux.advance();

	return OK;
}

Vector<uint8_t> RenderingDeviceD3D12::buffer_get_data(RID p_buffer) {
	_THREAD_SAFE_METHOD_

	// Get the vulkan buffer and the potential stage/access possible.
	Buffer *buffer = _get_buffer_from_owner(p_buffer);
	if (!buffer) {
		ERR_FAIL_V_MSG(Vector<uint8_t>(), "Buffer is either invalid or this type of buffer can't be retrieved. Only Index and Vertex buffers allow retrieving.");
	}

	ID3D12GraphicsCommandList *command_list = frames[frame].setup_command_list.Get();

	_resource_transition_batch(buffer, 0, 1, D3D12_RESOURCE_STATE_COPY_SOURCE);
	_resource_transitions_flush(command_list);

	Buffer tmp_buffer;
	Error err = _buffer_allocate(&tmp_buffer, buffer->size, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_HEAP_TYPE_READBACK);
	ERR_FAIL_COND_V(err != OK, Vector<uint8_t>());

	command_list->CopyBufferRegion(tmp_buffer.resource, 0, buffer->resource, 0, buffer->size);

	// Flush everything so memory can be safely mapped.
	_flush(true);

	void *buffer_mem;
	HRESULT res = tmp_buffer.resource->Map(0, &VOID_RANGE, &buffer_mem);
	ERR_FAIL_COND_V_MSG(res, Vector<uint8_t>(), "Map failed with error " + vformat("0x%08x", res) + ".");

	Vector<uint8_t> buffer_data;
	{
		buffer_data.resize(buffer->size);
		uint8_t *w = buffer_data.ptrw();
		memcpy(w, buffer_mem, buffer->size);
	}

	tmp_buffer.resource->Unmap(0, &VOID_RANGE);

	_buffer_free(&tmp_buffer);

	return buffer_data;
}

/*******************/
/**** PIPELINES ****/
/*******************/

Error RenderingDeviceD3D12::_apply_specialization_constants(
		const Shader *p_shader,
		const Vector<PipelineSpecializationConstant> &p_specialization_constants,
		HashMap<ShaderStage, Vector<uint8_t>> &r_final_stages_bytecode) {
	// If something needs to be patched, COW will do the trick.
	r_final_stages_bytecode = p_shader->stages_bytecode;
	uint32_t stages_re_sign_mask = 0;
	for (const PipelineSpecializationConstant &psc : p_specialization_constants) {
		if (!(p_shader->spirv_specialization_constants_ids_mask & (1 << psc.constant_id))) {
			// This SC wasn't even in the original SPIR-V shader.
			continue;
		}
		for (const Shader::SpecializationConstant &sc : p_shader->specialization_constants) {
			if (psc.constant_id == sc.constant.constant_id) {
				ERR_FAIL_COND_V_MSG(psc.type != sc.constant.type, ERR_INVALID_PARAMETER, "Specialization constant provided for id (" + itos(sc.constant.constant_id) + ") is of the wrong type.");
				if (psc.int_value != sc.constant.int_value) {
					stages_re_sign_mask |= _shader_patch_dxil_specialization_constant(psc.type, &psc.int_value, sc.stages_bit_offsets, r_final_stages_bytecode, false);
				}
				break;
			}
		}
	}
	// Re-sign patched stages.
	for (KeyValue<ShaderStage, Vector<uint8_t>> &E : r_final_stages_bytecode) {
		ShaderStage stage = E.key;
		Vector<uint8_t> &bytecode = E.value;
		if ((stages_re_sign_mask & (1 << stage))) {
			bool sign_ok = _shader_sign_dxil_bytecode(stage, bytecode);
			ERR_FAIL_COND_V(!sign_ok, ERR_QUERY_FAILED);
		}
	}

	return OK;
}

#ifdef DEV_ENABLED
String RenderingDeviceD3D12::_build_pipeline_blob_filename(
		const Vector<uint8_t> &p_blob,
		const Shader *p_shader,
		const Vector<PipelineSpecializationConstant> &p_specialization_constants,
		const String &p_extra_name_suffix,
		const String &p_forced_id) {
	String id;
	if (p_forced_id == "") {
		HashingContext hc;
		hc.start(HashingContext::HASH_MD5);
		hc.update(p_blob);
		Vector<uint8_t> hash_bin = hc.finish();
		String hash_str = String::hex_encode_buffer(hash_bin.ptr(), hash_bin.size());
	} else {
		id = p_forced_id;
	}

	Vector<String> sc_str_pieces;
	for (const Shader::SpecializationConstant &sc : p_shader->specialization_constants) {
		uint32_t int_value = sc.constant.int_value;
		for (const PipelineSpecializationConstant &psc : p_specialization_constants) {
			if (psc.constant_id == sc.constant.constant_id) {
				int_value = psc.int_value;
				break;
			}
		}
		sc_str_pieces.push_back(itos(sc.constant.constant_id) + "=" + itos(int_value));
	}

	String res = p_shader->name.replace(":", "-");
	res += "." + id;
	res += "." + String("_").join(sc_str_pieces);
	if (p_extra_name_suffix != "") {
		res += "." + p_extra_name_suffix;
	}
	return res;
}

void RenderingDeviceD3D12::_save_pso_blob(
		ID3D12PipelineState *p_pso,
		const Shader *p_shader,
		const Vector<PipelineSpecializationConstant> &p_specialization_constants) {
	ComPtr<ID3DBlob> pso_blob;
	p_pso->GetCachedBlob(pso_blob.GetAddressOf());
	Vector<uint8_t> pso_vector;
	pso_vector.resize(pso_blob->GetBufferSize());
	memcpy(pso_vector.ptrw(), pso_blob->GetBufferPointer(), pso_blob->GetBufferSize());

	String base_filename = _build_pipeline_blob_filename(pso_vector, p_shader, p_specialization_constants);

	Ref<FileAccess> fa = FileAccess::open("pso." + base_filename + ".bin", FileAccess::WRITE);
	fa->store_buffer((const uint8_t *)pso_blob->GetBufferPointer(), pso_blob->GetBufferSize());
}

void RenderingDeviceD3D12::_save_stages_bytecode(
		const HashMap<ShaderStage, Vector<uint8_t>> &p_stages_bytecode,
		const Shader *p_shader,
		const RID p_shader_rid,
		const Vector<PipelineSpecializationConstant> &p_specialization_constants) {
	for (const KeyValue<ShaderStage, Vector<uint8_t>> &E : p_stages_bytecode) {
		ShaderStage stage = E.key;
		const Vector<uint8_t> &bytecode = E.value;

		String base_filename = _build_pipeline_blob_filename(bytecode, p_shader, p_specialization_constants, shader_stage_names[stage], itos(p_shader_rid.get_id()));

		Ref<FileAccess> fa = FileAccess::open("dxil." + base_filename + ".bin", FileAccess::WRITE);
		fa->store_buffer(bytecode.ptr(), bytecode.size());
	}
}
#endif

/*************************/
/**** RENDER PIPELINE ****/
/*************************/

RID RenderingDeviceD3D12::render_pipeline_create(RID p_shader, FramebufferFormatID p_framebuffer_format, VertexFormatID p_vertex_format, RenderPrimitive p_render_primitive, const PipelineRasterizationState &p_rasterization_state, const PipelineMultisampleState &p_multisample_state, const PipelineDepthStencilState &p_depth_stencil_state, const PipelineColorBlendState &p_blend_state, BitField<PipelineDynamicStateFlags> p_dynamic_state_flags, uint32_t p_for_render_pass, const Vector<PipelineSpecializationConstant> &p_specialization_constants) {
#ifdef DEV_ENABLED
//#define DEBUG_CREATE_DEBUG_PSO
//#define DEBUG_SAVE_PSO_BLOBS
//#define DEBUG_SAVE_DXIL_BLOBS
#endif
	_THREAD_SAFE_METHOD_

	// Needs a shader.
	Shader *shader = shader_owner.get_or_null(p_shader);
	ERR_FAIL_COND_V(!shader, RID());

	ERR_FAIL_COND_V_MSG(shader->is_compute, RID(),
			"Compute shaders can't be used in render pipelines");

	if (p_framebuffer_format == INVALID_ID) {
		// If nothing provided, use an empty one (no attachments).
		p_framebuffer_format = framebuffer_format_create(Vector<AttachmentFormat>());
	}
	ERR_FAIL_COND_V(!framebuffer_formats.has(p_framebuffer_format), RID());
	const FramebufferFormat &fb_format = framebuffer_formats[p_framebuffer_format];
	const FramebufferPass &pass = fb_format.passes[p_for_render_pass];

	{ // Validate shader vs framebuffer.

		ERR_FAIL_COND_V_MSG(p_for_render_pass >= uint32_t(fb_format.passes.size()), RID(), "Render pass requested for pipeline creation (" + itos(p_for_render_pass) + ") is out of bounds");
		uint32_t output_mask = 0;
		for (int i = 0; i < pass.color_attachments.size(); i++) {
			if (pass.color_attachments[i] != FramebufferPass::ATTACHMENT_UNUSED) {
				output_mask |= 1 << i;
			}
		}
		ERR_FAIL_COND_V_MSG(shader->fragment_output_mask != output_mask, RID(),
				"Mismatch fragment shader output mask (" + itos(shader->fragment_output_mask) + ") and framebuffer color output mask (" + itos(output_mask) + ") when binding both in render pipeline.");
	}

	CD3DX12_PIPELINE_STATE_STREAM pipeline_desc;
	RenderPipeline::DynamicParams dyn_params;

	// Attachment formats.
	{
		for (int i = 0; i < pass.color_attachments.size(); i++) {
			int32_t attachment = pass.color_attachments[i];
			if (attachment == FramebufferPass::ATTACHMENT_UNUSED) {
				(&pipeline_desc.RTVFormats)->RTFormats[i] = DXGI_FORMAT_UNKNOWN;
			} else {
				(&pipeline_desc.RTVFormats)->RTFormats[i] = d3d12_formats[fb_format.attachments[attachment].format].general_format;
			}
		}
		(&pipeline_desc.RTVFormats)->NumRenderTargets = pass.color_attachments.size();

		if (pass.depth_attachment == FramebufferPass::ATTACHMENT_UNUSED) {
			pipeline_desc.DSVFormat = DXGI_FORMAT_UNKNOWN;
		} else {
			pipeline_desc.DSVFormat = d3d12_formats[fb_format.attachments[pass.depth_attachment].format].dsv_format;
		}
	}

	// Vertex.
	if (p_vertex_format != INVALID_ID) {
		// Uses vertices, else it does not.
		ERR_FAIL_COND_V(!vertex_formats.has(p_vertex_format), RID());
		const VertexDescriptionCache &vd = vertex_formats[p_vertex_format];

		(&pipeline_desc.InputLayout)->pInputElementDescs = vd.elements_desc.ptr();
		(&pipeline_desc.InputLayout)->NumElements = vd.elements_desc.size();

		// Validate with inputs.
		for (uint32_t i = 0; i < 32; i++) {
			if (!(shader->vertex_input_mask & (1UL << i))) {
				continue;
			}
			bool found = false;
			for (int j = 0; j < vd.vertex_formats.size(); j++) {
				if (vd.vertex_formats[j].location == i) {
					found = true;
				}
			}

			ERR_FAIL_COND_V_MSG(!found, RID(),
					"Shader vertex input location (" + itos(i) + ") not provided in vertex input description for pipeline creation.");
		}

	} else {
		// Does not use vertices.

		ERR_FAIL_COND_V_MSG(shader->vertex_input_mask != 0, RID(),
				"Shader contains vertex inputs, but no vertex input description was provided for pipeline creation.");
	}

	// Input assembly & tessellation.

	ERR_FAIL_INDEX_V(p_render_primitive, RENDER_PRIMITIVE_MAX, RID());

	static const D3D12_PRIMITIVE_TOPOLOGY_TYPE topology_types[RENDER_PRIMITIVE_MAX] = {
		D3D12_PRIMITIVE_TOPOLOGY_TYPE_POINT,
		D3D12_PRIMITIVE_TOPOLOGY_TYPE_LINE,
		D3D12_PRIMITIVE_TOPOLOGY_TYPE_LINE,
		D3D12_PRIMITIVE_TOPOLOGY_TYPE_LINE,
		D3D12_PRIMITIVE_TOPOLOGY_TYPE_LINE,
		D3D12_PRIMITIVE_TOPOLOGY_TYPE_TRIANGLE,
		D3D12_PRIMITIVE_TOPOLOGY_TYPE_TRIANGLE,
		D3D12_PRIMITIVE_TOPOLOGY_TYPE_TRIANGLE,
		D3D12_PRIMITIVE_TOPOLOGY_TYPE_TRIANGLE,
		D3D12_PRIMITIVE_TOPOLOGY_TYPE_TRIANGLE,
		D3D12_PRIMITIVE_TOPOLOGY_TYPE_PATCH,
	};

	static const D3D12_PRIMITIVE_TOPOLOGY topologies[RENDER_PRIMITIVE_MAX] = {
		D3D_PRIMITIVE_TOPOLOGY_POINTLIST,
		D3D_PRIMITIVE_TOPOLOGY_LINELIST,
		D3D_PRIMITIVE_TOPOLOGY_LINELIST_ADJ,
		D3D_PRIMITIVE_TOPOLOGY_LINESTRIP,
		D3D_PRIMITIVE_TOPOLOGY_LINESTRIP_ADJ,
		D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST,
		D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST_ADJ,
		D3D_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP,
		D3D_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP_ADJ,
		D3D_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP,
		D3D_PRIMITIVE_TOPOLOGY_1_CONTROL_POINT_PATCHLIST,
	};

	pipeline_desc.PrimitiveTopologyType = topology_types[p_render_primitive];
	if (p_render_primitive == RENDER_PRIMITIVE_TESSELATION_PATCH) {
		ERR_FAIL_COND_V(p_rasterization_state.patch_control_points < 1 || p_rasterization_state.patch_control_points > 32, RID()); // Is there any way to get the true point count limit?
		dyn_params.primitive_topology = (D3D12_PRIMITIVE_TOPOLOGY)((int)D3D_PRIMITIVE_TOPOLOGY_1_CONTROL_POINT_PATCHLIST + p_rasterization_state.patch_control_points);
	} else {
		dyn_params.primitive_topology = topologies[p_render_primitive];
	}
	if (p_render_primitive == RENDER_PRIMITIVE_TRIANGLE_STRIPS_WITH_RESTART_INDEX) {
		// TODO: This is right for 16-bit indices; for 32-bit there's a different enum value to set, but we don't know at this point.
		pipeline_desc.IBStripCutValue = D3D12_INDEX_BUFFER_STRIP_CUT_VALUE_0xFFFF;
	} else {
		pipeline_desc.IBStripCutValue = D3D12_INDEX_BUFFER_STRIP_CUT_VALUE_DISABLED;
	}

	// Rasterization.
	(&pipeline_desc.RasterizerState)->DepthClipEnable = !p_rasterization_state.enable_depth_clamp;
	// In D3D12, discard can be supported with some extra effort (empty pixel shader + disable depth/stencil test); that said, unsupported by now.
	ERR_FAIL_COND_V(p_rasterization_state.discard_primitives, RID());
	(&pipeline_desc.RasterizerState)->FillMode = p_rasterization_state.wireframe ? D3D12_FILL_MODE_WIREFRAME : D3D12_FILL_MODE_SOLID;
	static const D3D12_CULL_MODE cull_mode[3] = {
		D3D12_CULL_MODE_NONE,
		D3D12_CULL_MODE_FRONT,
		D3D12_CULL_MODE_BACK,
	};

	ERR_FAIL_INDEX_V(p_rasterization_state.cull_mode, 3, RID());
	(&pipeline_desc.RasterizerState)->CullMode = cull_mode[p_rasterization_state.cull_mode];
	(&pipeline_desc.RasterizerState)->FrontCounterClockwise = p_rasterization_state.front_face == POLYGON_FRONT_FACE_COUNTER_CLOCKWISE;
	// In D3D12, there's still a point in setting up depth bias with no depth buffer, but just zeroing (disabling) it all in such case is closer to Vulkan.
	if (p_rasterization_state.depth_bias_enabled && fb_format.passes[p_for_render_pass].depth_attachment != FramebufferPass::ATTACHMENT_UNUSED) {
		(&pipeline_desc.RasterizerState)->DepthBias = p_rasterization_state.depth_bias_constant_factor;
		(&pipeline_desc.RasterizerState)->DepthBiasClamp = p_rasterization_state.depth_bias_clamp;
		(&pipeline_desc.RasterizerState)->SlopeScaledDepthBias = p_rasterization_state.depth_bias_slope_factor;
	} else {
		(&pipeline_desc.RasterizerState)->DepthBias = 0;
		(&pipeline_desc.RasterizerState)->DepthBiasClamp = 0.0f;
		(&pipeline_desc.RasterizerState)->SlopeScaledDepthBias = 0.0f;
	}

	(&pipeline_desc.RasterizerState)->ForcedSampleCount = 0;
	(&pipeline_desc.RasterizerState)->ConservativeRaster = D3D12_CONSERVATIVE_RASTERIZATION_MODE_OFF;
	(&pipeline_desc.RasterizerState)->MultisampleEnable = rasterization_sample_count[p_multisample_state.sample_count] != 1;
	(&pipeline_desc.RasterizerState)->AntialiasedLineEnable = true;

	// In D3D12, there's no line width.
	ERR_FAIL_COND_V(!Math::is_equal_approx(p_rasterization_state.line_width, 1.0f), RID());

	// Multisample.
	ERR_FAIL_COND_V(p_multisample_state.enable_sample_shading, RID()); // How one enables this in D3D12?
	if ((&pipeline_desc.RTVFormats)->NumRenderTargets || pipeline_desc.DSVFormat != DXGI_FORMAT_UNKNOWN) {
		uint32_t sample_count = MIN(
				fb_format.max_supported_sample_count,
				rasterization_sample_count[p_multisample_state.sample_count]);
		(&pipeline_desc.SampleDesc)->Count = sample_count;
	} else {
		(&pipeline_desc.SampleDesc)->Count = 1;
	}
	if ((&pipeline_desc.SampleDesc)->Count > 1) {
		(&pipeline_desc.SampleDesc)->Quality = DXGI_STANDARD_MULTISAMPLE_QUALITY_PATTERN;
	} else {
		(&pipeline_desc.SampleDesc)->Quality = 0;
	}
	if (p_multisample_state.sample_mask.size()) {
		// Use sample mask.
		ERR_FAIL_COND_V(rasterization_sample_count[p_multisample_state.sample_count] != (uint32_t)p_multisample_state.sample_mask.size(), RID());
		for (int i = 1; i < p_multisample_state.sample_mask.size(); i++) {
			// In D3D12 there's a single sample mask for every pixel.
			ERR_FAIL_COND_V(p_multisample_state.sample_mask[i] != p_multisample_state.sample_mask[0], RID());
		}
		pipeline_desc.SampleMask = p_multisample_state.sample_mask[0];
	} else {
		pipeline_desc.SampleMask = 0xffffffff;
	}

	// Depth stencil.

	if (pass.depth_attachment == FramebufferPass::ATTACHMENT_UNUSED) {
		(&pipeline_desc.DepthStencilState)->DepthEnable = false;
		(&pipeline_desc.DepthStencilState)->StencilEnable = false;
	} else {
		(&pipeline_desc.DepthStencilState)->DepthEnable = p_depth_stencil_state.enable_depth_test;
		(&pipeline_desc.DepthStencilState)->DepthWriteMask = p_depth_stencil_state.enable_depth_write ? D3D12_DEPTH_WRITE_MASK_ALL : D3D12_DEPTH_WRITE_MASK_ZERO;
		ERR_FAIL_INDEX_V(p_depth_stencil_state.depth_compare_operator, COMPARE_OP_MAX, RID());
		(&pipeline_desc.DepthStencilState)->DepthFunc = compare_operators[p_depth_stencil_state.depth_compare_operator];
		(&pipeline_desc.DepthStencilState)->DepthBoundsTestEnable = p_depth_stencil_state.enable_depth_range;
		(&pipeline_desc.DepthStencilState)->StencilEnable = p_depth_stencil_state.enable_stencil;

		// In D3D12 some elements can't be different across front and back.
		ERR_FAIL_COND_V(p_depth_stencil_state.front_op.compare_mask != p_depth_stencil_state.back_op.compare_mask, RID());
		ERR_FAIL_COND_V(p_depth_stencil_state.front_op.write_mask != p_depth_stencil_state.back_op.write_mask, RID());
		ERR_FAIL_COND_V(p_depth_stencil_state.front_op.reference != p_depth_stencil_state.back_op.reference, RID());
		(&pipeline_desc.DepthStencilState)->StencilReadMask = p_depth_stencil_state.front_op.compare_mask;
		(&pipeline_desc.DepthStencilState)->StencilWriteMask = p_depth_stencil_state.front_op.write_mask;

		ERR_FAIL_INDEX_V(p_depth_stencil_state.front_op.fail, STENCIL_OP_MAX, RID());
		(&pipeline_desc.DepthStencilState)->FrontFace.StencilFailOp = stencil_operations[p_depth_stencil_state.front_op.fail];
		ERR_FAIL_INDEX_V(p_depth_stencil_state.front_op.pass, STENCIL_OP_MAX, RID());
		(&pipeline_desc.DepthStencilState)->FrontFace.StencilPassOp = stencil_operations[p_depth_stencil_state.front_op.pass];
		ERR_FAIL_INDEX_V(p_depth_stencil_state.front_op.depth_fail, STENCIL_OP_MAX, RID());
		(&pipeline_desc.DepthStencilState)->FrontFace.StencilDepthFailOp = stencil_operations[p_depth_stencil_state.front_op.depth_fail];
		ERR_FAIL_INDEX_V(p_depth_stencil_state.front_op.compare, COMPARE_OP_MAX, RID());
		(&pipeline_desc.DepthStencilState)->FrontFace.StencilFunc = compare_operators[p_depth_stencil_state.front_op.compare];

		ERR_FAIL_INDEX_V(p_depth_stencil_state.back_op.fail, STENCIL_OP_MAX, RID());
		(&pipeline_desc.DepthStencilState)->BackFace.StencilFailOp = stencil_operations[p_depth_stencil_state.back_op.fail];
		ERR_FAIL_INDEX_V(p_depth_stencil_state.back_op.pass, STENCIL_OP_MAX, RID());
		(&pipeline_desc.DepthStencilState)->BackFace.StencilPassOp = stencil_operations[p_depth_stencil_state.back_op.pass];
		ERR_FAIL_INDEX_V(p_depth_stencil_state.back_op.depth_fail, STENCIL_OP_MAX, RID());
		(&pipeline_desc.DepthStencilState)->BackFace.StencilDepthFailOp = stencil_operations[p_depth_stencil_state.back_op.depth_fail];
		ERR_FAIL_INDEX_V(p_depth_stencil_state.back_op.compare, COMPARE_OP_MAX, RID());
		(&pipeline_desc.DepthStencilState)->BackFace.StencilFunc = compare_operators[p_depth_stencil_state.back_op.compare];

		dyn_params.depth_bounds_min = p_depth_stencil_state.enable_depth_range ? p_depth_stencil_state.depth_range_min : 0.0f;
		dyn_params.depth_bounds_max = p_depth_stencil_state.enable_depth_range ? p_depth_stencil_state.depth_range_max : 1.0f;
		dyn_params.stencil_reference = p_depth_stencil_state.front_op.reference;
	}

	// Blend state.
	(&pipeline_desc.BlendState)->AlphaToCoverageEnable = p_multisample_state.enable_alpha_to_coverage;
	{
		ERR_FAIL_COND_V(p_blend_state.attachments.size() < pass.color_attachments.size(), RID());

		bool all_attachments_same_blend = true;
		for (int i = 0; i < pass.color_attachments.size(); i++) {
			const PipelineColorBlendState::Attachment &bs = p_blend_state.attachments[i];
			D3D12_RENDER_TARGET_BLEND_DESC &bd = (&pipeline_desc.BlendState)->RenderTarget[i];

			bd.BlendEnable = bs.enable_blend;
			bd.LogicOpEnable = p_blend_state.enable_logic_op;
			bd.LogicOp = logic_operations[p_blend_state.logic_op];

			ERR_FAIL_INDEX_V(bs.src_color_blend_factor, BLEND_FACTOR_MAX, RID());
			bd.SrcBlend = blend_factors[bs.src_color_blend_factor];
			ERR_FAIL_INDEX_V(bs.dst_color_blend_factor, BLEND_FACTOR_MAX, RID());
			bd.DestBlend = blend_factors[bs.dst_color_blend_factor];
			ERR_FAIL_INDEX_V(bs.color_blend_op, BLEND_OP_MAX, RID());
			bd.BlendOp = blend_operations[bs.color_blend_op];

			ERR_FAIL_INDEX_V(bs.src_alpha_blend_factor, BLEND_FACTOR_MAX, RID());
			bd.SrcBlendAlpha = blend_factors[bs.src_alpha_blend_factor];
			ERR_FAIL_INDEX_V(bs.dst_alpha_blend_factor, BLEND_FACTOR_MAX, RID());
			bd.DestBlendAlpha = blend_factors[bs.dst_alpha_blend_factor];
			ERR_FAIL_INDEX_V(bs.alpha_blend_op, BLEND_OP_MAX, RID());
			bd.BlendOpAlpha = blend_operations[bs.alpha_blend_op];

			if (bs.write_r) {
				bd.RenderTargetWriteMask |= D3D12_COLOR_WRITE_ENABLE_RED;
			}
			if (bs.write_g) {
				bd.RenderTargetWriteMask |= D3D12_COLOR_WRITE_ENABLE_GREEN;
			}
			if (bs.write_b) {
				bd.RenderTargetWriteMask |= D3D12_COLOR_WRITE_ENABLE_BLUE;
			}
			if (bs.write_a) {
				bd.RenderTargetWriteMask |= D3D12_COLOR_WRITE_ENABLE_ALPHA;
			}

			if (i > 0 && all_attachments_same_blend) {
				all_attachments_same_blend = &(&pipeline_desc.BlendState)->RenderTarget[i] == &(&pipeline_desc.BlendState)->RenderTarget[0];
			}
		}

		// Per D3D12 docs, if logic op used, independent blending is not supported.
		ERR_FAIL_COND_V(p_blend_state.enable_logic_op && !all_attachments_same_blend, RID());

		(&pipeline_desc.BlendState)->IndependentBlendEnable = !all_attachments_same_blend;
	}

	dyn_params.blend_constant = p_blend_state.blend_constant;

	// Stages bytecodes + specialization constants.

	pipeline_desc.pRootSignature = shader->root_signature.Get();

#ifdef DEBUG_CREATE_DEBUG_PSO
	pipeline_desc.Flags = D3D12_PIPELINE_STATE_FLAG_TOOL_DEBUG;
#endif

	HashMap<ShaderStage, Vector<uint8_t>> final_stages_bytecode;
	Error err = _apply_specialization_constants(shader, p_specialization_constants, final_stages_bytecode);
	ERR_FAIL_COND_V(err, RID());

	if (shader->stages_bytecode.has(SHADER_STAGE_VERTEX)) {
		pipeline_desc.VS = D3D12_SHADER_BYTECODE{
			final_stages_bytecode[SHADER_STAGE_VERTEX].ptr(),
			(SIZE_T)final_stages_bytecode[SHADER_STAGE_VERTEX].size()
		};
	}
	if (shader->stages_bytecode.has(SHADER_STAGE_FRAGMENT)) {
		pipeline_desc.PS = D3D12_SHADER_BYTECODE{
			final_stages_bytecode[SHADER_STAGE_FRAGMENT].ptr(),
			(SIZE_T)final_stages_bytecode[SHADER_STAGE_FRAGMENT].size()
		};
	}

	RenderPipeline pipeline;
	{
		ComPtr<ID3D12Device2> device2;
		device.As(&device2);
		HRESULT res = {};
		if (device2) {
			D3D12_PIPELINE_STATE_STREAM_DESC pssd = {};
			pssd.pPipelineStateSubobjectStream = &pipeline_desc;
			pssd.SizeInBytes = sizeof(pipeline_desc);
			res = device2->CreatePipelineState(&pssd, IID_PPV_ARGS(pipeline.pso.GetAddressOf()));
		} else {
			// Some features won't be available (like depth bounds).
			// TOOD: Check and/or report error then?
			D3D12_GRAPHICS_PIPELINE_STATE_DESC desc = pipeline_desc.GraphicsDescV0();
			res = device->CreateGraphicsPipelineState(&desc, IID_PPV_ARGS(pipeline.pso.GetAddressOf()));
		}
		ERR_FAIL_COND_V_MSG(res, RID(), "CreateGraphicsPipelineState failed with error " + vformat("0x%08x", res) + " for shader '" + shader->name + "'.");

#ifdef DEBUG_SAVE_PSO_BLOBS
		_save_pso_blob(pipeline.pso.Get(), shader, p_specialization_constants);
#endif
#ifdef DEBUG_SAVE_DXIL_BLOBS
		_save_stages_bytecode(final_stages_bytecode, shader, p_shader, p_specialization_constants);
#endif
	}

	{
		Vector<Vector<UniformBindingInfo>> bindings;
		bindings.resize(shader->sets.size());
		for (int i = 0; i < shader->sets.size(); i++) {
			bindings.write[i].resize(shader->sets[i].uniforms.size());
			for (int j = 0; j < shader->sets[i].uniforms.size(); j++) {
				bindings.write[i].write[j] = shader->sets[i].uniforms[j].binding;
			}
		}
		pipeline_bindings[next_pipeline_binding_id] = bindings;
		pipeline.bindings_id = next_pipeline_binding_id;
		next_pipeline_binding_id++;
	}

	pipeline.root_signature_crc = shader->root_signature_crc;
	pipeline.set_formats = shader->set_formats;
	pipeline.shader = p_shader;
	pipeline.spirv_push_constant_size = shader->spirv_push_constant_size;
	pipeline.dxil_push_constant_size = shader->dxil_push_constant_size;
	pipeline.dyn_params = dyn_params;

#ifdef DEBUG_ENABLED
	pipeline.validation.dynamic_state = p_dynamic_state_flags;
	pipeline.validation.framebuffer_format = p_framebuffer_format;
	pipeline.validation.render_pass = p_for_render_pass;
	pipeline.validation.vertex_format = p_vertex_format;
	pipeline.validation.uses_restart_indices = pipeline_desc.IBStripCutValue != D3D12_INDEX_BUFFER_STRIP_CUT_VALUE_DISABLED;

	static const uint32_t primitive_divisor[RENDER_PRIMITIVE_MAX] = {
		1, 2, 1, 1, 1, 3, 1, 1, 1, 1, 1
	};
	pipeline.validation.primitive_divisor = primitive_divisor[p_render_primitive];
	static const uint32_t primitive_minimum[RENDER_PRIMITIVE_MAX] = {
		1,
		2,
		2,
		2,
		2,
		3,
		3,
		3,
		3,
		3,
		1,
	};
	pipeline.validation.primitive_minimum = primitive_minimum[p_render_primitive];
#endif
	// Create ID to associate with this pipeline.
	RID id = render_pipeline_owner.make_rid(pipeline);
#ifdef DEV_ENABLED
	set_resource_name(id, "RID:" + itos(id.get_id()));
#endif
	// Now add all the dependencies.
	_add_dependency(id, p_shader);
	return id;
}

bool RenderingDeviceD3D12::render_pipeline_is_valid(RID p_pipeline) {
	_THREAD_SAFE_METHOD_
	return render_pipeline_owner.owns(p_pipeline);
}

/**************************/
/**** COMPUTE PIPELINE ****/
/**************************/

RID RenderingDeviceD3D12::compute_pipeline_create(RID p_shader, const Vector<PipelineSpecializationConstant> &p_specialization_constants) {
#ifdef DEV_ENABLED
//#define DEBUG_CREATE_DEBUG_PSO
//#define DEBUG_SAVE_PSO_BLOBS
//#define DEBUG_SAVE_DXIL_BLOBS
#endif
	_THREAD_SAFE_METHOD_

	// Needs a shader.
	Shader *shader = shader_owner.get_or_null(p_shader);
	ERR_FAIL_COND_V(!shader, RID());

	ERR_FAIL_COND_V_MSG(!shader->is_compute, RID(),
			"Non-compute shaders can't be used in compute pipelines");

	CD3DX12_PIPELINE_STATE_STREAM pipeline_desc = {};

	// Stages bytecodes + specialization constants.

	pipeline_desc.pRootSignature = shader->root_signature.Get();

#ifdef DEBUG_CREATE_DEBUG_PSO
	pipeline_desc.Flags = D3D12_PIPELINE_STATE_FLAG_TOOL_DEBUG;
#endif

	HashMap<ShaderStage, Vector<uint8_t>> final_stages_bytecode;
	Error err = _apply_specialization_constants(shader, p_specialization_constants, final_stages_bytecode);
	ERR_FAIL_COND_V(err, RID());

	pipeline_desc.CS = D3D12_SHADER_BYTECODE{
		final_stages_bytecode[SHADER_STAGE_COMPUTE].ptr(),
		(SIZE_T)final_stages_bytecode[SHADER_STAGE_COMPUTE].size()
	};

	ComputePipeline pipeline;
	{
		ComPtr<ID3D12Device2> device2;
		device.As(&device2);
		HRESULT res = {};
		if (device2) {
			D3D12_PIPELINE_STATE_STREAM_DESC pssd = {};
			pssd.pPipelineStateSubobjectStream = &pipeline_desc;
			pssd.SizeInBytes = sizeof(pipeline_desc);
			res = device2->CreatePipelineState(&pssd, IID_PPV_ARGS(pipeline.pso.GetAddressOf()));
		} else {
			D3D12_COMPUTE_PIPELINE_STATE_DESC desc = pipeline_desc.ComputeDescV0();
			res = device->CreateComputePipelineState(&desc, IID_PPV_ARGS(pipeline.pso.GetAddressOf()));
		}
		ERR_FAIL_COND_V_MSG(res, RID(), "CreateComputePipelineState failed with error " + vformat("0x%08x", res) + " for shader '" + shader->name + "'.");

#ifdef DEBUG_SAVE_PSO_BLOBS
		_save_pso_blob(pipeline.pso.Get(), shader, p_specialization_constants);
#endif
#ifdef DEBUG_SAVE_DXIL_BLOBS
		_save_stages_bytecode(final_stages_bytecode, shader, p_shader, p_specialization_constants);
#endif
	}

	{
		Vector<Vector<UniformBindingInfo>> bindings;
		bindings.resize(shader->sets.size());
		for (int i = 0; i < shader->sets.size(); i++) {
			bindings.write[i].resize(shader->sets[i].uniforms.size());
			for (int j = 0; j < shader->sets[i].uniforms.size(); j++) {
				bindings.write[i].write[j] = shader->sets[i].uniforms[j].binding;
			}
		}
		pipeline_bindings[next_pipeline_binding_id] = bindings;
		pipeline.bindings_id = next_pipeline_binding_id;
		next_pipeline_binding_id++;
	}

	pipeline.root_signature_crc = shader->root_signature_crc;
	pipeline.set_formats = shader->set_formats;
	pipeline.shader = p_shader;
	pipeline.spirv_push_constant_size = shader->spirv_push_constant_size;
	pipeline.dxil_push_constant_size = shader->dxil_push_constant_size;
	pipeline.local_group_size[0] = shader->compute_local_size[0];
	pipeline.local_group_size[1] = shader->compute_local_size[1];
	pipeline.local_group_size[2] = shader->compute_local_size[2];

	// Create ID to associate with this pipeline.
	RID id = compute_pipeline_owner.make_rid(pipeline);
#ifdef DEV_ENABLED
	set_resource_name(id, "RID:" + itos(id.get_id()));
#endif
	// Now add all the dependencies.
	_add_dependency(id, p_shader);
	return id;
}

bool RenderingDeviceD3D12::compute_pipeline_is_valid(RID p_pipeline) {
	return compute_pipeline_owner.owns(p_pipeline);
}

/****************/
/**** SCREEN ****/
/****************/

int RenderingDeviceD3D12::screen_get_width(DisplayServer::WindowID p_screen) const {
	_THREAD_SAFE_METHOD_
	ERR_FAIL_COND_V_MSG(local_device.is_valid(), -1, "Local devices have no screen");
	return context->window_get_width(p_screen);
}

int RenderingDeviceD3D12::screen_get_height(DisplayServer::WindowID p_screen) const {
	_THREAD_SAFE_METHOD_
	ERR_FAIL_COND_V_MSG(local_device.is_valid(), -1, "Local devices have no screen");

	return context->window_get_height(p_screen);
}

RenderingDevice::FramebufferFormatID RenderingDeviceD3D12::screen_get_framebuffer_format() const {
	_THREAD_SAFE_METHOD_
	ERR_FAIL_COND_V_MSG(local_device.is_valid(), INVALID_ID, "Local devices have no screen");

	// Very hacky, but not used often per frame so I guess ok.
	DXGI_FORMAT d3d12_format = context->get_screen_format();
	DataFormat format = DATA_FORMAT_MAX;
	for (int i = 0; i < DATA_FORMAT_MAX; i++) {
		if (d3d12_format == d3d12_formats[i].general_format) {
			format = DataFormat(i);
			break;
		}
	}

	ERR_FAIL_COND_V(format == DATA_FORMAT_MAX, INVALID_ID);

	AttachmentFormat attachment;
	attachment.format = format;
	attachment.samples = TEXTURE_SAMPLES_1;
	attachment.usage_flags = TEXTURE_USAGE_COLOR_ATTACHMENT_BIT;
	Vector<AttachmentFormat> screen_attachment;
	screen_attachment.push_back(attachment);
	return const_cast<RenderingDeviceD3D12 *>(this)->framebuffer_format_create(screen_attachment);
}

/*******************/
/**** DRAW LIST ****/
/*******************/

RenderingDevice::DrawListID RenderingDeviceD3D12::draw_list_begin_for_screen(DisplayServer::WindowID p_screen, const Color &p_clear_color) {
	_THREAD_SAFE_METHOD_
	ERR_FAIL_COND_V_MSG(local_device.is_valid(), INVALID_ID, "Local devices have no screen");

	ERR_FAIL_COND_V_MSG(draw_list != nullptr, INVALID_ID, "Only one draw list can be active at the same time.");
	ERR_FAIL_COND_V_MSG(compute_list != nullptr, INVALID_ID, "Only one draw/compute list can be active at the same time.");

	if (!context->window_is_valid_swapchain(p_screen)) {
		return INVALID_ID;
	}

	Size2i size = Size2i(context->window_get_width(p_screen), context->window_get_height(p_screen));

	_draw_list_allocate(Rect2i(Vector2i(), size), 0, 0);

	Vector<Color> clear_colors;
	clear_colors.push_back(p_clear_color);

	curr_screen_framebuffer = Framebuffer();
	curr_screen_framebuffer.window_id = p_screen;
	curr_screen_framebuffer.format_id = screen_get_framebuffer_format();
	curr_screen_framebuffer.size = size;
	curr_screen_framebuffer.screen_rtv_handle = context->window_get_framebuffer_rtv_handle(p_screen);

	ID3D12GraphicsCommandList *command_list = frames[frame].draw_command_list.Get();
	Error err = _draw_list_render_pass_begin(&curr_screen_framebuffer, INITIAL_ACTION_CLEAR, FINAL_ACTION_READ, INITIAL_ACTION_DROP, FINAL_ACTION_DISCARD, clear_colors, 0.0f, 0, Rect2i(), Point2i(), size, command_list, Vector<RID>());

	if (err != OK) {
		return INVALID_ID;
	}

	return int64_t(ID_TYPE_DRAW_LIST) << ID_BASE_SHIFT;
}

Error RenderingDeviceD3D12::_draw_list_render_pass_begin(Framebuffer *framebuffer, InitialAction p_initial_color_action, FinalAction p_final_color_action, InitialAction p_initial_depth_action, FinalAction p_final_depth_action, const Vector<Color> &p_clear_colors, float p_clear_depth, uint32_t p_clear_stencil, const Rect2 &p_region, Point2i viewport_offset, Point2i viewport_size, ID3D12GraphicsCommandList *command_list, const Vector<RID> &p_storage_textures) {
	const FramebufferFormat &fb_format = framebuffer_formats[framebuffer->format_id];

	bool is_screen = framebuffer->window_id != DisplayServer::INVALID_WINDOW_ID;
	if (!is_screen) {
		ERR_FAIL_COND_V(fb_format.attachments.size() != framebuffer->texture_ids.size(), ERR_BUG);
	}

	CD3DX12_RECT region_rect(0, 0, framebuffer->size.x, framebuffer->size.y);
	if (p_region != Rect2() && p_region != Rect2(Vector2(), viewport_size)) { // Check custom region.
		Rect2i viewport(viewport_offset, viewport_size);
		Rect2i regioni = p_region;
		if (!viewport.encloses(regioni)) {
			ERR_FAIL_V_MSG(ERR_INVALID_PARAMETER, "When supplying a custom region, it must be contained within the framebuffer rectangle");
		}
		viewport_offset = regioni.position;
		viewport_size = regioni.size;

		region_rect = CD3DX12_RECT(
				p_region.position.x,
				p_region.position.y,
				p_region.position.x + p_region.size.x,
				p_region.position.y + p_region.size.y);
	}

	if (p_initial_color_action == INITIAL_ACTION_CLEAR) { // Check clear values.
		int color_count = 0;
		if (is_screen) {
			color_count = 1;

		} else {
			for (int i = 0; i < framebuffer->texture_ids.size(); i++) {
				Texture *texture = texture_owner.get_or_null(framebuffer->texture_ids[i]);
				if (!texture || (!(texture->usage_flags & TEXTURE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT) && !(i != 0 && texture->usage_flags & TEXTURE_USAGE_VRS_ATTACHMENT_BIT))) {
					if (!texture || !texture->is_resolve_buffer) {
						color_count++;
					}
				}
			}
		}
		ERR_FAIL_COND_V_MSG(p_clear_colors.size() != color_count, ERR_INVALID_PARAMETER,
				"Clear color values supplied (" + itos(p_clear_colors.size()) + ") differ from the amount required for framebuffer color attachments (" + itos(color_count) + ").");
	}

	struct SetupInfo {
		enum {
			ACTION_NONE,
			ACTION_DISCARD,
			ACTION_CLEAR,
		} action = ACTION_NONE;
		UINT num_rects = 0;
		D3D12_RECT *rect_ptr = nullptr;
		D3D12_RESOURCE_STATES new_state = {};

		SetupInfo(InitialAction p_action, D3D12_RECT *p_region_rect, bool p_is_color) {
			switch (p_action) {
				case INITIAL_ACTION_CLEAR: {
					action = ACTION_CLEAR;
				} break;
				case INITIAL_ACTION_CLEAR_REGION: {
					action = ACTION_CLEAR;
					num_rects = 1;
					rect_ptr = p_region_rect;
				} break;
				case INITIAL_ACTION_CLEAR_REGION_CONTINUE: {
					action = ACTION_CLEAR;
					num_rects = 1;
					rect_ptr = p_region_rect;
				} break;
				case INITIAL_ACTION_KEEP: {
					// TODO: Is this what the comment about INITIAL_ACTION_KEEP means?
					action = p_is_color ? ACTION_NONE : ACTION_CLEAR;
				} break;
				case INITIAL_ACTION_DROP: {
					action = ACTION_DISCARD; // TODO: Are we really intended to do a resource Discard() as initial action, when final action can already do?
				} break;
				case INITIAL_ACTION_CONTINUE: {
				} break;
			}
		}
	};

	SetupInfo setup_color(p_initial_color_action, &region_rect, true);
	SetupInfo setup_depth(p_initial_depth_action, &region_rect, false);

	draw_list_bound_textures.clear();
	draw_list_unbind_color_textures = p_final_color_action != FINAL_ACTION_CONTINUE;
	draw_list_unbind_depth_textures = p_final_depth_action != FINAL_ACTION_CONTINUE;

	ID3D12Resource **discards = (ID3D12Resource **)alloca(sizeof(ID3D12Resource *) * fb_format.attachments.size());
	uint32_t num_discards = 0;

	struct RTVClear {
		D3D12_CPU_DESCRIPTOR_HANDLE handle;
		Color color;
	};
	RTVClear *rtv_clears = (RTVClear *)alloca(sizeof(RTVClear) * fb_format.attachments.size());
	uint32_t num_rtv_clears = 0;

	bool dsv_clear = false;

	DescriptorsHeap::Walker rtv_heap_walker = framebuffer->rtv_heap.make_walker();

	int color_index = 0;
	for (int i = 0; i < fb_format.attachments.size(); i++) {
		RID texture_rid;
		Texture *texture = nullptr;
		if (!is_screen) {
			texture_rid = framebuffer->texture_ids[i];
			if (texture_rid.is_null()) {
				color_index++;
				continue;
			}

			texture = texture_owner.get_or_null(texture_rid);
			ERR_FAIL_COND_V(!texture, ERR_BUG);

			texture->bound = true;
			draw_list_bound_textures.push_back(texture_rid);
		}

		// We can setup a framebuffer where we write to our VRS texture to set it up.
		// We make the assumption here that if our texture is actually used as our VRS attachment,
		// it is used as such for each subpass. This is fairly certain seeing the restrictions on subpasses (in Vulkan).
		// [[VRS_EVERY_SUBPASS_OR_NONE]]
		bool is_vrs = fb_format.attachments[i].usage_flags & TEXTURE_USAGE_VRS_ATTACHMENT_BIT && i == fb_format.passes[0].vrs_attachment;
		if (is_vrs) {
			DEV_ASSERT(!is_screen);

			DEV_ASSERT(texture->owner_mipmaps == 1);
			DEV_ASSERT(texture->owner_layers == 1);
			_resource_transition_batch(texture, 0, texture->planes, D3D12_RESOURCE_STATE_SHADING_RATE_SOURCE);
		} else {
			if ((fb_format.attachments[i].usage_flags & TEXTURE_USAGE_COLOR_ATTACHMENT_BIT)) {
				if (!is_screen) { // Screen backbuffers are transitioned in prepare_buffers().
					for (uint32_t j = 0; j < texture->layers; j++) {
						for (uint32_t k = 0; k < texture->mipmaps; k++) {
							uint32_t subresource = D3D12CalcSubresource(texture->base_mipmap + k, texture->base_layer + j, 0, texture->owner_mipmaps, texture->owner_layers);
							_resource_transition_batch(texture, subresource, texture->planes, D3D12_RESOURCE_STATE_RENDER_TARGET);
						}
					}
				}

				if (setup_color.action == SetupInfo::ACTION_DISCARD) {
					ID3D12Resource *resource = is_screen ? context->window_get_framebuffer_texture(framebuffer->window_id) : texture->resource;
					discards[num_discards++] = resource;
				} else if (setup_color.action == SetupInfo::ACTION_CLEAR) {
					D3D12_CPU_DESCRIPTOR_HANDLE handle = is_screen ? framebuffer->screen_rtv_handle : rtv_heap_walker.get_curr_cpu_handle();
					Color clear_color = color_index < p_clear_colors.size() ? p_clear_colors[color_index] : Color();
					rtv_clears[num_rtv_clears++] = RTVClear{ handle, clear_color };
				}

				color_index++;
				if (!is_screen) {
					rtv_heap_walker.advance();
				}
			} else if ((fb_format.attachments[i].usage_flags & TEXTURE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT)) {
				DEV_ASSERT(!is_screen);

				for (uint32_t j = 0; j < texture->layers; j++) {
					for (uint32_t k = 0; k < texture->mipmaps; k++) {
						uint32_t subresource = D3D12CalcSubresource(texture->base_mipmap + k, texture->base_layer + j, 0, texture->owner_mipmaps, texture->owner_layers);
						_resource_transition_batch(texture, subresource, texture->planes, D3D12_RESOURCE_STATE_DEPTH_WRITE);
					}
				}

				if (setup_depth.action == SetupInfo::ACTION_DISCARD) {
					discards[num_discards++] = texture->resource;
				} else if (setup_depth.action == SetupInfo::ACTION_CLEAR) {
					dsv_clear = true;
				}
			}
		}
	}

	for (int i = 0; i < p_storage_textures.size(); i++) {
		Texture *texture = texture_owner.get_or_null(p_storage_textures[i]);
		if (!texture) {
			continue;
		}
		ERR_CONTINUE_MSG(!(texture->usage_flags & TEXTURE_USAGE_STORAGE_BIT), "Supplied storage texture " + itos(i) + " for draw list is not set to be used for storage.");
	}

	_resource_transitions_flush(frames[frame].draw_command_list.Get());

	for (uint32_t i = 0; i < num_discards; i++) {
		command_list->DiscardResource(discards[i], nullptr);
	}
	for (uint32_t i = 0; i < num_rtv_clears; i++) {
		command_list->ClearRenderTargetView(
				rtv_clears[i].handle,
				rtv_clears[i].color.components,
				setup_color.num_rects,
				setup_color.rect_ptr);
	}

	if (dsv_clear) {
		command_list->ClearDepthStencilView(
				framebuffer->dsv_heap.get_heap()->GetCPUDescriptorHandleForHeapStart(),
				D3D12_CLEAR_FLAG_DEPTH | D3D12_CLEAR_FLAG_STENCIL,
				p_clear_depth,
				p_clear_stencil,
				setup_depth.num_rects,
				setup_depth.rect_ptr);
	}

	{
		CD3DX12_VIEWPORT viewport(
				viewport_offset.x,
				viewport_offset.y,
				viewport_size.x,
				viewport_size.y,
				0.0f,
				1.0f);
		command_list->RSSetViewports(1, &viewport);

		CD3DX12_RECT scissor(
				viewport_offset.x,
				viewport_offset.y,
				viewport_offset.x + viewport_size.x,
				viewport_offset.y + viewport_size.y);
		command_list->RSSetScissorRects(1, &scissor);
	}

	draw_list_subpass_count = fb_format.passes.size();
	draw_list_current_subpass = 0;
	draw_list_final_color_action = p_final_color_action;
	draw_list_final_depth_action = p_final_depth_action;
	draw_list_framebuffer = framebuffer;

	_draw_list_subpass_begin();

	return OK;
}

RenderingDevice::DrawListID RenderingDeviceD3D12::draw_list_begin(RID p_framebuffer, InitialAction p_initial_color_action, FinalAction p_final_color_action, InitialAction p_initial_depth_action, FinalAction p_final_depth_action, const Vector<Color> &p_clear_color_values, float p_clear_depth, uint32_t p_clear_stencil, const Rect2 &p_region, const Vector<RID> &p_storage_textures) {
	_THREAD_SAFE_METHOD_

	ERR_FAIL_COND_V_MSG(draw_list != nullptr, INVALID_ID, "Only one draw list can be active at the same time.");
	ERR_FAIL_COND_V_MSG(compute_list != nullptr && !compute_list->state.allow_draw_overlap, INVALID_ID, "Only one draw/compute list can be active at the same time.");

	Framebuffer *framebuffer = framebuffer_owner.get_or_null(p_framebuffer);
	ERR_FAIL_COND_V(!framebuffer, INVALID_ID);

	ID3D12GraphicsCommandList *command_list = frames[frame].draw_command_list.Get();
	Error err = _draw_list_render_pass_begin(framebuffer, p_initial_color_action, p_final_color_action, p_initial_depth_action, p_final_depth_action, p_clear_color_values, p_clear_depth, p_clear_stencil, p_region, Point2i(), framebuffer->size, command_list, p_storage_textures);

	if (err != OK) {
		return INVALID_ID;
	}

	_draw_list_allocate(Rect2i(Point2i(), framebuffer->size), 0, 0);

	return int64_t(ID_TYPE_DRAW_LIST) << ID_BASE_SHIFT;
}

Error RenderingDeviceD3D12::draw_list_begin_split(RID p_framebuffer, uint32_t p_splits, DrawListID *r_split_ids, InitialAction p_initial_color_action, FinalAction p_final_color_action, InitialAction p_initial_depth_action, FinalAction p_final_depth_action, const Vector<Color> &p_clear_color_values, float p_clear_depth, uint32_t p_clear_stencil, const Rect2 &p_region, const Vector<RID> &p_storage_textures) {
	_THREAD_SAFE_METHOD_

	ERR_FAIL_COND_V_MSG(draw_list != nullptr, ERR_BUSY, "Only one draw list can be active at the same time.");
	ERR_FAIL_COND_V_MSG(compute_list != nullptr && !compute_list->state.allow_draw_overlap, ERR_BUSY, "Only one draw/compute list can be active at the same time.");

	ERR_FAIL_COND_V(p_splits < 1, ERR_INVALID_DECLARATION);

	Framebuffer *framebuffer = framebuffer_owner.get_or_null(p_framebuffer);
	ERR_FAIL_COND_V(!framebuffer, ERR_INVALID_DECLARATION);

	ID3D12GraphicsCommandList *frame_command_list = frames[frame].draw_command_list.Get();
	Error err = _draw_list_render_pass_begin(framebuffer, p_initial_color_action, p_final_color_action, p_initial_depth_action, p_final_depth_action, p_clear_color_values, p_clear_depth, p_clear_stencil, p_region, Point2i(), framebuffer->size, frame_command_list, p_storage_textures);

	if (err != OK) {
		return ERR_CANT_CREATE;
	}

	err = _draw_list_allocate(Rect2i(Point2i(), framebuffer->size), p_splits, 0);
	if (err != OK) {
		return err;
	}

	for (uint32_t i = 0; i < p_splits; i++) {
		// In Vulkan, we'd be setting viewports and scissors for each split here;
		// D3D12 doesn't need it (it's even forbidden, for that matter).

		r_split_ids[i] = (int64_t(ID_TYPE_SPLIT_DRAW_LIST) << ID_BASE_SHIFT) + i;
	}

	return OK;
}

RenderingDeviceD3D12::DrawList *RenderingDeviceD3D12::_get_draw_list_ptr(DrawListID p_id) {
	if (p_id < 0) {
		return nullptr;
	}

	if (!draw_list) {
		return nullptr;
	} else if (p_id == (int64_t(ID_TYPE_DRAW_LIST) << ID_BASE_SHIFT)) {
		if (draw_list_split) {
			return nullptr;
		}
		return draw_list;
	} else if (p_id >> DrawListID(ID_BASE_SHIFT) == ID_TYPE_SPLIT_DRAW_LIST) {
		if (!draw_list_split) {
			return nullptr;
		}

		uint64_t index = p_id & ((DrawListID(1) << DrawListID(ID_BASE_SHIFT)) - 1); // Mask.

		if (index >= draw_list_count) {
			return nullptr;
		}

		return &draw_list[index];
	} else {
		return nullptr;
	}
}

void RenderingDeviceD3D12::draw_list_set_blend_constants(DrawListID p_list, const Color &p_color) {
	DrawList *dl = _get_draw_list_ptr(p_list);
	ERR_FAIL_COND(!dl);
#ifdef DEBUG_ENABLED
	ERR_FAIL_COND_MSG(!dl->validation.active, "Submitted Draw Lists can no longer be modified.");
#endif

	dl->command_list->OMSetBlendFactor(p_color.components);
}

void RenderingDeviceD3D12::draw_list_bind_render_pipeline(DrawListID p_list, RID p_render_pipeline) {
	DrawList *dl = _get_draw_list_ptr(p_list);
	ERR_FAIL_COND(!dl);
#ifdef DEBUG_ENABLED
	ERR_FAIL_COND_MSG(!dl->validation.active, "Submitted Draw Lists can no longer be modified.");
#endif

	const RenderPipeline *pipeline = render_pipeline_owner.get_or_null(p_render_pipeline);
	ERR_FAIL_COND(!pipeline);
#ifdef DEBUG_ENABLED
	ERR_FAIL_COND(pipeline->validation.framebuffer_format != draw_list_framebuffer->format_id && pipeline->validation.render_pass != draw_list_current_subpass);
#endif

	if (p_render_pipeline == dl->state.pipeline) {
		return; // Redundant state, return.
	}

	dl->state.pipeline = p_render_pipeline;
	dl->state.pso = pipeline->pso.Get();

	dl->command_list->IASetPrimitiveTopology(pipeline->dyn_params.primitive_topology);
	dl->command_list->OMSetBlendFactor(pipeline->dyn_params.blend_constant.components);
	dl->command_list->OMSetStencilRef(pipeline->dyn_params.stencil_reference);

	ID3D12GraphicsCommandList1 *command_list_1 = nullptr;
	dl->command_list->QueryInterface<ID3D12GraphicsCommandList1>(&command_list_1);
	if (command_list_1) {
		command_list_1->OMSetDepthBounds(pipeline->dyn_params.depth_bounds_min, pipeline->dyn_params.depth_bounds_max);
		command_list_1->Release();
	}

	Shader *shader = shader_owner.get_or_null(pipeline->shader);

	if (dl->state.pipeline_shader != pipeline->shader) {
		if (dl->state.root_signature_crc != pipeline->root_signature_crc) {
			dl->command_list->SetGraphicsRootSignature(shader->root_signature.Get());
			dl->state.root_signature_crc = pipeline->root_signature_crc;

			// Root signature changed, so current descriptor set bindings become invalid.
			for (uint32_t i = 0; i < dl->state.set_count; i++) {
				dl->state.sets[i].bound = false;
			}
		}

		const uint32_t *pformats = pipeline->set_formats.ptr(); // Pipeline set formats.
		dl->state.set_count = pipeline->set_formats.size(); // Update set count.
		for (uint32_t i = 0; i < dl->state.set_count; i++) {
			dl->state.sets[i].pipeline_expected_format = pformats[i];
#ifdef DEV_ENABLED
			dl->state.sets[i]._pipeline_expected_format = pformats[i] ? &uniform_set_format_cache_reverse[pformats[i] - 1]->key().uniform_info : nullptr;
#endif
		}

		if (pipeline->spirv_push_constant_size) {
#ifdef DEBUG_ENABLED
			dl->validation.pipeline_push_constant_supplied = false;
#endif
		}

		dl->state.pipeline_shader = pipeline->shader;
		dl->state.pipeline_dxil_push_constant_size = pipeline->dxil_push_constant_size;
		dl->state.pipeline_bindings_id = pipeline->bindings_id;
#ifdef DEV_ENABLED
		dl->state._shader = shader;
#endif
	}

#ifdef DEBUG_ENABLED
	// Update render pass pipeline info.
	dl->validation.pipeline_active = true;
	dl->validation.pipeline_dynamic_state = pipeline->validation.dynamic_state;
	dl->validation.pipeline_vertex_format = pipeline->validation.vertex_format;
	dl->validation.pipeline_uses_restart_indices = pipeline->validation.uses_restart_indices;
	dl->validation.pipeline_primitive_divisor = pipeline->validation.primitive_divisor;
	dl->validation.pipeline_primitive_minimum = pipeline->validation.primitive_minimum;
	dl->validation.pipeline_spirv_push_constant_size = pipeline->spirv_push_constant_size;
#endif
}

void RenderingDeviceD3D12::draw_list_bind_uniform_set(DrawListID p_list, RID p_uniform_set, uint32_t p_index) {
	DrawList *dl = _get_draw_list_ptr(p_list);
	ERR_FAIL_COND(!dl);

#ifdef DEBUG_ENABLED
	ERR_FAIL_COND_MSG(!dl->validation.active, "Submitted Draw Lists can no longer be modified.");
#endif

	const UniformSet *uniform_set = uniform_set_owner.get_or_null(p_uniform_set);
	ERR_FAIL_COND(!uniform_set);

	if (p_index > dl->state.set_count) {
		dl->state.set_count = p_index;
	}

	dl->state.sets[p_index].bound = false; // Needs rebind.
	dl->state.sets[p_index].uniform_set_format = uniform_set->format;
	dl->state.sets[p_index].uniform_set = p_uniform_set;
#ifdef DEV_ENABLED
	dl->state.sets[p_index]._uniform_set = uniform_set_owner.get_or_null(p_uniform_set);
#endif

#ifdef DEBUG_ENABLED
	{ // Validate that textures bound are not attached as framebuffer bindings.
		uint32_t attachable_count = uniform_set->attachable_textures.size();
		const UniformSet::AttachableTexture *attachable_ptr = uniform_set->attachable_textures.ptr();
		uint32_t bound_count = draw_list_bound_textures.size();
		const RID *bound_ptr = draw_list_bound_textures.ptr();
		for (uint32_t i = 0; i < attachable_count; i++) {
			for (uint32_t j = 0; j < bound_count; j++) {
				ERR_FAIL_COND_MSG(attachable_ptr[i].texture == bound_ptr[j],
						"Attempted to use the same texture in framebuffer attachment and a uniform (set: " + itos(p_index) + ", binding: " + itos(attachable_ptr[i].bind) + "), this is not allowed.");
			}
		}
	}
#endif
}

void RenderingDeviceD3D12::draw_list_bind_vertex_array(DrawListID p_list, RID p_vertex_array) {
	DrawList *dl = _get_draw_list_ptr(p_list);
	ERR_FAIL_COND(!dl);
#ifdef DEBUG_ENABLED
	ERR_FAIL_COND_MSG(!dl->validation.active, "Submitted Draw Lists can no longer be modified.");
#endif

	const VertexArray *vertex_array = vertex_array_owner.get_or_null(p_vertex_array);
	ERR_FAIL_COND(!vertex_array);

	if (dl->state.vertex_array == p_vertex_array) {
		return; // Already set.
	}

	dl->state.vertex_array = p_vertex_array;

#ifdef DEBUG_ENABLED
	dl->validation.vertex_format = vertex_array->description;
	dl->validation.vertex_max_instances_allowed = vertex_array->max_instances_allowed;
#endif
	dl->validation.vertex_array_size = vertex_array->vertex_count;

	for (Buffer *buffer : vertex_array->unique_buffers) {
		_resource_transition_batch(buffer, 0, 1, D3D12_RESOURCE_STATE_VERTEX_AND_CONSTANT_BUFFER);
	}
	_resource_transitions_flush(dl->command_list);

	dl->command_list->IASetVertexBuffers(0, vertex_array->views.size(), vertex_array->views.ptr());
}

void RenderingDeviceD3D12::draw_list_bind_index_array(DrawListID p_list, RID p_index_array) {
	DrawList *dl = _get_draw_list_ptr(p_list);
	ERR_FAIL_COND(!dl);
#ifdef DEBUG_ENABLED
	ERR_FAIL_COND_MSG(!dl->validation.active, "Submitted Draw Lists can no longer be modified.");
#endif

	const IndexArray *index_array = index_array_owner.get_or_null(p_index_array);
	ERR_FAIL_COND(!index_array);

	if (dl->state.index_array == p_index_array) {
		return; // Already set.
	}

	dl->state.index_array = p_index_array;
#ifdef DEBUG_ENABLED
	dl->validation.index_array_max_index = index_array->max_index;
#endif
	dl->validation.index_array_size = index_array->indices;
	dl->validation.index_array_offset = index_array->offset;

	_resource_transition_batch(index_array->buffer, 0, 1, D3D12_RESOURCE_STATE_INDEX_BUFFER);
	_resource_transitions_flush(dl->command_list);

	dl->command_list->IASetIndexBuffer(&index_array->view);
}

void RenderingDeviceD3D12::draw_list_set_line_width(DrawListID p_list, float p_width) {
	DrawList *dl = _get_draw_list_ptr(p_list);
	ERR_FAIL_COND(!dl);
#ifdef DEBUG_ENABLED
	ERR_FAIL_COND_MSG(!dl->validation.active, "Submitted Draw Lists can no longer be modified.");
#endif

	if (!Math::is_equal_approx(p_width, 1.0f)) {
		ERR_FAIL_MSG("Setting line widths other than 1.0 is not supported by the Direct3D 12 rendering driver.");
	}
}

void RenderingDeviceD3D12::_bind_uniform_set(UniformSet *p_uniform_set, const Shader::Set &p_shader_set, const Vector<UniformBindingInfo> &p_bindings, ID3D12GraphicsCommandList *p_command_list, bool p_for_compute) {
	using SetRootDescriptorTableFn = void (STDMETHODCALLTYPE ID3D12GraphicsCommandList::*)(UINT, D3D12_GPU_DESCRIPTOR_HANDLE);
	SetRootDescriptorTableFn set_root_desc_table_fn = p_for_compute ? &ID3D12GraphicsCommandList::SetComputeRootDescriptorTable : &ID3D12GraphicsCommandList1::SetGraphicsRootDescriptorTable;

	// If this set's descriptors have already been set for the current execution and a compatible root signature, reuse!
	// TODO: It may be interesting to see if keeping a history of binds per frame meaningfully increases the chances of recycling;
	//       also, we may reuse descriptors from a past frame still not reused by copying them first.
	uint32_t root_sig_crc = p_for_compute ? compute_list->state.root_signature_crc : draw_list->state.root_signature_crc;
	if (p_uniform_set->last_bind.execution_index == frames[frame].execution_index && p_uniform_set->last_bind.root_signature_crc == root_sig_crc) {
		for (const RootDescriptorTable &table : p_uniform_set->last_bind.root_tables.resources) {
			(p_command_list->*set_root_desc_table_fn)(table.root_param_idx, table.start_gpu_handle);
		}
		for (const RootDescriptorTable &table : p_uniform_set->last_bind.root_tables.samplers) {
			(p_command_list->*set_root_desc_table_fn)(table.root_param_idx, table.start_gpu_handle);
		}
#ifdef DEV_ENABLED
		frames[frame].uniform_set_reused++;
#endif
		return;
	}

	struct {
		DescriptorsHeap::Walker *resources = nullptr;
		DescriptorsHeap::Walker *samplers = nullptr;
	} frame_heap_walkers;
	frame_heap_walkers.resources = &frames[frame].desc_heap_walkers.resources;
	frame_heap_walkers.samplers = &frames[frame].desc_heap_walkers.samplers;

	struct {
		DescriptorsHeap::Walker resources;
		DescriptorsHeap::Walker samplers;
	} set_heap_walkers;
	set_heap_walkers.resources = p_uniform_set->desc_heaps.resources.make_walker();
	set_heap_walkers.samplers = p_uniform_set->desc_heaps.samplers.make_walker();

#ifdef DEV_ENABLED
	// Whether we have stages where the uniform is actually used should match
	// whether we have any root signature locations for it.
	for (int i = 0; i < p_shader_set.uniforms.size(); i++) {
		bool has_rs_locations = false;
		for (int j = 0; j < 2; j++) {
			if (p_bindings[i].root_sig_locations.resource[j].root_param_idx != UINT32_MAX ||
					p_bindings[i].root_sig_locations.sampler[j].root_param_idx != UINT32_MAX) {
				has_rs_locations = true;
				break;
			}
		}

		bool has_stages = p_bindings[i].stages;

		DEV_ASSERT(has_rs_locations == has_stages);
	}
#endif

	p_uniform_set->last_bind.root_tables.resources.reserve(p_shader_set.num_root_params.resources);
	p_uniform_set->last_bind.root_tables.resources.clear();
	p_uniform_set->last_bind.root_tables.samplers.reserve(p_shader_set.num_root_params.samplers);
	p_uniform_set->last_bind.root_tables.samplers.clear();

	// Maybe doing two full rounds is a bit inefficient, but I won't optimize unless benchmarking proves it.
	for (int vis_idx = 0; vis_idx < 2; vis_idx++) {
		if (vis_idx > 0) {
			set_heap_walkers.resources.rewind();
			set_heap_walkers.samplers.rewind();
		}

		struct {
			RootDescriptorTable *resources = nullptr;
			RootDescriptorTable *samplers = nullptr;
		} tables;

		for (int i = 0; i < p_shader_set.uniforms.size(); i++) {
			const Shader::ShaderUniformInfo &uniform_info = p_shader_set.uniforms[i];

			uint32_t num_resource_descs = 0;
			uint32_t num_sampler_descs = 0;
			switch (uniform_info.info.type) {
				case UNIFORM_TYPE_SAMPLER: {
					num_sampler_descs = uniform_info.info.length;
				} break;
				case UNIFORM_TYPE_SAMPLER_WITH_TEXTURE:
				case UNIFORM_TYPE_SAMPLER_WITH_TEXTURE_BUFFER: {
					num_sampler_descs = uniform_info.info.length;
					num_resource_descs = uniform_info.info.length;
				} break;
				case UNIFORM_TYPE_UNIFORM_BUFFER: {
					num_resource_descs = 1;
				} break;
				case UNIFORM_TYPE_STORAGE_BUFFER: {
					num_resource_descs = 1;
				} break;
				case UNIFORM_TYPE_IMAGE: {
					num_resource_descs = uniform_info.info.length;
				} break;
				default: {
					num_resource_descs = uniform_info.info.length;
				}
			}

			if (p_bindings[i].stages) {
				{
					const UniformBindingInfo::RootSignatureLocation &rs_loc_resource = p_bindings[i].root_sig_locations.resource[vis_idx];
					if (rs_loc_resource.root_param_idx != UINT32_MAX) { // Location used?
						DEV_ASSERT(num_resource_descs);

						bool must_flush_table = tables.resources && rs_loc_resource.root_param_idx != tables.resources->root_param_idx;
						if (must_flush_table) {
							// Check the root signature data has been filled ordered.
							DEV_ASSERT(rs_loc_resource.root_param_idx > tables.resources->root_param_idx);

							(p_command_list->*set_root_desc_table_fn)(tables.resources->root_param_idx, tables.resources->start_gpu_handle);
							tables.resources = nullptr;
						}

						if (!tables.resources) {
							DEV_ASSERT(p_uniform_set->last_bind.root_tables.resources.size() < p_uniform_set->last_bind.root_tables.resources.get_capacity());
							p_uniform_set->last_bind.root_tables.resources.resize(p_uniform_set->last_bind.root_tables.resources.size() + 1);
							tables.resources = &p_uniform_set->last_bind.root_tables.resources[p_uniform_set->last_bind.root_tables.resources.size() - 1];
							tables.resources->root_param_idx = rs_loc_resource.root_param_idx;
							tables.resources->start_gpu_handle = frame_heap_walkers.resources->get_curr_gpu_handle();
						}

						if (unlikely(frame_heap_walkers.resources->get_free_handles() < num_resource_descs)) {
							if (!frames[frame].desc_heaps_exhausted_reported.resources) {
								frames[frame].desc_heaps_exhausted_reported.resources = true;
								ERR_FAIL_MSG("Cannot bind uniform set because there's no enough room in current frame's RESOURCES descriptor heap.\n"
											 "Please increase the value of the rendering/rendering_device/d3d12/max_resource_descriptors_per_frame project setting.");
							} else {
								return;
							}
						}

						// TODO: Batch to avoid multiple calls where possible (in any case, flush before setting root descriptor tables, or even batch that as well).
						device->CopyDescriptorsSimple(
								num_resource_descs,
								frame_heap_walkers.resources->get_curr_cpu_handle(),
								set_heap_walkers.resources.get_curr_cpu_handle(),
								D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV);
						frame_heap_walkers.resources->advance(num_resource_descs);
					}
				}

				{
					const UniformBindingInfo::RootSignatureLocation &rs_loc_sampler = p_bindings[i].root_sig_locations.sampler[vis_idx];
					if (rs_loc_sampler.root_param_idx != UINT32_MAX) { // Location used?
						DEV_ASSERT(num_sampler_descs);

						bool must_flush_table = tables.samplers && rs_loc_sampler.root_param_idx != tables.samplers->root_param_idx;
						if (must_flush_table) {
							// Check the root signature data has been filled ordered.
							DEV_ASSERT(rs_loc_sampler.root_param_idx > tables.samplers->root_param_idx);

							(p_command_list->*set_root_desc_table_fn)(tables.samplers->root_param_idx, tables.samplers->start_gpu_handle);
							tables.samplers = nullptr;
						}

						if (!tables.samplers) {
							DEV_ASSERT(p_uniform_set->last_bind.root_tables.samplers.size() < p_uniform_set->last_bind.root_tables.samplers.get_capacity());
							p_uniform_set->last_bind.root_tables.samplers.resize(p_uniform_set->last_bind.root_tables.samplers.size() + 1);
							tables.samplers = &p_uniform_set->last_bind.root_tables.samplers[p_uniform_set->last_bind.root_tables.samplers.size() - 1];
							tables.samplers->root_param_idx = rs_loc_sampler.root_param_idx;
							tables.samplers->start_gpu_handle = frame_heap_walkers.samplers->get_curr_gpu_handle();
						}

						if (unlikely(frame_heap_walkers.samplers->get_free_handles() < num_sampler_descs)) {
							if (!frames[frame].desc_heaps_exhausted_reported.samplers) {
								frames[frame].desc_heaps_exhausted_reported.samplers = true;
								ERR_FAIL_MSG("Cannot bind uniform set because there's no enough room in current frame's SAMPLERS desciptors heap.\n"
											 "Please increase the value of the rendering/rendering_device/d3d12/max_sampler_descriptors_per_frame project setting.");
							} else {
								return;
							}
						}

						// TODO: Batch to avoid multiple calls where possible (in any case, flush before setting root descriptor tables, or even batch that as well).
						device->CopyDescriptorsSimple(
								num_sampler_descs,
								frame_heap_walkers.samplers->get_curr_cpu_handle(),
								set_heap_walkers.samplers.get_curr_cpu_handle(),
								D3D12_DESCRIPTOR_HEAP_TYPE_SAMPLER);
						frame_heap_walkers.samplers->advance(num_sampler_descs);
					}
				}
			}

			// Uniform set descriptor heaps are always full (descriptors are created for every uniform in them) despite
			// the shader variant a given set is created upon may not need all of them due to DXC optimizations.
			// Therefore, at this point we have to advance through the descriptor set descriptor's heap unconditionally.

			set_heap_walkers.resources.advance(num_resource_descs);
			set_heap_walkers.samplers.advance(num_sampler_descs);
		}

		{
			bool must_flush_table = tables.resources;
			if (must_flush_table) {
				(p_command_list->*set_root_desc_table_fn)(tables.resources->root_param_idx, tables.resources->start_gpu_handle);
			}
		}
		{
			bool must_flush_table = tables.samplers;
			if (must_flush_table) {
				(p_command_list->*set_root_desc_table_fn)(tables.samplers->root_param_idx, tables.samplers->start_gpu_handle);
			}
		}

		DEV_ASSERT(set_heap_walkers.resources.is_at_eof());
		DEV_ASSERT(set_heap_walkers.samplers.is_at_eof());
	}

	p_uniform_set->last_bind.root_signature_crc = root_sig_crc;
	p_uniform_set->last_bind.execution_index = frames[frame].execution_index;
}

void RenderingDeviceD3D12::_apply_uniform_set_resource_states(const UniformSet *p_uniform_set, const Shader::Set &p_shader_set) {
	for (const UniformSet::StateRequirement &sr : p_uniform_set->resource_states) {
#ifdef DEV_ENABLED
		{
			uint32_t stages = 0;
			D3D12_RESOURCE_STATES wanted_state = {};
			bool writable = false;
			// Doing the full loop for debugging since the real one below may break early,
			// but we want an exhaustive check
			for (uint32_t i = 0; i < UniformSet::StateRequirement::UNIFORM_IDX_MASK_BITS; i++) {
				if (likely(!(sr.shader_uniform_idx_mask & ((uint64_t)1 << i)))) {
					continue;
				}

				const Shader::ShaderUniformInfo &info = p_shader_set.uniforms[i];
				if (unlikely(!info.binding.stages)) {
					continue;
				}

				DEV_ASSERT((sr.states == D3D12_RESOURCE_STATE_UNORDERED_ACCESS) == (bool)(sr.states & D3D12_RESOURCE_STATE_UNORDERED_ACCESS));
				DEV_ASSERT((sr.states == D3D12_RESOURCE_STATE_UNORDERED_ACCESS) == info.info.writable);

				if (stages) { // Second occurrence at least?
					CRASH_COND_MSG(info.info.writable != writable, "A resource is used in the same uniform set both as R/O and R/W. That's not supported and shouldn't happen.");
					CRASH_COND_MSG(sr.states != wanted_state, "A resource is used in the same uniform set with different resource states. The code needs to be enhanced to support that.");
				} else {
					wanted_state = sr.states;
					stages |= info.binding.stages;
					writable = info.info.writable;
				}

				if (wanted_state == D3D12_RESOURCE_STATE_UNORDERED_ACCESS || wanted_state == D3D12_RESOURCE_STATE_RENDER_TARGET) {
					if (!sr.is_buffer) {
						Texture *texture = (Texture *)sr.resource;
						CRASH_COND_MSG(texture->resource != texture->owner_resource, "The texture format used for UAV or RTV must be the main one.");
					}
				}
			}
		}
#endif

		// We may have assumed D3D12_RESOURCE_STATE_ALL_SHADER_RESOURCE for a resource,
		// because at uniform set creation time we couldn't know for sure which stages
		// it would be used in (due to the fact that a set can be created against a different,
		// albeit compatible, shader, which may make a different usage in the end).
		// However, now we know and can exclude up to one undeeded state.

		// TODO: If subresources involved already in the needed state, or scheduled for it,
		// maybe it's more optimal not to do anything here

		uint32_t stages = 0;
		D3D12_RESOURCE_STATES wanted_state = {};
		for (uint32_t i = 0; i < UniformSet::StateRequirement::UNIFORM_IDX_MASK_BITS; i++) {
			if (likely(!(sr.shader_uniform_idx_mask & ((uint64_t)1 << i)))) {
				continue;
			}

			const Shader::ShaderUniformInfo &info = p_shader_set.uniforms[i];
			if (unlikely(!info.binding.stages)) {
				continue;
			}

			if (!stages) {
				wanted_state = sr.states;
				if (!(wanted_state & D3D12_RESOURCE_STATE_ALL_SHADER_RESOURCE)) {
					// By now, we already know the resource is used, and with no PS/NON_PS disjuntive; no need to check further.
					break;
				}
			}

			stages |= info.binding.stages;

			if (stages == (SHADER_STAGE_VERTEX_BIT | SHADER_STAGE_FRAGMENT_BIT) || stages == SHADER_STAGE_COMPUTE_BIT) {
				// By now, we already know the resource is used, and as both PS/NON_PS; no need to check further.
				break;
			}
		}

		if (likely(wanted_state)) {
			if ((wanted_state & D3D12_RESOURCE_STATE_ALL_SHADER_RESOURCE)) {
				if (stages == SHADER_STAGE_VERTEX_BIT || stages == SHADER_STAGE_COMPUTE_BIT) {
					D3D12_RESOURCE_STATES unneeded_states = D3D12_RESOURCE_STATE_PIXEL_SHADER_RESOURCE;
					wanted_state &= ~unneeded_states;
				} else if (stages == SHADER_STAGE_FRAGMENT_BIT) {
					D3D12_RESOURCE_STATES unneeded_states = D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE;
					wanted_state &= ~unneeded_states;
				}
			}

			if (likely(wanted_state)) {
				if (sr.is_buffer) {
					_resource_transition_batch(sr.resource, 0, 1, wanted_state);
				} else {
					Texture *texture = (Texture *)sr.resource;
					for (uint32_t i = 0; i < texture->layers; i++) {
						for (uint32_t j = 0; j < texture->mipmaps; j++) {
							uint32_t subresource = D3D12CalcSubresource(texture->base_mipmap + j, texture->base_layer + i, 0, texture->owner_mipmaps, texture->owner_layers);
							_resource_transition_batch(texture, subresource, texture->planes, wanted_state, texture->owner_resource);
						}
					}
				}
			}
		}
	}
}

void RenderingDeviceD3D12::draw_list_set_push_constant(DrawListID p_list, const void *p_data, uint32_t p_data_size) {
	DrawList *dl = _get_draw_list_ptr(p_list);
	ERR_FAIL_COND(!dl);

#ifdef DEBUG_ENABLED
	ERR_FAIL_COND_MSG(!dl->validation.active, "Submitted Draw Lists can no longer be modified.");
#endif

#ifdef DEBUG_ENABLED
	ERR_FAIL_COND_MSG(p_data_size != dl->validation.pipeline_spirv_push_constant_size,
			"This render pipeline requires (" + itos(dl->validation.pipeline_spirv_push_constant_size) + ") bytes of push constant data, supplied: (" + itos(p_data_size) + ")");
#endif
	if (dl->state.pipeline_dxil_push_constant_size) {
		dl->command_list->SetGraphicsRoot32BitConstants(0, p_data_size / sizeof(uint32_t), p_data, 0);
	}
#ifdef DEBUG_ENABLED
	dl->validation.pipeline_push_constant_supplied = true;
#endif
}

void RenderingDeviceD3D12::draw_list_draw(DrawListID p_list, bool p_use_indices, uint32_t p_instances, uint32_t p_procedural_vertices) {
	DrawList *dl = _get_draw_list_ptr(p_list);
	ERR_FAIL_COND(!dl);
#ifdef DEBUG_ENABLED
	ERR_FAIL_COND_MSG(!dl->validation.active, "Submitted Draw Lists can no longer be modified.");
#endif

#ifdef DEBUG_ENABLED
	ERR_FAIL_COND_MSG(!dl->validation.pipeline_active,
			"No render pipeline was set before attempting to draw.");
	if (dl->validation.pipeline_vertex_format != INVALID_ID) {
		// Pipeline uses vertices, validate format.
		ERR_FAIL_COND_MSG(dl->validation.vertex_format == INVALID_ID,
				"No vertex array was bound, and render pipeline expects vertices.");
		// Make sure format is right.
		ERR_FAIL_COND_MSG(dl->validation.pipeline_vertex_format != dl->validation.vertex_format,
				"The vertex format used to create the pipeline does not match the vertex format bound.");
		// Make sure number of instances is valid.
		ERR_FAIL_COND_MSG(p_instances > dl->validation.vertex_max_instances_allowed,
				"Number of instances requested (" + itos(p_instances) + " is larger than the maximum number supported by the bound vertex array (" + itos(dl->validation.vertex_max_instances_allowed) + ").");
	}

	if (dl->validation.pipeline_spirv_push_constant_size) {
		// Using push constants, check that they were supplied.
		ERR_FAIL_COND_MSG(!dl->validation.pipeline_push_constant_supplied,
				"The shader in this pipeline requires a push constant to be set before drawing, but it's not present.");
	}
#endif

	// Bind descriptor sets.

	Shader *shader = shader_owner.get_or_null(dl->state.pipeline_shader);
	struct SetToBind {
		uint32_t set;
		UniformSet *uniform_set;
		const Shader::Set *shader_set;
	};
	SetToBind *sets_to_bind = (SetToBind *)alloca(sizeof(SetToBind) * dl->state.set_count);
	uint32_t num_sets_to_bind = 0;
	for (uint32_t i = 0; i < dl->state.set_count; i++) {
		if (dl->state.sets[i].pipeline_expected_format == 0) {
			continue; // Nothing expected by this pipeline.
		}
#ifdef DEBUG_ENABLED
		if (dl->state.sets[i].pipeline_expected_format != dl->state.sets[i].uniform_set_format) {
			if (dl->state.sets[i].uniform_set_format == 0) {
				ERR_FAIL_MSG("Uniforms were never supplied for set (" + itos(i) + ") at the time of drawing, which are required by the pipeline");
			} else if (uniform_set_owner.owns(dl->state.sets[i].uniform_set)) {
				UniformSet *us = uniform_set_owner.get_or_null(dl->state.sets[i].uniform_set);
				ERR_FAIL_MSG("Uniforms supplied for set (" + itos(i) + "):\n" + _shader_uniform_debug(us->shader_id, us->shader_set) + "\nare not the same format as required by the pipeline shader. Pipeline shader requires the following bindings:\n" + _shader_uniform_debug(dl->state.pipeline_shader));
			} else {
				ERR_FAIL_MSG("Uniforms supplied for set (" + itos(i) + ", which was was just freed) are not the same format as required by the pipeline shader. Pipeline shader requires the following bindings:\n" + _shader_uniform_debug(dl->state.pipeline_shader));
			}
		}
#endif
		UniformSet *uniform_set = uniform_set_owner.get_or_null(dl->state.sets[i].uniform_set);
		const Shader::Set &shader_set = shader->sets[i];
		_apply_uniform_set_resource_states(uniform_set, shader_set);
		if (!dl->state.sets[i].bound) {
			sets_to_bind[num_sets_to_bind].set = i;
			sets_to_bind[num_sets_to_bind].uniform_set = uniform_set;
			sets_to_bind[num_sets_to_bind].shader_set = &shader_set;
			num_sets_to_bind++;
			dl->state.sets[i].bound = true;
		}
	}

	_resource_transitions_flush(dl->command_list);

	for (uint32_t i = 0; i < num_sets_to_bind; i++) {
		_bind_uniform_set(sets_to_bind[i].uniform_set, *sets_to_bind[i].shader_set, pipeline_bindings[dl->state.pipeline_bindings_id][sets_to_bind[i].set], dl->command_list, false);
	}

	if (dl->state.bound_pso != dl->state.pso) {
		dl->command_list->SetPipelineState(dl->state.pso);
		dl->state.bound_pso = dl->state.pso;
	}
	if (p_use_indices) {
#ifdef DEBUG_ENABLED
		ERR_FAIL_COND_MSG(p_procedural_vertices > 0,
				"Procedural vertices can't be used together with indices.");

		ERR_FAIL_COND_MSG(!dl->validation.index_array_size,
				"Draw command requested indices, but no index buffer was set.");

		ERR_FAIL_COND_MSG(dl->validation.pipeline_uses_restart_indices != dl->validation.index_buffer_uses_restart_indices,
				"The usage of restart indices in index buffer does not match the render primitive in the pipeline.");
#endif
		uint32_t to_draw = dl->validation.index_array_size;

#ifdef DEBUG_ENABLED
		ERR_FAIL_COND_MSG(to_draw < dl->validation.pipeline_primitive_minimum,
				"Too few indices (" + itos(to_draw) + ") for the render primitive set in the render pipeline (" + itos(dl->validation.pipeline_primitive_minimum) + ").");

		ERR_FAIL_COND_MSG((to_draw % dl->validation.pipeline_primitive_divisor) != 0,
				"Index amount (" + itos(to_draw) + ") must be a multiple of the amount of indices required by the render primitive (" + itos(dl->validation.pipeline_primitive_divisor) + ").");
#endif

		dl->command_list->DrawIndexedInstanced(to_draw, p_instances, dl->validation.index_array_offset, 0, 0);
	} else {
		uint32_t to_draw;

		if (p_procedural_vertices > 0) {
#ifdef DEBUG_ENABLED
			ERR_FAIL_COND_MSG(dl->validation.pipeline_vertex_format != INVALID_ID,
					"Procedural vertices requested, but pipeline expects a vertex array.");
#endif
			to_draw = p_procedural_vertices;
		} else {
#ifdef DEBUG_ENABLED
			ERR_FAIL_COND_MSG(dl->validation.pipeline_vertex_format == INVALID_ID,
					"Draw command lacks indices, but pipeline format does not use vertices.");
#endif
			to_draw = dl->validation.vertex_array_size;
		}

#ifdef DEBUG_ENABLED
		ERR_FAIL_COND_MSG(to_draw < dl->validation.pipeline_primitive_minimum,
				"Too few vertices (" + itos(to_draw) + ") for the render primitive set in the render pipeline (" + itos(dl->validation.pipeline_primitive_minimum) + ").");

		ERR_FAIL_COND_MSG((to_draw % dl->validation.pipeline_primitive_divisor) != 0,
				"Vertex amount (" + itos(to_draw) + ") must be a multiple of the amount of vertices required by the render primitive (" + itos(dl->validation.pipeline_primitive_divisor) + ").");
#endif

		dl->command_list->DrawInstanced(to_draw, p_instances, 0, 0);
	}
}

void RenderingDeviceD3D12::draw_list_enable_scissor(DrawListID p_list, const Rect2 &p_rect) {
	DrawList *dl = _get_draw_list_ptr(p_list);

	ERR_FAIL_COND(!dl);
#ifdef DEBUG_ENABLED
	ERR_FAIL_COND_MSG(!dl->validation.active, "Submitted Draw Lists can no longer be modified.");
#endif
	Rect2i rect = p_rect;
	rect.position += dl->viewport.position;

	rect = dl->viewport.intersection(rect);

	if (rect.get_area() == 0) {
		return;
	}
	CD3DX12_RECT scissor(
			rect.position.x,
			rect.position.y,
			rect.position.x + rect.size.width,
			rect.position.y + rect.size.height);

	dl->command_list->RSSetScissorRects(1, &scissor);
}

void RenderingDeviceD3D12::draw_list_disable_scissor(DrawListID p_list) {
	DrawList *dl = _get_draw_list_ptr(p_list);
	ERR_FAIL_COND(!dl);
#ifdef DEBUG_ENABLED
	ERR_FAIL_COND_MSG(!dl->validation.active, "Submitted Draw Lists can no longer be modified.");
#endif

	CD3DX12_RECT scissor(
			dl->viewport.position.x,
			dl->viewport.position.y,
			dl->viewport.position.x + dl->viewport.size.width,
			dl->viewport.position.y + dl->viewport.size.height);
	dl->command_list->RSSetScissorRects(1, &scissor);
}

uint32_t RenderingDeviceD3D12::draw_list_get_current_pass() {
	return draw_list_current_subpass;
}

void RenderingDeviceD3D12::_draw_list_subpass_begin() { // [[MANUAL_SUBPASSES]]
	const FramebufferFormat &fb_format = framebuffer_formats[draw_list_framebuffer->format_id];
	const FramebufferPass &pass = fb_format.passes[draw_list_current_subpass];

	ID3D12GraphicsCommandList *command_list = frames[frame].draw_command_list.Get();

	bool is_screen = draw_list_framebuffer->window_id != DisplayServer::INVALID_WINDOW_ID;

	if (is_screen) {
		DEV_ASSERT(!draw_list_framebuffer->dsv_heap.get_descriptor_count());
		command_list->OMSetRenderTargets(1, &draw_list_framebuffer->screen_rtv_handle, true, nullptr);
	} else {
		D3D12_CPU_DESCRIPTOR_HANDLE *rtv_handles = (D3D12_CPU_DESCRIPTOR_HANDLE *)alloca(sizeof(D3D12_CPU_DESCRIPTOR_HANDLE) * pass.color_attachments.size());
		DescriptorsHeap::Walker rtv_heap_walker = draw_list_framebuffer->rtv_heap.make_walker();
		for (int i = 0; i < pass.color_attachments.size(); i++) {
			uint32_t attachment = pass.color_attachments[i];
			if (attachment == FramebufferPass::ATTACHMENT_UNUSED) {
				if (!frames[frame].null_rtv_handle.ptr) {
					// No null descriptor-handle created for this frame yet.

					if (frames[frame].desc_heap_walkers.rtv.is_at_eof()) {
						if (!frames[frame].desc_heaps_exhausted_reported.rtv) {
							frames[frame].desc_heaps_exhausted_reported.rtv = true;
							ERR_FAIL_MSG("Cannot begin subpass because there's no enough room in current frame's RENDER TARGET desciptors heap.\n"
										 "Please increase the value of the rendering/rendering_device/d3d12/max_misc_descriptors_per_frame project setting.");
						} else {
							return;
						}
					}

					D3D12_RENDER_TARGET_VIEW_DESC rtv_desc_null = {};
					rtv_desc_null.Format = DXGI_FORMAT_R8_UINT;
					rtv_desc_null.ViewDimension = D3D12_RTV_DIMENSION_TEXTURE2D;
					frames[frame].null_rtv_handle = frames[frame].desc_heap_walkers.rtv.get_curr_cpu_handle();
					device->CreateRenderTargetView(nullptr, &rtv_desc_null, frames[frame].null_rtv_handle);
					frames[frame].desc_heap_walkers.rtv.advance();
				}
				rtv_handles[i] = frames[frame].null_rtv_handle;
			} else {
				uint32_t rt_index = draw_list_framebuffer->attachments_handle_inds[attachment];
				rtv_heap_walker.rewind();
				rtv_heap_walker.advance(rt_index);
				rtv_handles[i] = rtv_heap_walker.get_curr_cpu_handle();
			}
		}

		D3D12_CPU_DESCRIPTOR_HANDLE dsv_handle = {};
		{
			DescriptorsHeap::Walker dsv_heap_walker = draw_list_framebuffer->dsv_heap.make_walker();
			if (pass.depth_attachment != FramebufferPass::ATTACHMENT_UNUSED) {
				uint32_t ds_index = draw_list_framebuffer->attachments_handle_inds[pass.depth_attachment];
				dsv_heap_walker.rewind();
				dsv_heap_walker.advance(ds_index);
				dsv_handle = dsv_heap_walker.get_curr_cpu_handle();
			}
		}

		command_list->OMSetRenderTargets(pass.color_attachments.size(), rtv_handles, false, dsv_handle.ptr ? &dsv_handle : nullptr);

		// [[VRS_EVERY_SUBPASS_OR_NONE]]
		if (context->get_vrs_capabilities().ss_image_supported && draw_list_current_subpass == 0) {
			if (execution_index != vrs_state_execution_index) {
				vrs_state = {};
			}

			Texture *vrs_texture = nullptr;
			RID vrs_texture_id;
			if (pass.vrs_attachment != FramebufferPass::ATTACHMENT_UNUSED) {
				vrs_texture_id = draw_list_framebuffer->texture_ids[pass.vrs_attachment];
				vrs_texture = texture_owner.get_or_null(vrs_texture_id);
				if (!vrs_texture) {
					vrs_texture_id = RID();
				}
			}

			if (vrs_texture_id != vrs_state.texture_bound) {
				ID3D12GraphicsCommandList5 *command_list_5 = nullptr;
				command_list->QueryInterface<ID3D12GraphicsCommandList5>(&command_list_5);
				DEV_ASSERT(command_list_5);

				if (vrs_texture_id.is_valid()) {
					if (!vrs_state.configured) {
						static const D3D12_SHADING_RATE_COMBINER combiners[D3D12_RS_SET_SHADING_RATE_COMBINER_COUNT] = {
							D3D12_SHADING_RATE_COMBINER_PASSTHROUGH,
							D3D12_SHADING_RATE_COMBINER_OVERRIDE,
						};
						command_list_5->RSSetShadingRate(D3D12_SHADING_RATE_1X1, combiners);
						vrs_state.configured = true;

						command_list_5->RSSetShadingRateImage(vrs_texture->resource);
						vrs_state.texture_bound = vrs_texture_id;
					}
				} else {
					command_list_5->RSSetShadingRateImage(nullptr);
					vrs_state.texture_bound = RID();
				}

				command_list_5->Release();
			}

			vrs_state_execution_index = execution_index;
		}
	}
}

void RenderingDeviceD3D12::_draw_list_subpass_end() { // [[MANUAL_SUBPASSES]]
	const FramebufferFormat &fb_format = framebuffer_formats[draw_list_framebuffer->format_id];
	const FramebufferPass &pass = fb_format.passes[draw_list_current_subpass];

	ID3D12GraphicsCommandList *command_list = frames[frame].draw_command_list.Get();

	struct Resolve {
		ID3D12Resource *src_res;
		uint32_t src_subres;
		ID3D12Resource *dst_res;
		uint32_t dst_subres;
		DXGI_FORMAT format;
	};
	Resolve *resolves = (Resolve *)alloca(sizeof(Resolve) * pass.resolve_attachments.size());
	uint32_t num_resolves = 0;

	for (int i = 0; i < pass.resolve_attachments.size(); i++) {
		int32_t color_index = pass.color_attachments[i];
		int32_t resolve_index = pass.resolve_attachments[i];
		DEV_ASSERT((color_index == FramebufferPass::ATTACHMENT_UNUSED) == (resolve_index == FramebufferPass::ATTACHMENT_UNUSED));
		if (color_index == FramebufferPass::ATTACHMENT_UNUSED || draw_list_framebuffer->texture_ids[color_index].is_null()) {
			continue;
		}

		Texture *src_tex = texture_owner.get_or_null(draw_list_framebuffer->texture_ids[color_index]);
		uint32_t src_subresource = D3D12CalcSubresource(src_tex->base_mipmap, src_tex->base_layer, 0, src_tex->owner_mipmaps, src_tex->owner_layers);
		_resource_transition_batch(src_tex, src_subresource, src_tex->planes, D3D12_RESOURCE_STATE_RESOLVE_SOURCE);

		Texture *dst_tex = texture_owner.get_or_null(draw_list_framebuffer->texture_ids[resolve_index]);
		uint32_t dst_subresource = D3D12CalcSubresource(dst_tex->base_mipmap, dst_tex->base_layer, 0, dst_tex->owner_mipmaps, dst_tex->owner_layers);
		_resource_transition_batch(dst_tex, dst_subresource, dst_tex->planes, D3D12_RESOURCE_STATE_RESOLVE_DEST);

		resolves[num_resolves].src_res = src_tex->resource;
		resolves[num_resolves].src_subres = src_subresource;
		resolves[num_resolves].dst_res = dst_tex->resource;
		resolves[num_resolves].dst_subres = dst_subresource;
		resolves[num_resolves].format = d3d12_formats[src_tex->format].general_format;
		num_resolves++;
	}

	_resource_transitions_flush(command_list);

	for (uint32_t i = 0; i < num_resolves; i++) {
		command_list->ResolveSubresource(resolves[i].dst_res, resolves[i].dst_subres, resolves[i].src_res, resolves[i].src_subres, resolves[i].format);
	}
}

RenderingDevice::DrawListID RenderingDeviceD3D12::draw_list_switch_to_next_pass() {
	ERR_FAIL_COND_V(draw_list == nullptr, INVALID_ID);
	ERR_FAIL_COND_V(draw_list_current_subpass >= draw_list_subpass_count - 1, INVALID_FORMAT_ID);

	_draw_list_subpass_end();
	draw_list_current_subpass++;
	_draw_list_subpass_begin();

	Rect2i viewport;
	_draw_list_free(&viewport);

	_draw_list_allocate(viewport, 0, draw_list_current_subpass);

	return int64_t(ID_TYPE_DRAW_LIST) << ID_BASE_SHIFT;
}

Error RenderingDeviceD3D12::draw_list_switch_to_next_pass_split(uint32_t p_splits, DrawListID *r_split_ids) {
	ERR_FAIL_COND_V(draw_list == nullptr, ERR_INVALID_PARAMETER);
	ERR_FAIL_COND_V(draw_list_current_subpass >= draw_list_subpass_count - 1, ERR_INVALID_PARAMETER);

	_draw_list_subpass_end();
	draw_list_current_subpass++;
	_draw_list_subpass_begin();

	Rect2i viewport;
	_draw_list_free(&viewport);

	_draw_list_allocate(viewport, p_splits, draw_list_current_subpass);

	for (uint32_t i = 0; i < p_splits; i++) {
		r_split_ids[i] = (int64_t(ID_TYPE_SPLIT_DRAW_LIST) << ID_BASE_SHIFT) + i;
	}

	return OK;
}

Error RenderingDeviceD3D12::_draw_list_allocate(const Rect2i &p_viewport, uint32_t p_splits, uint32_t p_subpass) {
	if (p_splits == 0) {
		draw_list = memnew(DrawList);
		draw_list->command_list = frames[frame].draw_command_list.Get();
		draw_list->viewport = p_viewport;
		draw_list_count = 0;
		draw_list_split = false;
	} else {
		if (p_splits > (uint32_t)split_draw_list_allocators.size()) {
			uint32_t from = split_draw_list_allocators.size();
			split_draw_list_allocators.resize(p_splits);
			for (uint32_t i = from; i < p_splits; i++) {
				HRESULT res = device->CreateCommandAllocator(D3D12_COMMAND_LIST_TYPE_BUNDLE, IID_PPV_ARGS(&split_draw_list_allocators.write[i].command_allocator));
				ERR_FAIL_COND_V_MSG(res, ERR_CANT_CREATE, "CreateCommandAllocator failed with error " + vformat("0x%08x", res) + ".");

				for (int j = 0; j < frame_count; j++) {
					ID3D12GraphicsCommandList *command_list = nullptr;

					res = device->CreateCommandList(0, D3D12_COMMAND_LIST_TYPE_BUNDLE, split_draw_list_allocators[i].command_allocator, nullptr, IID_PPV_ARGS(&command_list));
					ERR_FAIL_COND_V_MSG(res, ERR_CANT_CREATE, "CreateCommandList failed with error " + vformat("0x%08x", res) + ".");

					split_draw_list_allocators.write[i].command_lists.push_back(command_list);
				}
			}
		}
		draw_list = memnew_arr(DrawList, p_splits);
		draw_list_count = p_splits;
		draw_list_split = true;

		for (uint32_t i = 0; i < p_splits; i++) {
			ID3D12GraphicsCommandList *command_list = split_draw_list_allocators[i].command_lists[frame];

			HRESULT res = frames[frame].setup_command_allocator->Reset();
			ERR_FAIL_COND_V_MSG(ERR_CANT_CREATE, ERR_CANT_CREATE, "Command allocator Reset failed with error " + vformat("0x%08x", res) + ".");
			res = command_list->Reset(split_draw_list_allocators[i].command_allocator, nullptr);
			if (res) {
				memdelete_arr(draw_list);
				draw_list = nullptr;
				ERR_FAIL_V_MSG(ERR_CANT_CREATE, "Command allocator Reset failed with error " + vformat("0x%08x", res) + ".");
			}

			draw_list[i].command_list = command_list;
			draw_list[i].viewport = p_viewport;
		}
	}

	return OK;
}

void RenderingDeviceD3D12::_draw_list_free(Rect2i *r_last_viewport) {
	if (draw_list_split) {
		// Send all command buffers.
		for (uint32_t i = 0; i < draw_list_count; i++) {
			draw_list[i].command_list->Close();
			frames[frame].draw_command_list->ExecuteBundle(draw_list[i].command_list);
			if (r_last_viewport) {
				if (i == 0 || draw_list[i].viewport_set) {
					*r_last_viewport = draw_list[i].viewport;
				}
			}
		}

		memdelete_arr(draw_list);
		draw_list = nullptr;

	} else {
		if (r_last_viewport) {
			*r_last_viewport = draw_list->viewport;
		}
		// Just end the list.
		memdelete(draw_list);
		draw_list = nullptr;
	}

	draw_list_count = 0;
}

void RenderingDeviceD3D12::draw_list_end(BitField<BarrierMask> p_post_barrier) {
	_THREAD_SAFE_METHOD_

	ERR_FAIL_COND_MSG(!draw_list, "Immediate draw list is already inactive.");

	_draw_list_subpass_end();

	const FramebufferFormat &fb_format = framebuffer_formats[draw_list_framebuffer->format_id];
	bool is_screen = draw_list_framebuffer->window_id != DisplayServer::INVALID_WINDOW_ID;

	ID3D12GraphicsCommandList *command_list = frames[frame].draw_command_list.Get();

	for (int i = 0; i < fb_format.attachments.size(); i++) {
		Texture *texture = nullptr;
		if (!is_screen) {
			texture = texture_owner.get_or_null(draw_list_framebuffer->texture_ids[i]);
		}
		if ((fb_format.attachments[i].usage_flags & TEXTURE_USAGE_COLOR_ATTACHMENT_BIT)) {
			switch (draw_list_final_color_action) {
				case FINAL_ACTION_READ: {
					// Nothing to do now.
				} break;
				case FINAL_ACTION_DISCARD: {
					ID3D12Resource *resource = is_screen ? context->window_get_framebuffer_texture(draw_list_framebuffer->window_id) : texture->resource;
					command_list->DiscardResource(resource, nullptr);
				} break;
				case FINAL_ACTION_CONTINUE: {
					ERR_FAIL_COND(draw_list_unbind_color_textures); // Bug!
				} break;
			}
		} else if ((fb_format.attachments[i].usage_flags & TEXTURE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT)) {
			ERR_FAIL_COND(is_screen); // Bug!
			switch (draw_list_final_depth_action) {
				case FINAL_ACTION_READ: {
					// Nothing to do now.
				} break;
				case FINAL_ACTION_DISCARD: {
					ID3D12Resource *resource = is_screen ? context->window_get_framebuffer_texture(draw_list_framebuffer->window_id) : texture->resource;
					command_list->DiscardResource(resource, nullptr);
				} break;
				case FINAL_ACTION_CONTINUE: {
					ERR_FAIL_COND(draw_list_unbind_depth_textures); // Bug!
				} break;
			}
		}
	}

	draw_list_subpass_count = 0;
	draw_list_current_subpass = 0;
	draw_list_framebuffer = nullptr;

	_draw_list_free();

	for (int i = 0; i < draw_list_bound_textures.size(); i++) {
		Texture *texture = texture_owner.get_or_null(draw_list_bound_textures[i]);
		ERR_CONTINUE(!texture); // Wtf.
		if (draw_list_unbind_color_textures && (texture->usage_flags & TEXTURE_USAGE_COLOR_ATTACHMENT_BIT)) {
			texture->bound = false;
		}
		if (draw_list_unbind_depth_textures && (texture->usage_flags & TEXTURE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT)) {
			texture->bound = false;
		}
	}
	draw_list_bound_textures.clear();
}

/***********************/
/**** COMPUTE LISTS ****/
/***********************/

RenderingDevice::ComputeListID RenderingDeviceD3D12::compute_list_begin(bool p_allow_draw_overlap) {
	ERR_FAIL_COND_V_MSG(!p_allow_draw_overlap && draw_list != nullptr, INVALID_ID, "Only one draw list can be active at the same time.");
	ERR_FAIL_COND_V_MSG(compute_list != nullptr, INVALID_ID, "Only one draw/compute list can be active at the same time.");

	compute_list = memnew(ComputeList);
	compute_list->command_list = frames[frame].draw_command_list.Get();
	compute_list->state.allow_draw_overlap = p_allow_draw_overlap;

	return ID_TYPE_COMPUTE_LIST;
}

void RenderingDeviceD3D12::compute_list_bind_compute_pipeline(ComputeListID p_list, RID p_compute_pipeline) {
	ERR_FAIL_COND(p_list != ID_TYPE_COMPUTE_LIST);
	ERR_FAIL_COND(!compute_list);

	ComputeList *cl = compute_list;

	const ComputePipeline *pipeline = compute_pipeline_owner.get_or_null(p_compute_pipeline);
	ERR_FAIL_COND(!pipeline);

	if (p_compute_pipeline == cl->state.pipeline) {
		return; // Redundant state, return.
	}

	cl->state.pipeline = p_compute_pipeline;
	cl->state.pso = pipeline->pso.Get();

	Shader *shader = shader_owner.get_or_null(pipeline->shader);

	if (cl->state.pipeline_shader != pipeline->shader) {
		if (cl->state.root_signature_crc != pipeline->root_signature_crc) {
			cl->command_list->SetComputeRootSignature(shader->root_signature.Get());
			cl->state.root_signature_crc = pipeline->root_signature_crc;
			// Root signature changed, so current descriptor set bindings become invalid.
			for (uint32_t i = 0; i < cl->state.set_count; i++) {
				cl->state.sets[i].bound = false;
			}
		}

		const uint32_t *pformats = pipeline->set_formats.ptr(); // Pipeline set formats.
		cl->state.set_count = pipeline->set_formats.size(); // Update set count.
		for (uint32_t i = 0; i < cl->state.set_count; i++) {
			cl->state.sets[i].pipeline_expected_format = pformats[i];
#ifdef DEV_ENABLED
			cl->state.sets[i]._pipeline_expected_format = pformats[i] ? &uniform_set_format_cache_reverse[pformats[i] - 1]->key().uniform_info : nullptr;
#endif
		}

		if (pipeline->spirv_push_constant_size) {
#ifdef DEBUG_ENABLED
			cl->validation.pipeline_push_constant_supplied = false;
#endif
		}

		cl->state.pipeline_shader = pipeline->shader;
		cl->state.pipeline_dxil_push_constant_size = pipeline->dxil_push_constant_size;
		cl->state.pipeline_bindings_id = pipeline->bindings_id;
		cl->state.local_group_size[0] = pipeline->local_group_size[0];
		cl->state.local_group_size[1] = pipeline->local_group_size[1];
		cl->state.local_group_size[2] = pipeline->local_group_size[2];
#ifdef DEV_ENABLED
		cl->state._shader = shader;
#endif
	}

#ifdef DEBUG_ENABLED
	// Update compute pass pipeline info.
	cl->validation.pipeline_active = true;
	cl->validation.pipeline_spirv_push_constant_size = pipeline->spirv_push_constant_size;
#endif
}

void RenderingDeviceD3D12::compute_list_bind_uniform_set(ComputeListID p_list, RID p_uniform_set, uint32_t p_index) {
	ERR_FAIL_COND(p_list != ID_TYPE_COMPUTE_LIST);
	ERR_FAIL_COND(!compute_list);

	ComputeList *cl = compute_list;

#ifdef DEBUG_ENABLED
	ERR_FAIL_COND_MSG(!cl->validation.active, "Submitted Compute Lists can no longer be modified.");
#endif

	UniformSet *uniform_set = uniform_set_owner.get_or_null(p_uniform_set);
	ERR_FAIL_COND(!uniform_set);

	if (p_index > cl->state.set_count) {
		cl->state.set_count = p_index;
	}

	cl->state.sets[p_index].bound = false; // Needs rebind.
	cl->state.sets[p_index].uniform_set_format = uniform_set->format;
	cl->state.sets[p_index].uniform_set = p_uniform_set;
#ifdef DEV_ENABLED
	cl->state.sets[p_index]._uniform_set = uniform_set_owner.get_or_null(p_uniform_set);
#endif
}

void RenderingDeviceD3D12::compute_list_set_push_constant(ComputeListID p_list, const void *p_data, uint32_t p_data_size) {
	ERR_FAIL_COND(p_list != ID_TYPE_COMPUTE_LIST);
	ERR_FAIL_COND(!compute_list);

	ComputeList *cl = compute_list;

#ifdef DEBUG_ENABLED
	ERR_FAIL_COND_MSG(!cl->validation.active, "Submitted Compute Lists can no longer be modified.");
#endif

#ifdef DEBUG_ENABLED
	ERR_FAIL_COND_MSG(p_data_size != cl->validation.pipeline_spirv_push_constant_size,
			"This render pipeline requires (" + itos(cl->validation.pipeline_spirv_push_constant_size) + ") bytes of push constant data, supplied: (" + itos(p_data_size) + ")");
#endif
	if (cl->state.pipeline_dxil_push_constant_size) {
		cl->command_list->SetComputeRoot32BitConstants(0, p_data_size / sizeof(uint32_t), p_data, 0);
	}
#ifdef DEBUG_ENABLED
	cl->validation.pipeline_push_constant_supplied = true;
#endif
}

void RenderingDeviceD3D12::compute_list_dispatch(ComputeListID p_list, uint32_t p_x_groups, uint32_t p_y_groups, uint32_t p_z_groups) {
	ERR_FAIL_COND(p_list != ID_TYPE_COMPUTE_LIST);
	ERR_FAIL_COND(!compute_list);

	ComputeList *cl = compute_list;

#ifdef DEBUG_ENABLED
	ERR_FAIL_COND_MSG(p_x_groups == 0, "Dispatch amount of X compute groups (" + itos(p_x_groups) + ") is zero.");
	ERR_FAIL_COND_MSG(p_z_groups == 0, "Dispatch amount of Z compute groups (" + itos(p_z_groups) + ") is zero.");
	ERR_FAIL_COND_MSG(p_y_groups == 0, "Dispatch amount of Y compute groups (" + itos(p_y_groups) + ") is zero.");
	ERR_FAIL_COND_MSG(p_x_groups > D3D12_CS_DISPATCH_MAX_THREAD_GROUPS_PER_DIMENSION,
			"Dispatch amount of X compute groups (" + itos(p_x_groups) + ") is larger than device limit (" + itos(D3D12_CS_DISPATCH_MAX_THREAD_GROUPS_PER_DIMENSION) + ")");
	ERR_FAIL_COND_MSG(p_y_groups > D3D12_CS_DISPATCH_MAX_THREAD_GROUPS_PER_DIMENSION,
			"Dispatch amount of Y compute groups (" + itos(p_x_groups) + ") is larger than device limit (" + itos(D3D12_CS_DISPATCH_MAX_THREAD_GROUPS_PER_DIMENSION) + ")");
	ERR_FAIL_COND_MSG(p_z_groups > D3D12_CS_DISPATCH_MAX_THREAD_GROUPS_PER_DIMENSION,
			"Dispatch amount of Z compute groups (" + itos(p_x_groups) + ") is larger than device limit (" + itos(D3D12_CS_DISPATCH_MAX_THREAD_GROUPS_PER_DIMENSION) + ")");

	ERR_FAIL_COND_MSG(!cl->validation.active, "Submitted Compute Lists can no longer be modified.");
#endif

#ifdef DEBUG_ENABLED

	ERR_FAIL_COND_MSG(!cl->validation.pipeline_active, "No compute pipeline was set before attempting to draw.");

	if (cl->validation.pipeline_spirv_push_constant_size) {
		// Using push constants, check that they were supplied.
		ERR_FAIL_COND_MSG(!cl->validation.pipeline_push_constant_supplied,
				"The shader in this pipeline requires a push constant to be set before drawing, but it's not present.");
	}

#endif

	// Bind descriptor sets.
	Shader *shader = shader_owner.get_or_null(cl->state.pipeline_shader);
	struct SetToBind {
		uint32_t set;
		UniformSet *uniform_set;
		const Shader::Set *shader_set;
	};
	SetToBind *sets_to_bind = (SetToBind *)alloca(sizeof(SetToBind) * cl->state.set_count);
	uint32_t num_sets_to_bind = 0;
	for (uint32_t i = 0; i < cl->state.set_count; i++) {
		if (cl->state.sets[i].pipeline_expected_format == 0) {
			continue; // Nothing expected by this pipeline.
		}
#ifdef DEBUG_ENABLED
		if (cl->state.sets[i].pipeline_expected_format != cl->state.sets[i].uniform_set_format) {
			if (cl->state.sets[i].uniform_set_format == 0) {
				ERR_FAIL_MSG("Uniforms were never supplied for set (" + itos(i) + ") at the time of drawing, which are required by the pipeline");
			} else if (uniform_set_owner.owns(cl->state.sets[i].uniform_set)) {
				UniformSet *us = uniform_set_owner.get_or_null(cl->state.sets[i].uniform_set);
				ERR_FAIL_MSG("Uniforms supplied for set (" + itos(i) + "):\n" + _shader_uniform_debug(us->shader_id, us->shader_set) + "\nare not the same format as required by the pipeline shader. Pipeline shader requires the following bindings:\n" + _shader_uniform_debug(cl->state.pipeline_shader));
			} else {
				ERR_FAIL_MSG("Uniforms supplied for set (" + itos(i) + ", which was was just freed) are not the same format as required by the pipeline shader. Pipeline shader requires the following bindings:\n" + _shader_uniform_debug(cl->state.pipeline_shader));
			}
		}
#endif
		UniformSet *uniform_set = uniform_set_owner.get_or_null(cl->state.sets[i].uniform_set);
		const Shader::Set &shader_set = shader->sets[i];
		_apply_uniform_set_resource_states(uniform_set, shader_set);
		if (!cl->state.sets[i].bound) {
			sets_to_bind[num_sets_to_bind].set = i;
			sets_to_bind[num_sets_to_bind].uniform_set = uniform_set;
			sets_to_bind[num_sets_to_bind].shader_set = &shader_set;
			num_sets_to_bind++;
			cl->state.sets[i].bound = true;
		}
	}

	_resource_transitions_flush(cl->command_list);

	for (uint32_t i = 0; i < num_sets_to_bind; i++) {
		_bind_uniform_set(sets_to_bind[i].uniform_set, *sets_to_bind[i].shader_set, pipeline_bindings[cl->state.pipeline_bindings_id][sets_to_bind[i].set], cl->command_list, true);
	}

	if (cl->state.bound_pso != cl->state.pso) {
		cl->command_list->SetPipelineState(cl->state.pso);
		cl->state.bound_pso = cl->state.pso;
	}
	cl->command_list->Dispatch(p_x_groups, p_y_groups, p_z_groups);
}

void RenderingDeviceD3D12::compute_list_dispatch_threads(ComputeListID p_list, uint32_t p_x_threads, uint32_t p_y_threads, uint32_t p_z_threads) {
	ERR_FAIL_COND(p_list != ID_TYPE_COMPUTE_LIST);
	ERR_FAIL_COND(!compute_list);

#ifdef DEBUG_ENABLED
	ERR_FAIL_COND_MSG(p_x_threads == 0, "Dispatch amount of X compute threads (" + itos(p_x_threads) + ") is zero.");
	ERR_FAIL_COND_MSG(p_y_threads == 0, "Dispatch amount of Y compute threads (" + itos(p_y_threads) + ") is zero.");
	ERR_FAIL_COND_MSG(p_z_threads == 0, "Dispatch amount of Z compute threads (" + itos(p_z_threads) + ") is zero.");
#endif

	ComputeList *cl = compute_list;

#ifdef DEBUG_ENABLED

	ERR_FAIL_COND_MSG(!cl->validation.pipeline_active, "No compute pipeline was set before attempting to draw.");

	if (cl->validation.pipeline_spirv_push_constant_size) {
		// Using push constants, check that they were supplied.
		ERR_FAIL_COND_MSG(!cl->validation.pipeline_push_constant_supplied,
				"The shader in this pipeline requires a push constant to be set before drawing, but it's not present.");
	}

#endif

	compute_list_dispatch(p_list, (p_x_threads - 1) / cl->state.local_group_size[0] + 1, (p_y_threads - 1) / cl->state.local_group_size[1] + 1, (p_z_threads - 1) / cl->state.local_group_size[2] + 1);
}

void RenderingDeviceD3D12::compute_list_dispatch_indirect(ComputeListID p_list, RID p_buffer, uint32_t p_offset) {
	ERR_FAIL_COND(p_list != ID_TYPE_COMPUTE_LIST);
	ERR_FAIL_COND(!compute_list);

	ComputeList *cl = compute_list;
	Buffer *buffer = storage_buffer_owner.get_or_null(p_buffer);
	ERR_FAIL_COND(!buffer);

	ERR_FAIL_COND_MSG(!(buffer->usage & D3D12_RESOURCE_STATE_INDIRECT_ARGUMENT), "Buffer provided was not created to do indirect dispatch.");

	ERR_FAIL_COND_MSG(p_offset + 12 > buffer->size, "Offset provided (+12) is past the end of buffer.");

#ifdef DEBUG_ENABLED

	ERR_FAIL_COND_MSG(!cl->validation.pipeline_active, "No compute pipeline was set before attempting to draw.");

	if (cl->validation.pipeline_spirv_push_constant_size) {
		// Using push constants, check that they were supplied.
		ERR_FAIL_COND_MSG(!cl->validation.pipeline_push_constant_supplied,
				"The shader in this pipeline requires a push constant to be set before drawing, but it's not present.");
	}

#endif

	// Bind descriptor sets.

	Shader *shader = shader_owner.get_or_null(cl->state.pipeline_shader);
	struct SetToBind {
		uint32_t set;
		UniformSet *uniform_set;
		const Shader::Set *shader_set;
	};
	SetToBind *sets_to_bind = (SetToBind *)alloca(sizeof(SetToBind) * cl->state.set_count);
	uint32_t num_sets_to_bind = 0;
	for (uint32_t i = 0; i < cl->state.set_count; i++) {
		if (cl->state.sets[i].pipeline_expected_format == 0) {
			continue; // Nothing expected by this pipeline.
		}
#ifdef DEBUG_ENABLED
		if (cl->state.sets[i].pipeline_expected_format != cl->state.sets[i].uniform_set_format) {
			if (cl->state.sets[i].uniform_set_format == 0) {
				ERR_FAIL_MSG("Uniforms were never supplied for set (" + itos(i) + ") at the time of drawing, which are required by the pipeline");
			} else if (uniform_set_owner.owns(cl->state.sets[i].uniform_set)) {
				UniformSet *us = uniform_set_owner.get_or_null(cl->state.sets[i].uniform_set);
				ERR_FAIL_MSG("Uniforms supplied for set (" + itos(i) + "):\n" + _shader_uniform_debug(us->shader_id, us->shader_set) + "\nare not the same format as required by the pipeline shader. Pipeline shader requires the following bindings:\n" + _shader_uniform_debug(cl->state.pipeline_shader));
			} else {
				ERR_FAIL_MSG("Uniforms supplied for set (" + itos(i) + ", which was was just freed) are not the same format as required by the pipeline shader. Pipeline shader requires the following bindings:\n" + _shader_uniform_debug(cl->state.pipeline_shader));
			}
		}
#endif
		UniformSet *uniform_set = uniform_set_owner.get_or_null(cl->state.sets[i].uniform_set);
		const Shader::Set &shader_set = shader->sets[i];
		_apply_uniform_set_resource_states(uniform_set, shader_set);
		if (!cl->state.sets[i].bound) {
			sets_to_bind[num_sets_to_bind].set = i;
			sets_to_bind[num_sets_to_bind].uniform_set = uniform_set;
			sets_to_bind[num_sets_to_bind].shader_set = &shader_set;
			num_sets_to_bind++;
			cl->state.sets[i].bound = true;
		}
	}

	_resource_transition_batch(buffer, 0, 1, D3D12_RESOURCE_STATE_INDIRECT_ARGUMENT);

	_resource_transitions_flush(cl->command_list);

	for (uint32_t i = 0; i < num_sets_to_bind; i++) {
		_bind_uniform_set(sets_to_bind[i].uniform_set, *sets_to_bind[i].shader_set, pipeline_bindings[cl->state.pipeline_bindings_id][sets_to_bind[i].set], cl->command_list, true);
	}

	if (cl->state.bound_pso != cl->state.pso) {
		cl->command_list->SetPipelineState(cl->state.pso);
		cl->state.bound_pso = cl->state.pso;
	}
	cl->command_list->ExecuteIndirect(indirect_dispatch_cmd_sig.Get(), 1, buffer->resource, p_offset, nullptr, 0);
}

void RenderingDeviceD3D12::compute_list_add_barrier(ComputeListID p_list) {
#ifdef FORCE_FULL_BARRIER
	full_barrier();
#else
	// Due to D3D12 resource-wise barriers, this is no op.
#endif
}

void RenderingDeviceD3D12::compute_list_end(BitField<BarrierMask> p_post_barrier) {
	ERR_FAIL_COND(!compute_list);

#ifdef FORCE_FULL_BARRIER
	full_barrier();
#endif

	memdelete(compute_list);
	compute_list = nullptr;
}

void RenderingDeviceD3D12::barrier(BitField<BarrierMask> p_from, BitField<BarrierMask> p_to) {
	// Due to D3D12 resource-wise barriers, this is no op.
}

void RenderingDeviceD3D12::full_barrier() {
#ifndef DEBUG_ENABLED
	ERR_PRINT("Full barrier is debug-only, should not be used in production");
#endif

	// In the resource barriers world, we can force a full barrier by discarding some resource, as per
	// https://microsoft.github.io/DirectX-Specs/d3d/D3D12EnhancedBarriers.html#synchronous-copy-discard-and-resolve.
	frames[frame].draw_command_list->DiscardResource(texture_owner.get_or_null(aux_resource)->resource, nullptr);
}

void RenderingDeviceD3D12::_free_internal(RID p_id) {
#ifdef DEV_ENABLED
	String resource_name;
	if (resource_names.has(p_id)) {
		resource_name = resource_names[p_id];
		resource_names.erase(p_id);
	}
#endif

	// Push everything so it's disposed of next time this frame index is processed (means, it's safe to do it).
	if (texture_owner.owns(p_id)) {
		Texture *texture = texture_owner.get_or_null(p_id);
		frames[frame].textures_to_dispose_of.push_back(*texture);
		texture_owner.free(p_id);
	} else if (framebuffer_owner.owns(p_id)) {
		Framebuffer *framebuffer = framebuffer_owner.get_or_null(p_id);
		frames[frame].framebuffers_to_dispose_of.push_back(*framebuffer);

		if (framebuffer->invalidated_callback != nullptr) {
			framebuffer->invalidated_callback(framebuffer->invalidated_callback_userdata);
		}
		framebuffer_owner.free(p_id);
	} else if (sampler_owner.owns(p_id)) {
		sampler_owner.free(p_id);
	} else if (vertex_buffer_owner.owns(p_id)) {
		Buffer *vertex_buffer = vertex_buffer_owner.get_or_null(p_id);
		frames[frame].buffers_to_dispose_of.push_back(*vertex_buffer);
		vertex_buffer_owner.free(p_id);
	} else if (vertex_array_owner.owns(p_id)) {
		vertex_array_owner.free(p_id);
	} else if (index_buffer_owner.owns(p_id)) {
		IndexBuffer *index_buffer = index_buffer_owner.get_or_null(p_id);
		frames[frame].buffers_to_dispose_of.push_back(*index_buffer);
		index_buffer_owner.free(p_id);
	} else if (index_array_owner.owns(p_id)) {
		index_array_owner.free(p_id);
	} else if (shader_owner.owns(p_id)) {
		Shader *shader = shader_owner.get_or_null(p_id);
		frames[frame].shaders_to_dispose_of.push_back(*shader);
		shader_owner.free(p_id);
	} else if (uniform_buffer_owner.owns(p_id)) {
		Buffer *uniform_buffer = uniform_buffer_owner.get_or_null(p_id);
		frames[frame].buffers_to_dispose_of.push_back(*uniform_buffer);
		uniform_buffer_owner.free(p_id);
	} else if (texture_buffer_owner.owns(p_id)) {
		TextureBuffer *texture_buffer = texture_buffer_owner.get_or_null(p_id);
		frames[frame].buffers_to_dispose_of.push_back(texture_buffer->buffer);
		texture_buffer_owner.free(p_id);
	} else if (storage_buffer_owner.owns(p_id)) {
		Buffer *storage_buffer = storage_buffer_owner.get_or_null(p_id);
		frames[frame].buffers_to_dispose_of.push_back(*storage_buffer);
		storage_buffer_owner.free(p_id);
	} else if (uniform_set_owner.owns(p_id)) {
		UniformSet *uniform_set = uniform_set_owner.get_or_null(p_id);
		uniform_set_owner.free(p_id);

		if (uniform_set->invalidated_callback != nullptr) {
			uniform_set->invalidated_callback(uniform_set->invalidated_callback_userdata);
		}
	} else if (render_pipeline_owner.owns(p_id)) {
		RenderPipeline *pipeline = render_pipeline_owner.get_or_null(p_id);
		frames[frame].render_pipelines_to_dispose_of.push_back(*pipeline);
		render_pipeline_owner.free(p_id);
	} else if (compute_pipeline_owner.owns(p_id)) {
		ComputePipeline *pipeline = compute_pipeline_owner.get_or_null(p_id);
		frames[frame].compute_pipelines_to_dispose_of.push_back(*pipeline);
		compute_pipeline_owner.free(p_id);
	} else {
#ifdef DEV_ENABLED
		ERR_PRINT("Attempted to free invalid ID: " + itos(p_id.get_id()) + " " + resource_name);
#else
		ERR_PRINT("Attempted to free invalid ID: " + itos(p_id.get_id()));
#endif
	}
}

void RenderingDeviceD3D12::free(RID p_id) {
	_THREAD_SAFE_METHOD_

	_free_dependencies(p_id); // Recursively erase dependencies first, to avoid potential API problems.
	_free_internal(p_id);
}

void RenderingDeviceD3D12::set_resource_name(RID p_id, const String p_name) {
	if (texture_owner.owns(p_id)) {
		Texture *texture = texture_owner.get_or_null(p_id);
		if (texture->owner.is_null()) {
			// Don't set the source texture's name when calling on a texture view.
			context->set_object_name(texture->resource, p_name);
		} else {
			context->set_object_name(texture->resource, p_name + " View");
		}
	} else if (framebuffer_owner.owns(p_id)) {
		// No D3D12 object to name.
	} else if (sampler_owner.owns(p_id)) {
		// No D3D12 object to name.
	} else if (shader_owner.owns(p_id)) {
		Shader *shader = shader_owner.get_or_null(p_id);
		context->set_object_name(shader->root_signature.Get(), p_name + " Root Signature");
	} else if (uniform_set_owner.owns(p_id)) {
		// No D3D12 object to name.
	} else if (render_pipeline_owner.owns(p_id)) {
		RenderPipeline *pipeline = render_pipeline_owner.get_or_null(p_id);
		context->set_object_name(pipeline->pso.Get(), p_name);
	} else if (compute_pipeline_owner.owns(p_id)) {
		ComputePipeline *pipeline = compute_pipeline_owner.get_or_null(p_id);
		context->set_object_name(pipeline->pso.Get(), p_name);
	} else {
		Buffer *buffer = _get_buffer_from_owner(p_id);
		if (buffer) {
			context->set_object_name(buffer->resource, p_name);
		} else {
			ERR_PRINT("Attempted to name invalid ID: " + itos(p_id.get_id()));
			return;
		}
	}
#ifdef DEV_ENABLED
	resource_names[p_id] = p_name;
#endif
}

void RenderingDeviceD3D12::draw_command_begin_label(String p_label_name, const Color p_color) {
	context->command_begin_label(frames[frame].draw_command_list.Get(), p_label_name, p_color);
}

void RenderingDeviceD3D12::draw_command_insert_label(String p_label_name, const Color p_color) {
	context->command_insert_label(frames[frame].draw_command_list.Get(), p_label_name, p_color);
}

void RenderingDeviceD3D12::draw_command_end_label() {
	context->command_end_label(frames[frame].draw_command_list.Get());
}

String RenderingDeviceD3D12::get_device_vendor_name() const {
	return context->get_device_vendor_name();
}

String RenderingDeviceD3D12::get_device_name() const {
	return context->get_device_name();
}

RenderingDevice::DeviceType RenderingDeviceD3D12::get_device_type() const {
	return context->get_device_type();
}

String RenderingDeviceD3D12::get_device_api_version() const {
	return context->get_device_api_version();
}

String RenderingDeviceD3D12::get_device_pipeline_cache_uuid() const {
	return context->get_device_pipeline_cache_uuid();
}

void RenderingDeviceD3D12::_finalize_command_bufers() {
	if (draw_list) {
		ERR_PRINT("Found open draw list at the end of the frame, this should never happen (further drawing will likely not work).");
	}

	if (compute_list) {
		ERR_PRINT("Found open compute list at the end of the frame, this should never happen (further compute will likely not work).");
	}

	{ // Complete the setup buffer (that needs to be processed before anything else).
		frames[frame].setup_command_list->Close();
		frames[frame].draw_command_list->Close();
	}
}

void RenderingDeviceD3D12::_begin_frame() {
	// Erase pending resources.
	_free_pending_resources(frame);

	HRESULT res = frames[frame].setup_command_allocator->Reset();
	ERR_FAIL_COND_MSG(res, "Command allocator Reset failed with error " + vformat("0x%08x", res) + ".");
	res = frames[frame].setup_command_list->Reset(frames[frame].setup_command_allocator.Get(), nullptr);
	ERR_FAIL_COND_MSG(res, "Command list Reset failed with error " + vformat("0x%08x", res) + ".");
	res = frames[frame].draw_command_allocator->Reset();
	ERR_FAIL_COND_MSG(res, "Command allocator Reset failed with error " + vformat("0x%08x", res) + ".");
	res = frames[frame].draw_command_list->Reset(frames[frame].draw_command_allocator.Get(), nullptr);
	ERR_FAIL_COND_MSG(res, "Command list Reset failed with error " + vformat("0x%08x", res) + ".");

	ID3D12DescriptorHeap *heaps[] = {
		frames[frame].desc_heaps.resources.get_heap(),
		frames[frame].desc_heaps.samplers.get_heap(),
	};
	frames[frame].draw_command_list->SetDescriptorHeaps(2, heaps);

	frames[frame].desc_heap_walkers.resources.rewind();
	frames[frame].desc_heap_walkers.samplers.rewind();
	frames[frame].desc_heap_walkers.aux.rewind();
	frames[frame].desc_heap_walkers.rtv.rewind();
	frames[frame].desc_heaps_exhausted_reported = {};
	frames[frame].null_rtv_handle = {};

#ifdef DEBUG_COUNT_BARRIERS
	print_verbose(vformat("Last frame: %d barriers (%d batches); %.1f ms", frame_barriers_count, frame_barriers_batches_count, frame_barriers_cpu_time * 0.001f));
	frame_barriers_count = 0;
	frame_barriers_batches_count = 0;
	frame_barriers_cpu_time = 0;
#endif

	if (local_device.is_null()) {
		context->append_command_list(frames[frame].draw_command_list.Get());
		context->set_setup_list(frames[frame].setup_command_list.Get()); // Append now so it's added before everything else.
	}

	// Advance current frame.
	frames_drawn++;
	// Advance staging buffer if used.
	if (staging_buffer_used) {
		staging_buffer_current = (staging_buffer_current + 1) % staging_buffer_blocks.size();
		staging_buffer_used = false;
	}

	allocator->SetCurrentFrameIndex(Engine::get_singleton()->get_frames_drawn());
	if (frames[frame].timestamp_count) {
		frames[frame].setup_command_list->ResolveQueryData(frames[frame].timestamp_heap.Get(), D3D12_QUERY_TYPE_TIMESTAMP, 0, frames[frame].timestamp_count, frames[frame].timestamp_result_values_buffer.resource, 0);
		uint64_t *gpu_timestamps = nullptr;
		res = frames[frame].timestamp_result_values_buffer.resource->Map(0, nullptr, (void **)&gpu_timestamps);
		if (SUCCEEDED(res)) {
			memcpy(frames[frame].timestamp_result_values.ptr(), gpu_timestamps, sizeof(uint64_t) * frames[frame].timestamp_count);
			frames[frame].timestamp_result_values_buffer.resource->Unmap(0, nullptr);
		}
		SWAP(frames[frame].timestamp_names, frames[frame].timestamp_result_names);
		SWAP(frames[frame].timestamp_cpu_values, frames[frame].timestamp_cpu_result_values);
	}

	frames[frame].timestamp_result_count = frames[frame].timestamp_count;
	frames[frame].timestamp_count = 0;
	frames[frame].index = Engine::get_singleton()->get_frames_drawn();
	frames[frame].execution_index = execution_index;
#ifdef DEV_ENABLED
	frames[frame].uniform_set_reused = 0;
#endif
}

void RenderingDeviceD3D12::swap_buffers() {
	ERR_FAIL_COND_MSG(local_device.is_valid(), "Local devices can't swap buffers.");
	_THREAD_SAFE_METHOD_

	context->postpare_buffers(frames[frame].draw_command_list.Get());
	screen_prepared = false;

	_finalize_command_bufers();

	context->swap_buffers();
	execution_index++;

	frame = (frame + 1) % frame_count;

	_begin_frame();
}

void RenderingDeviceD3D12::submit() {
	ERR_FAIL_COND_MSG(local_device.is_null(), "Only local devices can submit and sync.");
	ERR_FAIL_COND_MSG(local_device_processing, "device already submitted, call sync to wait until done.");

	_finalize_command_bufers();

	ID3D12CommandList *command_lists[2] = { frames[frame].setup_command_list.Get(), frames[frame].draw_command_list.Get() };
	context->local_device_push_command_lists(local_device, command_lists, 2);
	execution_index++;

	local_device_processing = true;
}

void RenderingDeviceD3D12::sync() {
	ERR_FAIL_COND_MSG(local_device.is_null(), "Only local devices can submit and sync.");
	ERR_FAIL_COND_MSG(!local_device_processing, "sync can only be called after a submit");

	context->local_device_sync(local_device);
	_begin_frame();
	local_device_processing = false;
}

#ifdef USE_SMALL_ALLOCS_POOL
D3D12MA::Pool *RenderingDeviceD3D12::_find_or_create_small_allocs_pool(D3D12_HEAP_TYPE p_heap_type, D3D12_HEAP_FLAGS p_heap_flags) {
	D3D12_HEAP_FLAGS effective_heap_flags = p_heap_flags;
	if (allocator->GetD3D12Options().ResourceHeapTier != D3D12_RESOURCE_HEAP_TIER_1) {
		// Heap tier 2 allows mixing resource types liberally.
		effective_heap_flags &= ~(D3D12_HEAP_FLAG_ALLOW_ONLY_BUFFERS | D3D12_HEAP_FLAG_ALLOW_ONLY_NON_RT_DS_TEXTURES | D3D12_HEAP_FLAG_ALLOW_ONLY_RT_DS_TEXTURES);
	}

	AllocPoolKey pool_key;
	pool_key.heap_type = p_heap_type;
	pool_key.heap_flags = effective_heap_flags;
	if (small_allocs_pools.has(pool_key.key)) {
		return small_allocs_pools[pool_key.key].Get();
	}

#ifdef DEV_ENABLED
	print_verbose("Creating D3D12MA small objects pool for heap type " + itos(p_heap_type) + " and heap flags " + itos(p_heap_flags));
#endif

	D3D12MA::POOL_DESC poolDesc = {};
	poolDesc.HeapProperties.Type = p_heap_type;
	poolDesc.HeapFlags = effective_heap_flags;

	ComPtr<D3D12MA::Pool> pool;
	HRESULT res = allocator->CreatePool(&poolDesc, pool.GetAddressOf());
	small_allocs_pools[pool_key.key] = pool; // Don't try to create it again if failed the first time.
	ERR_FAIL_COND_V_MSG(res, nullptr, "CreatePool failed with error " + vformat("0x%08x", res) + ".");

	return pool.Get();
}
#endif

void RenderingDeviceD3D12::_free_pending_resources(int p_frame) {
	// Free in dependency usage order, so nothing weird happens.
	// Pipelines.
	while (frames[p_frame].render_pipelines_to_dispose_of.front()) {
		RenderPipeline *rp = &frames[p_frame].render_pipelines_to_dispose_of.front()->get();
		pipeline_bindings.erase(rp->bindings_id);
		frames[p_frame].render_pipelines_to_dispose_of.pop_front();
	}
	while (frames[p_frame].compute_pipelines_to_dispose_of.front()) {
		ComputePipeline *cp = &frames[p_frame].compute_pipelines_to_dispose_of.front()->get();
		pipeline_bindings.erase(cp->bindings_id);
		frames[p_frame].compute_pipelines_to_dispose_of.pop_front();
	}

	// Shaders.
	frames[p_frame].shaders_to_dispose_of.clear();

	// Framebuffers.
	frames[p_frame].framebuffers_to_dispose_of.clear();

	// Textures.
	while (frames[p_frame].textures_to_dispose_of.front()) {
		Texture *texture = &frames[p_frame].textures_to_dispose_of.front()->get();

		if (texture->bound) {
			WARN_PRINT("Deleted a texture while it was bound.");
		}
		if (texture->owner.is_null()) {
			// Actually owns the image and the allocation too.
			image_memory -= texture->allocation->GetSize();
			for (uint32_t i = 0; i < texture->aliases.size(); i++) {
				if (texture->aliases[i]) {
					texture->aliases[i]->Release();
				}
			}
			texture->resource->Release();
			texture->resource = nullptr;
			texture->allocation->Release();
			texture->allocation = nullptr;
		}
		frames[p_frame].textures_to_dispose_of.pop_front();
	}

	// Buffers.
	while (frames[p_frame].buffers_to_dispose_of.front()) {
		_buffer_free(&frames[p_frame].buffers_to_dispose_of.front()->get());

		frames[p_frame].buffers_to_dispose_of.pop_front();
	}
}

void RenderingDeviceD3D12::prepare_screen_for_drawing() {
	_THREAD_SAFE_METHOD_
	context->prepare_buffers(frames[frame].draw_command_list.Get());
	screen_prepared = true;
}

uint32_t RenderingDeviceD3D12::get_frame_delay() const {
	return frame_count;
}

uint64_t RenderingDeviceD3D12::get_memory_usage(MemoryType p_type) const {
	if (p_type == MEMORY_BUFFERS) {
		return buffer_memory;
	} else if (p_type == MEMORY_TEXTURES) {
		return image_memory;
	} else {
		D3D12MA::TotalStatistics stats;
		allocator->CalculateStatistics(&stats);
		return stats.Total.Stats.BlockBytes;
	}
}

void RenderingDeviceD3D12::_flush(bool p_flush_current_frame) {
	if (local_device.is_valid() && !p_flush_current_frame) {
		return; // Flushing previous frames has no effect with local device.
	}

	if (p_flush_current_frame) {
		frames[frame].setup_command_list->Close();
		frames[frame].draw_command_list->Close();
	}

	if (local_device.is_valid()) {
		ID3D12CommandList *command_lists[2] = { frames[frame].setup_command_list.Get(), frames[frame].draw_command_list.Get() };
		context->local_device_push_command_lists(local_device, command_lists, 2);
		execution_index++;
		context->local_device_sync(local_device);

		HRESULT res = frames[frame].setup_command_allocator->Reset();
		ERR_FAIL_COND_MSG(res, "Command allocator Reset failed with error " + vformat("0x%08x", res) + ".");
		res = frames[frame].setup_command_list->Reset(frames[frame].setup_command_allocator.Get(), nullptr);
		ERR_FAIL_COND_MSG(res, "Command allocator Reset failed with error " + vformat("0x%08x", res) + ".");
		res = frames[frame].draw_command_allocator->Reset();
		ERR_FAIL_COND_MSG(res, "Command allocator Reset failed with error " + vformat("0x%08x", res) + ".");
		res = frames[frame].draw_command_list->Reset(frames[frame].draw_command_allocator.Get(), nullptr);
		ERR_FAIL_COND_MSG(res, "Command allocator Reset failed with error " + vformat("0x%08x", res) + ".");

		ID3D12DescriptorHeap *heaps[] = {
			frames[frame].desc_heaps.resources.get_heap(),
			frames[frame].desc_heaps.samplers.get_heap(),
		};
		frames[frame].draw_command_list->SetDescriptorHeaps(2, heaps);
		frames[frame].desc_heap_walkers.resources.rewind();
		frames[frame].desc_heap_walkers.samplers.rewind();
		frames[frame].desc_heap_walkers.aux.rewind();
		frames[frame].desc_heap_walkers.rtv.rewind();
		frames[frame].desc_heaps_exhausted_reported = {};
		frames[frame].null_rtv_handle = {};
		frames[frame].execution_index = execution_index;
	} else {
		context->flush(p_flush_current_frame, p_flush_current_frame);
		// Re-create the setup command.
		if (p_flush_current_frame) {
			execution_index++;

			HRESULT res = frames[frame].setup_command_allocator->Reset();
			ERR_FAIL_COND_MSG(res, "Command allocator Reset failed with error " + vformat("0x%08x", res) + ".");
			res = frames[frame].draw_command_allocator->Reset();
			ERR_FAIL_COND_MSG(res, "Command allocator Reset failed with error " + vformat("0x%08x", res) + ".");
			res = frames[frame].setup_command_list->Reset(frames[frame].setup_command_allocator.Get(), nullptr);
			ERR_FAIL_COND_MSG(res, "Command list Reset failed with error " + vformat("0x%08x", res) + ".");
			res = frames[frame].draw_command_list->Reset(frames[frame].draw_command_allocator.Get(), nullptr);
			ERR_FAIL_COND_MSG(res, "Command list Reset failed with error " + vformat("0x%08x", res) + ".");

			ID3D12DescriptorHeap *heaps[] = {
				frames[frame].desc_heaps.resources.get_heap(),
				frames[frame].desc_heaps.samplers.get_heap(),
			};
			frames[frame].draw_command_list->SetDescriptorHeaps(2, heaps);

			frames[frame].desc_heap_walkers.resources.rewind();
			frames[frame].desc_heap_walkers.samplers.rewind();
			frames[frame].desc_heap_walkers.aux.rewind();
			frames[frame].desc_heap_walkers.rtv.rewind();
			frames[frame].desc_heaps_exhausted_reported = {};
			frames[frame].null_rtv_handle = {};
			frames[frame].execution_index = execution_index;

			context->set_setup_list(frames[frame].setup_command_list.Get()); // Append now so it's added before everything else.
			context->append_command_list(frames[frame].draw_command_list.Get());
		}
	}
}

void RenderingDeviceD3D12::initialize(D3D12Context *p_context, bool p_local_device) {
	// Get our device capabilities.
	{
		device_capabilities.version_major = p_context->get_feat_level_major();
		device_capabilities.version_minor = p_context->get_feat_level_minor();
	}

	context = p_context;
	device = p_context->get_device();
	if (p_local_device) {
		frame_count = 1;
		local_device = p_context->local_device_create();
		device = p_context->local_device_get_d3d12_device(local_device);
	} else {
		frame_count = p_context->get_swapchain_image_count() + 1;
	}
	limits = p_context->get_device_limits();
	max_timestamp_query_elements = 256;

	{ // Initialize allocator.
		D3D12MA::ALLOCATOR_DESC allocator_desc = {};
		allocator_desc.pDevice = p_context->get_device().Get();
		allocator_desc.pAdapter = p_context->get_adapter().Get();

		HRESULT res = D3D12MA::CreateAllocator(&allocator_desc, &allocator);
		ERR_FAIL_COND_MSG(res, "D3D12MA::CreateAllocator failed with error " + vformat("0x%08x", res) + ".");
	}

	{ // Create command signature for indirect dispatch.
		D3D12_INDIRECT_ARGUMENT_DESC iarg_desc = {};
		iarg_desc.Type = D3D12_INDIRECT_ARGUMENT_TYPE_DISPATCH;
		D3D12_COMMAND_SIGNATURE_DESC cs_desc = {};
		cs_desc.ByteStride = sizeof(D3D12_DISPATCH_ARGUMENTS);
		cs_desc.NumArgumentDescs = 1;
		cs_desc.pArgumentDescs = &iarg_desc;
		cs_desc.NodeMask = 0;
		HRESULT res = device->CreateCommandSignature(&cs_desc, nullptr, IID_PPV_ARGS(indirect_dispatch_cmd_sig.GetAddressOf()));
		ERR_FAIL_COND_MSG(res, "CreateCommandSignature failed with error " + vformat("0x%08x", res) + ".");
	}

	uint32_t resource_descriptors_per_frame = GLOBAL_DEF("rendering/rendering_device/d3d12/max_resource_descriptors_per_frame", 16384);
	uint32_t sampler_descriptors_per_frame = GLOBAL_DEF("rendering/rendering_device/d3d12/max_sampler_descriptors_per_frame", 1024);
	uint32_t misc_descriptors_per_frame = GLOBAL_DEF("rendering/rendering_device/d3d12/max_misc_descriptors_per_frame", 512);

	frames.resize(frame_count);
	frame = 0;
	// Create setup and frame buffers.
	for (int i = 0; i < frame_count; i++) {
		frames[i].index = 0;

		{ // Create descriptor heaps.
			Error err = frames[i].desc_heaps.resources.allocate(device.Get(), D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV, resource_descriptors_per_frame, true);
			ERR_FAIL_COND_MSG(err, "Creating the frame's RESOURCE descriptors heap failed.");

			err = frames[i].desc_heaps.samplers.allocate(device.Get(), D3D12_DESCRIPTOR_HEAP_TYPE_SAMPLER, sampler_descriptors_per_frame, true);
			ERR_FAIL_COND_MSG(err, "Creating the frame's SAMPLER descriptors heap failed.");

			err = frames[i].desc_heaps.aux.allocate(device.Get(), D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV, misc_descriptors_per_frame, false);
			ERR_FAIL_COND_MSG(err, "Creating the frame's AUX descriptors heap failed.");

			err = frames[i].desc_heaps.rtv.allocate(device.Get(), D3D12_DESCRIPTOR_HEAP_TYPE_RTV, misc_descriptors_per_frame, false);
			ERR_FAIL_COND_MSG(err, "Creating the frame's RENDER TARGET descriptors heap failed.");

			frames[i].desc_heap_walkers.resources = frames[i].desc_heaps.resources.make_walker();
			frames[i].desc_heap_walkers.samplers = frames[i].desc_heaps.samplers.make_walker();
			frames[i].desc_heap_walkers.aux = frames[i].desc_heaps.aux.make_walker();
			frames[i].desc_heap_walkers.rtv = frames[i].desc_heaps.rtv.make_walker();
		}

		{ // Create command allocators.
			HRESULT res = device->CreateCommandAllocator(D3D12_COMMAND_LIST_TYPE_DIRECT, IID_PPV_ARGS(frames[i].setup_command_allocator.GetAddressOf()));
			ERR_CONTINUE_MSG(res, "CreateCommandAllocator failed with error " + vformat("0x%08x", res) + ".");

			res = device->CreateCommandAllocator(D3D12_COMMAND_LIST_TYPE_DIRECT, IID_PPV_ARGS(frames[i].draw_command_allocator.GetAddressOf()));
			ERR_CONTINUE_MSG(res, "CreateCommandAllocator failed with error " + vformat("0x%08x", res) + ".");
		}

		{ // Create command lists.
			HRESULT res = device->CreateCommandList(0, D3D12_COMMAND_LIST_TYPE_DIRECT, frames[i].setup_command_allocator.Get(), nullptr, IID_PPV_ARGS(frames[i].setup_command_list.GetAddressOf()));
			ERR_CONTINUE_MSG(res, "CreateCommandList failed with error " + vformat("0x%08x", res) + ".");

			res = device->CreateCommandList(0, D3D12_COMMAND_LIST_TYPE_DIRECT, frames[i].draw_command_allocator.Get(), nullptr, IID_PPV_ARGS(frames[i].draw_command_list.GetAddressOf()));
			ERR_CONTINUE_MSG(res, "CreateCommandList failed with error " + vformat("0x%08x", res) + ".");

			if (i > 0) {
				frames[i].setup_command_list->Close();
				frames[i].draw_command_list->Close();
			}
		}

		if (i == 0) {
			ID3D12DescriptorHeap *heaps[] = {
				frames[frame].desc_heaps.resources.get_heap(),
				frames[frame].desc_heaps.samplers.get_heap(),
			};
			frames[frame].draw_command_list->SetDescriptorHeaps(2, heaps);
		}

		{
			// Create query heap.
			D3D12_QUERY_HEAP_DESC qh_desc = {};
			qh_desc.Type = D3D12_QUERY_HEAP_TYPE_TIMESTAMP;
			qh_desc.Count = max_timestamp_query_elements;
			qh_desc.NodeMask = 0;
			HRESULT res = device->CreateQueryHeap(&qh_desc, IID_PPV_ARGS(frames[i].timestamp_heap.GetAddressOf()));
			ERR_CONTINUE_MSG(res, "CreateQueryHeap failed with error " + vformat("0x%08x", res) + ".");

			frames[i].timestamp_names.resize(max_timestamp_query_elements);
			frames[i].timestamp_cpu_values.resize(max_timestamp_query_elements);
			frames[i].timestamp_count = 0;
			frames[i].timestamp_result_names.resize(max_timestamp_query_elements);
			frames[i].timestamp_cpu_result_values.resize(max_timestamp_query_elements);
			frames[i].timestamp_result_values.resize(max_timestamp_query_elements);
			Error err = _buffer_allocate(&frames[i].timestamp_result_values_buffer, sizeof(uint64_t) * max_timestamp_query_elements, D3D12_RESOURCE_STATE_COMMON, D3D12_HEAP_TYPE_READBACK);
			ERR_CONTINUE(err);
			frames[i].timestamp_result_count = 0;
		}
	}

	if (local_device.is_null()) {
		context->set_setup_list(frames[0].setup_command_list.Get()); // Append now so it's added before everything else.
		context->append_command_list(frames[0].draw_command_list.Get());
	}

	staging_buffer_block_size = GLOBAL_GET("rendering/rendering_device/staging_buffer/block_size_kb");
	staging_buffer_block_size = MAX(4u, staging_buffer_block_size);
	staging_buffer_block_size *= 1024; // Kb -> bytes.
	staging_buffer_max_size = GLOBAL_GET("rendering/rendering_device/staging_buffer/max_size_mb");
	staging_buffer_max_size = MAX(1u, staging_buffer_max_size);
	staging_buffer_max_size *= 1024 * 1024;

	if (staging_buffer_max_size < staging_buffer_block_size * 4) {
		// Validate enough functions.
		staging_buffer_max_size = staging_buffer_block_size * 4;
	}
	texture_upload_region_size_px = GLOBAL_GET("rendering/rendering_device/staging_buffer/texture_upload_region_size_px");
	texture_upload_region_size_px = nearest_power_of_2_templated(texture_upload_region_size_px);

	frames_drawn = frame_count; // Start from frame count, so everything else is immediately old.
	execution_index = 1;

	// Ensure current staging block is valid and at least one per frame exists.
	staging_buffer_current = 0;
	staging_buffer_used = false;

	for (int i = 0; i < frame_count; i++) {
		// Staging was never used, create a block.
		Error err = _insert_staging_block();
		ERR_CONTINUE(err != OK);
	}

	{
		aux_resource = texture_create(TextureFormat(), TextureView());
		ERR_FAIL_COND(!aux_resource.is_valid());
	}

	// Load shader validation library.
	{
		HMODULE dxil_module = LoadLibrary("dxil.dll");
		ERR_FAIL_COND(!dxil_module);
		dxil_DxcCreateInstance = (DxcCreateInstanceProc)GetProcAddress(dxil_module, "DxcCreateInstance");
		ERR_FAIL_COND(!dxil_DxcCreateInstance);
	}

	DxcInitThreadMalloc();
	DxcSetThreadMallocToDefault();

	draw_list = nullptr;
	draw_list_count = 0;
	draw_list_split = false;

	vrs_state_execution_index = 0;
	vrs_state = {};

	compute_list = nullptr;
}

const RenderingDeviceD3D12::DxcObjects &RenderingDeviceD3D12::get_dxc_objects_for_current_thread() {
	MutexLock lock(dxc_mutex);

	int thread_idx = WorkerThreadPool::get_singleton()->get_thread_index();
	DxcObjects *dxc_objs = dxc_objects.lookup_ptr(thread_idx);
	if (dxc_objs) {
		return *dxc_objs;
	} else {
#ifdef DEV_ENABLED
		print_verbose("Creating DXC objects for worker thread index " + itos(thread_idx));
#endif

		DxcObjects new_dxc_objs;
		HRESULT res = DxcCreateInstance(CLSID_DxcUtils, IID_PPV_ARGS(&new_dxc_objs.utils));
		CRASH_COND(res);
		res = DxcCreateInstance(CLSID_DxcCompiler, IID_PPV_ARGS(&new_dxc_objs.compiler));
		CRASH_COND(res);
		res = dxil_DxcCreateInstance(CLSID_DxcValidator, IID_PPV_ARGS(&new_dxc_objs.validator));
		CRASH_COND(res);

		dxc_objects.insert(thread_idx, new_dxc_objs);
		return *dxc_objects.lookup_ptr(thread_idx);
	}
}

template <class T>
void RenderingDeviceD3D12::_free_rids(T &p_owner, const char *p_type) {
	List<RID> owned;
	p_owner.get_owned_list(&owned);
	if (owned.size()) {
		if (owned.size() == 1) {
			WARN_PRINT(vformat("1 RID of type \"%s\" was leaked.", p_type));
		} else {
			WARN_PRINT(vformat("%d RIDs of type \"%s\" were leaked.", owned.size(), p_type));
		}
		for (const RID &E : owned) {
#ifdef DEV_ENABLED
			if (resource_names.has(E)) {
				print_line(String(" - ") + resource_names[E]);
			}
#endif
			free(E);
		}
	}
}

void RenderingDeviceD3D12::capture_timestamp(const String &p_name) {
	ERR_FAIL_COND_MSG(draw_list != nullptr, "Capturing timestamps during draw list creation is not allowed. Offending timestamp was: " + p_name);
	ERR_FAIL_COND(frames[frame].timestamp_count >= max_timestamp_query_elements);

	// This should be optional for profiling, else it will slow things down.
	full_barrier();

	frames[frame].draw_command_list->EndQuery(frames[frame].timestamp_heap.Get(), D3D12_QUERY_TYPE_TIMESTAMP, frames[frame].timestamp_count);
	frames[frame].timestamp_names[frames[frame].timestamp_count] = p_name;
	frames[frame].timestamp_cpu_values[frames[frame].timestamp_count] = OS::get_singleton()->get_ticks_usec();
	frames[frame].timestamp_count++;
}

uint64_t RenderingDeviceD3D12::get_driver_resource(DriverResource p_resource, RID p_rid, uint64_t p_index) {
	_THREAD_SAFE_METHOD_
	return 0;
}

uint32_t RenderingDeviceD3D12::get_captured_timestamps_count() const {
	return frames[frame].timestamp_result_count;
}

uint64_t RenderingDeviceD3D12::get_captured_timestamps_frame() const {
	return frames[frame].index;
}

uint64_t RenderingDeviceD3D12::get_captured_timestamp_gpu_time(uint32_t p_index) const {
	ERR_FAIL_UNSIGNED_INDEX_V(p_index, frames[frame].timestamp_result_count, 0);

	return frames[frame].timestamp_result_values[p_index] / (double)limits.timestamp_frequency * 1000000000.0;
}

uint64_t RenderingDeviceD3D12::get_captured_timestamp_cpu_time(uint32_t p_index) const {
	ERR_FAIL_UNSIGNED_INDEX_V(p_index, frames[frame].timestamp_result_count, 0);
	return frames[frame].timestamp_cpu_result_values[p_index];
}

String RenderingDeviceD3D12::get_captured_timestamp_name(uint32_t p_index) const {
	ERR_FAIL_UNSIGNED_INDEX_V(p_index, frames[frame].timestamp_result_count, String());
	return frames[frame].timestamp_result_names[p_index];
}

uint64_t RenderingDeviceD3D12::limit_get(Limit p_limit) const {
	switch (p_limit) {
		case LIMIT_MAX_TEXTURES_PER_SHADER_STAGE:
			return limits.max_srvs_per_shader_stage;
		case LIMIT_MAX_UNIFORM_BUFFER_SIZE:
			return 65536;
		case LIMIT_MAX_VIEWPORT_DIMENSIONS_X:
			return 16384; // After max. texture size. Maybe not correct.
		case LIMIT_MAX_VIEWPORT_DIMENSIONS_Y:
			return 16384; // After max. texture size. Maybe not correct.
		case LIMIT_SUBGROUP_SIZE: {
			D3D12Context::SubgroupCapabilities subgroup_capabilities = context->get_subgroup_capabilities();
			return subgroup_capabilities.size;
		}
		case LIMIT_SUBGROUP_IN_SHADERS: {
			D3D12Context::SubgroupCapabilities subgroup_capabilities = context->get_subgroup_capabilities();
			return subgroup_capabilities.supported_stages_flags_rd();
		}
		case LIMIT_SUBGROUP_OPERATIONS: {
			D3D12Context::SubgroupCapabilities subgroup_capabilities = context->get_subgroup_capabilities();
			return subgroup_capabilities.supported_operations_flags_rd();
		}
		case LIMIT_VRS_TEXEL_WIDTH: {
			return context->get_vrs_capabilities().ss_image_tile_size;
		}
		case LIMIT_VRS_TEXEL_HEIGHT: {
			return context->get_vrs_capabilities().ss_image_tile_size;
		}
		default:
			ERR_FAIL_V_MSG(UINT64_MAX, "Returning maximum value for unknown limit " + itos(p_limit) + ".");
	}
}

bool RenderingDeviceD3D12::has_feature(const Features p_feature) const {
	switch (p_feature) {
		case SUPPORTS_MULTIVIEW: {
			D3D12Context::MultiviewCapabilities multiview_capabilies = context->get_multiview_capabilities();
			return multiview_capabilies.is_supported && multiview_capabilies.max_view_count > 1;
		} break;
		case SUPPORTS_FSR_HALF_FLOAT: {
			return context->get_shader_capabilities().native_16bit_ops && context->get_storage_buffer_capabilities().storage_buffer_16_bit_access_is_supported;
		} break;
		case SUPPORTS_ATTACHMENT_VRS: {
			D3D12Context::VRSCapabilities vrs_capabilities = context->get_vrs_capabilities();
			return vrs_capabilities.ss_image_supported;
		} break;
		default: {
			return false;
		}
	}
}

void RenderingDeviceD3D12::finalize() {
	// Free all resources.

	_flush(false);

	free(aux_resource);

	_free_rids(render_pipeline_owner, "Pipeline");
	_free_rids(compute_pipeline_owner, "Compute");
	_free_rids(uniform_set_owner, "UniformSet");
	_free_rids(texture_buffer_owner, "TextureBuffer");
	_free_rids(storage_buffer_owner, "StorageBuffer");
	_free_rids(uniform_buffer_owner, "UniformBuffer");
	_free_rids(shader_owner, "Shader");
	_free_rids(index_array_owner, "IndexArray");
	_free_rids(index_buffer_owner, "IndexBuffer");
	_free_rids(vertex_array_owner, "VertexArray");
	_free_rids(vertex_buffer_owner, "VertexBuffer");
	_free_rids(framebuffer_owner, "Framebuffer");
	_free_rids(sampler_owner, "Sampler");
	{
		// For textures it's a bit more difficult because they may be shared.
		List<RID> owned;
		texture_owner.get_owned_list(&owned);
		if (owned.size()) {
			if (owned.size() == 1) {
				WARN_PRINT("1 RID of type \"Texture\" was leaked.");
			} else {
				WARN_PRINT(vformat("%d RIDs of type \"Texture\" were leaked.", owned.size()));
			}
			// Free shared first.
			for (List<RID>::Element *E = owned.front(); E;) {
				List<RID>::Element *N = E->next();
				if (texture_is_shared(E->get())) {
#ifdef DEV_ENABLED
					if (resource_names.has(E->get())) {
						print_line(String(" - ") + resource_names[E->get()]);
					}
#endif
					free(E->get());
					owned.erase(E);
				}
				E = N;
			}
			// Free non shared second, this will avoid an error trying to free unexisting textures due to dependencies.
			for (const RID &E : owned) {
#ifdef DEV_ENABLED
				if (resource_names.has(E)) {
					print_line(String(" - ") + resource_names[E]);
				}
#endif
				free(E);
			}
		}
	}

	// Free everything pending.
	for (int i = 0; i < frame_count; i++) {
		int f = (frame + i) % frame_count;
		_free_pending_resources(f);
		frames[i].timestamp_result_values_buffer.allocation->Release();
		frames[i].timestamp_result_values_buffer.resource->Release();
	}

	frames.clear();

	pipeline_bindings.clear();
	next_pipeline_binding_id = 1;

	for (int i = 0; i < split_draw_list_allocators.size(); i++) {
		for (int j = 0; i < split_draw_list_allocators[i].command_lists.size(); j++) {
			split_draw_list_allocators[i].command_lists[j]->Release();
		}
		split_draw_list_allocators[i].command_allocator->Release();
	}

	res_barriers_requests.clear();
	res_barriers.clear();

	for (int i = 0; i < staging_buffer_blocks.size(); i++) {
		staging_buffer_blocks[i].allocation->Release();
		staging_buffer_blocks[i].resource->Release();
	}
#ifdef USE_SMALL_ALLOCS_POOL
	small_allocs_pools.clear();
#endif
	allocator.Reset();

	indirect_dispatch_cmd_sig.Reset();

	vertex_formats.clear();

	framebuffer_formats.clear();

	// All these should be clear at this point.
	ERR_FAIL_COND(dependency_map.size());
	ERR_FAIL_COND(reverse_dependency_map.size());

	dxc_mutex.lock();
	dxc_objects.clear();
	dxc_mutex.unlock();

	DxcClearThreadMalloc();
	DxcCleanupThreadMalloc();
}

RenderingDevice *RenderingDeviceD3D12::create_local_device() {
	RenderingDeviceD3D12 *rd = memnew(RenderingDeviceD3D12);
	rd->initialize(context, true);
	return rd;
}

RenderingDeviceD3D12::RenderingDeviceD3D12() {
	device_capabilities.device_family = DEVICE_DIRECTX;
}

RenderingDeviceD3D12::~RenderingDeviceD3D12() {
	if (local_device.is_valid()) {
		finalize();
		context->local_device_free(local_device);
	}
}
