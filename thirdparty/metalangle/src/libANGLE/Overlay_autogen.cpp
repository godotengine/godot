// GENERATED FILE - DO NOT EDIT.
// Generated by gen_overlay_widgets.py using data from overlay_widgets.json.
//
// Copyright 2019 The ANGLE Project Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
//
// Overlay_autogen.cpp:
//   Autogenerated overlay widget declarations.

#include "libANGLE/Overlay.h"
#include "libANGLE/OverlayWidgets.h"
#include "libANGLE/Overlay_font_autogen.h"
#include "libANGLE/renderer/driver_utils.h"

namespace gl
{
using namespace overlay;

namespace
{
int GetFontSize(int fontSize, bool largeFont)
{
    if (largeFont && fontSize > 0)
    {
        return fontSize - 1;
    }
    return fontSize;
}
}  // anonymous namespace

void Overlay::initOverlayWidgets()
{
    const bool kLargeFont = rx::IsAndroid();

    {
        PerSecond *widget = new PerSecond;
        {
            const int32_t fontSize = GetFontSize(kFontLayerMedium, kLargeFont);
            const int32_t offsetX  = 10;
            const int32_t offsetY  = 10;
            const int32_t width    = 12 * kFontGlyphWidths[fontSize];
            const int32_t height   = kFontGlyphHeights[fontSize];

            widget->type      = WidgetType::PerSecond;
            widget->fontSize  = fontSize;
            widget->coords[0] = offsetX;
            widget->coords[1] = offsetY;
            widget->coords[2] = offsetX + width;
            widget->coords[3] = offsetY + height;
            widget->color[0]  = 0.498039215686;
            widget->color[1]  = 0.749019607843;
            widget->color[2]  = 1.0;
            widget->color[3]  = 1.0;
        }
        mState.mOverlayWidgets[WidgetId::FPS].reset(widget);
    }

    {
        Text *widget = new Text;
        {
            const int32_t fontSize = GetFontSize(kFontLayerSmall, kLargeFont);
            const int32_t offsetX  = 10;
            const int32_t offsetY  = -10;
            const int32_t width    = 150 * kFontGlyphWidths[fontSize];
            const int32_t height   = kFontGlyphHeights[fontSize];

            widget->type      = WidgetType::Text;
            widget->fontSize  = fontSize;
            widget->coords[0] = offsetX;
            widget->coords[1] = offsetY - height;
            widget->coords[2] = offsetX + width;
            widget->coords[3] = offsetY;
            widget->color[0]  = 1.0;
            widget->color[1]  = 0.0;
            widget->color[2]  = 0.0;
            widget->color[3]  = 1.0;
        }
        mState.mOverlayWidgets[WidgetId::VulkanLastValidationMessage].reset(widget);
    }

    {
        Count *widget = new Count;
        {
            const int32_t fontSize = GetFontSize(kFontLayerSmall, kLargeFont);
            const int32_t offsetX  = 10;
            const int32_t offsetY =
                mState.mOverlayWidgets[WidgetId::VulkanLastValidationMessage]->coords[1];
            const int32_t width  = 25 * kFontGlyphWidths[fontSize];
            const int32_t height = kFontGlyphHeights[fontSize];

            widget->type      = WidgetType::Count;
            widget->fontSize  = fontSize;
            widget->coords[0] = offsetX;
            widget->coords[1] = offsetY - height;
            widget->coords[2] = offsetX + width;
            widget->coords[3] = offsetY;
            widget->color[0]  = 1.0;
            widget->color[1]  = 0.0;
            widget->color[2]  = 0.0;
            widget->color[3]  = 1.0;
        }
        mState.mOverlayWidgets[WidgetId::VulkanValidationMessageCount].reset(widget);
    }

    {
        RunningGraph *widget = new RunningGraph(60);
        {
            const int32_t fontSize = GetFontSize(0, kLargeFont);
            const int32_t offsetX  = 10;
            const int32_t offsetY  = 100;
            const int32_t width    = 5 * static_cast<uint32_t>(widget->runningValues.size());
            const int32_t height   = 100;

            widget->type      = WidgetType::RunningGraph;
            widget->fontSize  = fontSize;
            widget->coords[0] = offsetX;
            widget->coords[1] = offsetY;
            widget->coords[2] = offsetX + width;
            widget->coords[3] = offsetY + height;
            widget->color[0]  = 0.294117647059;
            widget->color[1]  = 0.78431372549;
            widget->color[2]  = 0.0;
            widget->color[3]  = 0.78431372549;
        }
        mState.mOverlayWidgets[WidgetId::VulkanCommandGraphSize].reset(widget);
        {
            const int32_t fontSize = GetFontSize(kFontLayerSmall, kLargeFont);
            const int32_t offsetX =
                mState.mOverlayWidgets[WidgetId::VulkanCommandGraphSize]->coords[0];
            const int32_t offsetY =
                mState.mOverlayWidgets[WidgetId::VulkanCommandGraphSize]->coords[1];
            const int32_t width  = 40 * kFontGlyphWidths[fontSize];
            const int32_t height = kFontGlyphHeights[fontSize];

            widget->description.type      = WidgetType::Text;
            widget->description.fontSize  = fontSize;
            widget->description.coords[0] = offsetX;
            widget->description.coords[1] = std::max(offsetY - height, 1);
            widget->description.coords[2] = offsetX + width;
            widget->description.coords[3] = offsetY;
            widget->description.color[0]  = 0.294117647059;
            widget->description.color[1]  = 0.78431372549;
            widget->description.color[2]  = 0.0;
            widget->description.color[3]  = 1.0;
        }
    }

    {
        RunningHistogram *widget = new RunningHistogram(50);
        {
            const int32_t fontSize = GetFontSize(0, kLargeFont);
            const int32_t offsetX  = -50;
            const int32_t offsetY  = 100;
            const int32_t width    = 6 * static_cast<uint32_t>(widget->runningValues.size());
            const int32_t height   = 100;

            widget->type      = WidgetType::RunningHistogram;
            widget->fontSize  = fontSize;
            widget->coords[0] = offsetX - width;
            widget->coords[1] = offsetY;
            widget->coords[2] = offsetX;
            widget->coords[3] = offsetY + height;
            widget->color[0]  = 1.0;
            widget->color[1]  = 0.78431372549;
            widget->color[2]  = 0.294117647059;
            widget->color[3]  = 0.78431372549;
        }
        mState.mOverlayWidgets[WidgetId::VulkanSecondaryCommandBufferPoolWaste].reset(widget);
        {
            const int32_t fontSize = GetFontSize(kFontLayerSmall, kLargeFont);
            const int32_t offsetX =
                mState.mOverlayWidgets[WidgetId::VulkanSecondaryCommandBufferPoolWaste]->coords[0];
            const int32_t offsetY =
                mState.mOverlayWidgets[WidgetId::VulkanSecondaryCommandBufferPoolWaste]->coords[1];
            const int32_t width  = 40 * kFontGlyphWidths[fontSize];
            const int32_t height = kFontGlyphHeights[fontSize];

            widget->description.type      = WidgetType::Text;
            widget->description.fontSize  = fontSize;
            widget->description.coords[0] = offsetX;
            widget->description.coords[1] = std::max(offsetY - height, 1);
            widget->description.coords[2] = std::min(offsetX + width, -1);
            widget->description.coords[3] = offsetY;
            widget->description.color[0]  = 1.0;
            widget->description.color[1]  = 0.78431372549;
            widget->description.color[2]  = 0.294117647059;
            widget->description.color[3]  = 1.0;
        }
    }
}

}  // namespace gl
