// Copyright (c) 2014-2024 The Khronos Group Inc.
// 
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and/or associated documentation files (the "Materials"),
// to deal in the Materials without restriction, including without limitation
// the rights to use, copy, modify, merge, publish, distribute, sublicense,
// and/or sell copies of the Materials, and to permit persons to whom the
// Materials are furnished to do so, subject to the following conditions:
// 
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Materials.
// 
// MODIFICATIONS TO THIS FILE MAY MEAN IT NO LONGER ACCURATELY REFLECTS KHRONOS
// STANDARDS. THE UNMODIFIED, NORMATIVE VERSIONS OF KHRONOS SPECIFICATIONS AND
// HEADER INFORMATION ARE LOCATED AT https://www.khronos.org/registry/ 
// 
// THE MATERIALS ARE PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
// FROM,OUT OF OR IN CONNECTION WITH THE MATERIALS OR THE USE OR OTHER DEALINGS
// IN THE MATERIALS.

// This header is automatically generated by the same tool that creates
// the Binary Section of the SPIR-V specification.

// Enumeration tokens for SPIR-V, in various styles:
//   C, C++, C++11, JSON, Lua, Python, C#, D, Beef
// 
// - C will have tokens with a "Spv" prefix, e.g.: SpvSourceLanguageGLSL
// - C++ will have tokens in the "spv" name space, e.g.: spv::SourceLanguageGLSL
// - C++11 will use enum classes in the spv namespace, e.g.: spv::SourceLanguage::GLSL
// - Lua will use tables, e.g.: spv.SourceLanguage.GLSL
// - Python will use dictionaries, e.g.: spv['SourceLanguage']['GLSL']
// - C# will use enum classes in the Specification class located in the "Spv" namespace,
//     e.g.: Spv.Specification.SourceLanguage.GLSL
// - D will have tokens under the "spv" module, e.g: spv.SourceLanguage.GLSL
// - Beef will use enum classes in the Specification class located in the "Spv" namespace,
//     e.g.: Spv.Specification.SourceLanguage.GLSL
// 
// Some tokens act like mask values, which can be OR'd together,
// while others are mutually exclusive.  The mask-like ones have
// "Mask" in their name, and a parallel enum that has the shift
// amount (1 << x) for each corresponding enumerant.

#ifndef spirv_HPP
#define spirv_HPP

namespace spv {

typedef unsigned int Id;

#define SPV_VERSION 0x10600
#define SPV_REVISION 1

static const unsigned int MagicNumber = 0x07230203;
static const unsigned int Version = 0x00010600;
static const unsigned int Revision = 1;
static const unsigned int OpCodeMask = 0xffff;
static const unsigned int WordCountShift = 16;

enum class SourceLanguage : unsigned {
    Unknown = 0,
    ESSL = 1,
    GLSL = 2,
    OpenCL_C = 3,
    OpenCL_CPP = 4,
    HLSL = 5,
    CPP_for_OpenCL = 6,
    SYCL = 7,
    HERO_C = 8,
    NZSL = 9,
    WGSL = 10,
    Slang = 11,
    Zig = 12,
    Max = 0x7fffffff,
};

enum class ExecutionModel : unsigned {
    Vertex = 0,
    TessellationControl = 1,
    TessellationEvaluation = 2,
    Geometry = 3,
    Fragment = 4,
    GLCompute = 5,
    Kernel = 6,
    TaskNV = 5267,
    MeshNV = 5268,
    RayGenerationKHR = 5313,
    RayGenerationNV = 5313,
    IntersectionKHR = 5314,
    IntersectionNV = 5314,
    AnyHitKHR = 5315,
    AnyHitNV = 5315,
    ClosestHitKHR = 5316,
    ClosestHitNV = 5316,
    MissKHR = 5317,
    MissNV = 5317,
    CallableKHR = 5318,
    CallableNV = 5318,
    TaskEXT = 5364,
    MeshEXT = 5365,
    Max = 0x7fffffff,
};

enum class AddressingModel : unsigned {
    Logical = 0,
    Physical32 = 1,
    Physical64 = 2,
    PhysicalStorageBuffer64 = 5348,
    PhysicalStorageBuffer64EXT = 5348,
    Max = 0x7fffffff,
};

enum class MemoryModel : unsigned {
    Simple = 0,
    GLSL450 = 1,
    OpenCL = 2,
    Vulkan = 3,
    VulkanKHR = 3,
    Max = 0x7fffffff,
};

enum class ExecutionMode : unsigned {
    Invocations = 0,
    SpacingEqual = 1,
    SpacingFractionalEven = 2,
    SpacingFractionalOdd = 3,
    VertexOrderCw = 4,
    VertexOrderCcw = 5,
    PixelCenterInteger = 6,
    OriginUpperLeft = 7,
    OriginLowerLeft = 8,
    EarlyFragmentTests = 9,
    PointMode = 10,
    Xfb = 11,
    DepthReplacing = 12,
    DepthGreater = 14,
    DepthLess = 15,
    DepthUnchanged = 16,
    LocalSize = 17,
    LocalSizeHint = 18,
    InputPoints = 19,
    InputLines = 20,
    InputLinesAdjacency = 21,
    Triangles = 22,
    InputTrianglesAdjacency = 23,
    Quads = 24,
    Isolines = 25,
    OutputVertices = 26,
    OutputPoints = 27,
    OutputLineStrip = 28,
    OutputTriangleStrip = 29,
    VecTypeHint = 30,
    ContractionOff = 31,
    Initializer = 33,
    Finalizer = 34,
    SubgroupSize = 35,
    SubgroupsPerWorkgroup = 36,
    SubgroupsPerWorkgroupId = 37,
    LocalSizeId = 38,
    LocalSizeHintId = 39,
    NonCoherentColorAttachmentReadEXT = 4169,
    NonCoherentDepthAttachmentReadEXT = 4170,
    NonCoherentStencilAttachmentReadEXT = 4171,
    SubgroupUniformControlFlowKHR = 4421,
    PostDepthCoverage = 4446,
    DenormPreserve = 4459,
    DenormFlushToZero = 4460,
    SignedZeroInfNanPreserve = 4461,
    RoundingModeRTE = 4462,
    RoundingModeRTZ = 4463,
    EarlyAndLateFragmentTestsAMD = 5017,
    StencilRefReplacingEXT = 5027,
    CoalescingAMDX = 5069,
    MaxNodeRecursionAMDX = 5071,
    StaticNumWorkgroupsAMDX = 5072,
    ShaderIndexAMDX = 5073,
    MaxNumWorkgroupsAMDX = 5077,
    StencilRefUnchangedFrontAMD = 5079,
    StencilRefGreaterFrontAMD = 5080,
    StencilRefLessFrontAMD = 5081,
    StencilRefUnchangedBackAMD = 5082,
    StencilRefGreaterBackAMD = 5083,
    StencilRefLessBackAMD = 5084,
    QuadDerivativesKHR = 5088,
    RequireFullQuadsKHR = 5089,
    OutputLinesEXT = 5269,
    OutputLinesNV = 5269,
    OutputPrimitivesEXT = 5270,
    OutputPrimitivesNV = 5270,
    DerivativeGroupQuadsNV = 5289,
    DerivativeGroupLinearNV = 5290,
    OutputTrianglesEXT = 5298,
    OutputTrianglesNV = 5298,
    PixelInterlockOrderedEXT = 5366,
    PixelInterlockUnorderedEXT = 5367,
    SampleInterlockOrderedEXT = 5368,
    SampleInterlockUnorderedEXT = 5369,
    ShadingRateInterlockOrderedEXT = 5370,
    ShadingRateInterlockUnorderedEXT = 5371,
    SharedLocalMemorySizeINTEL = 5618,
    RoundingModeRTPINTEL = 5620,
    RoundingModeRTNINTEL = 5621,
    FloatingPointModeALTINTEL = 5622,
    FloatingPointModeIEEEINTEL = 5623,
    MaxWorkgroupSizeINTEL = 5893,
    MaxWorkDimINTEL = 5894,
    NoGlobalOffsetINTEL = 5895,
    NumSIMDWorkitemsINTEL = 5896,
    SchedulerTargetFmaxMhzINTEL = 5903,
    MaximallyReconvergesKHR = 6023,
    FPFastMathDefault = 6028,
    StreamingInterfaceINTEL = 6154,
    RegisterMapInterfaceINTEL = 6160,
    NamedBarrierCountINTEL = 6417,
    MaximumRegistersINTEL = 6461,
    MaximumRegistersIdINTEL = 6462,
    NamedMaximumRegistersINTEL = 6463,
    Max = 0x7fffffff,
};

enum class StorageClass : unsigned {
    UniformConstant = 0,
    Input = 1,
    Uniform = 2,
    Output = 3,
    Workgroup = 4,
    CrossWorkgroup = 5,
    Private = 6,
    Function = 7,
    Generic = 8,
    PushConstant = 9,
    AtomicCounter = 10,
    Image = 11,
    StorageBuffer = 12,
    TileImageEXT = 4172,
    NodePayloadAMDX = 5068,
    NodeOutputPayloadAMDX = 5076,
    CallableDataKHR = 5328,
    CallableDataNV = 5328,
    IncomingCallableDataKHR = 5329,
    IncomingCallableDataNV = 5329,
    RayPayloadKHR = 5338,
    RayPayloadNV = 5338,
    HitAttributeKHR = 5339,
    HitAttributeNV = 5339,
    IncomingRayPayloadKHR = 5342,
    IncomingRayPayloadNV = 5342,
    ShaderRecordBufferKHR = 5343,
    ShaderRecordBufferNV = 5343,
    PhysicalStorageBuffer = 5349,
    PhysicalStorageBufferEXT = 5349,
    HitObjectAttributeNV = 5385,
    TaskPayloadWorkgroupEXT = 5402,
    CodeSectionINTEL = 5605,
    DeviceOnlyINTEL = 5936,
    HostOnlyINTEL = 5937,
    Max = 0x7fffffff,
};

enum class Dim : unsigned {
    Dim1D = 0,
    Dim2D = 1,
    Dim3D = 2,
    Cube = 3,
    Rect = 4,
    Buffer = 5,
    SubpassData = 6,
    TileImageDataEXT = 4173,
    Max = 0x7fffffff,
};

enum class SamplerAddressingMode : unsigned {
    None = 0,
    ClampToEdge = 1,
    Clamp = 2,
    Repeat = 3,
    RepeatMirrored = 4,
    Max = 0x7fffffff,
};

enum class SamplerFilterMode : unsigned {
    Nearest = 0,
    Linear = 1,
    Max = 0x7fffffff,
};

enum class ImageFormat : unsigned {
    Unknown = 0,
    Rgba32f = 1,
    Rgba16f = 2,
    R32f = 3,
    Rgba8 = 4,
    Rgba8Snorm = 5,
    Rg32f = 6,
    Rg16f = 7,
    R11fG11fB10f = 8,
    R16f = 9,
    Rgba16 = 10,
    Rgb10A2 = 11,
    Rg16 = 12,
    Rg8 = 13,
    R16 = 14,
    R8 = 15,
    Rgba16Snorm = 16,
    Rg16Snorm = 17,
    Rg8Snorm = 18,
    R16Snorm = 19,
    R8Snorm = 20,
    Rgba32i = 21,
    Rgba16i = 22,
    Rgba8i = 23,
    R32i = 24,
    Rg32i = 25,
    Rg16i = 26,
    Rg8i = 27,
    R16i = 28,
    R8i = 29,
    Rgba32ui = 30,
    Rgba16ui = 31,
    Rgba8ui = 32,
    R32ui = 33,
    Rgb10a2ui = 34,
    Rg32ui = 35,
    Rg16ui = 36,
    Rg8ui = 37,
    R16ui = 38,
    R8ui = 39,
    R64ui = 40,
    R64i = 41,
    Max = 0x7fffffff,
};

enum class ImageChannelOrder : unsigned {
    R = 0,
    A = 1,
    RG = 2,
    RA = 3,
    RGB = 4,
    RGBA = 5,
    BGRA = 6,
    ARGB = 7,
    Intensity = 8,
    Luminance = 9,
    Rx = 10,
    RGx = 11,
    RGBx = 12,
    Depth = 13,
    DepthStencil = 14,
    sRGB = 15,
    sRGBx = 16,
    sRGBA = 17,
    sBGRA = 18,
    ABGR = 19,
    Max = 0x7fffffff,
};

enum class ImageChannelDataType : unsigned {
    SnormInt8 = 0,
    SnormInt16 = 1,
    UnormInt8 = 2,
    UnormInt16 = 3,
    UnormShort565 = 4,
    UnormShort555 = 5,
    UnormInt101010 = 6,
    SignedInt8 = 7,
    SignedInt16 = 8,
    SignedInt32 = 9,
    UnsignedInt8 = 10,
    UnsignedInt16 = 11,
    UnsignedInt32 = 12,
    HalfFloat = 13,
    Float = 14,
    UnormInt24 = 15,
    UnormInt101010_2 = 16,
    UnsignedIntRaw10EXT = 19,
    UnsignedIntRaw12EXT = 20,
    Max = 0x7fffffff,
};

enum class ImageOperandsShift : unsigned {
    Bias = 0,
    Lod = 1,
    Grad = 2,
    ConstOffset = 3,
    Offset = 4,
    ConstOffsets = 5,
    Sample = 6,
    MinLod = 7,
    MakeTexelAvailable = 8,
    MakeTexelAvailableKHR = 8,
    MakeTexelVisible = 9,
    MakeTexelVisibleKHR = 9,
    NonPrivateTexel = 10,
    NonPrivateTexelKHR = 10,
    VolatileTexel = 11,
    VolatileTexelKHR = 11,
    SignExtend = 12,
    ZeroExtend = 13,
    Nontemporal = 14,
    Offsets = 16,
    Max = 0x7fffffff,
};

enum class ImageOperandsMask : unsigned {
    MaskNone = 0,
    Bias = 0x00000001,
    Lod = 0x00000002,
    Grad = 0x00000004,
    ConstOffset = 0x00000008,
    Offset = 0x00000010,
    ConstOffsets = 0x00000020,
    Sample = 0x00000040,
    MinLod = 0x00000080,
    MakeTexelAvailable = 0x00000100,
    MakeTexelAvailableKHR = 0x00000100,
    MakeTexelVisible = 0x00000200,
    MakeTexelVisibleKHR = 0x00000200,
    NonPrivateTexel = 0x00000400,
    NonPrivateTexelKHR = 0x00000400,
    VolatileTexel = 0x00000800,
    VolatileTexelKHR = 0x00000800,
    SignExtend = 0x00001000,
    ZeroExtend = 0x00002000,
    Nontemporal = 0x00004000,
    Offsets = 0x00010000,
};

enum class FPFastMathModeShift : unsigned {
    NotNaN = 0,
    NotInf = 1,
    NSZ = 2,
    AllowRecip = 3,
    Fast = 4,
    AllowContract = 16,
    AllowContractFastINTEL = 16,
    AllowReassoc = 17,
    AllowReassocINTEL = 17,
    AllowTransform = 18,
    Max = 0x7fffffff,
};

enum class FPFastMathModeMask : unsigned {
    MaskNone = 0,
    NotNaN = 0x00000001,
    NotInf = 0x00000002,
    NSZ = 0x00000004,
    AllowRecip = 0x00000008,
    Fast = 0x00000010,
    AllowContract = 0x00010000,
    AllowContractFastINTEL = 0x00010000,
    AllowReassoc = 0x00020000,
    AllowReassocINTEL = 0x00020000,
    AllowTransform = 0x00040000,
};

enum class FPRoundingMode : unsigned {
    RTE = 0,
    RTZ = 1,
    RTP = 2,
    RTN = 3,
    Max = 0x7fffffff,
};

enum class LinkageType : unsigned {
    Export = 0,
    Import = 1,
    LinkOnceODR = 2,
    Max = 0x7fffffff,
};

enum class AccessQualifier : unsigned {
    ReadOnly = 0,
    WriteOnly = 1,
    ReadWrite = 2,
    Max = 0x7fffffff,
};

enum class FunctionParameterAttribute : unsigned {
    Zext = 0,
    Sext = 1,
    ByVal = 2,
    Sret = 3,
    NoAlias = 4,
    NoCapture = 5,
    NoWrite = 6,
    NoReadWrite = 7,
    RuntimeAlignedINTEL = 5940,
    Max = 0x7fffffff,
};

enum class Decoration : unsigned {
    RelaxedPrecision = 0,
    SpecId = 1,
    Block = 2,
    BufferBlock = 3,
    RowMajor = 4,
    ColMajor = 5,
    ArrayStride = 6,
    MatrixStride = 7,
    GLSLShared = 8,
    GLSLPacked = 9,
    CPacked = 10,
    BuiltIn = 11,
    NoPerspective = 13,
    Flat = 14,
    Patch = 15,
    Centroid = 16,
    Sample = 17,
    Invariant = 18,
    Restrict = 19,
    Aliased = 20,
    Volatile = 21,
    Constant = 22,
    Coherent = 23,
    NonWritable = 24,
    NonReadable = 25,
    Uniform = 26,
    UniformId = 27,
    SaturatedConversion = 28,
    Stream = 29,
    Location = 30,
    Component = 31,
    Index = 32,
    Binding = 33,
    DescriptorSet = 34,
    Offset = 35,
    XfbBuffer = 36,
    XfbStride = 37,
    FuncParamAttr = 38,
    FPRoundingMode = 39,
    FPFastMathMode = 40,
    LinkageAttributes = 41,
    NoContraction = 42,
    InputAttachmentIndex = 43,
    Alignment = 44,
    MaxByteOffset = 45,
    AlignmentId = 46,
    MaxByteOffsetId = 47,
    NoSignedWrap = 4469,
    NoUnsignedWrap = 4470,
    WeightTextureQCOM = 4487,
    BlockMatchTextureQCOM = 4488,
    BlockMatchSamplerQCOM = 4499,
    ExplicitInterpAMD = 4999,
    NodeSharesPayloadLimitsWithAMDX = 5019,
    NodeMaxPayloadsAMDX = 5020,
    TrackFinishWritingAMDX = 5078,
    PayloadNodeNameAMDX = 5091,
    OverrideCoverageNV = 5248,
    PassthroughNV = 5250,
    ViewportRelativeNV = 5252,
    SecondaryViewportRelativeNV = 5256,
    PerPrimitiveEXT = 5271,
    PerPrimitiveNV = 5271,
    PerViewNV = 5272,
    PerTaskNV = 5273,
    PerVertexKHR = 5285,
    PerVertexNV = 5285,
    NonUniform = 5300,
    NonUniformEXT = 5300,
    RestrictPointer = 5355,
    RestrictPointerEXT = 5355,
    AliasedPointer = 5356,
    AliasedPointerEXT = 5356,
    HitObjectShaderRecordBufferNV = 5386,
    BindlessSamplerNV = 5398,
    BindlessImageNV = 5399,
    BoundSamplerNV = 5400,
    BoundImageNV = 5401,
    SIMTCallINTEL = 5599,
    ReferencedIndirectlyINTEL = 5602,
    ClobberINTEL = 5607,
    SideEffectsINTEL = 5608,
    VectorComputeVariableINTEL = 5624,
    FuncParamIOKindINTEL = 5625,
    VectorComputeFunctionINTEL = 5626,
    StackCallINTEL = 5627,
    GlobalVariableOffsetINTEL = 5628,
    CounterBuffer = 5634,
    HlslCounterBufferGOOGLE = 5634,
    HlslSemanticGOOGLE = 5635,
    UserSemantic = 5635,
    UserTypeGOOGLE = 5636,
    FunctionRoundingModeINTEL = 5822,
    FunctionDenormModeINTEL = 5823,
    RegisterINTEL = 5825,
    MemoryINTEL = 5826,
    NumbanksINTEL = 5827,
    BankwidthINTEL = 5828,
    MaxPrivateCopiesINTEL = 5829,
    SinglepumpINTEL = 5830,
    DoublepumpINTEL = 5831,
    MaxReplicatesINTEL = 5832,
    SimpleDualPortINTEL = 5833,
    MergeINTEL = 5834,
    BankBitsINTEL = 5835,
    ForcePow2DepthINTEL = 5836,
    StridesizeINTEL = 5883,
    WordsizeINTEL = 5884,
    TrueDualPortINTEL = 5885,
    BurstCoalesceINTEL = 5899,
    CacheSizeINTEL = 5900,
    DontStaticallyCoalesceINTEL = 5901,
    PrefetchINTEL = 5902,
    StallEnableINTEL = 5905,
    FuseLoopsInFunctionINTEL = 5907,
    MathOpDSPModeINTEL = 5909,
    AliasScopeINTEL = 5914,
    NoAliasINTEL = 5915,
    InitiationIntervalINTEL = 5917,
    MaxConcurrencyINTEL = 5918,
    PipelineEnableINTEL = 5919,
    BufferLocationINTEL = 5921,
    IOPipeStorageINTEL = 5944,
    FunctionFloatingPointModeINTEL = 6080,
    SingleElementVectorINTEL = 6085,
    VectorComputeCallableFunctionINTEL = 6087,
    MediaBlockIOINTEL = 6140,
    StallFreeINTEL = 6151,
    FPMaxErrorDecorationINTEL = 6170,
    LatencyControlLabelINTEL = 6172,
    LatencyControlConstraintINTEL = 6173,
    ConduitKernelArgumentINTEL = 6175,
    RegisterMapKernelArgumentINTEL = 6176,
    MMHostInterfaceAddressWidthINTEL = 6177,
    MMHostInterfaceDataWidthINTEL = 6178,
    MMHostInterfaceLatencyINTEL = 6179,
    MMHostInterfaceReadWriteModeINTEL = 6180,
    MMHostInterfaceMaxBurstINTEL = 6181,
    MMHostInterfaceWaitRequestINTEL = 6182,
    StableKernelArgumentINTEL = 6183,
    HostAccessINTEL = 6188,
    InitModeINTEL = 6190,
    ImplementInRegisterMapINTEL = 6191,
    CacheControlLoadINTEL = 6442,
    CacheControlStoreINTEL = 6443,
    Max = 0x7fffffff,
};

enum class BuiltIn : unsigned {
    Position = 0,
    PointSize = 1,
    ClipDistance = 3,
    CullDistance = 4,
    VertexId = 5,
    InstanceId = 6,
    PrimitiveId = 7,
    InvocationId = 8,
    Layer = 9,
    ViewportIndex = 10,
    TessLevelOuter = 11,
    TessLevelInner = 12,
    TessCoord = 13,
    PatchVertices = 14,
    FragCoord = 15,
    PointCoord = 16,
    FrontFacing = 17,
    SampleId = 18,
    SamplePosition = 19,
    SampleMask = 20,
    FragDepth = 22,
    HelperInvocation = 23,
    NumWorkgroups = 24,
    WorkgroupSize = 25,
    WorkgroupId = 26,
    LocalInvocationId = 27,
    GlobalInvocationId = 28,
    LocalInvocationIndex = 29,
    WorkDim = 30,
    GlobalSize = 31,
    EnqueuedWorkgroupSize = 32,
    GlobalOffset = 33,
    GlobalLinearId = 34,
    SubgroupSize = 36,
    SubgroupMaxSize = 37,
    NumSubgroups = 38,
    NumEnqueuedSubgroups = 39,
    SubgroupId = 40,
    SubgroupLocalInvocationId = 41,
    VertexIndex = 42,
    InstanceIndex = 43,
    CoreIDARM = 4160,
    CoreCountARM = 4161,
    CoreMaxIDARM = 4162,
    WarpIDARM = 4163,
    WarpMaxIDARM = 4164,
    SubgroupEqMask = 4416,
    SubgroupEqMaskKHR = 4416,
    SubgroupGeMask = 4417,
    SubgroupGeMaskKHR = 4417,
    SubgroupGtMask = 4418,
    SubgroupGtMaskKHR = 4418,
    SubgroupLeMask = 4419,
    SubgroupLeMaskKHR = 4419,
    SubgroupLtMask = 4420,
    SubgroupLtMaskKHR = 4420,
    BaseVertex = 4424,
    BaseInstance = 4425,
    DrawIndex = 4426,
    PrimitiveShadingRateKHR = 4432,
    DeviceIndex = 4438,
    ViewIndex = 4440,
    ShadingRateKHR = 4444,
    BaryCoordNoPerspAMD = 4992,
    BaryCoordNoPerspCentroidAMD = 4993,
    BaryCoordNoPerspSampleAMD = 4994,
    BaryCoordSmoothAMD = 4995,
    BaryCoordSmoothCentroidAMD = 4996,
    BaryCoordSmoothSampleAMD = 4997,
    BaryCoordPullModelAMD = 4998,
    FragStencilRefEXT = 5014,
    CoalescedInputCountAMDX = 5021,
    ShaderIndexAMDX = 5073,
    ViewportMaskNV = 5253,
    SecondaryPositionNV = 5257,
    SecondaryViewportMaskNV = 5258,
    PositionPerViewNV = 5261,
    ViewportMaskPerViewNV = 5262,
    FullyCoveredEXT = 5264,
    TaskCountNV = 5274,
    PrimitiveCountNV = 5275,
    PrimitiveIndicesNV = 5276,
    ClipDistancePerViewNV = 5277,
    CullDistancePerViewNV = 5278,
    LayerPerViewNV = 5279,
    MeshViewCountNV = 5280,
    MeshViewIndicesNV = 5281,
    BaryCoordKHR = 5286,
    BaryCoordNV = 5286,
    BaryCoordNoPerspKHR = 5287,
    BaryCoordNoPerspNV = 5287,
    FragSizeEXT = 5292,
    FragmentSizeNV = 5292,
    FragInvocationCountEXT = 5293,
    InvocationsPerPixelNV = 5293,
    PrimitivePointIndicesEXT = 5294,
    PrimitiveLineIndicesEXT = 5295,
    PrimitiveTriangleIndicesEXT = 5296,
    CullPrimitiveEXT = 5299,
    LaunchIdKHR = 5319,
    LaunchIdNV = 5319,
    LaunchSizeKHR = 5320,
    LaunchSizeNV = 5320,
    WorldRayOriginKHR = 5321,
    WorldRayOriginNV = 5321,
    WorldRayDirectionKHR = 5322,
    WorldRayDirectionNV = 5322,
    ObjectRayOriginKHR = 5323,
    ObjectRayOriginNV = 5323,
    ObjectRayDirectionKHR = 5324,
    ObjectRayDirectionNV = 5324,
    RayTminKHR = 5325,
    RayTminNV = 5325,
    RayTmaxKHR = 5326,
    RayTmaxNV = 5326,
    InstanceCustomIndexKHR = 5327,
    InstanceCustomIndexNV = 5327,
    ObjectToWorldKHR = 5330,
    ObjectToWorldNV = 5330,
    WorldToObjectKHR = 5331,
    WorldToObjectNV = 5331,
    HitTNV = 5332,
    HitKindKHR = 5333,
    HitKindNV = 5333,
    CurrentRayTimeNV = 5334,
    HitTriangleVertexPositionsKHR = 5335,
    HitMicroTriangleVertexPositionsNV = 5337,
    HitMicroTriangleVertexBarycentricsNV = 5344,
    IncomingRayFlagsKHR = 5351,
    IncomingRayFlagsNV = 5351,
    RayGeometryIndexKHR = 5352,
    WarpsPerSMNV = 5374,
    SMCountNV = 5375,
    WarpIDNV = 5376,
    SMIDNV = 5377,
    HitKindFrontFacingMicroTriangleNV = 5405,
    HitKindBackFacingMicroTriangleNV = 5406,
    CullMaskKHR = 6021,
    Max = 0x7fffffff,
};

enum class SelectionControlShift : unsigned {
    Flatten = 0,
    DontFlatten = 1,
    Max = 0x7fffffff,
};

enum class SelectionControlMask : unsigned {
    MaskNone = 0,
    Flatten = 0x00000001,
    DontFlatten = 0x00000002,
};

enum class LoopControlShift : unsigned {
    Unroll = 0,
    DontUnroll = 1,
    DependencyInfinite = 2,
    DependencyLength = 3,
    MinIterations = 4,
    MaxIterations = 5,
    IterationMultiple = 6,
    PeelCount = 7,
    PartialCount = 8,
    InitiationIntervalINTEL = 16,
    MaxConcurrencyINTEL = 17,
    DependencyArrayINTEL = 18,
    PipelineEnableINTEL = 19,
    LoopCoalesceINTEL = 20,
    MaxInterleavingINTEL = 21,
    SpeculatedIterationsINTEL = 22,
    NoFusionINTEL = 23,
    LoopCountINTEL = 24,
    MaxReinvocationDelayINTEL = 25,
    Max = 0x7fffffff,
};

enum class LoopControlMask : unsigned {
    MaskNone = 0,
    Unroll = 0x00000001,
    DontUnroll = 0x00000002,
    DependencyInfinite = 0x00000004,
    DependencyLength = 0x00000008,
    MinIterations = 0x00000010,
    MaxIterations = 0x00000020,
    IterationMultiple = 0x00000040,
    PeelCount = 0x00000080,
    PartialCount = 0x00000100,
    InitiationIntervalINTEL = 0x00010000,
    MaxConcurrencyINTEL = 0x00020000,
    DependencyArrayINTEL = 0x00040000,
    PipelineEnableINTEL = 0x00080000,
    LoopCoalesceINTEL = 0x00100000,
    MaxInterleavingINTEL = 0x00200000,
    SpeculatedIterationsINTEL = 0x00400000,
    NoFusionINTEL = 0x00800000,
    LoopCountINTEL = 0x01000000,
    MaxReinvocationDelayINTEL = 0x02000000,
};

enum class FunctionControlShift : unsigned {
    Inline = 0,
    DontInline = 1,
    Pure = 2,
    Const = 3,
    OptNoneINTEL = 16,
    Max = 0x7fffffff,
};

enum class FunctionControlMask : unsigned {
    MaskNone = 0,
    Inline = 0x00000001,
    DontInline = 0x00000002,
    Pure = 0x00000004,
    Const = 0x00000008,
    OptNoneINTEL = 0x00010000,
};

enum class MemorySemanticsShift : unsigned {
    Acquire = 1,
    Release = 2,
    AcquireRelease = 3,
    SequentiallyConsistent = 4,
    UniformMemory = 6,
    SubgroupMemory = 7,
    WorkgroupMemory = 8,
    CrossWorkgroupMemory = 9,
    AtomicCounterMemory = 10,
    ImageMemory = 11,
    OutputMemory = 12,
    OutputMemoryKHR = 12,
    MakeAvailable = 13,
    MakeAvailableKHR = 13,
    MakeVisible = 14,
    MakeVisibleKHR = 14,
    Volatile = 15,
    Max = 0x7fffffff,
};

enum class MemorySemanticsMask : unsigned {
    MaskNone = 0,
    Acquire = 0x00000002,
    Release = 0x00000004,
    AcquireRelease = 0x00000008,
    SequentiallyConsistent = 0x00000010,
    UniformMemory = 0x00000040,
    SubgroupMemory = 0x00000080,
    WorkgroupMemory = 0x00000100,
    CrossWorkgroupMemory = 0x00000200,
    AtomicCounterMemory = 0x00000400,
    ImageMemory = 0x00000800,
    OutputMemory = 0x00001000,
    OutputMemoryKHR = 0x00001000,
    MakeAvailable = 0x00002000,
    MakeAvailableKHR = 0x00002000,
    MakeVisible = 0x00004000,
    MakeVisibleKHR = 0x00004000,
    Volatile = 0x00008000,
};

enum class MemoryAccessShift : unsigned {
    Volatile = 0,
    Aligned = 1,
    Nontemporal = 2,
    MakePointerAvailable = 3,
    MakePointerAvailableKHR = 3,
    MakePointerVisible = 4,
    MakePointerVisibleKHR = 4,
    NonPrivatePointer = 5,
    NonPrivatePointerKHR = 5,
    AliasScopeINTELMask = 16,
    NoAliasINTELMask = 17,
    Max = 0x7fffffff,
};

enum class MemoryAccessMask : unsigned {
    MaskNone = 0,
    Volatile = 0x00000001,
    Aligned = 0x00000002,
    Nontemporal = 0x00000004,
    MakePointerAvailable = 0x00000008,
    MakePointerAvailableKHR = 0x00000008,
    MakePointerVisible = 0x00000010,
    MakePointerVisibleKHR = 0x00000010,
    NonPrivatePointer = 0x00000020,
    NonPrivatePointerKHR = 0x00000020,
    AliasScopeINTELMask = 0x00010000,
    NoAliasINTELMask = 0x00020000,
};

enum class Scope : unsigned {
    CrossDevice = 0,
    Device = 1,
    Workgroup = 2,
    Subgroup = 3,
    Invocation = 4,
    QueueFamily = 5,
    QueueFamilyKHR = 5,
    ShaderCallKHR = 6,
    Max = 0x7fffffff,
};

enum class GroupOperation : unsigned {
    Reduce = 0,
    InclusiveScan = 1,
    ExclusiveScan = 2,
    ClusteredReduce = 3,
    PartitionedReduceNV = 6,
    PartitionedInclusiveScanNV = 7,
    PartitionedExclusiveScanNV = 8,
    Max = 0x7fffffff,
};

enum class KernelEnqueueFlags : unsigned {
    NoWait = 0,
    WaitKernel = 1,
    WaitWorkGroup = 2,
    Max = 0x7fffffff,
};

enum class KernelProfilingInfoShift : unsigned {
    CmdExecTime = 0,
    Max = 0x7fffffff,
};

enum class KernelProfilingInfoMask : unsigned {
    MaskNone = 0,
    CmdExecTime = 0x00000001,
};

enum class Capability : unsigned {
    Matrix = 0,
    Shader = 1,
    Geometry = 2,
    Tessellation = 3,
    Addresses = 4,
    Linkage = 5,
    Kernel = 6,
    Vector16 = 7,
    Float16Buffer = 8,
    Float16 = 9,
    Float64 = 10,
    Int64 = 11,
    Int64Atomics = 12,
    ImageBasic = 13,
    ImageReadWrite = 14,
    ImageMipmap = 15,
    Pipes = 17,
    Groups = 18,
    DeviceEnqueue = 19,
    LiteralSampler = 20,
    AtomicStorage = 21,
    Int16 = 22,
    TessellationPointSize = 23,
    GeometryPointSize = 24,
    ImageGatherExtended = 25,
    StorageImageMultisample = 27,
    UniformBufferArrayDynamicIndexing = 28,
    SampledImageArrayDynamicIndexing = 29,
    StorageBufferArrayDynamicIndexing = 30,
    StorageImageArrayDynamicIndexing = 31,
    ClipDistance = 32,
    CullDistance = 33,
    ImageCubeArray = 34,
    SampleRateShading = 35,
    ImageRect = 36,
    SampledRect = 37,
    GenericPointer = 38,
    Int8 = 39,
    InputAttachment = 40,
    SparseResidency = 41,
    MinLod = 42,
    Sampled1D = 43,
    Image1D = 44,
    SampledCubeArray = 45,
    SampledBuffer = 46,
    ImageBuffer = 47,
    ImageMSArray = 48,
    StorageImageExtendedFormats = 49,
    ImageQuery = 50,
    DerivativeControl = 51,
    InterpolationFunction = 52,
    TransformFeedback = 53,
    GeometryStreams = 54,
    StorageImageReadWithoutFormat = 55,
    StorageImageWriteWithoutFormat = 56,
    MultiViewport = 57,
    SubgroupDispatch = 58,
    NamedBarrier = 59,
    PipeStorage = 60,
    GroupNonUniform = 61,
    GroupNonUniformVote = 62,
    GroupNonUniformArithmetic = 63,
    GroupNonUniformBallot = 64,
    GroupNonUniformShuffle = 65,
    GroupNonUniformShuffleRelative = 66,
    GroupNonUniformClustered = 67,
    GroupNonUniformQuad = 68,
    ShaderLayer = 69,
    ShaderViewportIndex = 70,
    UniformDecoration = 71,
    CoreBuiltinsARM = 4165,
    TileImageColorReadAccessEXT = 4166,
    TileImageDepthReadAccessEXT = 4167,
    TileImageStencilReadAccessEXT = 4168,
    CooperativeMatrixLayoutsARM = 4201,
    FragmentShadingRateKHR = 4422,
    SubgroupBallotKHR = 4423,
    DrawParameters = 4427,
    WorkgroupMemoryExplicitLayoutKHR = 4428,
    WorkgroupMemoryExplicitLayout8BitAccessKHR = 4429,
    WorkgroupMemoryExplicitLayout16BitAccessKHR = 4430,
    SubgroupVoteKHR = 4431,
    StorageBuffer16BitAccess = 4433,
    StorageUniformBufferBlock16 = 4433,
    StorageUniform16 = 4434,
    UniformAndStorageBuffer16BitAccess = 4434,
    StoragePushConstant16 = 4435,
    StorageInputOutput16 = 4436,
    DeviceGroup = 4437,
    MultiView = 4439,
    VariablePointersStorageBuffer = 4441,
    VariablePointers = 4442,
    AtomicStorageOps = 4445,
    SampleMaskPostDepthCoverage = 4447,
    StorageBuffer8BitAccess = 4448,
    UniformAndStorageBuffer8BitAccess = 4449,
    StoragePushConstant8 = 4450,
    DenormPreserve = 4464,
    DenormFlushToZero = 4465,
    SignedZeroInfNanPreserve = 4466,
    RoundingModeRTE = 4467,
    RoundingModeRTZ = 4468,
    RayQueryProvisionalKHR = 4471,
    RayQueryKHR = 4472,
    RayTraversalPrimitiveCullingKHR = 4478,
    RayTracingKHR = 4479,
    TextureSampleWeightedQCOM = 4484,
    TextureBoxFilterQCOM = 4485,
    TextureBlockMatchQCOM = 4486,
    TextureBlockMatch2QCOM = 4498,
    Float16ImageAMD = 5008,
    ImageGatherBiasLodAMD = 5009,
    FragmentMaskAMD = 5010,
    StencilExportEXT = 5013,
    ImageReadWriteLodAMD = 5015,
    Int64ImageEXT = 5016,
    ShaderClockKHR = 5055,
    ShaderEnqueueAMDX = 5067,
    QuadControlKHR = 5087,
    SampleMaskOverrideCoverageNV = 5249,
    GeometryShaderPassthroughNV = 5251,
    ShaderViewportIndexLayerEXT = 5254,
    ShaderViewportIndexLayerNV = 5254,
    ShaderViewportMaskNV = 5255,
    ShaderStereoViewNV = 5259,
    PerViewAttributesNV = 5260,
    FragmentFullyCoveredEXT = 5265,
    MeshShadingNV = 5266,
    ImageFootprintNV = 5282,
    MeshShadingEXT = 5283,
    FragmentBarycentricKHR = 5284,
    FragmentBarycentricNV = 5284,
    ComputeDerivativeGroupQuadsNV = 5288,
    FragmentDensityEXT = 5291,
    ShadingRateNV = 5291,
    GroupNonUniformPartitionedNV = 5297,
    ShaderNonUniform = 5301,
    ShaderNonUniformEXT = 5301,
    RuntimeDescriptorArray = 5302,
    RuntimeDescriptorArrayEXT = 5302,
    InputAttachmentArrayDynamicIndexing = 5303,
    InputAttachmentArrayDynamicIndexingEXT = 5303,
    UniformTexelBufferArrayDynamicIndexing = 5304,
    UniformTexelBufferArrayDynamicIndexingEXT = 5304,
    StorageTexelBufferArrayDynamicIndexing = 5305,
    StorageTexelBufferArrayDynamicIndexingEXT = 5305,
    UniformBufferArrayNonUniformIndexing = 5306,
    UniformBufferArrayNonUniformIndexingEXT = 5306,
    SampledImageArrayNonUniformIndexing = 5307,
    SampledImageArrayNonUniformIndexingEXT = 5307,
    StorageBufferArrayNonUniformIndexing = 5308,
    StorageBufferArrayNonUniformIndexingEXT = 5308,
    StorageImageArrayNonUniformIndexing = 5309,
    StorageImageArrayNonUniformIndexingEXT = 5309,
    InputAttachmentArrayNonUniformIndexing = 5310,
    InputAttachmentArrayNonUniformIndexingEXT = 5310,
    UniformTexelBufferArrayNonUniformIndexing = 5311,
    UniformTexelBufferArrayNonUniformIndexingEXT = 5311,
    StorageTexelBufferArrayNonUniformIndexing = 5312,
    StorageTexelBufferArrayNonUniformIndexingEXT = 5312,
    RayTracingPositionFetchKHR = 5336,
    RayTracingNV = 5340,
    RayTracingMotionBlurNV = 5341,
    VulkanMemoryModel = 5345,
    VulkanMemoryModelKHR = 5345,
    VulkanMemoryModelDeviceScope = 5346,
    VulkanMemoryModelDeviceScopeKHR = 5346,
    PhysicalStorageBufferAddresses = 5347,
    PhysicalStorageBufferAddressesEXT = 5347,
    ComputeDerivativeGroupLinearNV = 5350,
    RayTracingProvisionalKHR = 5353,
    CooperativeMatrixNV = 5357,
    FragmentShaderSampleInterlockEXT = 5363,
    FragmentShaderShadingRateInterlockEXT = 5372,
    ShaderSMBuiltinsNV = 5373,
    FragmentShaderPixelInterlockEXT = 5378,
    DemoteToHelperInvocation = 5379,
    DemoteToHelperInvocationEXT = 5379,
    DisplacementMicromapNV = 5380,
    RayTracingOpacityMicromapEXT = 5381,
    ShaderInvocationReorderNV = 5383,
    BindlessTextureNV = 5390,
    RayQueryPositionFetchKHR = 5391,
    AtomicFloat16VectorNV = 5404,
    RayTracingDisplacementMicromapNV = 5409,
    RawAccessChainsNV = 5414,
    SubgroupShuffleINTEL = 5568,
    SubgroupBufferBlockIOINTEL = 5569,
    SubgroupImageBlockIOINTEL = 5570,
    SubgroupImageMediaBlockIOINTEL = 5579,
    RoundToInfinityINTEL = 5582,
    FloatingPointModeINTEL = 5583,
    IntegerFunctions2INTEL = 5584,
    FunctionPointersINTEL = 5603,
    IndirectReferencesINTEL = 5604,
    AsmINTEL = 5606,
    AtomicFloat32MinMaxEXT = 5612,
    AtomicFloat64MinMaxEXT = 5613,
    AtomicFloat16MinMaxEXT = 5616,
    VectorComputeINTEL = 5617,
    VectorAnyINTEL = 5619,
    ExpectAssumeKHR = 5629,
    SubgroupAvcMotionEstimationINTEL = 5696,
    SubgroupAvcMotionEstimationIntraINTEL = 5697,
    SubgroupAvcMotionEstimationChromaINTEL = 5698,
    VariableLengthArrayINTEL = 5817,
    FunctionFloatControlINTEL = 5821,
    FPGAMemoryAttributesINTEL = 5824,
    FPFastMathModeINTEL = 5837,
    ArbitraryPrecisionIntegersINTEL = 5844,
    ArbitraryPrecisionFloatingPointINTEL = 5845,
    UnstructuredLoopControlsINTEL = 5886,
    FPGALoopControlsINTEL = 5888,
    KernelAttributesINTEL = 5892,
    FPGAKernelAttributesINTEL = 5897,
    FPGAMemoryAccessesINTEL = 5898,
    FPGAClusterAttributesINTEL = 5904,
    LoopFuseINTEL = 5906,
    FPGADSPControlINTEL = 5908,
    MemoryAccessAliasingINTEL = 5910,
    FPGAInvocationPipeliningAttributesINTEL = 5916,
    FPGABufferLocationINTEL = 5920,
    ArbitraryPrecisionFixedPointINTEL = 5922,
    USMStorageClassesINTEL = 5935,
    RuntimeAlignedAttributeINTEL = 5939,
    IOPipesINTEL = 5943,
    BlockingPipesINTEL = 5945,
    FPGARegINTEL = 5948,
    DotProductInputAll = 6016,
    DotProductInputAllKHR = 6016,
    DotProductInput4x8Bit = 6017,
    DotProductInput4x8BitKHR = 6017,
    DotProductInput4x8BitPacked = 6018,
    DotProductInput4x8BitPackedKHR = 6018,
    DotProduct = 6019,
    DotProductKHR = 6019,
    RayCullMaskKHR = 6020,
    CooperativeMatrixKHR = 6022,
    ReplicatedCompositesEXT = 6024,
    BitInstructions = 6025,
    GroupNonUniformRotateKHR = 6026,
    FloatControls2 = 6029,
    AtomicFloat32AddEXT = 6033,
    AtomicFloat64AddEXT = 6034,
    LongCompositesINTEL = 6089,
    OptNoneINTEL = 6094,
    AtomicFloat16AddEXT = 6095,
    DebugInfoModuleINTEL = 6114,
    BFloat16ConversionINTEL = 6115,
    SplitBarrierINTEL = 6141,
    FPGAClusterAttributesV2INTEL = 6150,
    FPGAKernelAttributesv2INTEL = 6161,
    FPMaxErrorINTEL = 6169,
    FPGALatencyControlINTEL = 6171,
    FPGAArgumentInterfacesINTEL = 6174,
    GlobalVariableHostAccessINTEL = 6187,
    GlobalVariableFPGADecorationsINTEL = 6189,
    GroupUniformArithmeticKHR = 6400,
    MaskedGatherScatterINTEL = 6427,
    CacheControlsINTEL = 6441,
    RegisterLimitsINTEL = 6460,
    Max = 0x7fffffff,
};

enum class RayFlagsShift : unsigned {
    OpaqueKHR = 0,
    NoOpaqueKHR = 1,
    TerminateOnFirstHitKHR = 2,
    SkipClosestHitShaderKHR = 3,
    CullBackFacingTrianglesKHR = 4,
    CullFrontFacingTrianglesKHR = 5,
    CullOpaqueKHR = 6,
    CullNoOpaqueKHR = 7,
    SkipTrianglesKHR = 8,
    SkipAABBsKHR = 9,
    ForceOpacityMicromap2StateEXT = 10,
    Max = 0x7fffffff,
};

enum class RayFlagsMask : unsigned {
    MaskNone = 0,
    OpaqueKHR = 0x00000001,
    NoOpaqueKHR = 0x00000002,
    TerminateOnFirstHitKHR = 0x00000004,
    SkipClosestHitShaderKHR = 0x00000008,
    CullBackFacingTrianglesKHR = 0x00000010,
    CullFrontFacingTrianglesKHR = 0x00000020,
    CullOpaqueKHR = 0x00000040,
    CullNoOpaqueKHR = 0x00000080,
    SkipTrianglesKHR = 0x00000100,
    SkipAABBsKHR = 0x00000200,
    ForceOpacityMicromap2StateEXT = 0x00000400,
};

enum class RayQueryIntersection : unsigned {
    RayQueryCandidateIntersectionKHR = 0,
    RayQueryCommittedIntersectionKHR = 1,
    Max = 0x7fffffff,
};

enum class RayQueryCommittedIntersectionType : unsigned {
    RayQueryCommittedIntersectionNoneKHR = 0,
    RayQueryCommittedIntersectionTriangleKHR = 1,
    RayQueryCommittedIntersectionGeneratedKHR = 2,
    Max = 0x7fffffff,
};

enum class RayQueryCandidateIntersectionType : unsigned {
    RayQueryCandidateIntersectionTriangleKHR = 0,
    RayQueryCandidateIntersectionAABBKHR = 1,
    Max = 0x7fffffff,
};

enum class FragmentShadingRateShift : unsigned {
    Vertical2Pixels = 0,
    Vertical4Pixels = 1,
    Horizontal2Pixels = 2,
    Horizontal4Pixels = 3,
    Max = 0x7fffffff,
};

enum class FragmentShadingRateMask : unsigned {
    MaskNone = 0,
    Vertical2Pixels = 0x00000001,
    Vertical4Pixels = 0x00000002,
    Horizontal2Pixels = 0x00000004,
    Horizontal4Pixels = 0x00000008,
};

enum class FPDenormMode : unsigned {
    Preserve = 0,
    FlushToZero = 1,
    Max = 0x7fffffff,
};

enum class FPOperationMode : unsigned {
    IEEE = 0,
    ALT = 1,
    Max = 0x7fffffff,
};

enum class QuantizationModes : unsigned {
    TRN = 0,
    TRN_ZERO = 1,
    RND = 2,
    RND_ZERO = 3,
    RND_INF = 4,
    RND_MIN_INF = 5,
    RND_CONV = 6,
    RND_CONV_ODD = 7,
    Max = 0x7fffffff,
};

enum class OverflowModes : unsigned {
    WRAP = 0,
    SAT = 1,
    SAT_ZERO = 2,
    SAT_SYM = 3,
    Max = 0x7fffffff,
};

enum class PackedVectorFormat : unsigned {
    PackedVectorFormat4x8Bit = 0,
    PackedVectorFormat4x8BitKHR = 0,
    Max = 0x7fffffff,
};

enum class CooperativeMatrixOperandsShift : unsigned {
    MatrixASignedComponentsKHR = 0,
    MatrixBSignedComponentsKHR = 1,
    MatrixCSignedComponentsKHR = 2,
    MatrixResultSignedComponentsKHR = 3,
    SaturatingAccumulationKHR = 4,
    Max = 0x7fffffff,
};

enum class CooperativeMatrixOperandsMask : unsigned {
    MaskNone = 0,
    MatrixASignedComponentsKHR = 0x00000001,
    MatrixBSignedComponentsKHR = 0x00000002,
    MatrixCSignedComponentsKHR = 0x00000004,
    MatrixResultSignedComponentsKHR = 0x00000008,
    SaturatingAccumulationKHR = 0x00000010,
};

enum class CooperativeMatrixLayout : unsigned {
    RowMajorKHR = 0,
    ColumnMajorKHR = 1,
    RowBlockedInterleavedARM = 4202,
    ColumnBlockedInterleavedARM = 4203,
    Max = 0x7fffffff,
};

enum class CooperativeMatrixUse : unsigned {
    MatrixAKHR = 0,
    MatrixBKHR = 1,
    MatrixAccumulatorKHR = 2,
    Max = 0x7fffffff,
};

enum class InitializationModeQualifier : unsigned {
    InitOnDeviceReprogramINTEL = 0,
    InitOnDeviceResetINTEL = 1,
    Max = 0x7fffffff,
};

enum class HostAccessQualifier : unsigned {
    NoneINTEL = 0,
    ReadINTEL = 1,
    WriteINTEL = 2,
    ReadWriteINTEL = 3,
    Max = 0x7fffffff,
};

enum class LoadCacheControl : unsigned {
    UncachedINTEL = 0,
    CachedINTEL = 1,
    StreamingINTEL = 2,
    InvalidateAfterReadINTEL = 3,
    ConstCachedINTEL = 4,
    Max = 0x7fffffff,
};

enum class StoreCacheControl : unsigned {
    UncachedINTEL = 0,
    WriteThroughINTEL = 1,
    WriteBackINTEL = 2,
    StreamingINTEL = 3,
    Max = 0x7fffffff,
};

enum class NamedMaximumNumberOfRegisters : unsigned {
    AutoINTEL = 0,
    Max = 0x7fffffff,
};

enum class RawAccessChainOperandsShift : unsigned {
    RobustnessPerComponentNV = 0,
    RobustnessPerElementNV = 1,
    Max = 0x7fffffff,
};

enum class RawAccessChainOperandsMask : unsigned {
    MaskNone = 0,
    RobustnessPerComponentNV = 0x00000001,
    RobustnessPerElementNV = 0x00000002,
};

enum class FPEncoding : unsigned {
    Max = 0x7fffffff,
};

enum class Op : unsigned {
    OpNop = 0,
    OpUndef = 1,
    OpSourceContinued = 2,
    OpSource = 3,
    OpSourceExtension = 4,
    OpName = 5,
    OpMemberName = 6,
    OpString = 7,
    OpLine = 8,
    OpExtension = 10,
    OpExtInstImport = 11,
    OpExtInst = 12,
    OpMemoryModel = 14,
    OpEntryPoint = 15,
    OpExecutionMode = 16,
    OpCapability = 17,
    OpTypeVoid = 19,
    OpTypeBool = 20,
    OpTypeInt = 21,
    OpTypeFloat = 22,
    OpTypeVector = 23,
    OpTypeMatrix = 24,
    OpTypeImage = 25,
    OpTypeSampler = 26,
    OpTypeSampledImage = 27,
    OpTypeArray = 28,
    OpTypeRuntimeArray = 29,
    OpTypeStruct = 30,
    OpTypeOpaque = 31,
    OpTypePointer = 32,
    OpTypeFunction = 33,
    OpTypeEvent = 34,
    OpTypeDeviceEvent = 35,
    OpTypeReserveId = 36,
    OpTypeQueue = 37,
    OpTypePipe = 38,
    OpTypeForwardPointer = 39,
    OpConstantTrue = 41,
    OpConstantFalse = 42,
    OpConstant = 43,
    OpConstantComposite = 44,
    OpConstantSampler = 45,
    OpConstantNull = 46,
    OpSpecConstantTrue = 48,
    OpSpecConstantFalse = 49,
    OpSpecConstant = 50,
    OpSpecConstantComposite = 51,
    OpSpecConstantOp = 52,
    OpFunction = 54,
    OpFunctionParameter = 55,
    OpFunctionEnd = 56,
    OpFunctionCall = 57,
    OpVariable = 59,
    OpImageTexelPointer = 60,
    OpLoad = 61,
    OpStore = 62,
    OpCopyMemory = 63,
    OpCopyMemorySized = 64,
    OpAccessChain = 65,
    OpInBoundsAccessChain = 66,
    OpPtrAccessChain = 67,
    OpArrayLength = 68,
    OpGenericPtrMemSemantics = 69,
    OpInBoundsPtrAccessChain = 70,
    OpDecorate = 71,
    OpMemberDecorate = 72,
    OpDecorationGroup = 73,
    OpGroupDecorate = 74,
    OpGroupMemberDecorate = 75,
    OpVectorExtractDynamic = 77,
    OpVectorInsertDynamic = 78,
    OpVectorShuffle = 79,
    OpCompositeConstruct = 80,
    OpCompositeExtract = 81,
    OpCompositeInsert = 82,
    OpCopyObject = 83,
    OpTranspose = 84,
    OpSampledImage = 86,
    OpImageSampleImplicitLod = 87,
    OpImageSampleExplicitLod = 88,
    OpImageSampleDrefImplicitLod = 89,
    OpImageSampleDrefExplicitLod = 90,
    OpImageSampleProjImplicitLod = 91,
    OpImageSampleProjExplicitLod = 92,
    OpImageSampleProjDrefImplicitLod = 93,
    OpImageSampleProjDrefExplicitLod = 94,
    OpImageFetch = 95,
    OpImageGather = 96,
    OpImageDrefGather = 97,
    OpImageRead = 98,
    OpImageWrite = 99,
    OpImage = 100,
    OpImageQueryFormat = 101,
    OpImageQueryOrder = 102,
    OpImageQuerySizeLod = 103,
    OpImageQuerySize = 104,
    OpImageQueryLod = 105,
    OpImageQueryLevels = 106,
    OpImageQuerySamples = 107,
    OpConvertFToU = 109,
    OpConvertFToS = 110,
    OpConvertSToF = 111,
    OpConvertUToF = 112,
    OpUConvert = 113,
    OpSConvert = 114,
    OpFConvert = 115,
    OpQuantizeToF16 = 116,
    OpConvertPtrToU = 117,
    OpSatConvertSToU = 118,
    OpSatConvertUToS = 119,
    OpConvertUToPtr = 120,
    OpPtrCastToGeneric = 121,
    OpGenericCastToPtr = 122,
    OpGenericCastToPtrExplicit = 123,
    OpBitcast = 124,
    OpSNegate = 126,
    OpFNegate = 127,
    OpIAdd = 128,
    OpFAdd = 129,
    OpISub = 130,
    OpFSub = 131,
    OpIMul = 132,
    OpFMul = 133,
    OpUDiv = 134,
    OpSDiv = 135,
    OpFDiv = 136,
    OpUMod = 137,
    OpSRem = 138,
    OpSMod = 139,
    OpFRem = 140,
    OpFMod = 141,
    OpVectorTimesScalar = 142,
    OpMatrixTimesScalar = 143,
    OpVectorTimesMatrix = 144,
    OpMatrixTimesVector = 145,
    OpMatrixTimesMatrix = 146,
    OpOuterProduct = 147,
    OpDot = 148,
    OpIAddCarry = 149,
    OpISubBorrow = 150,
    OpUMulExtended = 151,
    OpSMulExtended = 152,
    OpAny = 154,
    OpAll = 155,
    OpIsNan = 156,
    OpIsInf = 157,
    OpIsFinite = 158,
    OpIsNormal = 159,
    OpSignBitSet = 160,
    OpLessOrGreater = 161,
    OpOrdered = 162,
    OpUnordered = 163,
    OpLogicalEqual = 164,
    OpLogicalNotEqual = 165,
    OpLogicalOr = 166,
    OpLogicalAnd = 167,
    OpLogicalNot = 168,
    OpSelect = 169,
    OpIEqual = 170,
    OpINotEqual = 171,
    OpUGreaterThan = 172,
    OpSGreaterThan = 173,
    OpUGreaterThanEqual = 174,
    OpSGreaterThanEqual = 175,
    OpULessThan = 176,
    OpSLessThan = 177,
    OpULessThanEqual = 178,
    OpSLessThanEqual = 179,
    OpFOrdEqual = 180,
    OpFUnordEqual = 181,
    OpFOrdNotEqual = 182,
    OpFUnordNotEqual = 183,
    OpFOrdLessThan = 184,
    OpFUnordLessThan = 185,
    OpFOrdGreaterThan = 186,
    OpFUnordGreaterThan = 187,
    OpFOrdLessThanEqual = 188,
    OpFUnordLessThanEqual = 189,
    OpFOrdGreaterThanEqual = 190,
    OpFUnordGreaterThanEqual = 191,
    OpShiftRightLogical = 194,
    OpShiftRightArithmetic = 195,
    OpShiftLeftLogical = 196,
    OpBitwiseOr = 197,
    OpBitwiseXor = 198,
    OpBitwiseAnd = 199,
    OpNot = 200,
    OpBitFieldInsert = 201,
    OpBitFieldSExtract = 202,
    OpBitFieldUExtract = 203,
    OpBitReverse = 204,
    OpBitCount = 205,
    OpDPdx = 207,
    OpDPdy = 208,
    OpFwidth = 209,
    OpDPdxFine = 210,
    OpDPdyFine = 211,
    OpFwidthFine = 212,
    OpDPdxCoarse = 213,
    OpDPdyCoarse = 214,
    OpFwidthCoarse = 215,
    OpEmitVertex = 218,
    OpEndPrimitive = 219,
    OpEmitStreamVertex = 220,
    OpEndStreamPrimitive = 221,
    OpControlBarrier = 224,
    OpMemoryBarrier = 225,
    OpAtomicLoad = 227,
    OpAtomicStore = 228,
    OpAtomicExchange = 229,
    OpAtomicCompareExchange = 230,
    OpAtomicCompareExchangeWeak = 231,
    OpAtomicIIncrement = 232,
    OpAtomicIDecrement = 233,
    OpAtomicIAdd = 234,
    OpAtomicISub = 235,
    OpAtomicSMin = 236,
    OpAtomicUMin = 237,
    OpAtomicSMax = 238,
    OpAtomicUMax = 239,
    OpAtomicAnd = 240,
    OpAtomicOr = 241,
    OpAtomicXor = 242,
    OpPhi = 245,
    OpLoopMerge = 246,
    OpSelectionMerge = 247,
    OpLabel = 248,
    OpBranch = 249,
    OpBranchConditional = 250,
    OpSwitch = 251,
    OpKill = 252,
    OpReturn = 253,
    OpReturnValue = 254,
    OpUnreachable = 255,
    OpLifetimeStart = 256,
    OpLifetimeStop = 257,
    OpGroupAsyncCopy = 259,
    OpGroupWaitEvents = 260,
    OpGroupAll = 261,
    OpGroupAny = 262,
    OpGroupBroadcast = 263,
    OpGroupIAdd = 264,
    OpGroupFAdd = 265,
    OpGroupFMin = 266,
    OpGroupUMin = 267,
    OpGroupSMin = 268,
    OpGroupFMax = 269,
    OpGroupUMax = 270,
    OpGroupSMax = 271,
    OpReadPipe = 274,
    OpWritePipe = 275,
    OpReservedReadPipe = 276,
    OpReservedWritePipe = 277,
    OpReserveReadPipePackets = 278,
    OpReserveWritePipePackets = 279,
    OpCommitReadPipe = 280,
    OpCommitWritePipe = 281,
    OpIsValidReserveId = 282,
    OpGetNumPipePackets = 283,
    OpGetMaxPipePackets = 284,
    OpGroupReserveReadPipePackets = 285,
    OpGroupReserveWritePipePackets = 286,
    OpGroupCommitReadPipe = 287,
    OpGroupCommitWritePipe = 288,
    OpEnqueueMarker = 291,
    OpEnqueueKernel = 292,
    OpGetKernelNDrangeSubGroupCount = 293,
    OpGetKernelNDrangeMaxSubGroupSize = 294,
    OpGetKernelWorkGroupSize = 295,
    OpGetKernelPreferredWorkGroupSizeMultiple = 296,
    OpRetainEvent = 297,
    OpReleaseEvent = 298,
    OpCreateUserEvent = 299,
    OpIsValidEvent = 300,
    OpSetUserEventStatus = 301,
    OpCaptureEventProfilingInfo = 302,
    OpGetDefaultQueue = 303,
    OpBuildNDRange = 304,
    OpImageSparseSampleImplicitLod = 305,
    OpImageSparseSampleExplicitLod = 306,
    OpImageSparseSampleDrefImplicitLod = 307,
    OpImageSparseSampleDrefExplicitLod = 308,
    OpImageSparseSampleProjImplicitLod = 309,
    OpImageSparseSampleProjExplicitLod = 310,
    OpImageSparseSampleProjDrefImplicitLod = 311,
    OpImageSparseSampleProjDrefExplicitLod = 312,
    OpImageSparseFetch = 313,
    OpImageSparseGather = 314,
    OpImageSparseDrefGather = 315,
    OpImageSparseTexelsResident = 316,
    OpNoLine = 317,
    OpAtomicFlagTestAndSet = 318,
    OpAtomicFlagClear = 319,
    OpImageSparseRead = 320,
    OpSizeOf = 321,
    OpTypePipeStorage = 322,
    OpConstantPipeStorage = 323,
    OpCreatePipeFromPipeStorage = 324,
    OpGetKernelLocalSizeForSubgroupCount = 325,
    OpGetKernelMaxNumSubgroups = 326,
    OpTypeNamedBarrier = 327,
    OpNamedBarrierInitialize = 328,
    OpMemoryNamedBarrier = 329,
    OpModuleProcessed = 330,
    OpExecutionModeId = 331,
    OpDecorateId = 332,
    OpGroupNonUniformElect = 333,
    OpGroupNonUniformAll = 334,
    OpGroupNonUniformAny = 335,
    OpGroupNonUniformAllEqual = 336,
    OpGroupNonUniformBroadcast = 337,
    OpGroupNonUniformBroadcastFirst = 338,
    OpGroupNonUniformBallot = 339,
    OpGroupNonUniformInverseBallot = 340,
    OpGroupNonUniformBallotBitExtract = 341,
    OpGroupNonUniformBallotBitCount = 342,
    OpGroupNonUniformBallotFindLSB = 343,
    OpGroupNonUniformBallotFindMSB = 344,
    OpGroupNonUniformShuffle = 345,
    OpGroupNonUniformShuffleXor = 346,
    OpGroupNonUniformShuffleUp = 347,
    OpGroupNonUniformShuffleDown = 348,
    OpGroupNonUniformIAdd = 349,
    OpGroupNonUniformFAdd = 350,
    OpGroupNonUniformIMul = 351,
    OpGroupNonUniformFMul = 352,
    OpGroupNonUniformSMin = 353,
    OpGroupNonUniformUMin = 354,
    OpGroupNonUniformFMin = 355,
    OpGroupNonUniformSMax = 356,
    OpGroupNonUniformUMax = 357,
    OpGroupNonUniformFMax = 358,
    OpGroupNonUniformBitwiseAnd = 359,
    OpGroupNonUniformBitwiseOr = 360,
    OpGroupNonUniformBitwiseXor = 361,
    OpGroupNonUniformLogicalAnd = 362,
    OpGroupNonUniformLogicalOr = 363,
    OpGroupNonUniformLogicalXor = 364,
    OpGroupNonUniformQuadBroadcast = 365,
    OpGroupNonUniformQuadSwap = 366,
    OpCopyLogical = 400,
    OpPtrEqual = 401,
    OpPtrNotEqual = 402,
    OpPtrDiff = 403,
    OpColorAttachmentReadEXT = 4160,
    OpDepthAttachmentReadEXT = 4161,
    OpStencilAttachmentReadEXT = 4162,
    OpTerminateInvocation = 4416,
    OpSubgroupBallotKHR = 4421,
    OpSubgroupFirstInvocationKHR = 4422,
    OpSubgroupAllKHR = 4428,
    OpSubgroupAnyKHR = 4429,
    OpSubgroupAllEqualKHR = 4430,
    OpGroupNonUniformRotateKHR = 4431,
    OpSubgroupReadInvocationKHR = 4432,
    OpExtInstWithForwardRefsKHR = 4433,
    OpTraceRayKHR = 4445,
    OpExecuteCallableKHR = 4446,
    OpConvertUToAccelerationStructureKHR = 4447,
    OpIgnoreIntersectionKHR = 4448,
    OpTerminateRayKHR = 4449,
    OpSDot = 4450,
    OpSDotKHR = 4450,
    OpUDot = 4451,
    OpUDotKHR = 4451,
    OpSUDot = 4452,
    OpSUDotKHR = 4452,
    OpSDotAccSat = 4453,
    OpSDotAccSatKHR = 4453,
    OpUDotAccSat = 4454,
    OpUDotAccSatKHR = 4454,
    OpSUDotAccSat = 4455,
    OpSUDotAccSatKHR = 4455,
    OpTypeCooperativeMatrixKHR = 4456,
    OpCooperativeMatrixLoadKHR = 4457,
    OpCooperativeMatrixStoreKHR = 4458,
    OpCooperativeMatrixMulAddKHR = 4459,
    OpCooperativeMatrixLengthKHR = 4460,
    OpConstantCompositeReplicateEXT = 4461,
    OpSpecConstantCompositeReplicateEXT = 4462,
    OpCompositeConstructReplicateEXT = 4463,
    OpTypeRayQueryKHR = 4472,
    OpRayQueryInitializeKHR = 4473,
    OpRayQueryTerminateKHR = 4474,
    OpRayQueryGenerateIntersectionKHR = 4475,
    OpRayQueryConfirmIntersectionKHR = 4476,
    OpRayQueryProceedKHR = 4477,
    OpRayQueryGetIntersectionTypeKHR = 4479,
    OpImageSampleWeightedQCOM = 4480,
    OpImageBoxFilterQCOM = 4481,
    OpImageBlockMatchSSDQCOM = 4482,
    OpImageBlockMatchSADQCOM = 4483,
    OpImageBlockMatchWindowSSDQCOM = 4500,
    OpImageBlockMatchWindowSADQCOM = 4501,
    OpImageBlockMatchGatherSSDQCOM = 4502,
    OpImageBlockMatchGatherSADQCOM = 4503,
    OpGroupIAddNonUniformAMD = 5000,
    OpGroupFAddNonUniformAMD = 5001,
    OpGroupFMinNonUniformAMD = 5002,
    OpGroupUMinNonUniformAMD = 5003,
    OpGroupSMinNonUniformAMD = 5004,
    OpGroupFMaxNonUniformAMD = 5005,
    OpGroupUMaxNonUniformAMD = 5006,
    OpGroupSMaxNonUniformAMD = 5007,
    OpFragmentMaskFetchAMD = 5011,
    OpFragmentFetchAMD = 5012,
    OpReadClockKHR = 5056,
    OpFinalizeNodePayloadsAMDX = 5075,
    OpFinishWritingNodePayloadAMDX = 5078,
    OpInitializeNodePayloadsAMDX = 5090,
    OpGroupNonUniformQuadAllKHR = 5110,
    OpGroupNonUniformQuadAnyKHR = 5111,
    OpHitObjectRecordHitMotionNV = 5249,
    OpHitObjectRecordHitWithIndexMotionNV = 5250,
    OpHitObjectRecordMissMotionNV = 5251,
    OpHitObjectGetWorldToObjectNV = 5252,
    OpHitObjectGetObjectToWorldNV = 5253,
    OpHitObjectGetObjectRayDirectionNV = 5254,
    OpHitObjectGetObjectRayOriginNV = 5255,
    OpHitObjectTraceRayMotionNV = 5256,
    OpHitObjectGetShaderRecordBufferHandleNV = 5257,
    OpHitObjectGetShaderBindingTableRecordIndexNV = 5258,
    OpHitObjectRecordEmptyNV = 5259,
    OpHitObjectTraceRayNV = 5260,
    OpHitObjectRecordHitNV = 5261,
    OpHitObjectRecordHitWithIndexNV = 5262,
    OpHitObjectRecordMissNV = 5263,
    OpHitObjectExecuteShaderNV = 5264,
    OpHitObjectGetCurrentTimeNV = 5265,
    OpHitObjectGetAttributesNV = 5266,
    OpHitObjectGetHitKindNV = 5267,
    OpHitObjectGetPrimitiveIndexNV = 5268,
    OpHitObjectGetGeometryIndexNV = 5269,
    OpHitObjectGetInstanceIdNV = 5270,
    OpHitObjectGetInstanceCustomIndexNV = 5271,
    OpHitObjectGetWorldRayDirectionNV = 5272,
    OpHitObjectGetWorldRayOriginNV = 5273,
    OpHitObjectGetRayTMaxNV = 5274,
    OpHitObjectGetRayTMinNV = 5275,
    OpHitObjectIsEmptyNV = 5276,
    OpHitObjectIsHitNV = 5277,
    OpHitObjectIsMissNV = 5278,
    OpReorderThreadWithHitObjectNV = 5279,
    OpReorderThreadWithHintNV = 5280,
    OpTypeHitObjectNV = 5281,
    OpImageSampleFootprintNV = 5283,
    OpEmitMeshTasksEXT = 5294,
    OpSetMeshOutputsEXT = 5295,
    OpGroupNonUniformPartitionNV = 5296,
    OpWritePackedPrimitiveIndices4x8NV = 5299,
    OpFetchMicroTriangleVertexPositionNV = 5300,
    OpFetchMicroTriangleVertexBarycentricNV = 5301,
    OpReportIntersectionKHR = 5334,
    OpReportIntersectionNV = 5334,
    OpIgnoreIntersectionNV = 5335,
    OpTerminateRayNV = 5336,
    OpTraceNV = 5337,
    OpTraceMotionNV = 5338,
    OpTraceRayMotionNV = 5339,
    OpRayQueryGetIntersectionTriangleVertexPositionsKHR = 5340,
    OpTypeAccelerationStructureKHR = 5341,
    OpTypeAccelerationStructureNV = 5341,
    OpExecuteCallableNV = 5344,
    OpTypeCooperativeMatrixNV = 5358,
    OpCooperativeMatrixLoadNV = 5359,
    OpCooperativeMatrixStoreNV = 5360,
    OpCooperativeMatrixMulAddNV = 5361,
    OpCooperativeMatrixLengthNV = 5362,
    OpBeginInvocationInterlockEXT = 5364,
    OpEndInvocationInterlockEXT = 5365,
    OpDemoteToHelperInvocation = 5380,
    OpDemoteToHelperInvocationEXT = 5380,
    OpIsHelperInvocationEXT = 5381,
    OpConvertUToImageNV = 5391,
    OpConvertUToSamplerNV = 5392,
    OpConvertImageToUNV = 5393,
    OpConvertSamplerToUNV = 5394,
    OpConvertUToSampledImageNV = 5395,
    OpConvertSampledImageToUNV = 5396,
    OpSamplerImageAddressingModeNV = 5397,
    OpRawAccessChainNV = 5398,
    OpSubgroupShuffleINTEL = 5571,
    OpSubgroupShuffleDownINTEL = 5572,
    OpSubgroupShuffleUpINTEL = 5573,
    OpSubgroupShuffleXorINTEL = 5574,
    OpSubgroupBlockReadINTEL = 5575,
    OpSubgroupBlockWriteINTEL = 5576,
    OpSubgroupImageBlockReadINTEL = 5577,
    OpSubgroupImageBlockWriteINTEL = 5578,
    OpSubgroupImageMediaBlockReadINTEL = 5580,
    OpSubgroupImageMediaBlockWriteINTEL = 5581,
    OpUCountLeadingZerosINTEL = 5585,
    OpUCountTrailingZerosINTEL = 5586,
    OpAbsISubINTEL = 5587,
    OpAbsUSubINTEL = 5588,
    OpIAddSatINTEL = 5589,
    OpUAddSatINTEL = 5590,
    OpIAverageINTEL = 5591,
    OpUAverageINTEL = 5592,
    OpIAverageRoundedINTEL = 5593,
    OpUAverageRoundedINTEL = 5594,
    OpISubSatINTEL = 5595,
    OpUSubSatINTEL = 5596,
    OpIMul32x16INTEL = 5597,
    OpUMul32x16INTEL = 5598,
    OpConstantFunctionPointerINTEL = 5600,
    OpFunctionPointerCallINTEL = 5601,
    OpAsmTargetINTEL = 5609,
    OpAsmINTEL = 5610,
    OpAsmCallINTEL = 5611,
    OpAtomicFMinEXT = 5614,
    OpAtomicFMaxEXT = 5615,
    OpAssumeTrueKHR = 5630,
    OpExpectKHR = 5631,
    OpDecorateString = 5632,
    OpDecorateStringGOOGLE = 5632,
    OpMemberDecorateString = 5633,
    OpMemberDecorateStringGOOGLE = 5633,
    OpVmeImageINTEL = 5699,
    OpTypeVmeImageINTEL = 5700,
    OpTypeAvcImePayloadINTEL = 5701,
    OpTypeAvcRefPayloadINTEL = 5702,
    OpTypeAvcSicPayloadINTEL = 5703,
    OpTypeAvcMcePayloadINTEL = 5704,
    OpTypeAvcMceResultINTEL = 5705,
    OpTypeAvcImeResultINTEL = 5706,
    OpTypeAvcImeResultSingleReferenceStreamoutINTEL = 5707,
    OpTypeAvcImeResultDualReferenceStreamoutINTEL = 5708,
    OpTypeAvcImeSingleReferenceStreaminINTEL = 5709,
    OpTypeAvcImeDualReferenceStreaminINTEL = 5710,
    OpTypeAvcRefResultINTEL = 5711,
    OpTypeAvcSicResultINTEL = 5712,
    OpSubgroupAvcMceGetDefaultInterBaseMultiReferencePenaltyINTEL = 5713,
    OpSubgroupAvcMceSetInterBaseMultiReferencePenaltyINTEL = 5714,
    OpSubgroupAvcMceGetDefaultInterShapePenaltyINTEL = 5715,
    OpSubgroupAvcMceSetInterShapePenaltyINTEL = 5716,
    OpSubgroupAvcMceGetDefaultInterDirectionPenaltyINTEL = 5717,
    OpSubgroupAvcMceSetInterDirectionPenaltyINTEL = 5718,
    OpSubgroupAvcMceGetDefaultIntraLumaShapePenaltyINTEL = 5719,
    OpSubgroupAvcMceGetDefaultInterMotionVectorCostTableINTEL = 5720,
    OpSubgroupAvcMceGetDefaultHighPenaltyCostTableINTEL = 5721,
    OpSubgroupAvcMceGetDefaultMediumPenaltyCostTableINTEL = 5722,
    OpSubgroupAvcMceGetDefaultLowPenaltyCostTableINTEL = 5723,
    OpSubgroupAvcMceSetMotionVectorCostFunctionINTEL = 5724,
    OpSubgroupAvcMceGetDefaultIntraLumaModePenaltyINTEL = 5725,
    OpSubgroupAvcMceGetDefaultNonDcLumaIntraPenaltyINTEL = 5726,
    OpSubgroupAvcMceGetDefaultIntraChromaModeBasePenaltyINTEL = 5727,
    OpSubgroupAvcMceSetAcOnlyHaarINTEL = 5728,
    OpSubgroupAvcMceSetSourceInterlacedFieldPolarityINTEL = 5729,
    OpSubgroupAvcMceSetSingleReferenceInterlacedFieldPolarityINTEL = 5730,
    OpSubgroupAvcMceSetDualReferenceInterlacedFieldPolaritiesINTEL = 5731,
    OpSubgroupAvcMceConvertToImePayloadINTEL = 5732,
    OpSubgroupAvcMceConvertToImeResultINTEL = 5733,
    OpSubgroupAvcMceConvertToRefPayloadINTEL = 5734,
    OpSubgroupAvcMceConvertToRefResultINTEL = 5735,
    OpSubgroupAvcMceConvertToSicPayloadINTEL = 5736,
    OpSubgroupAvcMceConvertToSicResultINTEL = 5737,
    OpSubgroupAvcMceGetMotionVectorsINTEL = 5738,
    OpSubgroupAvcMceGetInterDistortionsINTEL = 5739,
    OpSubgroupAvcMceGetBestInterDistortionsINTEL = 5740,
    OpSubgroupAvcMceGetInterMajorShapeINTEL = 5741,
    OpSubgroupAvcMceGetInterMinorShapeINTEL = 5742,
    OpSubgroupAvcMceGetInterDirectionsINTEL = 5743,
    OpSubgroupAvcMceGetInterMotionVectorCountINTEL = 5744,
    OpSubgroupAvcMceGetInterReferenceIdsINTEL = 5745,
    OpSubgroupAvcMceGetInterReferenceInterlacedFieldPolaritiesINTEL = 5746,
    OpSubgroupAvcImeInitializeINTEL = 5747,
    OpSubgroupAvcImeSetSingleReferenceINTEL = 5748,
    OpSubgroupAvcImeSetDualReferenceINTEL = 5749,
    OpSubgroupAvcImeRefWindowSizeINTEL = 5750,
    OpSubgroupAvcImeAdjustRefOffsetINTEL = 5751,
    OpSubgroupAvcImeConvertToMcePayloadINTEL = 5752,
    OpSubgroupAvcImeSetMaxMotionVectorCountINTEL = 5753,
    OpSubgroupAvcImeSetUnidirectionalMixDisableINTEL = 5754,
    OpSubgroupAvcImeSetEarlySearchTerminationThresholdINTEL = 5755,
    OpSubgroupAvcImeSetWeightedSadINTEL = 5756,
    OpSubgroupAvcImeEvaluateWithSingleReferenceINTEL = 5757,
    OpSubgroupAvcImeEvaluateWithDualReferenceINTEL = 5758,
    OpSubgroupAvcImeEvaluateWithSingleReferenceStreaminINTEL = 5759,
    OpSubgroupAvcImeEvaluateWithDualReferenceStreaminINTEL = 5760,
    OpSubgroupAvcImeEvaluateWithSingleReferenceStreamoutINTEL = 5761,
    OpSubgroupAvcImeEvaluateWithDualReferenceStreamoutINTEL = 5762,
    OpSubgroupAvcImeEvaluateWithSingleReferenceStreaminoutINTEL = 5763,
    OpSubgroupAvcImeEvaluateWithDualReferenceStreaminoutINTEL = 5764,
    OpSubgroupAvcImeConvertToMceResultINTEL = 5765,
    OpSubgroupAvcImeGetSingleReferenceStreaminINTEL = 5766,
    OpSubgroupAvcImeGetDualReferenceStreaminINTEL = 5767,
    OpSubgroupAvcImeStripSingleReferenceStreamoutINTEL = 5768,
    OpSubgroupAvcImeStripDualReferenceStreamoutINTEL = 5769,
    OpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeMotionVectorsINTEL = 5770,
    OpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeDistortionsINTEL = 5771,
    OpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeReferenceIdsINTEL = 5772,
    OpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeMotionVectorsINTEL = 5773,
    OpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeDistortionsINTEL = 5774,
    OpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeReferenceIdsINTEL = 5775,
    OpSubgroupAvcImeGetBorderReachedINTEL = 5776,
    OpSubgroupAvcImeGetTruncatedSearchIndicationINTEL = 5777,
    OpSubgroupAvcImeGetUnidirectionalEarlySearchTerminationINTEL = 5778,
    OpSubgroupAvcImeGetWeightingPatternMinimumMotionVectorINTEL = 5779,
    OpSubgroupAvcImeGetWeightingPatternMinimumDistortionINTEL = 5780,
    OpSubgroupAvcFmeInitializeINTEL = 5781,
    OpSubgroupAvcBmeInitializeINTEL = 5782,
    OpSubgroupAvcRefConvertToMcePayloadINTEL = 5783,
    OpSubgroupAvcRefSetBidirectionalMixDisableINTEL = 5784,
    OpSubgroupAvcRefSetBilinearFilterEnableINTEL = 5785,
    OpSubgroupAvcRefEvaluateWithSingleReferenceINTEL = 5786,
    OpSubgroupAvcRefEvaluateWithDualReferenceINTEL = 5787,
    OpSubgroupAvcRefEvaluateWithMultiReferenceINTEL = 5788,
    OpSubgroupAvcRefEvaluateWithMultiReferenceInterlacedINTEL = 5789,
    OpSubgroupAvcRefConvertToMceResultINTEL = 5790,
    OpSubgroupAvcSicInitializeINTEL = 5791,
    OpSubgroupAvcSicConfigureSkcINTEL = 5792,
    OpSubgroupAvcSicConfigureIpeLumaINTEL = 5793,
    OpSubgroupAvcSicConfigureIpeLumaChromaINTEL = 5794,
    OpSubgroupAvcSicGetMotionVectorMaskINTEL = 5795,
    OpSubgroupAvcSicConvertToMcePayloadINTEL = 5796,
    OpSubgroupAvcSicSetIntraLumaShapePenaltyINTEL = 5797,
    OpSubgroupAvcSicSetIntraLumaModeCostFunctionINTEL = 5798,
    OpSubgroupAvcSicSetIntraChromaModeCostFunctionINTEL = 5799,
    OpSubgroupAvcSicSetBilinearFilterEnableINTEL = 5800,
    OpSubgroupAvcSicSetSkcForwardTransformEnableINTEL = 5801,
    OpSubgroupAvcSicSetBlockBasedRawSkipSadINTEL = 5802,
    OpSubgroupAvcSicEvaluateIpeINTEL = 5803,
    OpSubgroupAvcSicEvaluateWithSingleReferenceINTEL = 5804,
    OpSubgroupAvcSicEvaluateWithDualReferenceINTEL = 5805,
    OpSubgroupAvcSicEvaluateWithMultiReferenceINTEL = 5806,
    OpSubgroupAvcSicEvaluateWithMultiReferenceInterlacedINTEL = 5807,
    OpSubgroupAvcSicConvertToMceResultINTEL = 5808,
    OpSubgroupAvcSicGetIpeLumaShapeINTEL = 5809,
    OpSubgroupAvcSicGetBestIpeLumaDistortionINTEL = 5810,
    OpSubgroupAvcSicGetBestIpeChromaDistortionINTEL = 5811,
    OpSubgroupAvcSicGetPackedIpeLumaModesINTEL = 5812,
    OpSubgroupAvcSicGetIpeChromaModeINTEL = 5813,
    OpSubgroupAvcSicGetPackedSkcLumaCountThresholdINTEL = 5814,
    OpSubgroupAvcSicGetPackedSkcLumaSumThresholdINTEL = 5815,
    OpSubgroupAvcSicGetInterRawSadsINTEL = 5816,
    OpVariableLengthArrayINTEL = 5818,
    OpSaveMemoryINTEL = 5819,
    OpRestoreMemoryINTEL = 5820,
    OpArbitraryFloatSinCosPiINTEL = 5840,
    OpArbitraryFloatCastINTEL = 5841,
    OpArbitraryFloatCastFromIntINTEL = 5842,
    OpArbitraryFloatCastToIntINTEL = 5843,
    OpArbitraryFloatAddINTEL = 5846,
    OpArbitraryFloatSubINTEL = 5847,
    OpArbitraryFloatMulINTEL = 5848,
    OpArbitraryFloatDivINTEL = 5849,
    OpArbitraryFloatGTINTEL = 5850,
    OpArbitraryFloatGEINTEL = 5851,
    OpArbitraryFloatLTINTEL = 5852,
    OpArbitraryFloatLEINTEL = 5853,
    OpArbitraryFloatEQINTEL = 5854,
    OpArbitraryFloatRecipINTEL = 5855,
    OpArbitraryFloatRSqrtINTEL = 5856,
    OpArbitraryFloatCbrtINTEL = 5857,
    OpArbitraryFloatHypotINTEL = 5858,
    OpArbitraryFloatSqrtINTEL = 5859,
    OpArbitraryFloatLogINTEL = 5860,
    OpArbitraryFloatLog2INTEL = 5861,
    OpArbitraryFloatLog10INTEL = 5862,
    OpArbitraryFloatLog1pINTEL = 5863,
    OpArbitraryFloatExpINTEL = 5864,
    OpArbitraryFloatExp2INTEL = 5865,
    OpArbitraryFloatExp10INTEL = 5866,
    OpArbitraryFloatExpm1INTEL = 5867,
    OpArbitraryFloatSinINTEL = 5868,
    OpArbitraryFloatCosINTEL = 5869,
    OpArbitraryFloatSinCosINTEL = 5870,
    OpArbitraryFloatSinPiINTEL = 5871,
    OpArbitraryFloatCosPiINTEL = 5872,
    OpArbitraryFloatASinINTEL = 5873,
    OpArbitraryFloatASinPiINTEL = 5874,
    OpArbitraryFloatACosINTEL = 5875,
    OpArbitraryFloatACosPiINTEL = 5876,
    OpArbitraryFloatATanINTEL = 5877,
    OpArbitraryFloatATanPiINTEL = 5878,
    OpArbitraryFloatATan2INTEL = 5879,
    OpArbitraryFloatPowINTEL = 5880,
    OpArbitraryFloatPowRINTEL = 5881,
    OpArbitraryFloatPowNINTEL = 5882,
    OpLoopControlINTEL = 5887,
    OpAliasDomainDeclINTEL = 5911,
    OpAliasScopeDeclINTEL = 5912,
    OpAliasScopeListDeclINTEL = 5913,
    OpFixedSqrtINTEL = 5923,
    OpFixedRecipINTEL = 5924,
    OpFixedRsqrtINTEL = 5925,
    OpFixedSinINTEL = 5926,
    OpFixedCosINTEL = 5927,
    OpFixedSinCosINTEL = 5928,
    OpFixedSinPiINTEL = 5929,
    OpFixedCosPiINTEL = 5930,
    OpFixedSinCosPiINTEL = 5931,
    OpFixedLogINTEL = 5932,
    OpFixedExpINTEL = 5933,
    OpPtrCastToCrossWorkgroupINTEL = 5934,
    OpCrossWorkgroupCastToPtrINTEL = 5938,
    OpReadPipeBlockingINTEL = 5946,
    OpWritePipeBlockingINTEL = 5947,
    OpFPGARegINTEL = 5949,
    OpRayQueryGetRayTMinKHR = 6016,
    OpRayQueryGetRayFlagsKHR = 6017,
    OpRayQueryGetIntersectionTKHR = 6018,
    OpRayQueryGetIntersectionInstanceCustomIndexKHR = 6019,
    OpRayQueryGetIntersectionInstanceIdKHR = 6020,
    OpRayQueryGetIntersectionInstanceShaderBindingTableRecordOffsetKHR = 6021,
    OpRayQueryGetIntersectionGeometryIndexKHR = 6022,
    OpRayQueryGetIntersectionPrimitiveIndexKHR = 6023,
    OpRayQueryGetIntersectionBarycentricsKHR = 6024,
    OpRayQueryGetIntersectionFrontFaceKHR = 6025,
    OpRayQueryGetIntersectionCandidateAABBOpaqueKHR = 6026,
    OpRayQueryGetIntersectionObjectRayDirectionKHR = 6027,
    OpRayQueryGetIntersectionObjectRayOriginKHR = 6028,
    OpRayQueryGetWorldRayDirectionKHR = 6029,
    OpRayQueryGetWorldRayOriginKHR = 6030,
    OpRayQueryGetIntersectionObjectToWorldKHR = 6031,
    OpRayQueryGetIntersectionWorldToObjectKHR = 6032,
    OpAtomicFAddEXT = 6035,
    OpTypeBufferSurfaceINTEL = 6086,
    OpTypeStructContinuedINTEL = 6090,
    OpConstantCompositeContinuedINTEL = 6091,
    OpSpecConstantCompositeContinuedINTEL = 6092,
    OpCompositeConstructContinuedINTEL = 6096,
    OpConvertFToBF16INTEL = 6116,
    OpConvertBF16ToFINTEL = 6117,
    OpControlBarrierArriveINTEL = 6142,
    OpControlBarrierWaitINTEL = 6143,
    OpGroupIMulKHR = 6401,
    OpGroupFMulKHR = 6402,
    OpGroupBitwiseAndKHR = 6403,
    OpGroupBitwiseOrKHR = 6404,
    OpGroupBitwiseXorKHR = 6405,
    OpGroupLogicalAndKHR = 6406,
    OpGroupLogicalOrKHR = 6407,
    OpGroupLogicalXorKHR = 6408,
    OpMaskedGatherINTEL = 6428,
    OpMaskedScatterINTEL = 6429,
    Max = 0x7fffffff,
};

#ifdef SPV_ENABLE_UTILITY_CODE
#ifndef __cplusplus
#include <stdbool.h>
#endif
inline void HasResultAndType(Op opcode, bool *hasResult, bool *hasResultType) {
    *hasResult = *hasResultType = false;
    switch (opcode) {
    default: /* unknown opcode */ break;
    case Op::OpNop: *hasResult = false; *hasResultType = false; break;
    case Op::OpUndef: *hasResult = true; *hasResultType = true; break;
    case Op::OpSourceContinued: *hasResult = false; *hasResultType = false; break;
    case Op::OpSource: *hasResult = false; *hasResultType = false; break;
    case Op::OpSourceExtension: *hasResult = false; *hasResultType = false; break;
    case Op::OpName: *hasResult = false; *hasResultType = false; break;
    case Op::OpMemberName: *hasResult = false; *hasResultType = false; break;
    case Op::OpString: *hasResult = true; *hasResultType = false; break;
    case Op::OpLine: *hasResult = false; *hasResultType = false; break;
    case Op::OpExtension: *hasResult = false; *hasResultType = false; break;
    case Op::OpExtInstImport: *hasResult = true; *hasResultType = false; break;
    case Op::OpExtInst: *hasResult = true; *hasResultType = true; break;
    case Op::OpMemoryModel: *hasResult = false; *hasResultType = false; break;
    case Op::OpEntryPoint: *hasResult = false; *hasResultType = false; break;
    case Op::OpExecutionMode: *hasResult = false; *hasResultType = false; break;
    case Op::OpCapability: *hasResult = false; *hasResultType = false; break;
    case Op::OpTypeVoid: *hasResult = true; *hasResultType = false; break;
    case Op::OpTypeBool: *hasResult = true; *hasResultType = false; break;
    case Op::OpTypeInt: *hasResult = true; *hasResultType = false; break;
    case Op::OpTypeFloat: *hasResult = true; *hasResultType = false; break;
    case Op::OpTypeVector: *hasResult = true; *hasResultType = false; break;
    case Op::OpTypeMatrix: *hasResult = true; *hasResultType = false; break;
    case Op::OpTypeImage: *hasResult = true; *hasResultType = false; break;
    case Op::OpTypeSampler: *hasResult = true; *hasResultType = false; break;
    case Op::OpTypeSampledImage: *hasResult = true; *hasResultType = false; break;
    case Op::OpTypeArray: *hasResult = true; *hasResultType = false; break;
    case Op::OpTypeRuntimeArray: *hasResult = true; *hasResultType = false; break;
    case Op::OpTypeStruct: *hasResult = true; *hasResultType = false; break;
    case Op::OpTypeOpaque: *hasResult = true; *hasResultType = false; break;
    case Op::OpTypePointer: *hasResult = true; *hasResultType = false; break;
    case Op::OpTypeFunction: *hasResult = true; *hasResultType = false; break;
    case Op::OpTypeEvent: *hasResult = true; *hasResultType = false; break;
    case Op::OpTypeDeviceEvent: *hasResult = true; *hasResultType = false; break;
    case Op::OpTypeReserveId: *hasResult = true; *hasResultType = false; break;
    case Op::OpTypeQueue: *hasResult = true; *hasResultType = false; break;
    case Op::OpTypePipe: *hasResult = true; *hasResultType = false; break;
    case Op::OpTypeForwardPointer: *hasResult = false; *hasResultType = false; break;
    case Op::OpConstantTrue: *hasResult = true; *hasResultType = true; break;
    case Op::OpConstantFalse: *hasResult = true; *hasResultType = true; break;
    case Op::OpConstant: *hasResult = true; *hasResultType = true; break;
    case Op::OpConstantComposite: *hasResult = true; *hasResultType = true; break;
    case Op::OpConstantSampler: *hasResult = true; *hasResultType = true; break;
    case Op::OpConstantNull: *hasResult = true; *hasResultType = true; break;
    case Op::OpSpecConstantTrue: *hasResult = true; *hasResultType = true; break;
    case Op::OpSpecConstantFalse: *hasResult = true; *hasResultType = true; break;
    case Op::OpSpecConstant: *hasResult = true; *hasResultType = true; break;
    case Op::OpSpecConstantComposite: *hasResult = true; *hasResultType = true; break;
    case Op::OpSpecConstantOp: *hasResult = true; *hasResultType = true; break;
    case Op::OpFunction: *hasResult = true; *hasResultType = true; break;
    case Op::OpFunctionParameter: *hasResult = true; *hasResultType = true; break;
    case Op::OpFunctionEnd: *hasResult = false; *hasResultType = false; break;
    case Op::OpFunctionCall: *hasResult = true; *hasResultType = true; break;
    case Op::OpVariable: *hasResult = true; *hasResultType = true; break;
    case Op::OpImageTexelPointer: *hasResult = true; *hasResultType = true; break;
    case Op::OpLoad: *hasResult = true; *hasResultType = true; break;
    case Op::OpStore: *hasResult = false; *hasResultType = false; break;
    case Op::OpCopyMemory: *hasResult = false; *hasResultType = false; break;
    case Op::OpCopyMemorySized: *hasResult = false; *hasResultType = false; break;
    case Op::OpAccessChain: *hasResult = true; *hasResultType = true; break;
    case Op::OpInBoundsAccessChain: *hasResult = true; *hasResultType = true; break;
    case Op::OpPtrAccessChain: *hasResult = true; *hasResultType = true; break;
    case Op::OpArrayLength: *hasResult = true; *hasResultType = true; break;
    case Op::OpGenericPtrMemSemantics: *hasResult = true; *hasResultType = true; break;
    case Op::OpInBoundsPtrAccessChain: *hasResult = true; *hasResultType = true; break;
    case Op::OpDecorate: *hasResult = false; *hasResultType = false; break;
    case Op::OpMemberDecorate: *hasResult = false; *hasResultType = false; break;
    case Op::OpDecorationGroup: *hasResult = true; *hasResultType = false; break;
    case Op::OpGroupDecorate: *hasResult = false; *hasResultType = false; break;
    case Op::OpGroupMemberDecorate: *hasResult = false; *hasResultType = false; break;
    case Op::OpVectorExtractDynamic: *hasResult = true; *hasResultType = true; break;
    case Op::OpVectorInsertDynamic: *hasResult = true; *hasResultType = true; break;
    case Op::OpVectorShuffle: *hasResult = true; *hasResultType = true; break;
    case Op::OpCompositeConstruct: *hasResult = true; *hasResultType = true; break;
    case Op::OpCompositeExtract: *hasResult = true; *hasResultType = true; break;
    case Op::OpCompositeInsert: *hasResult = true; *hasResultType = true; break;
    case Op::OpCopyObject: *hasResult = true; *hasResultType = true; break;
    case Op::OpTranspose: *hasResult = true; *hasResultType = true; break;
    case Op::OpSampledImage: *hasResult = true; *hasResultType = true; break;
    case Op::OpImageSampleImplicitLod: *hasResult = true; *hasResultType = true; break;
    case Op::OpImageSampleExplicitLod: *hasResult = true; *hasResultType = true; break;
    case Op::OpImageSampleDrefImplicitLod: *hasResult = true; *hasResultType = true; break;
    case Op::OpImageSampleDrefExplicitLod: *hasResult = true; *hasResultType = true; break;
    case Op::OpImageSampleProjImplicitLod: *hasResult = true; *hasResultType = true; break;
    case Op::OpImageSampleProjExplicitLod: *hasResult = true; *hasResultType = true; break;
    case Op::OpImageSampleProjDrefImplicitLod: *hasResult = true; *hasResultType = true; break;
    case Op::OpImageSampleProjDrefExplicitLod: *hasResult = true; *hasResultType = true; break;
    case Op::OpImageFetch: *hasResult = true; *hasResultType = true; break;
    case Op::OpImageGather: *hasResult = true; *hasResultType = true; break;
    case Op::OpImageDrefGather: *hasResult = true; *hasResultType = true; break;
    case Op::OpImageRead: *hasResult = true; *hasResultType = true; break;
    case Op::OpImageWrite: *hasResult = false; *hasResultType = false; break;
    case Op::OpImage: *hasResult = true; *hasResultType = true; break;
    case Op::OpImageQueryFormat: *hasResult = true; *hasResultType = true; break;
    case Op::OpImageQueryOrder: *hasResult = true; *hasResultType = true; break;
    case Op::OpImageQuerySizeLod: *hasResult = true; *hasResultType = true; break;
    case Op::OpImageQuerySize: *hasResult = true; *hasResultType = true; break;
    case Op::OpImageQueryLod: *hasResult = true; *hasResultType = true; break;
    case Op::OpImageQueryLevels: *hasResult = true; *hasResultType = true; break;
    case Op::OpImageQuerySamples: *hasResult = true; *hasResultType = true; break;
    case Op::OpConvertFToU: *hasResult = true; *hasResultType = true; break;
    case Op::OpConvertFToS: *hasResult = true; *hasResultType = true; break;
    case Op::OpConvertSToF: *hasResult = true; *hasResultType = true; break;
    case Op::OpConvertUToF: *hasResult = true; *hasResultType = true; break;
    case Op::OpUConvert: *hasResult = true; *hasResultType = true; break;
    case Op::OpSConvert: *hasResult = true; *hasResultType = true; break;
    case Op::OpFConvert: *hasResult = true; *hasResultType = true; break;
    case Op::OpQuantizeToF16: *hasResult = true; *hasResultType = true; break;
    case Op::OpConvertPtrToU: *hasResult = true; *hasResultType = true; break;
    case Op::OpSatConvertSToU: *hasResult = true; *hasResultType = true; break;
    case Op::OpSatConvertUToS: *hasResult = true; *hasResultType = true; break;
    case Op::OpConvertUToPtr: *hasResult = true; *hasResultType = true; break;
    case Op::OpPtrCastToGeneric: *hasResult = true; *hasResultType = true; break;
    case Op::OpGenericCastToPtr: *hasResult = true; *hasResultType = true; break;
    case Op::OpGenericCastToPtrExplicit: *hasResult = true; *hasResultType = true; break;
    case Op::OpBitcast: *hasResult = true; *hasResultType = true; break;
    case Op::OpSNegate: *hasResult = true; *hasResultType = true; break;
    case Op::OpFNegate: *hasResult = true; *hasResultType = true; break;
    case Op::OpIAdd: *hasResult = true; *hasResultType = true; break;
    case Op::OpFAdd: *hasResult = true; *hasResultType = true; break;
    case Op::OpISub: *hasResult = true; *hasResultType = true; break;
    case Op::OpFSub: *hasResult = true; *hasResultType = true; break;
    case Op::OpIMul: *hasResult = true; *hasResultType = true; break;
    case Op::OpFMul: *hasResult = true; *hasResultType = true; break;
    case Op::OpUDiv: *hasResult = true; *hasResultType = true; break;
    case Op::OpSDiv: *hasResult = true; *hasResultType = true; break;
    case Op::OpFDiv: *hasResult = true; *hasResultType = true; break;
    case Op::OpUMod: *hasResult = true; *hasResultType = true; break;
    case Op::OpSRem: *hasResult = true; *hasResultType = true; break;
    case Op::OpSMod: *hasResult = true; *hasResultType = true; break;
    case Op::OpFRem: *hasResult = true; *hasResultType = true; break;
    case Op::OpFMod: *hasResult = true; *hasResultType = true; break;
    case Op::OpVectorTimesScalar: *hasResult = true; *hasResultType = true; break;
    case Op::OpMatrixTimesScalar: *hasResult = true; *hasResultType = true; break;
    case Op::OpVectorTimesMatrix: *hasResult = true; *hasResultType = true; break;
    case Op::OpMatrixTimesVector: *hasResult = true; *hasResultType = true; break;
    case Op::OpMatrixTimesMatrix: *hasResult = true; *hasResultType = true; break;
    case Op::OpOuterProduct: *hasResult = true; *hasResultType = true; break;
    case Op::OpDot: *hasResult = true; *hasResultType = true; break;
    case Op::OpIAddCarry: *hasResult = true; *hasResultType = true; break;
    case Op::OpISubBorrow: *hasResult = true; *hasResultType = true; break;
    case Op::OpUMulExtended: *hasResult = true; *hasResultType = true; break;
    case Op::OpSMulExtended: *hasResult = true; *hasResultType = true; break;
    case Op::OpAny: *hasResult = true; *hasResultType = true; break;
    case Op::OpAll: *hasResult = true; *hasResultType = true; break;
    case Op::OpIsNan: *hasResult = true; *hasResultType = true; break;
    case Op::OpIsInf: *hasResult = true; *hasResultType = true; break;
    case Op::OpIsFinite: *hasResult = true; *hasResultType = true; break;
    case Op::OpIsNormal: *hasResult = true; *hasResultType = true; break;
    case Op::OpSignBitSet: *hasResult = true; *hasResultType = true; break;
    case Op::OpLessOrGreater: *hasResult = true; *hasResultType = true; break;
    case Op::OpOrdered: *hasResult = true; *hasResultType = true; break;
    case Op::OpUnordered: *hasResult = true; *hasResultType = true; break;
    case Op::OpLogicalEqual: *hasResult = true; *hasResultType = true; break;
    case Op::OpLogicalNotEqual: *hasResult = true; *hasResultType = true; break;
    case Op::OpLogicalOr: *hasResult = true; *hasResultType = true; break;
    case Op::OpLogicalAnd: *hasResult = true; *hasResultType = true; break;
    case Op::OpLogicalNot: *hasResult = true; *hasResultType = true; break;
    case Op::OpSelect: *hasResult = true; *hasResultType = true; break;
    case Op::OpIEqual: *hasResult = true; *hasResultType = true; break;
    case Op::OpINotEqual: *hasResult = true; *hasResultType = true; break;
    case Op::OpUGreaterThan: *hasResult = true; *hasResultType = true; break;
    case Op::OpSGreaterThan: *hasResult = true; *hasResultType = true; break;
    case Op::OpUGreaterThanEqual: *hasResult = true; *hasResultType = true; break;
    case Op::OpSGreaterThanEqual: *hasResult = true; *hasResultType = true; break;
    case Op::OpULessThan: *hasResult = true; *hasResultType = true; break;
    case Op::OpSLessThan: *hasResult = true; *hasResultType = true; break;
    case Op::OpULessThanEqual: *hasResult = true; *hasResultType = true; break;
    case Op::OpSLessThanEqual: *hasResult = true; *hasResultType = true; break;
    case Op::OpFOrdEqual: *hasResult = true; *hasResultType = true; break;
    case Op::OpFUnordEqual: *hasResult = true; *hasResultType = true; break;
    case Op::OpFOrdNotEqual: *hasResult = true; *hasResultType = true; break;
    case Op::OpFUnordNotEqual: *hasResult = true; *hasResultType = true; break;
    case Op::OpFOrdLessThan: *hasResult = true; *hasResultType = true; break;
    case Op::OpFUnordLessThan: *hasResult = true; *hasResultType = true; break;
    case Op::OpFOrdGreaterThan: *hasResult = true; *hasResultType = true; break;
    case Op::OpFUnordGreaterThan: *hasResult = true; *hasResultType = true; break;
    case Op::OpFOrdLessThanEqual: *hasResult = true; *hasResultType = true; break;
    case Op::OpFUnordLessThanEqual: *hasResult = true; *hasResultType = true; break;
    case Op::OpFOrdGreaterThanEqual: *hasResult = true; *hasResultType = true; break;
    case Op::OpFUnordGreaterThanEqual: *hasResult = true; *hasResultType = true; break;
    case Op::OpShiftRightLogical: *hasResult = true; *hasResultType = true; break;
    case Op::OpShiftRightArithmetic: *hasResult = true; *hasResultType = true; break;
    case Op::OpShiftLeftLogical: *hasResult = true; *hasResultType = true; break;
    case Op::OpBitwiseOr: *hasResult = true; *hasResultType = true; break;
    case Op::OpBitwiseXor: *hasResult = true; *hasResultType = true; break;
    case Op::OpBitwiseAnd: *hasResult = true; *hasResultType = true; break;
    case Op::OpNot: *hasResult = true; *hasResultType = true; break;
    case Op::OpBitFieldInsert: *hasResult = true; *hasResultType = true; break;
    case Op::OpBitFieldSExtract: *hasResult = true; *hasResultType = true; break;
    case Op::OpBitFieldUExtract: *hasResult = true; *hasResultType = true; break;
    case Op::OpBitReverse: *hasResult = true; *hasResultType = true; break;
    case Op::OpBitCount: *hasResult = true; *hasResultType = true; break;
    case Op::OpDPdx: *hasResult = true; *hasResultType = true; break;
    case Op::OpDPdy: *hasResult = true; *hasResultType = true; break;
    case Op::OpFwidth: *hasResult = true; *hasResultType = true; break;
    case Op::OpDPdxFine: *hasResult = true; *hasResultType = true; break;
    case Op::OpDPdyFine: *hasResult = true; *hasResultType = true; break;
    case Op::OpFwidthFine: *hasResult = true; *hasResultType = true; break;
    case Op::OpDPdxCoarse: *hasResult = true; *hasResultType = true; break;
    case Op::OpDPdyCoarse: *hasResult = true; *hasResultType = true; break;
    case Op::OpFwidthCoarse: *hasResult = true; *hasResultType = true; break;
    case Op::OpEmitVertex: *hasResult = false; *hasResultType = false; break;
    case Op::OpEndPrimitive: *hasResult = false; *hasResultType = false; break;
    case Op::OpEmitStreamVertex: *hasResult = false; *hasResultType = false; break;
    case Op::OpEndStreamPrimitive: *hasResult = false; *hasResultType = false; break;
    case Op::OpControlBarrier: *hasResult = false; *hasResultType = false; break;
    case Op::OpMemoryBarrier: *hasResult = false; *hasResultType = false; break;
    case Op::OpAtomicLoad: *hasResult = true; *hasResultType = true; break;
    case Op::OpAtomicStore: *hasResult = false; *hasResultType = false; break;
    case Op::OpAtomicExchange: *hasResult = true; *hasResultType = true; break;
    case Op::OpAtomicCompareExchange: *hasResult = true; *hasResultType = true; break;
    case Op::OpAtomicCompareExchangeWeak: *hasResult = true; *hasResultType = true; break;
    case Op::OpAtomicIIncrement: *hasResult = true; *hasResultType = true; break;
    case Op::OpAtomicIDecrement: *hasResult = true; *hasResultType = true; break;
    case Op::OpAtomicIAdd: *hasResult = true; *hasResultType = true; break;
    case Op::OpAtomicISub: *hasResult = true; *hasResultType = true; break;
    case Op::OpAtomicSMin: *hasResult = true; *hasResultType = true; break;
    case Op::OpAtomicUMin: *hasResult = true; *hasResultType = true; break;
    case Op::OpAtomicSMax: *hasResult = true; *hasResultType = true; break;
    case Op::OpAtomicUMax: *hasResult = true; *hasResultType = true; break;
    case Op::OpAtomicAnd: *hasResult = true; *hasResultType = true; break;
    case Op::OpAtomicOr: *hasResult = true; *hasResultType = true; break;
    case Op::OpAtomicXor: *hasResult = true; *hasResultType = true; break;
    case Op::OpPhi: *hasResult = true; *hasResultType = true; break;
    case Op::OpLoopMerge: *hasResult = false; *hasResultType = false; break;
    case Op::OpSelectionMerge: *hasResult = false; *hasResultType = false; break;
    case Op::OpLabel: *hasResult = true; *hasResultType = false; break;
    case Op::OpBranch: *hasResult = false; *hasResultType = false; break;
    case Op::OpBranchConditional: *hasResult = false; *hasResultType = false; break;
    case Op::OpSwitch: *hasResult = false; *hasResultType = false; break;
    case Op::OpKill: *hasResult = false; *hasResultType = false; break;
    case Op::OpReturn: *hasResult = false; *hasResultType = false; break;
    case Op::OpReturnValue: *hasResult = false; *hasResultType = false; break;
    case Op::OpUnreachable: *hasResult = false; *hasResultType = false; break;
    case Op::OpLifetimeStart: *hasResult = false; *hasResultType = false; break;
    case Op::OpLifetimeStop: *hasResult = false; *hasResultType = false; break;
    case Op::OpGroupAsyncCopy: *hasResult = true; *hasResultType = true; break;
    case Op::OpGroupWaitEvents: *hasResult = false; *hasResultType = false; break;
    case Op::OpGroupAll: *hasResult = true; *hasResultType = true; break;
    case Op::OpGroupAny: *hasResult = true; *hasResultType = true; break;
    case Op::OpGroupBroadcast: *hasResult = true; *hasResultType = true; break;
    case Op::OpGroupIAdd: *hasResult = true; *hasResultType = true; break;
    case Op::OpGroupFAdd: *hasResult = true; *hasResultType = true; break;
    case Op::OpGroupFMin: *hasResult = true; *hasResultType = true; break;
    case Op::OpGroupUMin: *hasResult = true; *hasResultType = true; break;
    case Op::OpGroupSMin: *hasResult = true; *hasResultType = true; break;
    case Op::OpGroupFMax: *hasResult = true; *hasResultType = true; break;
    case Op::OpGroupUMax: *hasResult = true; *hasResultType = true; break;
    case Op::OpGroupSMax: *hasResult = true; *hasResultType = true; break;
    case Op::OpReadPipe: *hasResult = true; *hasResultType = true; break;
    case Op::OpWritePipe: *hasResult = true; *hasResultType = true; break;
    case Op::OpReservedReadPipe: *hasResult = true; *hasResultType = true; break;
    case Op::OpReservedWritePipe: *hasResult = true; *hasResultType = true; break;
    case Op::OpReserveReadPipePackets: *hasResult = true; *hasResultType = true; break;
    case Op::OpReserveWritePipePackets: *hasResult = true; *hasResultType = true; break;
    case Op::OpCommitReadPipe: *hasResult = false; *hasResultType = false; break;
    case Op::OpCommitWritePipe: *hasResult = false; *hasResultType = false; break;
    case Op::OpIsValidReserveId: *hasResult = true; *hasResultType = true; break;
    case Op::OpGetNumPipePackets: *hasResult = true; *hasResultType = true; break;
    case Op::OpGetMaxPipePackets: *hasResult = true; *hasResultType = true; break;
    case Op::OpGroupReserveReadPipePackets: *hasResult = true; *hasResultType = true; break;
    case Op::OpGroupReserveWritePipePackets: *hasResult = true; *hasResultType = true; break;
    case Op::OpGroupCommitReadPipe: *hasResult = false; *hasResultType = false; break;
    case Op::OpGroupCommitWritePipe: *hasResult = false; *hasResultType = false; break;
    case Op::OpEnqueueMarker: *hasResult = true; *hasResultType = true; break;
    case Op::OpEnqueueKernel: *hasResult = true; *hasResultType = true; break;
    case Op::OpGetKernelNDrangeSubGroupCount: *hasResult = true; *hasResultType = true; break;
    case Op::OpGetKernelNDrangeMaxSubGroupSize: *hasResult = true; *hasResultType = true; break;
    case Op::OpGetKernelWorkGroupSize: *hasResult = true; *hasResultType = true; break;
    case Op::OpGetKernelPreferredWorkGroupSizeMultiple: *hasResult = true; *hasResultType = true; break;
    case Op::OpRetainEvent: *hasResult = false; *hasResultType = false; break;
    case Op::OpReleaseEvent: *hasResult = false; *hasResultType = false; break;
    case Op::OpCreateUserEvent: *hasResult = true; *hasResultType = true; break;
    case Op::OpIsValidEvent: *hasResult = true; *hasResultType = true; break;
    case Op::OpSetUserEventStatus: *hasResult = false; *hasResultType = false; break;
    case Op::OpCaptureEventProfilingInfo: *hasResult = false; *hasResultType = false; break;
    case Op::OpGetDefaultQueue: *hasResult = true; *hasResultType = true; break;
    case Op::OpBuildNDRange: *hasResult = true; *hasResultType = true; break;
    case Op::OpImageSparseSampleImplicitLod: *hasResult = true; *hasResultType = true; break;
    case Op::OpImageSparseSampleExplicitLod: *hasResult = true; *hasResultType = true; break;
    case Op::OpImageSparseSampleDrefImplicitLod: *hasResult = true; *hasResultType = true; break;
    case Op::OpImageSparseSampleDrefExplicitLod: *hasResult = true; *hasResultType = true; break;
    case Op::OpImageSparseSampleProjImplicitLod: *hasResult = true; *hasResultType = true; break;
    case Op::OpImageSparseSampleProjExplicitLod: *hasResult = true; *hasResultType = true; break;
    case Op::OpImageSparseSampleProjDrefImplicitLod: *hasResult = true; *hasResultType = true; break;
    case Op::OpImageSparseSampleProjDrefExplicitLod: *hasResult = true; *hasResultType = true; break;
    case Op::OpImageSparseFetch: *hasResult = true; *hasResultType = true; break;
    case Op::OpImageSparseGather: *hasResult = true; *hasResultType = true; break;
    case Op::OpImageSparseDrefGather: *hasResult = true; *hasResultType = true; break;
    case Op::OpImageSparseTexelsResident: *hasResult = true; *hasResultType = true; break;
    case Op::OpNoLine: *hasResult = false; *hasResultType = false; break;
    case Op::OpAtomicFlagTestAndSet: *hasResult = true; *hasResultType = true; break;
    case Op::OpAtomicFlagClear: *hasResult = false; *hasResultType = false; break;
    case Op::OpImageSparseRead: *hasResult = true; *hasResultType = true; break;
    case Op::OpSizeOf: *hasResult = true; *hasResultType = true; break;
    case Op::OpTypePipeStorage: *hasResult = true; *hasResultType = false; break;
    case Op::OpConstantPipeStorage: *hasResult = true; *hasResultType = true; break;
    case Op::OpCreatePipeFromPipeStorage: *hasResult = true; *hasResultType = true; break;
    case Op::OpGetKernelLocalSizeForSubgroupCount: *hasResult = true; *hasResultType = true; break;
    case Op::OpGetKernelMaxNumSubgroups: *hasResult = true; *hasResultType = true; break;
    case Op::OpTypeNamedBarrier: *hasResult = true; *hasResultType = false; break;
    case Op::OpNamedBarrierInitialize: *hasResult = true; *hasResultType = true; break;
    case Op::OpMemoryNamedBarrier: *hasResult = false; *hasResultType = false; break;
    case Op::OpModuleProcessed: *hasResult = false; *hasResultType = false; break;
    case Op::OpExecutionModeId: *hasResult = false; *hasResultType = false; break;
    case Op::OpDecorateId: *hasResult = false; *hasResultType = false; break;
    case Op::OpGroupNonUniformElect: *hasResult = true; *hasResultType = true; break;
    case Op::OpGroupNonUniformAll: *hasResult = true; *hasResultType = true; break;
    case Op::OpGroupNonUniformAny: *hasResult = true; *hasResultType = true; break;
    case Op::OpGroupNonUniformAllEqual: *hasResult = true; *hasResultType = true; break;
    case Op::OpGroupNonUniformBroadcast: *hasResult = true; *hasResultType = true; break;
    case Op::OpGroupNonUniformBroadcastFirst: *hasResult = true; *hasResultType = true; break;
    case Op::OpGroupNonUniformBallot: *hasResult = true; *hasResultType = true; break;
    case Op::OpGroupNonUniformInverseBallot: *hasResult = true; *hasResultType = true; break;
    case Op::OpGroupNonUniformBallotBitExtract: *hasResult = true; *hasResultType = true; break;
    case Op::OpGroupNonUniformBallotBitCount: *hasResult = true; *hasResultType = true; break;
    case Op::OpGroupNonUniformBallotFindLSB: *hasResult = true; *hasResultType = true; break;
    case Op::OpGroupNonUniformBallotFindMSB: *hasResult = true; *hasResultType = true; break;
    case Op::OpGroupNonUniformShuffle: *hasResult = true; *hasResultType = true; break;
    case Op::OpGroupNonUniformShuffleXor: *hasResult = true; *hasResultType = true; break;
    case Op::OpGroupNonUniformShuffleUp: *hasResult = true; *hasResultType = true; break;
    case Op::OpGroupNonUniformShuffleDown: *hasResult = true; *hasResultType = true; break;
    case Op::OpGroupNonUniformIAdd: *hasResult = true; *hasResultType = true; break;
    case Op::OpGroupNonUniformFAdd: *hasResult = true; *hasResultType = true; break;
    case Op::OpGroupNonUniformIMul: *hasResult = true; *hasResultType = true; break;
    case Op::OpGroupNonUniformFMul: *hasResult = true; *hasResultType = true; break;
    case Op::OpGroupNonUniformSMin: *hasResult = true; *hasResultType = true; break;
    case Op::OpGroupNonUniformUMin: *hasResult = true; *hasResultType = true; break;
    case Op::OpGroupNonUniformFMin: *hasResult = true; *hasResultType = true; break;
    case Op::OpGroupNonUniformSMax: *hasResult = true; *hasResultType = true; break;
    case Op::OpGroupNonUniformUMax: *hasResult = true; *hasResultType = true; break;
    case Op::OpGroupNonUniformFMax: *hasResult = true; *hasResultType = true; break;
    case Op::OpGroupNonUniformBitwiseAnd: *hasResult = true; *hasResultType = true; break;
    case Op::OpGroupNonUniformBitwiseOr: *hasResult = true; *hasResultType = true; break;
    case Op::OpGroupNonUniformBitwiseXor: *hasResult = true; *hasResultType = true; break;
    case Op::OpGroupNonUniformLogicalAnd: *hasResult = true; *hasResultType = true; break;
    case Op::OpGroupNonUniformLogicalOr: *hasResult = true; *hasResultType = true; break;
    case Op::OpGroupNonUniformLogicalXor: *hasResult = true; *hasResultType = true; break;
    case Op::OpGroupNonUniformQuadBroadcast: *hasResult = true; *hasResultType = true; break;
    case Op::OpGroupNonUniformQuadSwap: *hasResult = true; *hasResultType = true; break;
    case Op::OpCopyLogical: *hasResult = true; *hasResultType = true; break;
    case Op::OpPtrEqual: *hasResult = true; *hasResultType = true; break;
    case Op::OpPtrNotEqual: *hasResult = true; *hasResultType = true; break;
    case Op::OpPtrDiff: *hasResult = true; *hasResultType = true; break;
    case Op::OpColorAttachmentReadEXT: *hasResult = true; *hasResultType = true; break;
    case Op::OpDepthAttachmentReadEXT: *hasResult = true; *hasResultType = true; break;
    case Op::OpStencilAttachmentReadEXT: *hasResult = true; *hasResultType = true; break;
    case Op::OpTerminateInvocation: *hasResult = false; *hasResultType = false; break;
    case Op::OpSubgroupBallotKHR: *hasResult = true; *hasResultType = true; break;
    case Op::OpSubgroupFirstInvocationKHR: *hasResult = true; *hasResultType = true; break;
    case Op::OpSubgroupAllKHR: *hasResult = true; *hasResultType = true; break;
    case Op::OpSubgroupAnyKHR: *hasResult = true; *hasResultType = true; break;
    case Op::OpSubgroupAllEqualKHR: *hasResult = true; *hasResultType = true; break;
    case Op::OpGroupNonUniformRotateKHR: *hasResult = true; *hasResultType = true; break;
    case Op::OpSubgroupReadInvocationKHR: *hasResult = true; *hasResultType = true; break;
    case Op::OpExtInstWithForwardRefsKHR: *hasResult = true; *hasResultType = true; break;
    case Op::OpTraceRayKHR: *hasResult = false; *hasResultType = false; break;
    case Op::OpExecuteCallableKHR: *hasResult = false; *hasResultType = false; break;
    case Op::OpConvertUToAccelerationStructureKHR: *hasResult = true; *hasResultType = true; break;
    case Op::OpIgnoreIntersectionKHR: *hasResult = false; *hasResultType = false; break;
    case Op::OpTerminateRayKHR: *hasResult = false; *hasResultType = false; break;
    case Op::OpSDot: *hasResult = true; *hasResultType = true; break;
    case Op::OpUDot: *hasResult = true; *hasResultType = true; break;
    case Op::OpSUDot: *hasResult = true; *hasResultType = true; break;
    case Op::OpSDotAccSat: *hasResult = true; *hasResultType = true; break;
    case Op::OpUDotAccSat: *hasResult = true; *hasResultType = true; break;
    case Op::OpSUDotAccSat: *hasResult = true; *hasResultType = true; break;
    case Op::OpTypeCooperativeMatrixKHR: *hasResult = true; *hasResultType = false; break;
    case Op::OpCooperativeMatrixLoadKHR: *hasResult = true; *hasResultType = true; break;
    case Op::OpCooperativeMatrixStoreKHR: *hasResult = false; *hasResultType = false; break;
    case Op::OpCooperativeMatrixMulAddKHR: *hasResult = true; *hasResultType = true; break;
    case Op::OpCooperativeMatrixLengthKHR: *hasResult = true; *hasResultType = true; break;
    case Op::OpConstantCompositeReplicateEXT: *hasResult = true; *hasResultType = true; break;
    case Op::OpSpecConstantCompositeReplicateEXT: *hasResult = true; *hasResultType = true; break;
    case Op::OpCompositeConstructReplicateEXT: *hasResult = true; *hasResultType = true; break;
    case Op::OpTypeRayQueryKHR: *hasResult = true; *hasResultType = false; break;
    case Op::OpRayQueryInitializeKHR: *hasResult = false; *hasResultType = false; break;
    case Op::OpRayQueryTerminateKHR: *hasResult = false; *hasResultType = false; break;
    case Op::OpRayQueryGenerateIntersectionKHR: *hasResult = false; *hasResultType = false; break;
    case Op::OpRayQueryConfirmIntersectionKHR: *hasResult = false; *hasResultType = false; break;
    case Op::OpRayQueryProceedKHR: *hasResult = true; *hasResultType = true; break;
    case Op::OpRayQueryGetIntersectionTypeKHR: *hasResult = true; *hasResultType = true; break;
    case Op::OpImageSampleWeightedQCOM: *hasResult = true; *hasResultType = true; break;
    case Op::OpImageBoxFilterQCOM: *hasResult = true; *hasResultType = true; break;
    case Op::OpImageBlockMatchSSDQCOM: *hasResult = true; *hasResultType = true; break;
    case Op::OpImageBlockMatchSADQCOM: *hasResult = true; *hasResultType = true; break;
    case Op::OpImageBlockMatchWindowSSDQCOM: *hasResult = true; *hasResultType = true; break;
    case Op::OpImageBlockMatchWindowSADQCOM: *hasResult = true; *hasResultType = true; break;
    case Op::OpImageBlockMatchGatherSSDQCOM: *hasResult = true; *hasResultType = true; break;
    case Op::OpImageBlockMatchGatherSADQCOM: *hasResult = true; *hasResultType = true; break;
    case Op::OpGroupIAddNonUniformAMD: *hasResult = true; *hasResultType = true; break;
    case Op::OpGroupFAddNonUniformAMD: *hasResult = true; *hasResultType = true; break;
    case Op::OpGroupFMinNonUniformAMD: *hasResult = true; *hasResultType = true; break;
    case Op::OpGroupUMinNonUniformAMD: *hasResult = true; *hasResultType = true; break;
    case Op::OpGroupSMinNonUniformAMD: *hasResult = true; *hasResultType = true; break;
    case Op::OpGroupFMaxNonUniformAMD: *hasResult = true; *hasResultType = true; break;
    case Op::OpGroupUMaxNonUniformAMD: *hasResult = true; *hasResultType = true; break;
    case Op::OpGroupSMaxNonUniformAMD: *hasResult = true; *hasResultType = true; break;
    case Op::OpFragmentMaskFetchAMD: *hasResult = true; *hasResultType = true; break;
    case Op::OpFragmentFetchAMD: *hasResult = true; *hasResultType = true; break;
    case Op::OpReadClockKHR: *hasResult = true; *hasResultType = true; break;
    case Op::OpFinalizeNodePayloadsAMDX: *hasResult = false; *hasResultType = false; break;
    case Op::OpFinishWritingNodePayloadAMDX: *hasResult = true; *hasResultType = true; break;
    case Op::OpInitializeNodePayloadsAMDX: *hasResult = false; *hasResultType = false; break;
    case Op::OpGroupNonUniformQuadAllKHR: *hasResult = true; *hasResultType = true; break;
    case Op::OpGroupNonUniformQuadAnyKHR: *hasResult = true; *hasResultType = true; break;
    case Op::OpHitObjectRecordHitMotionNV: *hasResult = false; *hasResultType = false; break;
    case Op::OpHitObjectRecordHitWithIndexMotionNV: *hasResult = false; *hasResultType = false; break;
    case Op::OpHitObjectRecordMissMotionNV: *hasResult = false; *hasResultType = false; break;
    case Op::OpHitObjectGetWorldToObjectNV: *hasResult = true; *hasResultType = true; break;
    case Op::OpHitObjectGetObjectToWorldNV: *hasResult = true; *hasResultType = true; break;
    case Op::OpHitObjectGetObjectRayDirectionNV: *hasResult = true; *hasResultType = true; break;
    case Op::OpHitObjectGetObjectRayOriginNV: *hasResult = true; *hasResultType = true; break;
    case Op::OpHitObjectTraceRayMotionNV: *hasResult = false; *hasResultType = false; break;
    case Op::OpHitObjectGetShaderRecordBufferHandleNV: *hasResult = true; *hasResultType = true; break;
    case Op::OpHitObjectGetShaderBindingTableRecordIndexNV: *hasResult = true; *hasResultType = true; break;
    case Op::OpHitObjectRecordEmptyNV: *hasResult = false; *hasResultType = false; break;
    case Op::OpHitObjectTraceRayNV: *hasResult = false; *hasResultType = false; break;
    case Op::OpHitObjectRecordHitNV: *hasResult = false; *hasResultType = false; break;
    case Op::OpHitObjectRecordHitWithIndexNV: *hasResult = false; *hasResultType = false; break;
    case Op::OpHitObjectRecordMissNV: *hasResult = false; *hasResultType = false; break;
    case Op::OpHitObjectExecuteShaderNV: *hasResult = false; *hasResultType = false; break;
    case Op::OpHitObjectGetCurrentTimeNV: *hasResult = true; *hasResultType = true; break;
    case Op::OpHitObjectGetAttributesNV: *hasResult = false; *hasResultType = false; break;
    case Op::OpHitObjectGetHitKindNV: *hasResult = true; *hasResultType = true; break;
    case Op::OpHitObjectGetPrimitiveIndexNV: *hasResult = true; *hasResultType = true; break;
    case Op::OpHitObjectGetGeometryIndexNV: *hasResult = true; *hasResultType = true; break;
    case Op::OpHitObjectGetInstanceIdNV: *hasResult = true; *hasResultType = true; break;
    case Op::OpHitObjectGetInstanceCustomIndexNV: *hasResult = true; *hasResultType = true; break;
    case Op::OpHitObjectGetWorldRayDirectionNV: *hasResult = true; *hasResultType = true; break;
    case Op::OpHitObjectGetWorldRayOriginNV: *hasResult = true; *hasResultType = true; break;
    case Op::OpHitObjectGetRayTMaxNV: *hasResult = true; *hasResultType = true; break;
    case Op::OpHitObjectGetRayTMinNV: *hasResult = true; *hasResultType = true; break;
    case Op::OpHitObjectIsEmptyNV: *hasResult = true; *hasResultType = true; break;
    case Op::OpHitObjectIsHitNV: *hasResult = true; *hasResultType = true; break;
    case Op::OpHitObjectIsMissNV: *hasResult = true; *hasResultType = true; break;
    case Op::OpReorderThreadWithHitObjectNV: *hasResult = false; *hasResultType = false; break;
    case Op::OpReorderThreadWithHintNV: *hasResult = false; *hasResultType = false; break;
    case Op::OpTypeHitObjectNV: *hasResult = true; *hasResultType = false; break;
    case Op::OpImageSampleFootprintNV: *hasResult = true; *hasResultType = true; break;
    case Op::OpEmitMeshTasksEXT: *hasResult = false; *hasResultType = false; break;
    case Op::OpSetMeshOutputsEXT: *hasResult = false; *hasResultType = false; break;
    case Op::OpGroupNonUniformPartitionNV: *hasResult = true; *hasResultType = true; break;
    case Op::OpWritePackedPrimitiveIndices4x8NV: *hasResult = false; *hasResultType = false; break;
    case Op::OpFetchMicroTriangleVertexPositionNV: *hasResult = true; *hasResultType = true; break;
    case Op::OpFetchMicroTriangleVertexBarycentricNV: *hasResult = true; *hasResultType = true; break;
    case Op::OpReportIntersectionKHR: *hasResult = true; *hasResultType = true; break;
    case Op::OpIgnoreIntersectionNV: *hasResult = false; *hasResultType = false; break;
    case Op::OpTerminateRayNV: *hasResult = false; *hasResultType = false; break;
    case Op::OpTraceNV: *hasResult = false; *hasResultType = false; break;
    case Op::OpTraceMotionNV: *hasResult = false; *hasResultType = false; break;
    case Op::OpTraceRayMotionNV: *hasResult = false; *hasResultType = false; break;
    case Op::OpRayQueryGetIntersectionTriangleVertexPositionsKHR: *hasResult = true; *hasResultType = true; break;
    case Op::OpTypeAccelerationStructureKHR: *hasResult = true; *hasResultType = false; break;
    case Op::OpExecuteCallableNV: *hasResult = false; *hasResultType = false; break;
    case Op::OpTypeCooperativeMatrixNV: *hasResult = true; *hasResultType = false; break;
    case Op::OpCooperativeMatrixLoadNV: *hasResult = true; *hasResultType = true; break;
    case Op::OpCooperativeMatrixStoreNV: *hasResult = false; *hasResultType = false; break;
    case Op::OpCooperativeMatrixMulAddNV: *hasResult = true; *hasResultType = true; break;
    case Op::OpCooperativeMatrixLengthNV: *hasResult = true; *hasResultType = true; break;
    case Op::OpBeginInvocationInterlockEXT: *hasResult = false; *hasResultType = false; break;
    case Op::OpEndInvocationInterlockEXT: *hasResult = false; *hasResultType = false; break;
    case Op::OpDemoteToHelperInvocation: *hasResult = false; *hasResultType = false; break;
    case Op::OpIsHelperInvocationEXT: *hasResult = true; *hasResultType = true; break;
    case Op::OpConvertUToImageNV: *hasResult = true; *hasResultType = true; break;
    case Op::OpConvertUToSamplerNV: *hasResult = true; *hasResultType = true; break;
    case Op::OpConvertImageToUNV: *hasResult = true; *hasResultType = true; break;
    case Op::OpConvertSamplerToUNV: *hasResult = true; *hasResultType = true; break;
    case Op::OpConvertUToSampledImageNV: *hasResult = true; *hasResultType = true; break;
    case Op::OpConvertSampledImageToUNV: *hasResult = true; *hasResultType = true; break;
    case Op::OpSamplerImageAddressingModeNV: *hasResult = false; *hasResultType = false; break;
    case Op::OpRawAccessChainNV: *hasResult = true; *hasResultType = true; break;
    case Op::OpSubgroupShuffleINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpSubgroupShuffleDownINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpSubgroupShuffleUpINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpSubgroupShuffleXorINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpSubgroupBlockReadINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpSubgroupBlockWriteINTEL: *hasResult = false; *hasResultType = false; break;
    case Op::OpSubgroupImageBlockReadINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpSubgroupImageBlockWriteINTEL: *hasResult = false; *hasResultType = false; break;
    case Op::OpSubgroupImageMediaBlockReadINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpSubgroupImageMediaBlockWriteINTEL: *hasResult = false; *hasResultType = false; break;
    case Op::OpUCountLeadingZerosINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpUCountTrailingZerosINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpAbsISubINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpAbsUSubINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpIAddSatINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpUAddSatINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpIAverageINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpUAverageINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpIAverageRoundedINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpUAverageRoundedINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpISubSatINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpUSubSatINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpIMul32x16INTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpUMul32x16INTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpConstantFunctionPointerINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpFunctionPointerCallINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpAsmTargetINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpAsmINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpAsmCallINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpAtomicFMinEXT: *hasResult = true; *hasResultType = true; break;
    case Op::OpAtomicFMaxEXT: *hasResult = true; *hasResultType = true; break;
    case Op::OpAssumeTrueKHR: *hasResult = false; *hasResultType = false; break;
    case Op::OpExpectKHR: *hasResult = true; *hasResultType = true; break;
    case Op::OpDecorateString: *hasResult = false; *hasResultType = false; break;
    case Op::OpMemberDecorateString: *hasResult = false; *hasResultType = false; break;
    case Op::OpVmeImageINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpTypeVmeImageINTEL: *hasResult = true; *hasResultType = false; break;
    case Op::OpTypeAvcImePayloadINTEL: *hasResult = true; *hasResultType = false; break;
    case Op::OpTypeAvcRefPayloadINTEL: *hasResult = true; *hasResultType = false; break;
    case Op::OpTypeAvcSicPayloadINTEL: *hasResult = true; *hasResultType = false; break;
    case Op::OpTypeAvcMcePayloadINTEL: *hasResult = true; *hasResultType = false; break;
    case Op::OpTypeAvcMceResultINTEL: *hasResult = true; *hasResultType = false; break;
    case Op::OpTypeAvcImeResultINTEL: *hasResult = true; *hasResultType = false; break;
    case Op::OpTypeAvcImeResultSingleReferenceStreamoutINTEL: *hasResult = true; *hasResultType = false; break;
    case Op::OpTypeAvcImeResultDualReferenceStreamoutINTEL: *hasResult = true; *hasResultType = false; break;
    case Op::OpTypeAvcImeSingleReferenceStreaminINTEL: *hasResult = true; *hasResultType = false; break;
    case Op::OpTypeAvcImeDualReferenceStreaminINTEL: *hasResult = true; *hasResultType = false; break;
    case Op::OpTypeAvcRefResultINTEL: *hasResult = true; *hasResultType = false; break;
    case Op::OpTypeAvcSicResultINTEL: *hasResult = true; *hasResultType = false; break;
    case Op::OpSubgroupAvcMceGetDefaultInterBaseMultiReferencePenaltyINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpSubgroupAvcMceSetInterBaseMultiReferencePenaltyINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpSubgroupAvcMceGetDefaultInterShapePenaltyINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpSubgroupAvcMceSetInterShapePenaltyINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpSubgroupAvcMceGetDefaultInterDirectionPenaltyINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpSubgroupAvcMceSetInterDirectionPenaltyINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpSubgroupAvcMceGetDefaultIntraLumaShapePenaltyINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpSubgroupAvcMceGetDefaultInterMotionVectorCostTableINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpSubgroupAvcMceGetDefaultHighPenaltyCostTableINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpSubgroupAvcMceGetDefaultMediumPenaltyCostTableINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpSubgroupAvcMceGetDefaultLowPenaltyCostTableINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpSubgroupAvcMceSetMotionVectorCostFunctionINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpSubgroupAvcMceGetDefaultIntraLumaModePenaltyINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpSubgroupAvcMceGetDefaultNonDcLumaIntraPenaltyINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpSubgroupAvcMceGetDefaultIntraChromaModeBasePenaltyINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpSubgroupAvcMceSetAcOnlyHaarINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpSubgroupAvcMceSetSourceInterlacedFieldPolarityINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpSubgroupAvcMceSetSingleReferenceInterlacedFieldPolarityINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpSubgroupAvcMceSetDualReferenceInterlacedFieldPolaritiesINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpSubgroupAvcMceConvertToImePayloadINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpSubgroupAvcMceConvertToImeResultINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpSubgroupAvcMceConvertToRefPayloadINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpSubgroupAvcMceConvertToRefResultINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpSubgroupAvcMceConvertToSicPayloadINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpSubgroupAvcMceConvertToSicResultINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpSubgroupAvcMceGetMotionVectorsINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpSubgroupAvcMceGetInterDistortionsINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpSubgroupAvcMceGetBestInterDistortionsINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpSubgroupAvcMceGetInterMajorShapeINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpSubgroupAvcMceGetInterMinorShapeINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpSubgroupAvcMceGetInterDirectionsINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpSubgroupAvcMceGetInterMotionVectorCountINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpSubgroupAvcMceGetInterReferenceIdsINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpSubgroupAvcMceGetInterReferenceInterlacedFieldPolaritiesINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpSubgroupAvcImeInitializeINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpSubgroupAvcImeSetSingleReferenceINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpSubgroupAvcImeSetDualReferenceINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpSubgroupAvcImeRefWindowSizeINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpSubgroupAvcImeAdjustRefOffsetINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpSubgroupAvcImeConvertToMcePayloadINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpSubgroupAvcImeSetMaxMotionVectorCountINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpSubgroupAvcImeSetUnidirectionalMixDisableINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpSubgroupAvcImeSetEarlySearchTerminationThresholdINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpSubgroupAvcImeSetWeightedSadINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpSubgroupAvcImeEvaluateWithSingleReferenceINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpSubgroupAvcImeEvaluateWithDualReferenceINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpSubgroupAvcImeEvaluateWithSingleReferenceStreaminINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpSubgroupAvcImeEvaluateWithDualReferenceStreaminINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpSubgroupAvcImeEvaluateWithSingleReferenceStreamoutINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpSubgroupAvcImeEvaluateWithDualReferenceStreamoutINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpSubgroupAvcImeEvaluateWithSingleReferenceStreaminoutINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpSubgroupAvcImeEvaluateWithDualReferenceStreaminoutINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpSubgroupAvcImeConvertToMceResultINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpSubgroupAvcImeGetSingleReferenceStreaminINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpSubgroupAvcImeGetDualReferenceStreaminINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpSubgroupAvcImeStripSingleReferenceStreamoutINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpSubgroupAvcImeStripDualReferenceStreamoutINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeMotionVectorsINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeDistortionsINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeReferenceIdsINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeMotionVectorsINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeDistortionsINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeReferenceIdsINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpSubgroupAvcImeGetBorderReachedINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpSubgroupAvcImeGetTruncatedSearchIndicationINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpSubgroupAvcImeGetUnidirectionalEarlySearchTerminationINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpSubgroupAvcImeGetWeightingPatternMinimumMotionVectorINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpSubgroupAvcImeGetWeightingPatternMinimumDistortionINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpSubgroupAvcFmeInitializeINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpSubgroupAvcBmeInitializeINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpSubgroupAvcRefConvertToMcePayloadINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpSubgroupAvcRefSetBidirectionalMixDisableINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpSubgroupAvcRefSetBilinearFilterEnableINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpSubgroupAvcRefEvaluateWithSingleReferenceINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpSubgroupAvcRefEvaluateWithDualReferenceINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpSubgroupAvcRefEvaluateWithMultiReferenceINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpSubgroupAvcRefEvaluateWithMultiReferenceInterlacedINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpSubgroupAvcRefConvertToMceResultINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpSubgroupAvcSicInitializeINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpSubgroupAvcSicConfigureSkcINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpSubgroupAvcSicConfigureIpeLumaINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpSubgroupAvcSicConfigureIpeLumaChromaINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpSubgroupAvcSicGetMotionVectorMaskINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpSubgroupAvcSicConvertToMcePayloadINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpSubgroupAvcSicSetIntraLumaShapePenaltyINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpSubgroupAvcSicSetIntraLumaModeCostFunctionINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpSubgroupAvcSicSetIntraChromaModeCostFunctionINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpSubgroupAvcSicSetBilinearFilterEnableINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpSubgroupAvcSicSetSkcForwardTransformEnableINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpSubgroupAvcSicSetBlockBasedRawSkipSadINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpSubgroupAvcSicEvaluateIpeINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpSubgroupAvcSicEvaluateWithSingleReferenceINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpSubgroupAvcSicEvaluateWithDualReferenceINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpSubgroupAvcSicEvaluateWithMultiReferenceINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpSubgroupAvcSicEvaluateWithMultiReferenceInterlacedINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpSubgroupAvcSicConvertToMceResultINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpSubgroupAvcSicGetIpeLumaShapeINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpSubgroupAvcSicGetBestIpeLumaDistortionINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpSubgroupAvcSicGetBestIpeChromaDistortionINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpSubgroupAvcSicGetPackedIpeLumaModesINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpSubgroupAvcSicGetIpeChromaModeINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpSubgroupAvcSicGetPackedSkcLumaCountThresholdINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpSubgroupAvcSicGetPackedSkcLumaSumThresholdINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpSubgroupAvcSicGetInterRawSadsINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpVariableLengthArrayINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpSaveMemoryINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpRestoreMemoryINTEL: *hasResult = false; *hasResultType = false; break;
    case Op::OpArbitraryFloatSinCosPiINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpArbitraryFloatCastINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpArbitraryFloatCastFromIntINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpArbitraryFloatCastToIntINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpArbitraryFloatAddINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpArbitraryFloatSubINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpArbitraryFloatMulINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpArbitraryFloatDivINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpArbitraryFloatGTINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpArbitraryFloatGEINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpArbitraryFloatLTINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpArbitraryFloatLEINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpArbitraryFloatEQINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpArbitraryFloatRecipINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpArbitraryFloatRSqrtINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpArbitraryFloatCbrtINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpArbitraryFloatHypotINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpArbitraryFloatSqrtINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpArbitraryFloatLogINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpArbitraryFloatLog2INTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpArbitraryFloatLog10INTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpArbitraryFloatLog1pINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpArbitraryFloatExpINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpArbitraryFloatExp2INTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpArbitraryFloatExp10INTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpArbitraryFloatExpm1INTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpArbitraryFloatSinINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpArbitraryFloatCosINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpArbitraryFloatSinCosINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpArbitraryFloatSinPiINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpArbitraryFloatCosPiINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpArbitraryFloatASinINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpArbitraryFloatASinPiINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpArbitraryFloatACosINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpArbitraryFloatACosPiINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpArbitraryFloatATanINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpArbitraryFloatATanPiINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpArbitraryFloatATan2INTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpArbitraryFloatPowINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpArbitraryFloatPowRINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpArbitraryFloatPowNINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpLoopControlINTEL: *hasResult = false; *hasResultType = false; break;
    case Op::OpAliasDomainDeclINTEL: *hasResult = true; *hasResultType = false; break;
    case Op::OpAliasScopeDeclINTEL: *hasResult = true; *hasResultType = false; break;
    case Op::OpAliasScopeListDeclINTEL: *hasResult = true; *hasResultType = false; break;
    case Op::OpFixedSqrtINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpFixedRecipINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpFixedRsqrtINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpFixedSinINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpFixedCosINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpFixedSinCosINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpFixedSinPiINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpFixedCosPiINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpFixedSinCosPiINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpFixedLogINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpFixedExpINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpPtrCastToCrossWorkgroupINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpCrossWorkgroupCastToPtrINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpReadPipeBlockingINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpWritePipeBlockingINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpFPGARegINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpRayQueryGetRayTMinKHR: *hasResult = true; *hasResultType = true; break;
    case Op::OpRayQueryGetRayFlagsKHR: *hasResult = true; *hasResultType = true; break;
    case Op::OpRayQueryGetIntersectionTKHR: *hasResult = true; *hasResultType = true; break;
    case Op::OpRayQueryGetIntersectionInstanceCustomIndexKHR: *hasResult = true; *hasResultType = true; break;
    case Op::OpRayQueryGetIntersectionInstanceIdKHR: *hasResult = true; *hasResultType = true; break;
    case Op::OpRayQueryGetIntersectionInstanceShaderBindingTableRecordOffsetKHR: *hasResult = true; *hasResultType = true; break;
    case Op::OpRayQueryGetIntersectionGeometryIndexKHR: *hasResult = true; *hasResultType = true; break;
    case Op::OpRayQueryGetIntersectionPrimitiveIndexKHR: *hasResult = true; *hasResultType = true; break;
    case Op::OpRayQueryGetIntersectionBarycentricsKHR: *hasResult = true; *hasResultType = true; break;
    case Op::OpRayQueryGetIntersectionFrontFaceKHR: *hasResult = true; *hasResultType = true; break;
    case Op::OpRayQueryGetIntersectionCandidateAABBOpaqueKHR: *hasResult = true; *hasResultType = true; break;
    case Op::OpRayQueryGetIntersectionObjectRayDirectionKHR: *hasResult = true; *hasResultType = true; break;
    case Op::OpRayQueryGetIntersectionObjectRayOriginKHR: *hasResult = true; *hasResultType = true; break;
    case Op::OpRayQueryGetWorldRayDirectionKHR: *hasResult = true; *hasResultType = true; break;
    case Op::OpRayQueryGetWorldRayOriginKHR: *hasResult = true; *hasResultType = true; break;
    case Op::OpRayQueryGetIntersectionObjectToWorldKHR: *hasResult = true; *hasResultType = true; break;
    case Op::OpRayQueryGetIntersectionWorldToObjectKHR: *hasResult = true; *hasResultType = true; break;
    case Op::OpAtomicFAddEXT: *hasResult = true; *hasResultType = true; break;
    case Op::OpTypeBufferSurfaceINTEL: *hasResult = true; *hasResultType = false; break;
    case Op::OpTypeStructContinuedINTEL: *hasResult = false; *hasResultType = false; break;
    case Op::OpConstantCompositeContinuedINTEL: *hasResult = false; *hasResultType = false; break;
    case Op::OpSpecConstantCompositeContinuedINTEL: *hasResult = false; *hasResultType = false; break;
    case Op::OpCompositeConstructContinuedINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpConvertFToBF16INTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpConvertBF16ToFINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpControlBarrierArriveINTEL: *hasResult = false; *hasResultType = false; break;
    case Op::OpControlBarrierWaitINTEL: *hasResult = false; *hasResultType = false; break;
    case Op::OpGroupIMulKHR: *hasResult = true; *hasResultType = true; break;
    case Op::OpGroupFMulKHR: *hasResult = true; *hasResultType = true; break;
    case Op::OpGroupBitwiseAndKHR: *hasResult = true; *hasResultType = true; break;
    case Op::OpGroupBitwiseOrKHR: *hasResult = true; *hasResultType = true; break;
    case Op::OpGroupBitwiseXorKHR: *hasResult = true; *hasResultType = true; break;
    case Op::OpGroupLogicalAndKHR: *hasResult = true; *hasResultType = true; break;
    case Op::OpGroupLogicalOrKHR: *hasResult = true; *hasResultType = true; break;
    case Op::OpGroupLogicalXorKHR: *hasResult = true; *hasResultType = true; break;
    case Op::OpMaskedGatherINTEL: *hasResult = true; *hasResultType = true; break;
    case Op::OpMaskedScatterINTEL: *hasResult = false; *hasResultType = false; break;
    }
}
inline const char* SourceLanguageToString(SourceLanguage value) {
    switch (value) {
    case SourceLanguageUnknown: return "Unknown";
    case SourceLanguageESSL: return "ESSL";
    case SourceLanguageGLSL: return "GLSL";
    case SourceLanguageOpenCL_C: return "OpenCL_C";
    case SourceLanguageOpenCL_CPP: return "OpenCL_CPP";
    case SourceLanguageHLSL: return "HLSL";
    case SourceLanguageCPP_for_OpenCL: return "CPP_for_OpenCL";
    case SourceLanguageSYCL: return "SYCL";
    case SourceLanguageHERO_C: return "HERO_C";
    case SourceLanguageNZSL: return "NZSL";
    case SourceLanguageWGSL: return "WGSL";
    case SourceLanguageSlang: return "Slang";
    case SourceLanguageZig: return "Zig";
    default: return "Unknown";
    }
}

inline const char* ExecutionModelToString(ExecutionModel value) {
    switch (value) {
    case ExecutionModelVertex: return "Vertex";
    case ExecutionModelTessellationControl: return "TessellationControl";
    case ExecutionModelTessellationEvaluation: return "TessellationEvaluation";
    case ExecutionModelGeometry: return "Geometry";
    case ExecutionModelFragment: return "Fragment";
    case ExecutionModelGLCompute: return "GLCompute";
    case ExecutionModelKernel: return "Kernel";
    case ExecutionModelTaskNV: return "TaskNV";
    case ExecutionModelMeshNV: return "MeshNV";
    case ExecutionModelRayGenerationKHR: return "RayGenerationKHR";
    case ExecutionModelIntersectionKHR: return "IntersectionKHR";
    case ExecutionModelAnyHitKHR: return "AnyHitKHR";
    case ExecutionModelClosestHitKHR: return "ClosestHitKHR";
    case ExecutionModelMissKHR: return "MissKHR";
    case ExecutionModelCallableKHR: return "CallableKHR";
    case ExecutionModelTaskEXT: return "TaskEXT";
    case ExecutionModelMeshEXT: return "MeshEXT";
    default: return "Unknown";
    }
}

inline const char* AddressingModelToString(AddressingModel value) {
    switch (value) {
    case AddressingModelLogical: return "Logical";
    case AddressingModelPhysical32: return "Physical32";
    case AddressingModelPhysical64: return "Physical64";
    case AddressingModelPhysicalStorageBuffer64: return "PhysicalStorageBuffer64";
    default: return "Unknown";
    }
}

inline const char* MemoryModelToString(MemoryModel value) {
    switch (value) {
    case MemoryModelSimple: return "Simple";
    case MemoryModelGLSL450: return "GLSL450";
    case MemoryModelOpenCL: return "OpenCL";
    case MemoryModelVulkan: return "Vulkan";
    default: return "Unknown";
    }
}

inline const char* ExecutionModeToString(ExecutionMode value) {
    switch (value) {
    case ExecutionModeInvocations: return "Invocations";
    case ExecutionModeSpacingEqual: return "SpacingEqual";
    case ExecutionModeSpacingFractionalEven: return "SpacingFractionalEven";
    case ExecutionModeSpacingFractionalOdd: return "SpacingFractionalOdd";
    case ExecutionModeVertexOrderCw: return "VertexOrderCw";
    case ExecutionModeVertexOrderCcw: return "VertexOrderCcw";
    case ExecutionModePixelCenterInteger: return "PixelCenterInteger";
    case ExecutionModeOriginUpperLeft: return "OriginUpperLeft";
    case ExecutionModeOriginLowerLeft: return "OriginLowerLeft";
    case ExecutionModeEarlyFragmentTests: return "EarlyFragmentTests";
    case ExecutionModePointMode: return "PointMode";
    case ExecutionModeXfb: return "Xfb";
    case ExecutionModeDepthReplacing: return "DepthReplacing";
    case ExecutionModeDepthGreater: return "DepthGreater";
    case ExecutionModeDepthLess: return "DepthLess";
    case ExecutionModeDepthUnchanged: return "DepthUnchanged";
    case ExecutionModeLocalSize: return "LocalSize";
    case ExecutionModeLocalSizeHint: return "LocalSizeHint";
    case ExecutionModeInputPoints: return "InputPoints";
    case ExecutionModeInputLines: return "InputLines";
    case ExecutionModeInputLinesAdjacency: return "InputLinesAdjacency";
    case ExecutionModeTriangles: return "Triangles";
    case ExecutionModeInputTrianglesAdjacency: return "InputTrianglesAdjacency";
    case ExecutionModeQuads: return "Quads";
    case ExecutionModeIsolines: return "Isolines";
    case ExecutionModeOutputVertices: return "OutputVertices";
    case ExecutionModeOutputPoints: return "OutputPoints";
    case ExecutionModeOutputLineStrip: return "OutputLineStrip";
    case ExecutionModeOutputTriangleStrip: return "OutputTriangleStrip";
    case ExecutionModeVecTypeHint: return "VecTypeHint";
    case ExecutionModeContractionOff: return "ContractionOff";
    case ExecutionModeInitializer: return "Initializer";
    case ExecutionModeFinalizer: return "Finalizer";
    case ExecutionModeSubgroupSize: return "SubgroupSize";
    case ExecutionModeSubgroupsPerWorkgroup: return "SubgroupsPerWorkgroup";
    case ExecutionModeSubgroupsPerWorkgroupId: return "SubgroupsPerWorkgroupId";
    case ExecutionModeLocalSizeId: return "LocalSizeId";
    case ExecutionModeLocalSizeHintId: return "LocalSizeHintId";
    case ExecutionModeNonCoherentColorAttachmentReadEXT: return "NonCoherentColorAttachmentReadEXT";
    case ExecutionModeNonCoherentDepthAttachmentReadEXT: return "NonCoherentDepthAttachmentReadEXT";
    case ExecutionModeNonCoherentStencilAttachmentReadEXT: return "NonCoherentStencilAttachmentReadEXT";
    case ExecutionModeSubgroupUniformControlFlowKHR: return "SubgroupUniformControlFlowKHR";
    case ExecutionModePostDepthCoverage: return "PostDepthCoverage";
    case ExecutionModeDenormPreserve: return "DenormPreserve";
    case ExecutionModeDenormFlushToZero: return "DenormFlushToZero";
    case ExecutionModeSignedZeroInfNanPreserve: return "SignedZeroInfNanPreserve";
    case ExecutionModeRoundingModeRTE: return "RoundingModeRTE";
    case ExecutionModeRoundingModeRTZ: return "RoundingModeRTZ";
    case ExecutionModeEarlyAndLateFragmentTestsAMD: return "EarlyAndLateFragmentTestsAMD";
    case ExecutionModeStencilRefReplacingEXT: return "StencilRefReplacingEXT";
    case ExecutionModeCoalescingAMDX: return "CoalescingAMDX";
    case ExecutionModeMaxNodeRecursionAMDX: return "MaxNodeRecursionAMDX";
    case ExecutionModeStaticNumWorkgroupsAMDX: return "StaticNumWorkgroupsAMDX";
    case ExecutionModeShaderIndexAMDX: return "ShaderIndexAMDX";
    case ExecutionModeMaxNumWorkgroupsAMDX: return "MaxNumWorkgroupsAMDX";
    case ExecutionModeStencilRefUnchangedFrontAMD: return "StencilRefUnchangedFrontAMD";
    case ExecutionModeStencilRefGreaterFrontAMD: return "StencilRefGreaterFrontAMD";
    case ExecutionModeStencilRefLessFrontAMD: return "StencilRefLessFrontAMD";
    case ExecutionModeStencilRefUnchangedBackAMD: return "StencilRefUnchangedBackAMD";
    case ExecutionModeStencilRefGreaterBackAMD: return "StencilRefGreaterBackAMD";
    case ExecutionModeStencilRefLessBackAMD: return "StencilRefLessBackAMD";
    case ExecutionModeQuadDerivativesKHR: return "QuadDerivativesKHR";
    case ExecutionModeRequireFullQuadsKHR: return "RequireFullQuadsKHR";
    case ExecutionModeOutputLinesEXT: return "OutputLinesEXT";
    case ExecutionModeOutputPrimitivesEXT: return "OutputPrimitivesEXT";
    case ExecutionModeDerivativeGroupQuadsNV: return "DerivativeGroupQuadsNV";
    case ExecutionModeDerivativeGroupLinearNV: return "DerivativeGroupLinearNV";
    case ExecutionModeOutputTrianglesEXT: return "OutputTrianglesEXT";
    case ExecutionModePixelInterlockOrderedEXT: return "PixelInterlockOrderedEXT";
    case ExecutionModePixelInterlockUnorderedEXT: return "PixelInterlockUnorderedEXT";
    case ExecutionModeSampleInterlockOrderedEXT: return "SampleInterlockOrderedEXT";
    case ExecutionModeSampleInterlockUnorderedEXT: return "SampleInterlockUnorderedEXT";
    case ExecutionModeShadingRateInterlockOrderedEXT: return "ShadingRateInterlockOrderedEXT";
    case ExecutionModeShadingRateInterlockUnorderedEXT: return "ShadingRateInterlockUnorderedEXT";
    case ExecutionModeSharedLocalMemorySizeINTEL: return "SharedLocalMemorySizeINTEL";
    case ExecutionModeRoundingModeRTPINTEL: return "RoundingModeRTPINTEL";
    case ExecutionModeRoundingModeRTNINTEL: return "RoundingModeRTNINTEL";
    case ExecutionModeFloatingPointModeALTINTEL: return "FloatingPointModeALTINTEL";
    case ExecutionModeFloatingPointModeIEEEINTEL: return "FloatingPointModeIEEEINTEL";
    case ExecutionModeMaxWorkgroupSizeINTEL: return "MaxWorkgroupSizeINTEL";
    case ExecutionModeMaxWorkDimINTEL: return "MaxWorkDimINTEL";
    case ExecutionModeNoGlobalOffsetINTEL: return "NoGlobalOffsetINTEL";
    case ExecutionModeNumSIMDWorkitemsINTEL: return "NumSIMDWorkitemsINTEL";
    case ExecutionModeSchedulerTargetFmaxMhzINTEL: return "SchedulerTargetFmaxMhzINTEL";
    case ExecutionModeMaximallyReconvergesKHR: return "MaximallyReconvergesKHR";
    case ExecutionModeFPFastMathDefault: return "FPFastMathDefault";
    case ExecutionModeStreamingInterfaceINTEL: return "StreamingInterfaceINTEL";
    case ExecutionModeRegisterMapInterfaceINTEL: return "RegisterMapInterfaceINTEL";
    case ExecutionModeNamedBarrierCountINTEL: return "NamedBarrierCountINTEL";
    case ExecutionModeMaximumRegistersINTEL: return "MaximumRegistersINTEL";
    case ExecutionModeMaximumRegistersIdINTEL: return "MaximumRegistersIdINTEL";
    case ExecutionModeNamedMaximumRegistersINTEL: return "NamedMaximumRegistersINTEL";
    default: return "Unknown";
    }
}

inline const char* StorageClassToString(StorageClass value) {
    switch (value) {
    case StorageClassUniformConstant: return "UniformConstant";
    case StorageClassInput: return "Input";
    case StorageClassUniform: return "Uniform";
    case StorageClassOutput: return "Output";
    case StorageClassWorkgroup: return "Workgroup";
    case StorageClassCrossWorkgroup: return "CrossWorkgroup";
    case StorageClassPrivate: return "Private";
    case StorageClassFunction: return "Function";
    case StorageClassGeneric: return "Generic";
    case StorageClassPushConstant: return "PushConstant";
    case StorageClassAtomicCounter: return "AtomicCounter";
    case StorageClassImage: return "Image";
    case StorageClassStorageBuffer: return "StorageBuffer";
    case StorageClassTileImageEXT: return "TileImageEXT";
    case StorageClassNodePayloadAMDX: return "NodePayloadAMDX";
    case StorageClassNodeOutputPayloadAMDX: return "NodeOutputPayloadAMDX";
    case StorageClassCallableDataKHR: return "CallableDataKHR";
    case StorageClassIncomingCallableDataKHR: return "IncomingCallableDataKHR";
    case StorageClassRayPayloadKHR: return "RayPayloadKHR";
    case StorageClassHitAttributeKHR: return "HitAttributeKHR";
    case StorageClassIncomingRayPayloadKHR: return "IncomingRayPayloadKHR";
    case StorageClassShaderRecordBufferKHR: return "ShaderRecordBufferKHR";
    case StorageClassPhysicalStorageBuffer: return "PhysicalStorageBuffer";
    case StorageClassHitObjectAttributeNV: return "HitObjectAttributeNV";
    case StorageClassTaskPayloadWorkgroupEXT: return "TaskPayloadWorkgroupEXT";
    case StorageClassCodeSectionINTEL: return "CodeSectionINTEL";
    case StorageClassDeviceOnlyINTEL: return "DeviceOnlyINTEL";
    case StorageClassHostOnlyINTEL: return "HostOnlyINTEL";
    default: return "Unknown";
    }
}

inline const char* DimToString(Dim value) {
    switch (value) {
    case Dim1D: return "1D";
    case Dim2D: return "2D";
    case Dim3D: return "3D";
    case DimCube: return "Cube";
    case DimRect: return "Rect";
    case DimBuffer: return "Buffer";
    case DimSubpassData: return "SubpassData";
    case DimTileImageDataEXT: return "TileImageDataEXT";
    default: return "Unknown";
    }
}

inline const char* SamplerAddressingModeToString(SamplerAddressingMode value) {
    switch (value) {
    case SamplerAddressingModeNone: return "None";
    case SamplerAddressingModeClampToEdge: return "ClampToEdge";
    case SamplerAddressingModeClamp: return "Clamp";
    case SamplerAddressingModeRepeat: return "Repeat";
    case SamplerAddressingModeRepeatMirrored: return "RepeatMirrored";
    default: return "Unknown";
    }
}

inline const char* SamplerFilterModeToString(SamplerFilterMode value) {
    switch (value) {
    case SamplerFilterModeNearest: return "Nearest";
    case SamplerFilterModeLinear: return "Linear";
    default: return "Unknown";
    }
}

inline const char* ImageFormatToString(ImageFormat value) {
    switch (value) {
    case ImageFormatUnknown: return "Unknown";
    case ImageFormatRgba32f: return "Rgba32f";
    case ImageFormatRgba16f: return "Rgba16f";
    case ImageFormatR32f: return "R32f";
    case ImageFormatRgba8: return "Rgba8";
    case ImageFormatRgba8Snorm: return "Rgba8Snorm";
    case ImageFormatRg32f: return "Rg32f";
    case ImageFormatRg16f: return "Rg16f";
    case ImageFormatR11fG11fB10f: return "R11fG11fB10f";
    case ImageFormatR16f: return "R16f";
    case ImageFormatRgba16: return "Rgba16";
    case ImageFormatRgb10A2: return "Rgb10A2";
    case ImageFormatRg16: return "Rg16";
    case ImageFormatRg8: return "Rg8";
    case ImageFormatR16: return "R16";
    case ImageFormatR8: return "R8";
    case ImageFormatRgba16Snorm: return "Rgba16Snorm";
    case ImageFormatRg16Snorm: return "Rg16Snorm";
    case ImageFormatRg8Snorm: return "Rg8Snorm";
    case ImageFormatR16Snorm: return "R16Snorm";
    case ImageFormatR8Snorm: return "R8Snorm";
    case ImageFormatRgba32i: return "Rgba32i";
    case ImageFormatRgba16i: return "Rgba16i";
    case ImageFormatRgba8i: return "Rgba8i";
    case ImageFormatR32i: return "R32i";
    case ImageFormatRg32i: return "Rg32i";
    case ImageFormatRg16i: return "Rg16i";
    case ImageFormatRg8i: return "Rg8i";
    case ImageFormatR16i: return "R16i";
    case ImageFormatR8i: return "R8i";
    case ImageFormatRgba32ui: return "Rgba32ui";
    case ImageFormatRgba16ui: return "Rgba16ui";
    case ImageFormatRgba8ui: return "Rgba8ui";
    case ImageFormatR32ui: return "R32ui";
    case ImageFormatRgb10a2ui: return "Rgb10a2ui";
    case ImageFormatRg32ui: return "Rg32ui";
    case ImageFormatRg16ui: return "Rg16ui";
    case ImageFormatRg8ui: return "Rg8ui";
    case ImageFormatR16ui: return "R16ui";
    case ImageFormatR8ui: return "R8ui";
    case ImageFormatR64ui: return "R64ui";
    case ImageFormatR64i: return "R64i";
    default: return "Unknown";
    }
}

inline const char* ImageChannelOrderToString(ImageChannelOrder value) {
    switch (value) {
    case ImageChannelOrderR: return "R";
    case ImageChannelOrderA: return "A";
    case ImageChannelOrderRG: return "RG";
    case ImageChannelOrderRA: return "RA";
    case ImageChannelOrderRGB: return "RGB";
    case ImageChannelOrderRGBA: return "RGBA";
    case ImageChannelOrderBGRA: return "BGRA";
    case ImageChannelOrderARGB: return "ARGB";
    case ImageChannelOrderIntensity: return "Intensity";
    case ImageChannelOrderLuminance: return "Luminance";
    case ImageChannelOrderRx: return "Rx";
    case ImageChannelOrderRGx: return "RGx";
    case ImageChannelOrderRGBx: return "RGBx";
    case ImageChannelOrderDepth: return "Depth";
    case ImageChannelOrderDepthStencil: return "DepthStencil";
    case ImageChannelOrdersRGB: return "sRGB";
    case ImageChannelOrdersRGBx: return "sRGBx";
    case ImageChannelOrdersRGBA: return "sRGBA";
    case ImageChannelOrdersBGRA: return "sBGRA";
    case ImageChannelOrderABGR: return "ABGR";
    default: return "Unknown";
    }
}

inline const char* ImageChannelDataTypeToString(ImageChannelDataType value) {
    switch (value) {
    case ImageChannelDataTypeSnormInt8: return "SnormInt8";
    case ImageChannelDataTypeSnormInt16: return "SnormInt16";
    case ImageChannelDataTypeUnormInt8: return "UnormInt8";
    case ImageChannelDataTypeUnormInt16: return "UnormInt16";
    case ImageChannelDataTypeUnormShort565: return "UnormShort565";
    case ImageChannelDataTypeUnormShort555: return "UnormShort555";
    case ImageChannelDataTypeUnormInt101010: return "UnormInt101010";
    case ImageChannelDataTypeSignedInt8: return "SignedInt8";
    case ImageChannelDataTypeSignedInt16: return "SignedInt16";
    case ImageChannelDataTypeSignedInt32: return "SignedInt32";
    case ImageChannelDataTypeUnsignedInt8: return "UnsignedInt8";
    case ImageChannelDataTypeUnsignedInt16: return "UnsignedInt16";
    case ImageChannelDataTypeUnsignedInt32: return "UnsignedInt32";
    case ImageChannelDataTypeHalfFloat: return "HalfFloat";
    case ImageChannelDataTypeFloat: return "Float";
    case ImageChannelDataTypeUnormInt24: return "UnormInt24";
    case ImageChannelDataTypeUnormInt101010_2: return "UnormInt101010_2";
    case ImageChannelDataTypeUnsignedIntRaw10EXT: return "UnsignedIntRaw10EXT";
    case ImageChannelDataTypeUnsignedIntRaw12EXT: return "UnsignedIntRaw12EXT";
    default: return "Unknown";
    }
}

inline const char* FPRoundingModeToString(FPRoundingMode value) {
    switch (value) {
    case FPRoundingModeRTE: return "RTE";
    case FPRoundingModeRTZ: return "RTZ";
    case FPRoundingModeRTP: return "RTP";
    case FPRoundingModeRTN: return "RTN";
    default: return "Unknown";
    }
}

inline const char* LinkageTypeToString(LinkageType value) {
    switch (value) {
    case LinkageTypeExport: return "Export";
    case LinkageTypeImport: return "Import";
    case LinkageTypeLinkOnceODR: return "LinkOnceODR";
    default: return "Unknown";
    }
}

inline const char* AccessQualifierToString(AccessQualifier value) {
    switch (value) {
    case AccessQualifierReadOnly: return "ReadOnly";
    case AccessQualifierWriteOnly: return "WriteOnly";
    case AccessQualifierReadWrite: return "ReadWrite";
    default: return "Unknown";
    }
}

inline const char* FunctionParameterAttributeToString(FunctionParameterAttribute value) {
    switch (value) {
    case FunctionParameterAttributeZext: return "Zext";
    case FunctionParameterAttributeSext: return "Sext";
    case FunctionParameterAttributeByVal: return "ByVal";
    case FunctionParameterAttributeSret: return "Sret";
    case FunctionParameterAttributeNoAlias: return "NoAlias";
    case FunctionParameterAttributeNoCapture: return "NoCapture";
    case FunctionParameterAttributeNoWrite: return "NoWrite";
    case FunctionParameterAttributeNoReadWrite: return "NoReadWrite";
    case FunctionParameterAttributeRuntimeAlignedINTEL: return "RuntimeAlignedINTEL";
    default: return "Unknown";
    }
}

inline const char* DecorationToString(Decoration value) {
    switch (value) {
    case DecorationRelaxedPrecision: return "RelaxedPrecision";
    case DecorationSpecId: return "SpecId";
    case DecorationBlock: return "Block";
    case DecorationBufferBlock: return "BufferBlock";
    case DecorationRowMajor: return "RowMajor";
    case DecorationColMajor: return "ColMajor";
    case DecorationArrayStride: return "ArrayStride";
    case DecorationMatrixStride: return "MatrixStride";
    case DecorationGLSLShared: return "GLSLShared";
    case DecorationGLSLPacked: return "GLSLPacked";
    case DecorationCPacked: return "CPacked";
    case DecorationBuiltIn: return "BuiltIn";
    case DecorationNoPerspective: return "NoPerspective";
    case DecorationFlat: return "Flat";
    case DecorationPatch: return "Patch";
    case DecorationCentroid: return "Centroid";
    case DecorationSample: return "Sample";
    case DecorationInvariant: return "Invariant";
    case DecorationRestrict: return "Restrict";
    case DecorationAliased: return "Aliased";
    case DecorationVolatile: return "Volatile";
    case DecorationConstant: return "Constant";
    case DecorationCoherent: return "Coherent";
    case DecorationNonWritable: return "NonWritable";
    case DecorationNonReadable: return "NonReadable";
    case DecorationUniform: return "Uniform";
    case DecorationUniformId: return "UniformId";
    case DecorationSaturatedConversion: return "SaturatedConversion";
    case DecorationStream: return "Stream";
    case DecorationLocation: return "Location";
    case DecorationComponent: return "Component";
    case DecorationIndex: return "Index";
    case DecorationBinding: return "Binding";
    case DecorationDescriptorSet: return "DescriptorSet";
    case DecorationOffset: return "Offset";
    case DecorationXfbBuffer: return "XfbBuffer";
    case DecorationXfbStride: return "XfbStride";
    case DecorationFuncParamAttr: return "FuncParamAttr";
    case DecorationFPRoundingMode: return "FPRoundingMode";
    case DecorationFPFastMathMode: return "FPFastMathMode";
    case DecorationLinkageAttributes: return "LinkageAttributes";
    case DecorationNoContraction: return "NoContraction";
    case DecorationInputAttachmentIndex: return "InputAttachmentIndex";
    case DecorationAlignment: return "Alignment";
    case DecorationMaxByteOffset: return "MaxByteOffset";
    case DecorationAlignmentId: return "AlignmentId";
    case DecorationMaxByteOffsetId: return "MaxByteOffsetId";
    case DecorationNoSignedWrap: return "NoSignedWrap";
    case DecorationNoUnsignedWrap: return "NoUnsignedWrap";
    case DecorationWeightTextureQCOM: return "WeightTextureQCOM";
    case DecorationBlockMatchTextureQCOM: return "BlockMatchTextureQCOM";
    case DecorationBlockMatchSamplerQCOM: return "BlockMatchSamplerQCOM";
    case DecorationExplicitInterpAMD: return "ExplicitInterpAMD";
    case DecorationNodeSharesPayloadLimitsWithAMDX: return "NodeSharesPayloadLimitsWithAMDX";
    case DecorationNodeMaxPayloadsAMDX: return "NodeMaxPayloadsAMDX";
    case DecorationTrackFinishWritingAMDX: return "TrackFinishWritingAMDX";
    case DecorationPayloadNodeNameAMDX: return "PayloadNodeNameAMDX";
    case DecorationOverrideCoverageNV: return "OverrideCoverageNV";
    case DecorationPassthroughNV: return "PassthroughNV";
    case DecorationViewportRelativeNV: return "ViewportRelativeNV";
    case DecorationSecondaryViewportRelativeNV: return "SecondaryViewportRelativeNV";
    case DecorationPerPrimitiveEXT: return "PerPrimitiveEXT";
    case DecorationPerViewNV: return "PerViewNV";
    case DecorationPerTaskNV: return "PerTaskNV";
    case DecorationPerVertexKHR: return "PerVertexKHR";
    case DecorationNonUniform: return "NonUniform";
    case DecorationRestrictPointer: return "RestrictPointer";
    case DecorationAliasedPointer: return "AliasedPointer";
    case DecorationHitObjectShaderRecordBufferNV: return "HitObjectShaderRecordBufferNV";
    case DecorationBindlessSamplerNV: return "BindlessSamplerNV";
    case DecorationBindlessImageNV: return "BindlessImageNV";
    case DecorationBoundSamplerNV: return "BoundSamplerNV";
    case DecorationBoundImageNV: return "BoundImageNV";
    case DecorationSIMTCallINTEL: return "SIMTCallINTEL";
    case DecorationReferencedIndirectlyINTEL: return "ReferencedIndirectlyINTEL";
    case DecorationClobberINTEL: return "ClobberINTEL";
    case DecorationSideEffectsINTEL: return "SideEffectsINTEL";
    case DecorationVectorComputeVariableINTEL: return "VectorComputeVariableINTEL";
    case DecorationFuncParamIOKindINTEL: return "FuncParamIOKindINTEL";
    case DecorationVectorComputeFunctionINTEL: return "VectorComputeFunctionINTEL";
    case DecorationStackCallINTEL: return "StackCallINTEL";
    case DecorationGlobalVariableOffsetINTEL: return "GlobalVariableOffsetINTEL";
    case DecorationCounterBuffer: return "CounterBuffer";
    case DecorationHlslSemanticGOOGLE: return "HlslSemanticGOOGLE";
    case DecorationUserTypeGOOGLE: return "UserTypeGOOGLE";
    case DecorationFunctionRoundingModeINTEL: return "FunctionRoundingModeINTEL";
    case DecorationFunctionDenormModeINTEL: return "FunctionDenormModeINTEL";
    case DecorationRegisterINTEL: return "RegisterINTEL";
    case DecorationMemoryINTEL: return "MemoryINTEL";
    case DecorationNumbanksINTEL: return "NumbanksINTEL";
    case DecorationBankwidthINTEL: return "BankwidthINTEL";
    case DecorationMaxPrivateCopiesINTEL: return "MaxPrivateCopiesINTEL";
    case DecorationSinglepumpINTEL: return "SinglepumpINTEL";
    case DecorationDoublepumpINTEL: return "DoublepumpINTEL";
    case DecorationMaxReplicatesINTEL: return "MaxReplicatesINTEL";
    case DecorationSimpleDualPortINTEL: return "SimpleDualPortINTEL";
    case DecorationMergeINTEL: return "MergeINTEL";
    case DecorationBankBitsINTEL: return "BankBitsINTEL";
    case DecorationForcePow2DepthINTEL: return "ForcePow2DepthINTEL";
    case DecorationStridesizeINTEL: return "StridesizeINTEL";
    case DecorationWordsizeINTEL: return "WordsizeINTEL";
    case DecorationTrueDualPortINTEL: return "TrueDualPortINTEL";
    case DecorationBurstCoalesceINTEL: return "BurstCoalesceINTEL";
    case DecorationCacheSizeINTEL: return "CacheSizeINTEL";
    case DecorationDontStaticallyCoalesceINTEL: return "DontStaticallyCoalesceINTEL";
    case DecorationPrefetchINTEL: return "PrefetchINTEL";
    case DecorationStallEnableINTEL: return "StallEnableINTEL";
    case DecorationFuseLoopsInFunctionINTEL: return "FuseLoopsInFunctionINTEL";
    case DecorationMathOpDSPModeINTEL: return "MathOpDSPModeINTEL";
    case DecorationAliasScopeINTEL: return "AliasScopeINTEL";
    case DecorationNoAliasINTEL: return "NoAliasINTEL";
    case DecorationInitiationIntervalINTEL: return "InitiationIntervalINTEL";
    case DecorationMaxConcurrencyINTEL: return "MaxConcurrencyINTEL";
    case DecorationPipelineEnableINTEL: return "PipelineEnableINTEL";
    case DecorationBufferLocationINTEL: return "BufferLocationINTEL";
    case DecorationIOPipeStorageINTEL: return "IOPipeStorageINTEL";
    case DecorationFunctionFloatingPointModeINTEL: return "FunctionFloatingPointModeINTEL";
    case DecorationSingleElementVectorINTEL: return "SingleElementVectorINTEL";
    case DecorationVectorComputeCallableFunctionINTEL: return "VectorComputeCallableFunctionINTEL";
    case DecorationMediaBlockIOINTEL: return "MediaBlockIOINTEL";
    case DecorationStallFreeINTEL: return "StallFreeINTEL";
    case DecorationFPMaxErrorDecorationINTEL: return "FPMaxErrorDecorationINTEL";
    case DecorationLatencyControlLabelINTEL: return "LatencyControlLabelINTEL";
    case DecorationLatencyControlConstraintINTEL: return "LatencyControlConstraintINTEL";
    case DecorationConduitKernelArgumentINTEL: return "ConduitKernelArgumentINTEL";
    case DecorationRegisterMapKernelArgumentINTEL: return "RegisterMapKernelArgumentINTEL";
    case DecorationMMHostInterfaceAddressWidthINTEL: return "MMHostInterfaceAddressWidthINTEL";
    case DecorationMMHostInterfaceDataWidthINTEL: return "MMHostInterfaceDataWidthINTEL";
    case DecorationMMHostInterfaceLatencyINTEL: return "MMHostInterfaceLatencyINTEL";
    case DecorationMMHostInterfaceReadWriteModeINTEL: return "MMHostInterfaceReadWriteModeINTEL";
    case DecorationMMHostInterfaceMaxBurstINTEL: return "MMHostInterfaceMaxBurstINTEL";
    case DecorationMMHostInterfaceWaitRequestINTEL: return "MMHostInterfaceWaitRequestINTEL";
    case DecorationStableKernelArgumentINTEL: return "StableKernelArgumentINTEL";
    case DecorationHostAccessINTEL: return "HostAccessINTEL";
    case DecorationInitModeINTEL: return "InitModeINTEL";
    case DecorationImplementInRegisterMapINTEL: return "ImplementInRegisterMapINTEL";
    case DecorationCacheControlLoadINTEL: return "CacheControlLoadINTEL";
    case DecorationCacheControlStoreINTEL: return "CacheControlStoreINTEL";
    default: return "Unknown";
    }
}

inline const char* BuiltInToString(BuiltIn value) {
    switch (value) {
    case BuiltInPosition: return "Position";
    case BuiltInPointSize: return "PointSize";
    case BuiltInClipDistance: return "ClipDistance";
    case BuiltInCullDistance: return "CullDistance";
    case BuiltInVertexId: return "VertexId";
    case BuiltInInstanceId: return "InstanceId";
    case BuiltInPrimitiveId: return "PrimitiveId";
    case BuiltInInvocationId: return "InvocationId";
    case BuiltInLayer: return "Layer";
    case BuiltInViewportIndex: return "ViewportIndex";
    case BuiltInTessLevelOuter: return "TessLevelOuter";
    case BuiltInTessLevelInner: return "TessLevelInner";
    case BuiltInTessCoord: return "TessCoord";
    case BuiltInPatchVertices: return "PatchVertices";
    case BuiltInFragCoord: return "FragCoord";
    case BuiltInPointCoord: return "PointCoord";
    case BuiltInFrontFacing: return "FrontFacing";
    case BuiltInSampleId: return "SampleId";
    case BuiltInSamplePosition: return "SamplePosition";
    case BuiltInSampleMask: return "SampleMask";
    case BuiltInFragDepth: return "FragDepth";
    case BuiltInHelperInvocation: return "HelperInvocation";
    case BuiltInNumWorkgroups: return "NumWorkgroups";
    case BuiltInWorkgroupSize: return "WorkgroupSize";
    case BuiltInWorkgroupId: return "WorkgroupId";
    case BuiltInLocalInvocationId: return "LocalInvocationId";
    case BuiltInGlobalInvocationId: return "GlobalInvocationId";
    case BuiltInLocalInvocationIndex: return "LocalInvocationIndex";
    case BuiltInWorkDim: return "WorkDim";
    case BuiltInGlobalSize: return "GlobalSize";
    case BuiltInEnqueuedWorkgroupSize: return "EnqueuedWorkgroupSize";
    case BuiltInGlobalOffset: return "GlobalOffset";
    case BuiltInGlobalLinearId: return "GlobalLinearId";
    case BuiltInSubgroupSize: return "SubgroupSize";
    case BuiltInSubgroupMaxSize: return "SubgroupMaxSize";
    case BuiltInNumSubgroups: return "NumSubgroups";
    case BuiltInNumEnqueuedSubgroups: return "NumEnqueuedSubgroups";
    case BuiltInSubgroupId: return "SubgroupId";
    case BuiltInSubgroupLocalInvocationId: return "SubgroupLocalInvocationId";
    case BuiltInVertexIndex: return "VertexIndex";
    case BuiltInInstanceIndex: return "InstanceIndex";
    case BuiltInCoreIDARM: return "CoreIDARM";
    case BuiltInCoreCountARM: return "CoreCountARM";
    case BuiltInCoreMaxIDARM: return "CoreMaxIDARM";
    case BuiltInWarpIDARM: return "WarpIDARM";
    case BuiltInWarpMaxIDARM: return "WarpMaxIDARM";
    case BuiltInSubgroupEqMask: return "SubgroupEqMask";
    case BuiltInSubgroupGeMask: return "SubgroupGeMask";
    case BuiltInSubgroupGtMask: return "SubgroupGtMask";
    case BuiltInSubgroupLeMask: return "SubgroupLeMask";
    case BuiltInSubgroupLtMask: return "SubgroupLtMask";
    case BuiltInBaseVertex: return "BaseVertex";
    case BuiltInBaseInstance: return "BaseInstance";
    case BuiltInDrawIndex: return "DrawIndex";
    case BuiltInPrimitiveShadingRateKHR: return "PrimitiveShadingRateKHR";
    case BuiltInDeviceIndex: return "DeviceIndex";
    case BuiltInViewIndex: return "ViewIndex";
    case BuiltInShadingRateKHR: return "ShadingRateKHR";
    case BuiltInBaryCoordNoPerspAMD: return "BaryCoordNoPerspAMD";
    case BuiltInBaryCoordNoPerspCentroidAMD: return "BaryCoordNoPerspCentroidAMD";
    case BuiltInBaryCoordNoPerspSampleAMD: return "BaryCoordNoPerspSampleAMD";
    case BuiltInBaryCoordSmoothAMD: return "BaryCoordSmoothAMD";
    case BuiltInBaryCoordSmoothCentroidAMD: return "BaryCoordSmoothCentroidAMD";
    case BuiltInBaryCoordSmoothSampleAMD: return "BaryCoordSmoothSampleAMD";
    case BuiltInBaryCoordPullModelAMD: return "BaryCoordPullModelAMD";
    case BuiltInFragStencilRefEXT: return "FragStencilRefEXT";
    case BuiltInCoalescedInputCountAMDX: return "CoalescedInputCountAMDX";
    case BuiltInShaderIndexAMDX: return "ShaderIndexAMDX";
    case BuiltInViewportMaskNV: return "ViewportMaskNV";
    case BuiltInSecondaryPositionNV: return "SecondaryPositionNV";
    case BuiltInSecondaryViewportMaskNV: return "SecondaryViewportMaskNV";
    case BuiltInPositionPerViewNV: return "PositionPerViewNV";
    case BuiltInViewportMaskPerViewNV: return "ViewportMaskPerViewNV";
    case BuiltInFullyCoveredEXT: return "FullyCoveredEXT";
    case BuiltInTaskCountNV: return "TaskCountNV";
    case BuiltInPrimitiveCountNV: return "PrimitiveCountNV";
    case BuiltInPrimitiveIndicesNV: return "PrimitiveIndicesNV";
    case BuiltInClipDistancePerViewNV: return "ClipDistancePerViewNV";
    case BuiltInCullDistancePerViewNV: return "CullDistancePerViewNV";
    case BuiltInLayerPerViewNV: return "LayerPerViewNV";
    case BuiltInMeshViewCountNV: return "MeshViewCountNV";
    case BuiltInMeshViewIndicesNV: return "MeshViewIndicesNV";
    case BuiltInBaryCoordKHR: return "BaryCoordKHR";
    case BuiltInBaryCoordNoPerspKHR: return "BaryCoordNoPerspKHR";
    case BuiltInFragSizeEXT: return "FragSizeEXT";
    case BuiltInFragInvocationCountEXT: return "FragInvocationCountEXT";
    case BuiltInPrimitivePointIndicesEXT: return "PrimitivePointIndicesEXT";
    case BuiltInPrimitiveLineIndicesEXT: return "PrimitiveLineIndicesEXT";
    case BuiltInPrimitiveTriangleIndicesEXT: return "PrimitiveTriangleIndicesEXT";
    case BuiltInCullPrimitiveEXT: return "CullPrimitiveEXT";
    case BuiltInLaunchIdKHR: return "LaunchIdKHR";
    case BuiltInLaunchSizeKHR: return "LaunchSizeKHR";
    case BuiltInWorldRayOriginKHR: return "WorldRayOriginKHR";
    case BuiltInWorldRayDirectionKHR: return "WorldRayDirectionKHR";
    case BuiltInObjectRayOriginKHR: return "ObjectRayOriginKHR";
    case BuiltInObjectRayDirectionKHR: return "ObjectRayDirectionKHR";
    case BuiltInRayTminKHR: return "RayTminKHR";
    case BuiltInRayTmaxKHR: return "RayTmaxKHR";
    case BuiltInInstanceCustomIndexKHR: return "InstanceCustomIndexKHR";
    case BuiltInObjectToWorldKHR: return "ObjectToWorldKHR";
    case BuiltInWorldToObjectKHR: return "WorldToObjectKHR";
    case BuiltInHitTNV: return "HitTNV";
    case BuiltInHitKindKHR: return "HitKindKHR";
    case BuiltInCurrentRayTimeNV: return "CurrentRayTimeNV";
    case BuiltInHitTriangleVertexPositionsKHR: return "HitTriangleVertexPositionsKHR";
    case BuiltInHitMicroTriangleVertexPositionsNV: return "HitMicroTriangleVertexPositionsNV";
    case BuiltInHitMicroTriangleVertexBarycentricsNV: return "HitMicroTriangleVertexBarycentricsNV";
    case BuiltInIncomingRayFlagsKHR: return "IncomingRayFlagsKHR";
    case BuiltInRayGeometryIndexKHR: return "RayGeometryIndexKHR";
    case BuiltInWarpsPerSMNV: return "WarpsPerSMNV";
    case BuiltInSMCountNV: return "SMCountNV";
    case BuiltInWarpIDNV: return "WarpIDNV";
    case BuiltInSMIDNV: return "SMIDNV";
    case BuiltInHitKindFrontFacingMicroTriangleNV: return "HitKindFrontFacingMicroTriangleNV";
    case BuiltInHitKindBackFacingMicroTriangleNV: return "HitKindBackFacingMicroTriangleNV";
    case BuiltInCullMaskKHR: return "CullMaskKHR";
    default: return "Unknown";
    }
}

inline const char* ScopeToString(Scope value) {
    switch (value) {
    case ScopeCrossDevice: return "CrossDevice";
    case ScopeDevice: return "Device";
    case ScopeWorkgroup: return "Workgroup";
    case ScopeSubgroup: return "Subgroup";
    case ScopeInvocation: return "Invocation";
    case ScopeQueueFamily: return "QueueFamily";
    case ScopeShaderCallKHR: return "ShaderCallKHR";
    default: return "Unknown";
    }
}

inline const char* GroupOperationToString(GroupOperation value) {
    switch (value) {
    case GroupOperationReduce: return "Reduce";
    case GroupOperationInclusiveScan: return "InclusiveScan";
    case GroupOperationExclusiveScan: return "ExclusiveScan";
    case GroupOperationClusteredReduce: return "ClusteredReduce";
    case GroupOperationPartitionedReduceNV: return "PartitionedReduceNV";
    case GroupOperationPartitionedInclusiveScanNV: return "PartitionedInclusiveScanNV";
    case GroupOperationPartitionedExclusiveScanNV: return "PartitionedExclusiveScanNV";
    default: return "Unknown";
    }
}

inline const char* KernelEnqueueFlagsToString(KernelEnqueueFlags value) {
    switch (value) {
    case KernelEnqueueFlagsNoWait: return "NoWait";
    case KernelEnqueueFlagsWaitKernel: return "WaitKernel";
    case KernelEnqueueFlagsWaitWorkGroup: return "WaitWorkGroup";
    default: return "Unknown";
    }
}

inline const char* CapabilityToString(Capability value) {
    switch (value) {
    case CapabilityMatrix: return "Matrix";
    case CapabilityShader: return "Shader";
    case CapabilityGeometry: return "Geometry";
    case CapabilityTessellation: return "Tessellation";
    case CapabilityAddresses: return "Addresses";
    case CapabilityLinkage: return "Linkage";
    case CapabilityKernel: return "Kernel";
    case CapabilityVector16: return "Vector16";
    case CapabilityFloat16Buffer: return "Float16Buffer";
    case CapabilityFloat16: return "Float16";
    case CapabilityFloat64: return "Float64";
    case CapabilityInt64: return "Int64";
    case CapabilityInt64Atomics: return "Int64Atomics";
    case CapabilityImageBasic: return "ImageBasic";
    case CapabilityImageReadWrite: return "ImageReadWrite";
    case CapabilityImageMipmap: return "ImageMipmap";
    case CapabilityPipes: return "Pipes";
    case CapabilityGroups: return "Groups";
    case CapabilityDeviceEnqueue: return "DeviceEnqueue";
    case CapabilityLiteralSampler: return "LiteralSampler";
    case CapabilityAtomicStorage: return "AtomicStorage";
    case CapabilityInt16: return "Int16";
    case CapabilityTessellationPointSize: return "TessellationPointSize";
    case CapabilityGeometryPointSize: return "GeometryPointSize";
    case CapabilityImageGatherExtended: return "ImageGatherExtended";
    case CapabilityStorageImageMultisample: return "StorageImageMultisample";
    case CapabilityUniformBufferArrayDynamicIndexing: return "UniformBufferArrayDynamicIndexing";
    case CapabilitySampledImageArrayDynamicIndexing: return "SampledImageArrayDynamicIndexing";
    case CapabilityStorageBufferArrayDynamicIndexing: return "StorageBufferArrayDynamicIndexing";
    case CapabilityStorageImageArrayDynamicIndexing: return "StorageImageArrayDynamicIndexing";
    case CapabilityClipDistance: return "ClipDistance";
    case CapabilityCullDistance: return "CullDistance";
    case CapabilityImageCubeArray: return "ImageCubeArray";
    case CapabilitySampleRateShading: return "SampleRateShading";
    case CapabilityImageRect: return "ImageRect";
    case CapabilitySampledRect: return "SampledRect";
    case CapabilityGenericPointer: return "GenericPointer";
    case CapabilityInt8: return "Int8";
    case CapabilityInputAttachment: return "InputAttachment";
    case CapabilitySparseResidency: return "SparseResidency";
    case CapabilityMinLod: return "MinLod";
    case CapabilitySampled1D: return "Sampled1D";
    case CapabilityImage1D: return "Image1D";
    case CapabilitySampledCubeArray: return "SampledCubeArray";
    case CapabilitySampledBuffer: return "SampledBuffer";
    case CapabilityImageBuffer: return "ImageBuffer";
    case CapabilityImageMSArray: return "ImageMSArray";
    case CapabilityStorageImageExtendedFormats: return "StorageImageExtendedFormats";
    case CapabilityImageQuery: return "ImageQuery";
    case CapabilityDerivativeControl: return "DerivativeControl";
    case CapabilityInterpolationFunction: return "InterpolationFunction";
    case CapabilityTransformFeedback: return "TransformFeedback";
    case CapabilityGeometryStreams: return "GeometryStreams";
    case CapabilityStorageImageReadWithoutFormat: return "StorageImageReadWithoutFormat";
    case CapabilityStorageImageWriteWithoutFormat: return "StorageImageWriteWithoutFormat";
    case CapabilityMultiViewport: return "MultiViewport";
    case CapabilitySubgroupDispatch: return "SubgroupDispatch";
    case CapabilityNamedBarrier: return "NamedBarrier";
    case CapabilityPipeStorage: return "PipeStorage";
    case CapabilityGroupNonUniform: return "GroupNonUniform";
    case CapabilityGroupNonUniformVote: return "GroupNonUniformVote";
    case CapabilityGroupNonUniformArithmetic: return "GroupNonUniformArithmetic";
    case CapabilityGroupNonUniformBallot: return "GroupNonUniformBallot";
    case CapabilityGroupNonUniformShuffle: return "GroupNonUniformShuffle";
    case CapabilityGroupNonUniformShuffleRelative: return "GroupNonUniformShuffleRelative";
    case CapabilityGroupNonUniformClustered: return "GroupNonUniformClustered";
    case CapabilityGroupNonUniformQuad: return "GroupNonUniformQuad";
    case CapabilityShaderLayer: return "ShaderLayer";
    case CapabilityShaderViewportIndex: return "ShaderViewportIndex";
    case CapabilityUniformDecoration: return "UniformDecoration";
    case CapabilityCoreBuiltinsARM: return "CoreBuiltinsARM";
    case CapabilityTileImageColorReadAccessEXT: return "TileImageColorReadAccessEXT";
    case CapabilityTileImageDepthReadAccessEXT: return "TileImageDepthReadAccessEXT";
    case CapabilityTileImageStencilReadAccessEXT: return "TileImageStencilReadAccessEXT";
    case CapabilityCooperativeMatrixLayoutsARM: return "CooperativeMatrixLayoutsARM";
    case CapabilityFragmentShadingRateKHR: return "FragmentShadingRateKHR";
    case CapabilitySubgroupBallotKHR: return "SubgroupBallotKHR";
    case CapabilityDrawParameters: return "DrawParameters";
    case CapabilityWorkgroupMemoryExplicitLayoutKHR: return "WorkgroupMemoryExplicitLayoutKHR";
    case CapabilityWorkgroupMemoryExplicitLayout8BitAccessKHR: return "WorkgroupMemoryExplicitLayout8BitAccessKHR";
    case CapabilityWorkgroupMemoryExplicitLayout16BitAccessKHR: return "WorkgroupMemoryExplicitLayout16BitAccessKHR";
    case CapabilitySubgroupVoteKHR: return "SubgroupVoteKHR";
    case CapabilityStorageBuffer16BitAccess: return "StorageBuffer16BitAccess";
    case CapabilityStorageUniform16: return "StorageUniform16";
    case CapabilityStoragePushConstant16: return "StoragePushConstant16";
    case CapabilityStorageInputOutput16: return "StorageInputOutput16";
    case CapabilityDeviceGroup: return "DeviceGroup";
    case CapabilityMultiView: return "MultiView";
    case CapabilityVariablePointersStorageBuffer: return "VariablePointersStorageBuffer";
    case CapabilityVariablePointers: return "VariablePointers";
    case CapabilityAtomicStorageOps: return "AtomicStorageOps";
    case CapabilitySampleMaskPostDepthCoverage: return "SampleMaskPostDepthCoverage";
    case CapabilityStorageBuffer8BitAccess: return "StorageBuffer8BitAccess";
    case CapabilityUniformAndStorageBuffer8BitAccess: return "UniformAndStorageBuffer8BitAccess";
    case CapabilityStoragePushConstant8: return "StoragePushConstant8";
    case CapabilityDenormPreserve: return "DenormPreserve";
    case CapabilityDenormFlushToZero: return "DenormFlushToZero";
    case CapabilitySignedZeroInfNanPreserve: return "SignedZeroInfNanPreserve";
    case CapabilityRoundingModeRTE: return "RoundingModeRTE";
    case CapabilityRoundingModeRTZ: return "RoundingModeRTZ";
    case CapabilityRayQueryProvisionalKHR: return "RayQueryProvisionalKHR";
    case CapabilityRayQueryKHR: return "RayQueryKHR";
    case CapabilityRayTraversalPrimitiveCullingKHR: return "RayTraversalPrimitiveCullingKHR";
    case CapabilityRayTracingKHR: return "RayTracingKHR";
    case CapabilityTextureSampleWeightedQCOM: return "TextureSampleWeightedQCOM";
    case CapabilityTextureBoxFilterQCOM: return "TextureBoxFilterQCOM";
    case CapabilityTextureBlockMatchQCOM: return "TextureBlockMatchQCOM";
    case CapabilityTextureBlockMatch2QCOM: return "TextureBlockMatch2QCOM";
    case CapabilityFloat16ImageAMD: return "Float16ImageAMD";
    case CapabilityImageGatherBiasLodAMD: return "ImageGatherBiasLodAMD";
    case CapabilityFragmentMaskAMD: return "FragmentMaskAMD";
    case CapabilityStencilExportEXT: return "StencilExportEXT";
    case CapabilityImageReadWriteLodAMD: return "ImageReadWriteLodAMD";
    case CapabilityInt64ImageEXT: return "Int64ImageEXT";
    case CapabilityShaderClockKHR: return "ShaderClockKHR";
    case CapabilityShaderEnqueueAMDX: return "ShaderEnqueueAMDX";
    case CapabilityQuadControlKHR: return "QuadControlKHR";
    case CapabilitySampleMaskOverrideCoverageNV: return "SampleMaskOverrideCoverageNV";
    case CapabilityGeometryShaderPassthroughNV: return "GeometryShaderPassthroughNV";
    case CapabilityShaderViewportIndexLayerEXT: return "ShaderViewportIndexLayerEXT";
    case CapabilityShaderViewportMaskNV: return "ShaderViewportMaskNV";
    case CapabilityShaderStereoViewNV: return "ShaderStereoViewNV";
    case CapabilityPerViewAttributesNV: return "PerViewAttributesNV";
    case CapabilityFragmentFullyCoveredEXT: return "FragmentFullyCoveredEXT";
    case CapabilityMeshShadingNV: return "MeshShadingNV";
    case CapabilityImageFootprintNV: return "ImageFootprintNV";
    case CapabilityMeshShadingEXT: return "MeshShadingEXT";
    case CapabilityFragmentBarycentricKHR: return "FragmentBarycentricKHR";
    case CapabilityComputeDerivativeGroupQuadsNV: return "ComputeDerivativeGroupQuadsNV";
    case CapabilityFragmentDensityEXT: return "FragmentDensityEXT";
    case CapabilityGroupNonUniformPartitionedNV: return "GroupNonUniformPartitionedNV";
    case CapabilityShaderNonUniform: return "ShaderNonUniform";
    case CapabilityRuntimeDescriptorArray: return "RuntimeDescriptorArray";
    case CapabilityInputAttachmentArrayDynamicIndexing: return "InputAttachmentArrayDynamicIndexing";
    case CapabilityUniformTexelBufferArrayDynamicIndexing: return "UniformTexelBufferArrayDynamicIndexing";
    case CapabilityStorageTexelBufferArrayDynamicIndexing: return "StorageTexelBufferArrayDynamicIndexing";
    case CapabilityUniformBufferArrayNonUniformIndexing: return "UniformBufferArrayNonUniformIndexing";
    case CapabilitySampledImageArrayNonUniformIndexing: return "SampledImageArrayNonUniformIndexing";
    case CapabilityStorageBufferArrayNonUniformIndexing: return "StorageBufferArrayNonUniformIndexing";
    case CapabilityStorageImageArrayNonUniformIndexing: return "StorageImageArrayNonUniformIndexing";
    case CapabilityInputAttachmentArrayNonUniformIndexing: return "InputAttachmentArrayNonUniformIndexing";
    case CapabilityUniformTexelBufferArrayNonUniformIndexing: return "UniformTexelBufferArrayNonUniformIndexing";
    case CapabilityStorageTexelBufferArrayNonUniformIndexing: return "StorageTexelBufferArrayNonUniformIndexing";
    case CapabilityRayTracingPositionFetchKHR: return "RayTracingPositionFetchKHR";
    case CapabilityRayTracingNV: return "RayTracingNV";
    case CapabilityRayTracingMotionBlurNV: return "RayTracingMotionBlurNV";
    case CapabilityVulkanMemoryModel: return "VulkanMemoryModel";
    case CapabilityVulkanMemoryModelDeviceScope: return "VulkanMemoryModelDeviceScope";
    case CapabilityPhysicalStorageBufferAddresses: return "PhysicalStorageBufferAddresses";
    case CapabilityComputeDerivativeGroupLinearNV: return "ComputeDerivativeGroupLinearNV";
    case CapabilityRayTracingProvisionalKHR: return "RayTracingProvisionalKHR";
    case CapabilityCooperativeMatrixNV: return "CooperativeMatrixNV";
    case CapabilityFragmentShaderSampleInterlockEXT: return "FragmentShaderSampleInterlockEXT";
    case CapabilityFragmentShaderShadingRateInterlockEXT: return "FragmentShaderShadingRateInterlockEXT";
    case CapabilityShaderSMBuiltinsNV: return "ShaderSMBuiltinsNV";
    case CapabilityFragmentShaderPixelInterlockEXT: return "FragmentShaderPixelInterlockEXT";
    case CapabilityDemoteToHelperInvocation: return "DemoteToHelperInvocation";
    case CapabilityDisplacementMicromapNV: return "DisplacementMicromapNV";
    case CapabilityRayTracingOpacityMicromapEXT: return "RayTracingOpacityMicromapEXT";
    case CapabilityShaderInvocationReorderNV: return "ShaderInvocationReorderNV";
    case CapabilityBindlessTextureNV: return "BindlessTextureNV";
    case CapabilityRayQueryPositionFetchKHR: return "RayQueryPositionFetchKHR";
    case CapabilityAtomicFloat16VectorNV: return "AtomicFloat16VectorNV";
    case CapabilityRayTracingDisplacementMicromapNV: return "RayTracingDisplacementMicromapNV";
    case CapabilityRawAccessChainsNV: return "RawAccessChainsNV";
    case CapabilitySubgroupShuffleINTEL: return "SubgroupShuffleINTEL";
    case CapabilitySubgroupBufferBlockIOINTEL: return "SubgroupBufferBlockIOINTEL";
    case CapabilitySubgroupImageBlockIOINTEL: return "SubgroupImageBlockIOINTEL";
    case CapabilitySubgroupImageMediaBlockIOINTEL: return "SubgroupImageMediaBlockIOINTEL";
    case CapabilityRoundToInfinityINTEL: return "RoundToInfinityINTEL";
    case CapabilityFloatingPointModeINTEL: return "FloatingPointModeINTEL";
    case CapabilityIntegerFunctions2INTEL: return "IntegerFunctions2INTEL";
    case CapabilityFunctionPointersINTEL: return "FunctionPointersINTEL";
    case CapabilityIndirectReferencesINTEL: return "IndirectReferencesINTEL";
    case CapabilityAsmINTEL: return "AsmINTEL";
    case CapabilityAtomicFloat32MinMaxEXT: return "AtomicFloat32MinMaxEXT";
    case CapabilityAtomicFloat64MinMaxEXT: return "AtomicFloat64MinMaxEXT";
    case CapabilityAtomicFloat16MinMaxEXT: return "AtomicFloat16MinMaxEXT";
    case CapabilityVectorComputeINTEL: return "VectorComputeINTEL";
    case CapabilityVectorAnyINTEL: return "VectorAnyINTEL";
    case CapabilityExpectAssumeKHR: return "ExpectAssumeKHR";
    case CapabilitySubgroupAvcMotionEstimationINTEL: return "SubgroupAvcMotionEstimationINTEL";
    case CapabilitySubgroupAvcMotionEstimationIntraINTEL: return "SubgroupAvcMotionEstimationIntraINTEL";
    case CapabilitySubgroupAvcMotionEstimationChromaINTEL: return "SubgroupAvcMotionEstimationChromaINTEL";
    case CapabilityVariableLengthArrayINTEL: return "VariableLengthArrayINTEL";
    case CapabilityFunctionFloatControlINTEL: return "FunctionFloatControlINTEL";
    case CapabilityFPGAMemoryAttributesINTEL: return "FPGAMemoryAttributesINTEL";
    case CapabilityFPFastMathModeINTEL: return "FPFastMathModeINTEL";
    case CapabilityArbitraryPrecisionIntegersINTEL: return "ArbitraryPrecisionIntegersINTEL";
    case CapabilityArbitraryPrecisionFloatingPointINTEL: return "ArbitraryPrecisionFloatingPointINTEL";
    case CapabilityUnstructuredLoopControlsINTEL: return "UnstructuredLoopControlsINTEL";
    case CapabilityFPGALoopControlsINTEL: return "FPGALoopControlsINTEL";
    case CapabilityKernelAttributesINTEL: return "KernelAttributesINTEL";
    case CapabilityFPGAKernelAttributesINTEL: return "FPGAKernelAttributesINTEL";
    case CapabilityFPGAMemoryAccessesINTEL: return "FPGAMemoryAccessesINTEL";
    case CapabilityFPGAClusterAttributesINTEL: return "FPGAClusterAttributesINTEL";
    case CapabilityLoopFuseINTEL: return "LoopFuseINTEL";
    case CapabilityFPGADSPControlINTEL: return "FPGADSPControlINTEL";
    case CapabilityMemoryAccessAliasingINTEL: return "MemoryAccessAliasingINTEL";
    case CapabilityFPGAInvocationPipeliningAttributesINTEL: return "FPGAInvocationPipeliningAttributesINTEL";
    case CapabilityFPGABufferLocationINTEL: return "FPGABufferLocationINTEL";
    case CapabilityArbitraryPrecisionFixedPointINTEL: return "ArbitraryPrecisionFixedPointINTEL";
    case CapabilityUSMStorageClassesINTEL: return "USMStorageClassesINTEL";
    case CapabilityRuntimeAlignedAttributeINTEL: return "RuntimeAlignedAttributeINTEL";
    case CapabilityIOPipesINTEL: return "IOPipesINTEL";
    case CapabilityBlockingPipesINTEL: return "BlockingPipesINTEL";
    case CapabilityFPGARegINTEL: return "FPGARegINTEL";
    case CapabilityDotProductInputAll: return "DotProductInputAll";
    case CapabilityDotProductInput4x8Bit: return "DotProductInput4x8Bit";
    case CapabilityDotProductInput4x8BitPacked: return "DotProductInput4x8BitPacked";
    case CapabilityDotProduct: return "DotProduct";
    case CapabilityRayCullMaskKHR: return "RayCullMaskKHR";
    case CapabilityCooperativeMatrixKHR: return "CooperativeMatrixKHR";
    case CapabilityReplicatedCompositesEXT: return "ReplicatedCompositesEXT";
    case CapabilityBitInstructions: return "BitInstructions";
    case CapabilityGroupNonUniformRotateKHR: return "GroupNonUniformRotateKHR";
    case CapabilityFloatControls2: return "FloatControls2";
    case CapabilityAtomicFloat32AddEXT: return "AtomicFloat32AddEXT";
    case CapabilityAtomicFloat64AddEXT: return "AtomicFloat64AddEXT";
    case CapabilityLongCompositesINTEL: return "LongCompositesINTEL";
    case CapabilityOptNoneINTEL: return "OptNoneINTEL";
    case CapabilityAtomicFloat16AddEXT: return "AtomicFloat16AddEXT";
    case CapabilityDebugInfoModuleINTEL: return "DebugInfoModuleINTEL";
    case CapabilityBFloat16ConversionINTEL: return "BFloat16ConversionINTEL";
    case CapabilitySplitBarrierINTEL: return "SplitBarrierINTEL";
    case CapabilityFPGAClusterAttributesV2INTEL: return "FPGAClusterAttributesV2INTEL";
    case CapabilityFPGAKernelAttributesv2INTEL: return "FPGAKernelAttributesv2INTEL";
    case CapabilityFPMaxErrorINTEL: return "FPMaxErrorINTEL";
    case CapabilityFPGALatencyControlINTEL: return "FPGALatencyControlINTEL";
    case CapabilityFPGAArgumentInterfacesINTEL: return "FPGAArgumentInterfacesINTEL";
    case CapabilityGlobalVariableHostAccessINTEL: return "GlobalVariableHostAccessINTEL";
    case CapabilityGlobalVariableFPGADecorationsINTEL: return "GlobalVariableFPGADecorationsINTEL";
    case CapabilityGroupUniformArithmeticKHR: return "GroupUniformArithmeticKHR";
    case CapabilityMaskedGatherScatterINTEL: return "MaskedGatherScatterINTEL";
    case CapabilityCacheControlsINTEL: return "CacheControlsINTEL";
    case CapabilityRegisterLimitsINTEL: return "RegisterLimitsINTEL";
    default: return "Unknown";
    }
}

inline const char* RayQueryIntersectionToString(RayQueryIntersection value) {
    switch (value) {
    case RayQueryIntersectionRayQueryCandidateIntersectionKHR: return "RayQueryCandidateIntersectionKHR";
    case RayQueryIntersectionRayQueryCommittedIntersectionKHR: return "RayQueryCommittedIntersectionKHR";
    default: return "Unknown";
    }
}

inline const char* RayQueryCommittedIntersectionTypeToString(RayQueryCommittedIntersectionType value) {
    switch (value) {
    case RayQueryCommittedIntersectionTypeRayQueryCommittedIntersectionNoneKHR: return "RayQueryCommittedIntersectionNoneKHR";
    case RayQueryCommittedIntersectionTypeRayQueryCommittedIntersectionTriangleKHR: return "RayQueryCommittedIntersectionTriangleKHR";
    case RayQueryCommittedIntersectionTypeRayQueryCommittedIntersectionGeneratedKHR: return "RayQueryCommittedIntersectionGeneratedKHR";
    default: return "Unknown";
    }
}

inline const char* RayQueryCandidateIntersectionTypeToString(RayQueryCandidateIntersectionType value) {
    switch (value) {
    case RayQueryCandidateIntersectionTypeRayQueryCandidateIntersectionTriangleKHR: return "RayQueryCandidateIntersectionTriangleKHR";
    case RayQueryCandidateIntersectionTypeRayQueryCandidateIntersectionAABBKHR: return "RayQueryCandidateIntersectionAABBKHR";
    default: return "Unknown";
    }
}

inline const char* FPDenormModeToString(FPDenormMode value) {
    switch (value) {
    case FPDenormModePreserve: return "Preserve";
    case FPDenormModeFlushToZero: return "FlushToZero";
    default: return "Unknown";
    }
}

inline const char* FPOperationModeToString(FPOperationMode value) {
    switch (value) {
    case FPOperationModeIEEE: return "IEEE";
    case FPOperationModeALT: return "ALT";
    default: return "Unknown";
    }
}

inline const char* QuantizationModesToString(QuantizationModes value) {
    switch (value) {
    case QuantizationModesTRN: return "TRN";
    case QuantizationModesTRN_ZERO: return "TRN_ZERO";
    case QuantizationModesRND: return "RND";
    case QuantizationModesRND_ZERO: return "RND_ZERO";
    case QuantizationModesRND_INF: return "RND_INF";
    case QuantizationModesRND_MIN_INF: return "RND_MIN_INF";
    case QuantizationModesRND_CONV: return "RND_CONV";
    case QuantizationModesRND_CONV_ODD: return "RND_CONV_ODD";
    default: return "Unknown";
    }
}

inline const char* OverflowModesToString(OverflowModes value) {
    switch (value) {
    case OverflowModesWRAP: return "WRAP";
    case OverflowModesSAT: return "SAT";
    case OverflowModesSAT_ZERO: return "SAT_ZERO";
    case OverflowModesSAT_SYM: return "SAT_SYM";
    default: return "Unknown";
    }
}

inline const char* PackedVectorFormatToString(PackedVectorFormat value) {
    switch (value) {
    case PackedVectorFormatPackedVectorFormat4x8Bit: return "PackedVectorFormat4x8Bit";
    default: return "Unknown";
    }
}

inline const char* CooperativeMatrixLayoutToString(CooperativeMatrixLayout value) {
    switch (value) {
    case CooperativeMatrixLayoutRowMajorKHR: return "RowMajorKHR";
    case CooperativeMatrixLayoutColumnMajorKHR: return "ColumnMajorKHR";
    case CooperativeMatrixLayoutRowBlockedInterleavedARM: return "RowBlockedInterleavedARM";
    case CooperativeMatrixLayoutColumnBlockedInterleavedARM: return "ColumnBlockedInterleavedARM";
    default: return "Unknown";
    }
}

inline const char* CooperativeMatrixUseToString(CooperativeMatrixUse value) {
    switch (value) {
    case CooperativeMatrixUseMatrixAKHR: return "MatrixAKHR";
    case CooperativeMatrixUseMatrixBKHR: return "MatrixBKHR";
    case CooperativeMatrixUseMatrixAccumulatorKHR: return "MatrixAccumulatorKHR";
    default: return "Unknown";
    }
}

inline const char* InitializationModeQualifierToString(InitializationModeQualifier value) {
    switch (value) {
    case InitializationModeQualifierInitOnDeviceReprogramINTEL: return "InitOnDeviceReprogramINTEL";
    case InitializationModeQualifierInitOnDeviceResetINTEL: return "InitOnDeviceResetINTEL";
    default: return "Unknown";
    }
}

inline const char* HostAccessQualifierToString(HostAccessQualifier value) {
    switch (value) {
    case HostAccessQualifierNoneINTEL: return "NoneINTEL";
    case HostAccessQualifierReadINTEL: return "ReadINTEL";
    case HostAccessQualifierWriteINTEL: return "WriteINTEL";
    case HostAccessQualifierReadWriteINTEL: return "ReadWriteINTEL";
    default: return "Unknown";
    }
}

inline const char* LoadCacheControlToString(LoadCacheControl value) {
    switch (value) {
    case LoadCacheControlUncachedINTEL: return "UncachedINTEL";
    case LoadCacheControlCachedINTEL: return "CachedINTEL";
    case LoadCacheControlStreamingINTEL: return "StreamingINTEL";
    case LoadCacheControlInvalidateAfterReadINTEL: return "InvalidateAfterReadINTEL";
    case LoadCacheControlConstCachedINTEL: return "ConstCachedINTEL";
    default: return "Unknown";
    }
}

inline const char* StoreCacheControlToString(StoreCacheControl value) {
    switch (value) {
    case StoreCacheControlUncachedINTEL: return "UncachedINTEL";
    case StoreCacheControlWriteThroughINTEL: return "WriteThroughINTEL";
    case StoreCacheControlWriteBackINTEL: return "WriteBackINTEL";
    case StoreCacheControlStreamingINTEL: return "StreamingINTEL";
    default: return "Unknown";
    }
}

inline const char* NamedMaximumNumberOfRegistersToString(NamedMaximumNumberOfRegisters value) {
    switch (value) {
    case NamedMaximumNumberOfRegistersAutoINTEL: return "AutoINTEL";
    default: return "Unknown";
    }
}

inline const char* FPEncodingToString(FPEncoding value) {
    switch (value) {
    default: return "Unknown";
    }
}

inline const char* OpToString(Op value) {
    switch (value) {
    case OpNop: return "OpNop";
    case OpUndef: return "OpUndef";
    case OpSourceContinued: return "OpSourceContinued";
    case OpSource: return "OpSource";
    case OpSourceExtension: return "OpSourceExtension";
    case OpName: return "OpName";
    case OpMemberName: return "OpMemberName";
    case OpString: return "OpString";
    case OpLine: return "OpLine";
    case OpExtension: return "OpExtension";
    case OpExtInstImport: return "OpExtInstImport";
    case OpExtInst: return "OpExtInst";
    case OpMemoryModel: return "OpMemoryModel";
    case OpEntryPoint: return "OpEntryPoint";
    case OpExecutionMode: return "OpExecutionMode";
    case OpCapability: return "OpCapability";
    case OpTypeVoid: return "OpTypeVoid";
    case OpTypeBool: return "OpTypeBool";
    case OpTypeInt: return "OpTypeInt";
    case OpTypeFloat: return "OpTypeFloat";
    case OpTypeVector: return "OpTypeVector";
    case OpTypeMatrix: return "OpTypeMatrix";
    case OpTypeImage: return "OpTypeImage";
    case OpTypeSampler: return "OpTypeSampler";
    case OpTypeSampledImage: return "OpTypeSampledImage";
    case OpTypeArray: return "OpTypeArray";
    case OpTypeRuntimeArray: return "OpTypeRuntimeArray";
    case OpTypeStruct: return "OpTypeStruct";
    case OpTypeOpaque: return "OpTypeOpaque";
    case OpTypePointer: return "OpTypePointer";
    case OpTypeFunction: return "OpTypeFunction";
    case OpTypeEvent: return "OpTypeEvent";
    case OpTypeDeviceEvent: return "OpTypeDeviceEvent";
    case OpTypeReserveId: return "OpTypeReserveId";
    case OpTypeQueue: return "OpTypeQueue";
    case OpTypePipe: return "OpTypePipe";
    case OpTypeForwardPointer: return "OpTypeForwardPointer";
    case OpConstantTrue: return "OpConstantTrue";
    case OpConstantFalse: return "OpConstantFalse";
    case OpConstant: return "OpConstant";
    case OpConstantComposite: return "OpConstantComposite";
    case OpConstantSampler: return "OpConstantSampler";
    case OpConstantNull: return "OpConstantNull";
    case OpSpecConstantTrue: return "OpSpecConstantTrue";
    case OpSpecConstantFalse: return "OpSpecConstantFalse";
    case OpSpecConstant: return "OpSpecConstant";
    case OpSpecConstantComposite: return "OpSpecConstantComposite";
    case OpSpecConstantOp: return "OpSpecConstantOp";
    case OpFunction: return "OpFunction";
    case OpFunctionParameter: return "OpFunctionParameter";
    case OpFunctionEnd: return "OpFunctionEnd";
    case OpFunctionCall: return "OpFunctionCall";
    case OpVariable: return "OpVariable";
    case OpImageTexelPointer: return "OpImageTexelPointer";
    case OpLoad: return "OpLoad";
    case OpStore: return "OpStore";
    case OpCopyMemory: return "OpCopyMemory";
    case OpCopyMemorySized: return "OpCopyMemorySized";
    case OpAccessChain: return "OpAccessChain";
    case OpInBoundsAccessChain: return "OpInBoundsAccessChain";
    case OpPtrAccessChain: return "OpPtrAccessChain";
    case OpArrayLength: return "OpArrayLength";
    case OpGenericPtrMemSemantics: return "OpGenericPtrMemSemantics";
    case OpInBoundsPtrAccessChain: return "OpInBoundsPtrAccessChain";
    case OpDecorate: return "OpDecorate";
    case OpMemberDecorate: return "OpMemberDecorate";
    case OpDecorationGroup: return "OpDecorationGroup";
    case OpGroupDecorate: return "OpGroupDecorate";
    case OpGroupMemberDecorate: return "OpGroupMemberDecorate";
    case OpVectorExtractDynamic: return "OpVectorExtractDynamic";
    case OpVectorInsertDynamic: return "OpVectorInsertDynamic";
    case OpVectorShuffle: return "OpVectorShuffle";
    case OpCompositeConstruct: return "OpCompositeConstruct";
    case OpCompositeExtract: return "OpCompositeExtract";
    case OpCompositeInsert: return "OpCompositeInsert";
    case OpCopyObject: return "OpCopyObject";
    case OpTranspose: return "OpTranspose";
    case OpSampledImage: return "OpSampledImage";
    case OpImageSampleImplicitLod: return "OpImageSampleImplicitLod";
    case OpImageSampleExplicitLod: return "OpImageSampleExplicitLod";
    case OpImageSampleDrefImplicitLod: return "OpImageSampleDrefImplicitLod";
    case OpImageSampleDrefExplicitLod: return "OpImageSampleDrefExplicitLod";
    case OpImageSampleProjImplicitLod: return "OpImageSampleProjImplicitLod";
    case OpImageSampleProjExplicitLod: return "OpImageSampleProjExplicitLod";
    case OpImageSampleProjDrefImplicitLod: return "OpImageSampleProjDrefImplicitLod";
    case OpImageSampleProjDrefExplicitLod: return "OpImageSampleProjDrefExplicitLod";
    case OpImageFetch: return "OpImageFetch";
    case OpImageGather: return "OpImageGather";
    case OpImageDrefGather: return "OpImageDrefGather";
    case OpImageRead: return "OpImageRead";
    case OpImageWrite: return "OpImageWrite";
    case OpImage: return "OpImage";
    case OpImageQueryFormat: return "OpImageQueryFormat";
    case OpImageQueryOrder: return "OpImageQueryOrder";
    case OpImageQuerySizeLod: return "OpImageQuerySizeLod";
    case OpImageQuerySize: return "OpImageQuerySize";
    case OpImageQueryLod: return "OpImageQueryLod";
    case OpImageQueryLevels: return "OpImageQueryLevels";
    case OpImageQuerySamples: return "OpImageQuerySamples";
    case OpConvertFToU: return "OpConvertFToU";
    case OpConvertFToS: return "OpConvertFToS";
    case OpConvertSToF: return "OpConvertSToF";
    case OpConvertUToF: return "OpConvertUToF";
    case OpUConvert: return "OpUConvert";
    case OpSConvert: return "OpSConvert";
    case OpFConvert: return "OpFConvert";
    case OpQuantizeToF16: return "OpQuantizeToF16";
    case OpConvertPtrToU: return "OpConvertPtrToU";
    case OpSatConvertSToU: return "OpSatConvertSToU";
    case OpSatConvertUToS: return "OpSatConvertUToS";
    case OpConvertUToPtr: return "OpConvertUToPtr";
    case OpPtrCastToGeneric: return "OpPtrCastToGeneric";
    case OpGenericCastToPtr: return "OpGenericCastToPtr";
    case OpGenericCastToPtrExplicit: return "OpGenericCastToPtrExplicit";
    case OpBitcast: return "OpBitcast";
    case OpSNegate: return "OpSNegate";
    case OpFNegate: return "OpFNegate";
    case OpIAdd: return "OpIAdd";
    case OpFAdd: return "OpFAdd";
    case OpISub: return "OpISub";
    case OpFSub: return "OpFSub";
    case OpIMul: return "OpIMul";
    case OpFMul: return "OpFMul";
    case OpUDiv: return "OpUDiv";
    case OpSDiv: return "OpSDiv";
    case OpFDiv: return "OpFDiv";
    case OpUMod: return "OpUMod";
    case OpSRem: return "OpSRem";
    case OpSMod: return "OpSMod";
    case OpFRem: return "OpFRem";
    case OpFMod: return "OpFMod";
    case OpVectorTimesScalar: return "OpVectorTimesScalar";
    case OpMatrixTimesScalar: return "OpMatrixTimesScalar";
    case OpVectorTimesMatrix: return "OpVectorTimesMatrix";
    case OpMatrixTimesVector: return "OpMatrixTimesVector";
    case OpMatrixTimesMatrix: return "OpMatrixTimesMatrix";
    case OpOuterProduct: return "OpOuterProduct";
    case OpDot: return "OpDot";
    case OpIAddCarry: return "OpIAddCarry";
    case OpISubBorrow: return "OpISubBorrow";
    case OpUMulExtended: return "OpUMulExtended";
    case OpSMulExtended: return "OpSMulExtended";
    case OpAny: return "OpAny";
    case OpAll: return "OpAll";
    case OpIsNan: return "OpIsNan";
    case OpIsInf: return "OpIsInf";
    case OpIsFinite: return "OpIsFinite";
    case OpIsNormal: return "OpIsNormal";
    case OpSignBitSet: return "OpSignBitSet";
    case OpLessOrGreater: return "OpLessOrGreater";
    case OpOrdered: return "OpOrdered";
    case OpUnordered: return "OpUnordered";
    case OpLogicalEqual: return "OpLogicalEqual";
    case OpLogicalNotEqual: return "OpLogicalNotEqual";
    case OpLogicalOr: return "OpLogicalOr";
    case OpLogicalAnd: return "OpLogicalAnd";
    case OpLogicalNot: return "OpLogicalNot";
    case OpSelect: return "OpSelect";
    case OpIEqual: return "OpIEqual";
    case OpINotEqual: return "OpINotEqual";
    case OpUGreaterThan: return "OpUGreaterThan";
    case OpSGreaterThan: return "OpSGreaterThan";
    case OpUGreaterThanEqual: return "OpUGreaterThanEqual";
    case OpSGreaterThanEqual: return "OpSGreaterThanEqual";
    case OpULessThan: return "OpULessThan";
    case OpSLessThan: return "OpSLessThan";
    case OpULessThanEqual: return "OpULessThanEqual";
    case OpSLessThanEqual: return "OpSLessThanEqual";
    case OpFOrdEqual: return "OpFOrdEqual";
    case OpFUnordEqual: return "OpFUnordEqual";
    case OpFOrdNotEqual: return "OpFOrdNotEqual";
    case OpFUnordNotEqual: return "OpFUnordNotEqual";
    case OpFOrdLessThan: return "OpFOrdLessThan";
    case OpFUnordLessThan: return "OpFUnordLessThan";
    case OpFOrdGreaterThan: return "OpFOrdGreaterThan";
    case OpFUnordGreaterThan: return "OpFUnordGreaterThan";
    case OpFOrdLessThanEqual: return "OpFOrdLessThanEqual";
    case OpFUnordLessThanEqual: return "OpFUnordLessThanEqual";
    case OpFOrdGreaterThanEqual: return "OpFOrdGreaterThanEqual";
    case OpFUnordGreaterThanEqual: return "OpFUnordGreaterThanEqual";
    case OpShiftRightLogical: return "OpShiftRightLogical";
    case OpShiftRightArithmetic: return "OpShiftRightArithmetic";
    case OpShiftLeftLogical: return "OpShiftLeftLogical";
    case OpBitwiseOr: return "OpBitwiseOr";
    case OpBitwiseXor: return "OpBitwiseXor";
    case OpBitwiseAnd: return "OpBitwiseAnd";
    case OpNot: return "OpNot";
    case OpBitFieldInsert: return "OpBitFieldInsert";
    case OpBitFieldSExtract: return "OpBitFieldSExtract";
    case OpBitFieldUExtract: return "OpBitFieldUExtract";
    case OpBitReverse: return "OpBitReverse";
    case OpBitCount: return "OpBitCount";
    case OpDPdx: return "OpDPdx";
    case OpDPdy: return "OpDPdy";
    case OpFwidth: return "OpFwidth";
    case OpDPdxFine: return "OpDPdxFine";
    case OpDPdyFine: return "OpDPdyFine";
    case OpFwidthFine: return "OpFwidthFine";
    case OpDPdxCoarse: return "OpDPdxCoarse";
    case OpDPdyCoarse: return "OpDPdyCoarse";
    case OpFwidthCoarse: return "OpFwidthCoarse";
    case OpEmitVertex: return "OpEmitVertex";
    case OpEndPrimitive: return "OpEndPrimitive";
    case OpEmitStreamVertex: return "OpEmitStreamVertex";
    case OpEndStreamPrimitive: return "OpEndStreamPrimitive";
    case OpControlBarrier: return "OpControlBarrier";
    case OpMemoryBarrier: return "OpMemoryBarrier";
    case OpAtomicLoad: return "OpAtomicLoad";
    case OpAtomicStore: return "OpAtomicStore";
    case OpAtomicExchange: return "OpAtomicExchange";
    case OpAtomicCompareExchange: return "OpAtomicCompareExchange";
    case OpAtomicCompareExchangeWeak: return "OpAtomicCompareExchangeWeak";
    case OpAtomicIIncrement: return "OpAtomicIIncrement";
    case OpAtomicIDecrement: return "OpAtomicIDecrement";
    case OpAtomicIAdd: return "OpAtomicIAdd";
    case OpAtomicISub: return "OpAtomicISub";
    case OpAtomicSMin: return "OpAtomicSMin";
    case OpAtomicUMin: return "OpAtomicUMin";
    case OpAtomicSMax: return "OpAtomicSMax";
    case OpAtomicUMax: return "OpAtomicUMax";
    case OpAtomicAnd: return "OpAtomicAnd";
    case OpAtomicOr: return "OpAtomicOr";
    case OpAtomicXor: return "OpAtomicXor";
    case OpPhi: return "OpPhi";
    case OpLoopMerge: return "OpLoopMerge";
    case OpSelectionMerge: return "OpSelectionMerge";
    case OpLabel: return "OpLabel";
    case OpBranch: return "OpBranch";
    case OpBranchConditional: return "OpBranchConditional";
    case OpSwitch: return "OpSwitch";
    case OpKill: return "OpKill";
    case OpReturn: return "OpReturn";
    case OpReturnValue: return "OpReturnValue";
    case OpUnreachable: return "OpUnreachable";
    case OpLifetimeStart: return "OpLifetimeStart";
    case OpLifetimeStop: return "OpLifetimeStop";
    case OpGroupAsyncCopy: return "OpGroupAsyncCopy";
    case OpGroupWaitEvents: return "OpGroupWaitEvents";
    case OpGroupAll: return "OpGroupAll";
    case OpGroupAny: return "OpGroupAny";
    case OpGroupBroadcast: return "OpGroupBroadcast";
    case OpGroupIAdd: return "OpGroupIAdd";
    case OpGroupFAdd: return "OpGroupFAdd";
    case OpGroupFMin: return "OpGroupFMin";
    case OpGroupUMin: return "OpGroupUMin";
    case OpGroupSMin: return "OpGroupSMin";
    case OpGroupFMax: return "OpGroupFMax";
    case OpGroupUMax: return "OpGroupUMax";
    case OpGroupSMax: return "OpGroupSMax";
    case OpReadPipe: return "OpReadPipe";
    case OpWritePipe: return "OpWritePipe";
    case OpReservedReadPipe: return "OpReservedReadPipe";
    case OpReservedWritePipe: return "OpReservedWritePipe";
    case OpReserveReadPipePackets: return "OpReserveReadPipePackets";
    case OpReserveWritePipePackets: return "OpReserveWritePipePackets";
    case OpCommitReadPipe: return "OpCommitReadPipe";
    case OpCommitWritePipe: return "OpCommitWritePipe";
    case OpIsValidReserveId: return "OpIsValidReserveId";
    case OpGetNumPipePackets: return "OpGetNumPipePackets";
    case OpGetMaxPipePackets: return "OpGetMaxPipePackets";
    case OpGroupReserveReadPipePackets: return "OpGroupReserveReadPipePackets";
    case OpGroupReserveWritePipePackets: return "OpGroupReserveWritePipePackets";
    case OpGroupCommitReadPipe: return "OpGroupCommitReadPipe";
    case OpGroupCommitWritePipe: return "OpGroupCommitWritePipe";
    case OpEnqueueMarker: return "OpEnqueueMarker";
    case OpEnqueueKernel: return "OpEnqueueKernel";
    case OpGetKernelNDrangeSubGroupCount: return "OpGetKernelNDrangeSubGroupCount";
    case OpGetKernelNDrangeMaxSubGroupSize: return "OpGetKernelNDrangeMaxSubGroupSize";
    case OpGetKernelWorkGroupSize: return "OpGetKernelWorkGroupSize";
    case OpGetKernelPreferredWorkGroupSizeMultiple: return "OpGetKernelPreferredWorkGroupSizeMultiple";
    case OpRetainEvent: return "OpRetainEvent";
    case OpReleaseEvent: return "OpReleaseEvent";
    case OpCreateUserEvent: return "OpCreateUserEvent";
    case OpIsValidEvent: return "OpIsValidEvent";
    case OpSetUserEventStatus: return "OpSetUserEventStatus";
    case OpCaptureEventProfilingInfo: return "OpCaptureEventProfilingInfo";
    case OpGetDefaultQueue: return "OpGetDefaultQueue";
    case OpBuildNDRange: return "OpBuildNDRange";
    case OpImageSparseSampleImplicitLod: return "OpImageSparseSampleImplicitLod";
    case OpImageSparseSampleExplicitLod: return "OpImageSparseSampleExplicitLod";
    case OpImageSparseSampleDrefImplicitLod: return "OpImageSparseSampleDrefImplicitLod";
    case OpImageSparseSampleDrefExplicitLod: return "OpImageSparseSampleDrefExplicitLod";
    case OpImageSparseSampleProjImplicitLod: return "OpImageSparseSampleProjImplicitLod";
    case OpImageSparseSampleProjExplicitLod: return "OpImageSparseSampleProjExplicitLod";
    case OpImageSparseSampleProjDrefImplicitLod: return "OpImageSparseSampleProjDrefImplicitLod";
    case OpImageSparseSampleProjDrefExplicitLod: return "OpImageSparseSampleProjDrefExplicitLod";
    case OpImageSparseFetch: return "OpImageSparseFetch";
    case OpImageSparseGather: return "OpImageSparseGather";
    case OpImageSparseDrefGather: return "OpImageSparseDrefGather";
    case OpImageSparseTexelsResident: return "OpImageSparseTexelsResident";
    case OpNoLine: return "OpNoLine";
    case OpAtomicFlagTestAndSet: return "OpAtomicFlagTestAndSet";
    case OpAtomicFlagClear: return "OpAtomicFlagClear";
    case OpImageSparseRead: return "OpImageSparseRead";
    case OpSizeOf: return "OpSizeOf";
    case OpTypePipeStorage: return "OpTypePipeStorage";
    case OpConstantPipeStorage: return "OpConstantPipeStorage";
    case OpCreatePipeFromPipeStorage: return "OpCreatePipeFromPipeStorage";
    case OpGetKernelLocalSizeForSubgroupCount: return "OpGetKernelLocalSizeForSubgroupCount";
    case OpGetKernelMaxNumSubgroups: return "OpGetKernelMaxNumSubgroups";
    case OpTypeNamedBarrier: return "OpTypeNamedBarrier";
    case OpNamedBarrierInitialize: return "OpNamedBarrierInitialize";
    case OpMemoryNamedBarrier: return "OpMemoryNamedBarrier";
    case OpModuleProcessed: return "OpModuleProcessed";
    case OpExecutionModeId: return "OpExecutionModeId";
    case OpDecorateId: return "OpDecorateId";
    case OpGroupNonUniformElect: return "OpGroupNonUniformElect";
    case OpGroupNonUniformAll: return "OpGroupNonUniformAll";
    case OpGroupNonUniformAny: return "OpGroupNonUniformAny";
    case OpGroupNonUniformAllEqual: return "OpGroupNonUniformAllEqual";
    case OpGroupNonUniformBroadcast: return "OpGroupNonUniformBroadcast";
    case OpGroupNonUniformBroadcastFirst: return "OpGroupNonUniformBroadcastFirst";
    case OpGroupNonUniformBallot: return "OpGroupNonUniformBallot";
    case OpGroupNonUniformInverseBallot: return "OpGroupNonUniformInverseBallot";
    case OpGroupNonUniformBallotBitExtract: return "OpGroupNonUniformBallotBitExtract";
    case OpGroupNonUniformBallotBitCount: return "OpGroupNonUniformBallotBitCount";
    case OpGroupNonUniformBallotFindLSB: return "OpGroupNonUniformBallotFindLSB";
    case OpGroupNonUniformBallotFindMSB: return "OpGroupNonUniformBallotFindMSB";
    case OpGroupNonUniformShuffle: return "OpGroupNonUniformShuffle";
    case OpGroupNonUniformShuffleXor: return "OpGroupNonUniformShuffleXor";
    case OpGroupNonUniformShuffleUp: return "OpGroupNonUniformShuffleUp";
    case OpGroupNonUniformShuffleDown: return "OpGroupNonUniformShuffleDown";
    case OpGroupNonUniformIAdd: return "OpGroupNonUniformIAdd";
    case OpGroupNonUniformFAdd: return "OpGroupNonUniformFAdd";
    case OpGroupNonUniformIMul: return "OpGroupNonUniformIMul";
    case OpGroupNonUniformFMul: return "OpGroupNonUniformFMul";
    case OpGroupNonUniformSMin: return "OpGroupNonUniformSMin";
    case OpGroupNonUniformUMin: return "OpGroupNonUniformUMin";
    case OpGroupNonUniformFMin: return "OpGroupNonUniformFMin";
    case OpGroupNonUniformSMax: return "OpGroupNonUniformSMax";
    case OpGroupNonUniformUMax: return "OpGroupNonUniformUMax";
    case OpGroupNonUniformFMax: return "OpGroupNonUniformFMax";
    case OpGroupNonUniformBitwiseAnd: return "OpGroupNonUniformBitwiseAnd";
    case OpGroupNonUniformBitwiseOr: return "OpGroupNonUniformBitwiseOr";
    case OpGroupNonUniformBitwiseXor: return "OpGroupNonUniformBitwiseXor";
    case OpGroupNonUniformLogicalAnd: return "OpGroupNonUniformLogicalAnd";
    case OpGroupNonUniformLogicalOr: return "OpGroupNonUniformLogicalOr";
    case OpGroupNonUniformLogicalXor: return "OpGroupNonUniformLogicalXor";
    case OpGroupNonUniformQuadBroadcast: return "OpGroupNonUniformQuadBroadcast";
    case OpGroupNonUniformQuadSwap: return "OpGroupNonUniformQuadSwap";
    case OpCopyLogical: return "OpCopyLogical";
    case OpPtrEqual: return "OpPtrEqual";
    case OpPtrNotEqual: return "OpPtrNotEqual";
    case OpPtrDiff: return "OpPtrDiff";
    case OpColorAttachmentReadEXT: return "OpColorAttachmentReadEXT";
    case OpDepthAttachmentReadEXT: return "OpDepthAttachmentReadEXT";
    case OpStencilAttachmentReadEXT: return "OpStencilAttachmentReadEXT";
    case OpTerminateInvocation: return "OpTerminateInvocation";
    case OpSubgroupBallotKHR: return "OpSubgroupBallotKHR";
    case OpSubgroupFirstInvocationKHR: return "OpSubgroupFirstInvocationKHR";
    case OpSubgroupAllKHR: return "OpSubgroupAllKHR";
    case OpSubgroupAnyKHR: return "OpSubgroupAnyKHR";
    case OpSubgroupAllEqualKHR: return "OpSubgroupAllEqualKHR";
    case OpGroupNonUniformRotateKHR: return "OpGroupNonUniformRotateKHR";
    case OpSubgroupReadInvocationKHR: return "OpSubgroupReadInvocationKHR";
    case OpExtInstWithForwardRefsKHR: return "OpExtInstWithForwardRefsKHR";
    case OpTraceRayKHR: return "OpTraceRayKHR";
    case OpExecuteCallableKHR: return "OpExecuteCallableKHR";
    case OpConvertUToAccelerationStructureKHR: return "OpConvertUToAccelerationStructureKHR";
    case OpIgnoreIntersectionKHR: return "OpIgnoreIntersectionKHR";
    case OpTerminateRayKHR: return "OpTerminateRayKHR";
    case OpSDot: return "OpSDot";
    case OpUDot: return "OpUDot";
    case OpSUDot: return "OpSUDot";
    case OpSDotAccSat: return "OpSDotAccSat";
    case OpUDotAccSat: return "OpUDotAccSat";
    case OpSUDotAccSat: return "OpSUDotAccSat";
    case OpTypeCooperativeMatrixKHR: return "OpTypeCooperativeMatrixKHR";
    case OpCooperativeMatrixLoadKHR: return "OpCooperativeMatrixLoadKHR";
    case OpCooperativeMatrixStoreKHR: return "OpCooperativeMatrixStoreKHR";
    case OpCooperativeMatrixMulAddKHR: return "OpCooperativeMatrixMulAddKHR";
    case OpCooperativeMatrixLengthKHR: return "OpCooperativeMatrixLengthKHR";
    case OpConstantCompositeReplicateEXT: return "OpConstantCompositeReplicateEXT";
    case OpSpecConstantCompositeReplicateEXT: return "OpSpecConstantCompositeReplicateEXT";
    case OpCompositeConstructReplicateEXT: return "OpCompositeConstructReplicateEXT";
    case OpTypeRayQueryKHR: return "OpTypeRayQueryKHR";
    case OpRayQueryInitializeKHR: return "OpRayQueryInitializeKHR";
    case OpRayQueryTerminateKHR: return "OpRayQueryTerminateKHR";
    case OpRayQueryGenerateIntersectionKHR: return "OpRayQueryGenerateIntersectionKHR";
    case OpRayQueryConfirmIntersectionKHR: return "OpRayQueryConfirmIntersectionKHR";
    case OpRayQueryProceedKHR: return "OpRayQueryProceedKHR";
    case OpRayQueryGetIntersectionTypeKHR: return "OpRayQueryGetIntersectionTypeKHR";
    case OpImageSampleWeightedQCOM: return "OpImageSampleWeightedQCOM";
    case OpImageBoxFilterQCOM: return "OpImageBoxFilterQCOM";
    case OpImageBlockMatchSSDQCOM: return "OpImageBlockMatchSSDQCOM";
    case OpImageBlockMatchSADQCOM: return "OpImageBlockMatchSADQCOM";
    case OpImageBlockMatchWindowSSDQCOM: return "OpImageBlockMatchWindowSSDQCOM";
    case OpImageBlockMatchWindowSADQCOM: return "OpImageBlockMatchWindowSADQCOM";
    case OpImageBlockMatchGatherSSDQCOM: return "OpImageBlockMatchGatherSSDQCOM";
    case OpImageBlockMatchGatherSADQCOM: return "OpImageBlockMatchGatherSADQCOM";
    case OpGroupIAddNonUniformAMD: return "OpGroupIAddNonUniformAMD";
    case OpGroupFAddNonUniformAMD: return "OpGroupFAddNonUniformAMD";
    case OpGroupFMinNonUniformAMD: return "OpGroupFMinNonUniformAMD";
    case OpGroupUMinNonUniformAMD: return "OpGroupUMinNonUniformAMD";
    case OpGroupSMinNonUniformAMD: return "OpGroupSMinNonUniformAMD";
    case OpGroupFMaxNonUniformAMD: return "OpGroupFMaxNonUniformAMD";
    case OpGroupUMaxNonUniformAMD: return "OpGroupUMaxNonUniformAMD";
    case OpGroupSMaxNonUniformAMD: return "OpGroupSMaxNonUniformAMD";
    case OpFragmentMaskFetchAMD: return "OpFragmentMaskFetchAMD";
    case OpFragmentFetchAMD: return "OpFragmentFetchAMD";
    case OpReadClockKHR: return "OpReadClockKHR";
    case OpFinalizeNodePayloadsAMDX: return "OpFinalizeNodePayloadsAMDX";
    case OpFinishWritingNodePayloadAMDX: return "OpFinishWritingNodePayloadAMDX";
    case OpInitializeNodePayloadsAMDX: return "OpInitializeNodePayloadsAMDX";
    case OpGroupNonUniformQuadAllKHR: return "OpGroupNonUniformQuadAllKHR";
    case OpGroupNonUniformQuadAnyKHR: return "OpGroupNonUniformQuadAnyKHR";
    case OpHitObjectRecordHitMotionNV: return "OpHitObjectRecordHitMotionNV";
    case OpHitObjectRecordHitWithIndexMotionNV: return "OpHitObjectRecordHitWithIndexMotionNV";
    case OpHitObjectRecordMissMotionNV: return "OpHitObjectRecordMissMotionNV";
    case OpHitObjectGetWorldToObjectNV: return "OpHitObjectGetWorldToObjectNV";
    case OpHitObjectGetObjectToWorldNV: return "OpHitObjectGetObjectToWorldNV";
    case OpHitObjectGetObjectRayDirectionNV: return "OpHitObjectGetObjectRayDirectionNV";
    case OpHitObjectGetObjectRayOriginNV: return "OpHitObjectGetObjectRayOriginNV";
    case OpHitObjectTraceRayMotionNV: return "OpHitObjectTraceRayMotionNV";
    case OpHitObjectGetShaderRecordBufferHandleNV: return "OpHitObjectGetShaderRecordBufferHandleNV";
    case OpHitObjectGetShaderBindingTableRecordIndexNV: return "OpHitObjectGetShaderBindingTableRecordIndexNV";
    case OpHitObjectRecordEmptyNV: return "OpHitObjectRecordEmptyNV";
    case OpHitObjectTraceRayNV: return "OpHitObjectTraceRayNV";
    case OpHitObjectRecordHitNV: return "OpHitObjectRecordHitNV";
    case OpHitObjectRecordHitWithIndexNV: return "OpHitObjectRecordHitWithIndexNV";
    case OpHitObjectRecordMissNV: return "OpHitObjectRecordMissNV";
    case OpHitObjectExecuteShaderNV: return "OpHitObjectExecuteShaderNV";
    case OpHitObjectGetCurrentTimeNV: return "OpHitObjectGetCurrentTimeNV";
    case OpHitObjectGetAttributesNV: return "OpHitObjectGetAttributesNV";
    case OpHitObjectGetHitKindNV: return "OpHitObjectGetHitKindNV";
    case OpHitObjectGetPrimitiveIndexNV: return "OpHitObjectGetPrimitiveIndexNV";
    case OpHitObjectGetGeometryIndexNV: return "OpHitObjectGetGeometryIndexNV";
    case OpHitObjectGetInstanceIdNV: return "OpHitObjectGetInstanceIdNV";
    case OpHitObjectGetInstanceCustomIndexNV: return "OpHitObjectGetInstanceCustomIndexNV";
    case OpHitObjectGetWorldRayDirectionNV: return "OpHitObjectGetWorldRayDirectionNV";
    case OpHitObjectGetWorldRayOriginNV: return "OpHitObjectGetWorldRayOriginNV";
    case OpHitObjectGetRayTMaxNV: return "OpHitObjectGetRayTMaxNV";
    case OpHitObjectGetRayTMinNV: return "OpHitObjectGetRayTMinNV";
    case OpHitObjectIsEmptyNV: return "OpHitObjectIsEmptyNV";
    case OpHitObjectIsHitNV: return "OpHitObjectIsHitNV";
    case OpHitObjectIsMissNV: return "OpHitObjectIsMissNV";
    case OpReorderThreadWithHitObjectNV: return "OpReorderThreadWithHitObjectNV";
    case OpReorderThreadWithHintNV: return "OpReorderThreadWithHintNV";
    case OpTypeHitObjectNV: return "OpTypeHitObjectNV";
    case OpImageSampleFootprintNV: return "OpImageSampleFootprintNV";
    case OpEmitMeshTasksEXT: return "OpEmitMeshTasksEXT";
    case OpSetMeshOutputsEXT: return "OpSetMeshOutputsEXT";
    case OpGroupNonUniformPartitionNV: return "OpGroupNonUniformPartitionNV";
    case OpWritePackedPrimitiveIndices4x8NV: return "OpWritePackedPrimitiveIndices4x8NV";
    case OpFetchMicroTriangleVertexPositionNV: return "OpFetchMicroTriangleVertexPositionNV";
    case OpFetchMicroTriangleVertexBarycentricNV: return "OpFetchMicroTriangleVertexBarycentricNV";
    case OpReportIntersectionKHR: return "OpReportIntersectionKHR";
    case OpIgnoreIntersectionNV: return "OpIgnoreIntersectionNV";
    case OpTerminateRayNV: return "OpTerminateRayNV";
    case OpTraceNV: return "OpTraceNV";
    case OpTraceMotionNV: return "OpTraceMotionNV";
    case OpTraceRayMotionNV: return "OpTraceRayMotionNV";
    case OpRayQueryGetIntersectionTriangleVertexPositionsKHR: return "OpRayQueryGetIntersectionTriangleVertexPositionsKHR";
    case OpTypeAccelerationStructureKHR: return "OpTypeAccelerationStructureKHR";
    case OpExecuteCallableNV: return "OpExecuteCallableNV";
    case OpTypeCooperativeMatrixNV: return "OpTypeCooperativeMatrixNV";
    case OpCooperativeMatrixLoadNV: return "OpCooperativeMatrixLoadNV";
    case OpCooperativeMatrixStoreNV: return "OpCooperativeMatrixStoreNV";
    case OpCooperativeMatrixMulAddNV: return "OpCooperativeMatrixMulAddNV";
    case OpCooperativeMatrixLengthNV: return "OpCooperativeMatrixLengthNV";
    case OpBeginInvocationInterlockEXT: return "OpBeginInvocationInterlockEXT";
    case OpEndInvocationInterlockEXT: return "OpEndInvocationInterlockEXT";
    case OpDemoteToHelperInvocation: return "OpDemoteToHelperInvocation";
    case OpIsHelperInvocationEXT: return "OpIsHelperInvocationEXT";
    case OpConvertUToImageNV: return "OpConvertUToImageNV";
    case OpConvertUToSamplerNV: return "OpConvertUToSamplerNV";
    case OpConvertImageToUNV: return "OpConvertImageToUNV";
    case OpConvertSamplerToUNV: return "OpConvertSamplerToUNV";
    case OpConvertUToSampledImageNV: return "OpConvertUToSampledImageNV";
    case OpConvertSampledImageToUNV: return "OpConvertSampledImageToUNV";
    case OpSamplerImageAddressingModeNV: return "OpSamplerImageAddressingModeNV";
    case OpRawAccessChainNV: return "OpRawAccessChainNV";
    case OpSubgroupShuffleINTEL: return "OpSubgroupShuffleINTEL";
    case OpSubgroupShuffleDownINTEL: return "OpSubgroupShuffleDownINTEL";
    case OpSubgroupShuffleUpINTEL: return "OpSubgroupShuffleUpINTEL";
    case OpSubgroupShuffleXorINTEL: return "OpSubgroupShuffleXorINTEL";
    case OpSubgroupBlockReadINTEL: return "OpSubgroupBlockReadINTEL";
    case OpSubgroupBlockWriteINTEL: return "OpSubgroupBlockWriteINTEL";
    case OpSubgroupImageBlockReadINTEL: return "OpSubgroupImageBlockReadINTEL";
    case OpSubgroupImageBlockWriteINTEL: return "OpSubgroupImageBlockWriteINTEL";
    case OpSubgroupImageMediaBlockReadINTEL: return "OpSubgroupImageMediaBlockReadINTEL";
    case OpSubgroupImageMediaBlockWriteINTEL: return "OpSubgroupImageMediaBlockWriteINTEL";
    case OpUCountLeadingZerosINTEL: return "OpUCountLeadingZerosINTEL";
    case OpUCountTrailingZerosINTEL: return "OpUCountTrailingZerosINTEL";
    case OpAbsISubINTEL: return "OpAbsISubINTEL";
    case OpAbsUSubINTEL: return "OpAbsUSubINTEL";
    case OpIAddSatINTEL: return "OpIAddSatINTEL";
    case OpUAddSatINTEL: return "OpUAddSatINTEL";
    case OpIAverageINTEL: return "OpIAverageINTEL";
    case OpUAverageINTEL: return "OpUAverageINTEL";
    case OpIAverageRoundedINTEL: return "OpIAverageRoundedINTEL";
    case OpUAverageRoundedINTEL: return "OpUAverageRoundedINTEL";
    case OpISubSatINTEL: return "OpISubSatINTEL";
    case OpUSubSatINTEL: return "OpUSubSatINTEL";
    case OpIMul32x16INTEL: return "OpIMul32x16INTEL";
    case OpUMul32x16INTEL: return "OpUMul32x16INTEL";
    case OpConstantFunctionPointerINTEL: return "OpConstantFunctionPointerINTEL";
    case OpFunctionPointerCallINTEL: return "OpFunctionPointerCallINTEL";
    case OpAsmTargetINTEL: return "OpAsmTargetINTEL";
    case OpAsmINTEL: return "OpAsmINTEL";
    case OpAsmCallINTEL: return "OpAsmCallINTEL";
    case OpAtomicFMinEXT: return "OpAtomicFMinEXT";
    case OpAtomicFMaxEXT: return "OpAtomicFMaxEXT";
    case OpAssumeTrueKHR: return "OpAssumeTrueKHR";
    case OpExpectKHR: return "OpExpectKHR";
    case OpDecorateString: return "OpDecorateString";
    case OpMemberDecorateString: return "OpMemberDecorateString";
    case OpVmeImageINTEL: return "OpVmeImageINTEL";
    case OpTypeVmeImageINTEL: return "OpTypeVmeImageINTEL";
    case OpTypeAvcImePayloadINTEL: return "OpTypeAvcImePayloadINTEL";
    case OpTypeAvcRefPayloadINTEL: return "OpTypeAvcRefPayloadINTEL";
    case OpTypeAvcSicPayloadINTEL: return "OpTypeAvcSicPayloadINTEL";
    case OpTypeAvcMcePayloadINTEL: return "OpTypeAvcMcePayloadINTEL";
    case OpTypeAvcMceResultINTEL: return "OpTypeAvcMceResultINTEL";
    case OpTypeAvcImeResultINTEL: return "OpTypeAvcImeResultINTEL";
    case OpTypeAvcImeResultSingleReferenceStreamoutINTEL: return "OpTypeAvcImeResultSingleReferenceStreamoutINTEL";
    case OpTypeAvcImeResultDualReferenceStreamoutINTEL: return "OpTypeAvcImeResultDualReferenceStreamoutINTEL";
    case OpTypeAvcImeSingleReferenceStreaminINTEL: return "OpTypeAvcImeSingleReferenceStreaminINTEL";
    case OpTypeAvcImeDualReferenceStreaminINTEL: return "OpTypeAvcImeDualReferenceStreaminINTEL";
    case OpTypeAvcRefResultINTEL: return "OpTypeAvcRefResultINTEL";
    case OpTypeAvcSicResultINTEL: return "OpTypeAvcSicResultINTEL";
    case OpSubgroupAvcMceGetDefaultInterBaseMultiReferencePenaltyINTEL: return "OpSubgroupAvcMceGetDefaultInterBaseMultiReferencePenaltyINTEL";
    case OpSubgroupAvcMceSetInterBaseMultiReferencePenaltyINTEL: return "OpSubgroupAvcMceSetInterBaseMultiReferencePenaltyINTEL";
    case OpSubgroupAvcMceGetDefaultInterShapePenaltyINTEL: return "OpSubgroupAvcMceGetDefaultInterShapePenaltyINTEL";
    case OpSubgroupAvcMceSetInterShapePenaltyINTEL: return "OpSubgroupAvcMceSetInterShapePenaltyINTEL";
    case OpSubgroupAvcMceGetDefaultInterDirectionPenaltyINTEL: return "OpSubgroupAvcMceGetDefaultInterDirectionPenaltyINTEL";
    case OpSubgroupAvcMceSetInterDirectionPenaltyINTEL: return "OpSubgroupAvcMceSetInterDirectionPenaltyINTEL";
    case OpSubgroupAvcMceGetDefaultIntraLumaShapePenaltyINTEL: return "OpSubgroupAvcMceGetDefaultIntraLumaShapePenaltyINTEL";
    case OpSubgroupAvcMceGetDefaultInterMotionVectorCostTableINTEL: return "OpSubgroupAvcMceGetDefaultInterMotionVectorCostTableINTEL";
    case OpSubgroupAvcMceGetDefaultHighPenaltyCostTableINTEL: return "OpSubgroupAvcMceGetDefaultHighPenaltyCostTableINTEL";
    case OpSubgroupAvcMceGetDefaultMediumPenaltyCostTableINTEL: return "OpSubgroupAvcMceGetDefaultMediumPenaltyCostTableINTEL";
    case OpSubgroupAvcMceGetDefaultLowPenaltyCostTableINTEL: return "OpSubgroupAvcMceGetDefaultLowPenaltyCostTableINTEL";
    case OpSubgroupAvcMceSetMotionVectorCostFunctionINTEL: return "OpSubgroupAvcMceSetMotionVectorCostFunctionINTEL";
    case OpSubgroupAvcMceGetDefaultIntraLumaModePenaltyINTEL: return "OpSubgroupAvcMceGetDefaultIntraLumaModePenaltyINTEL";
    case OpSubgroupAvcMceGetDefaultNonDcLumaIntraPenaltyINTEL: return "OpSubgroupAvcMceGetDefaultNonDcLumaIntraPenaltyINTEL";
    case OpSubgroupAvcMceGetDefaultIntraChromaModeBasePenaltyINTEL: return "OpSubgroupAvcMceGetDefaultIntraChromaModeBasePenaltyINTEL";
    case OpSubgroupAvcMceSetAcOnlyHaarINTEL: return "OpSubgroupAvcMceSetAcOnlyHaarINTEL";
    case OpSubgroupAvcMceSetSourceInterlacedFieldPolarityINTEL: return "OpSubgroupAvcMceSetSourceInterlacedFieldPolarityINTEL";
    case OpSubgroupAvcMceSetSingleReferenceInterlacedFieldPolarityINTEL: return "OpSubgroupAvcMceSetSingleReferenceInterlacedFieldPolarityINTEL";
    case OpSubgroupAvcMceSetDualReferenceInterlacedFieldPolaritiesINTEL: return "OpSubgroupAvcMceSetDualReferenceInterlacedFieldPolaritiesINTEL";
    case OpSubgroupAvcMceConvertToImePayloadINTEL: return "OpSubgroupAvcMceConvertToImePayloadINTEL";
    case OpSubgroupAvcMceConvertToImeResultINTEL: return "OpSubgroupAvcMceConvertToImeResultINTEL";
    case OpSubgroupAvcMceConvertToRefPayloadINTEL: return "OpSubgroupAvcMceConvertToRefPayloadINTEL";
    case OpSubgroupAvcMceConvertToRefResultINTEL: return "OpSubgroupAvcMceConvertToRefResultINTEL";
    case OpSubgroupAvcMceConvertToSicPayloadINTEL: return "OpSubgroupAvcMceConvertToSicPayloadINTEL";
    case OpSubgroupAvcMceConvertToSicResultINTEL: return "OpSubgroupAvcMceConvertToSicResultINTEL";
    case OpSubgroupAvcMceGetMotionVectorsINTEL: return "OpSubgroupAvcMceGetMotionVectorsINTEL";
    case OpSubgroupAvcMceGetInterDistortionsINTEL: return "OpSubgroupAvcMceGetInterDistortionsINTEL";
    case OpSubgroupAvcMceGetBestInterDistortionsINTEL: return "OpSubgroupAvcMceGetBestInterDistortionsINTEL";
    case OpSubgroupAvcMceGetInterMajorShapeINTEL: return "OpSubgroupAvcMceGetInterMajorShapeINTEL";
    case OpSubgroupAvcMceGetInterMinorShapeINTEL: return "OpSubgroupAvcMceGetInterMinorShapeINTEL";
    case OpSubgroupAvcMceGetInterDirectionsINTEL: return "OpSubgroupAvcMceGetInterDirectionsINTEL";
    case OpSubgroupAvcMceGetInterMotionVectorCountINTEL: return "OpSubgroupAvcMceGetInterMotionVectorCountINTEL";
    case OpSubgroupAvcMceGetInterReferenceIdsINTEL: return "OpSubgroupAvcMceGetInterReferenceIdsINTEL";
    case OpSubgroupAvcMceGetInterReferenceInterlacedFieldPolaritiesINTEL: return "OpSubgroupAvcMceGetInterReferenceInterlacedFieldPolaritiesINTEL";
    case OpSubgroupAvcImeInitializeINTEL: return "OpSubgroupAvcImeInitializeINTEL";
    case OpSubgroupAvcImeSetSingleReferenceINTEL: return "OpSubgroupAvcImeSetSingleReferenceINTEL";
    case OpSubgroupAvcImeSetDualReferenceINTEL: return "OpSubgroupAvcImeSetDualReferenceINTEL";
    case OpSubgroupAvcImeRefWindowSizeINTEL: return "OpSubgroupAvcImeRefWindowSizeINTEL";
    case OpSubgroupAvcImeAdjustRefOffsetINTEL: return "OpSubgroupAvcImeAdjustRefOffsetINTEL";
    case OpSubgroupAvcImeConvertToMcePayloadINTEL: return "OpSubgroupAvcImeConvertToMcePayloadINTEL";
    case OpSubgroupAvcImeSetMaxMotionVectorCountINTEL: return "OpSubgroupAvcImeSetMaxMotionVectorCountINTEL";
    case OpSubgroupAvcImeSetUnidirectionalMixDisableINTEL: return "OpSubgroupAvcImeSetUnidirectionalMixDisableINTEL";
    case OpSubgroupAvcImeSetEarlySearchTerminationThresholdINTEL: return "OpSubgroupAvcImeSetEarlySearchTerminationThresholdINTEL";
    case OpSubgroupAvcImeSetWeightedSadINTEL: return "OpSubgroupAvcImeSetWeightedSadINTEL";
    case OpSubgroupAvcImeEvaluateWithSingleReferenceINTEL: return "OpSubgroupAvcImeEvaluateWithSingleReferenceINTEL";
    case OpSubgroupAvcImeEvaluateWithDualReferenceINTEL: return "OpSubgroupAvcImeEvaluateWithDualReferenceINTEL";
    case OpSubgroupAvcImeEvaluateWithSingleReferenceStreaminINTEL: return "OpSubgroupAvcImeEvaluateWithSingleReferenceStreaminINTEL";
    case OpSubgroupAvcImeEvaluateWithDualReferenceStreaminINTEL: return "OpSubgroupAvcImeEvaluateWithDualReferenceStreaminINTEL";
    case OpSubgroupAvcImeEvaluateWithSingleReferenceStreamoutINTEL: return "OpSubgroupAvcImeEvaluateWithSingleReferenceStreamoutINTEL";
    case OpSubgroupAvcImeEvaluateWithDualReferenceStreamoutINTEL: return "OpSubgroupAvcImeEvaluateWithDualReferenceStreamoutINTEL";
    case OpSubgroupAvcImeEvaluateWithSingleReferenceStreaminoutINTEL: return "OpSubgroupAvcImeEvaluateWithSingleReferenceStreaminoutINTEL";
    case OpSubgroupAvcImeEvaluateWithDualReferenceStreaminoutINTEL: return "OpSubgroupAvcImeEvaluateWithDualReferenceStreaminoutINTEL";
    case OpSubgroupAvcImeConvertToMceResultINTEL: return "OpSubgroupAvcImeConvertToMceResultINTEL";
    case OpSubgroupAvcImeGetSingleReferenceStreaminINTEL: return "OpSubgroupAvcImeGetSingleReferenceStreaminINTEL";
    case OpSubgroupAvcImeGetDualReferenceStreaminINTEL: return "OpSubgroupAvcImeGetDualReferenceStreaminINTEL";
    case OpSubgroupAvcImeStripSingleReferenceStreamoutINTEL: return "OpSubgroupAvcImeStripSingleReferenceStreamoutINTEL";
    case OpSubgroupAvcImeStripDualReferenceStreamoutINTEL: return "OpSubgroupAvcImeStripDualReferenceStreamoutINTEL";
    case OpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeMotionVectorsINTEL: return "OpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeMotionVectorsINTEL";
    case OpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeDistortionsINTEL: return "OpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeDistortionsINTEL";
    case OpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeReferenceIdsINTEL: return "OpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeReferenceIdsINTEL";
    case OpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeMotionVectorsINTEL: return "OpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeMotionVectorsINTEL";
    case OpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeDistortionsINTEL: return "OpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeDistortionsINTEL";
    case OpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeReferenceIdsINTEL: return "OpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeReferenceIdsINTEL";
    case OpSubgroupAvcImeGetBorderReachedINTEL: return "OpSubgroupAvcImeGetBorderReachedINTEL";
    case OpSubgroupAvcImeGetTruncatedSearchIndicationINTEL: return "OpSubgroupAvcImeGetTruncatedSearchIndicationINTEL";
    case OpSubgroupAvcImeGetUnidirectionalEarlySearchTerminationINTEL: return "OpSubgroupAvcImeGetUnidirectionalEarlySearchTerminationINTEL";
    case OpSubgroupAvcImeGetWeightingPatternMinimumMotionVectorINTEL: return "OpSubgroupAvcImeGetWeightingPatternMinimumMotionVectorINTEL";
    case OpSubgroupAvcImeGetWeightingPatternMinimumDistortionINTEL: return "OpSubgroupAvcImeGetWeightingPatternMinimumDistortionINTEL";
    case OpSubgroupAvcFmeInitializeINTEL: return "OpSubgroupAvcFmeInitializeINTEL";
    case OpSubgroupAvcBmeInitializeINTEL: return "OpSubgroupAvcBmeInitializeINTEL";
    case OpSubgroupAvcRefConvertToMcePayloadINTEL: return "OpSubgroupAvcRefConvertToMcePayloadINTEL";
    case OpSubgroupAvcRefSetBidirectionalMixDisableINTEL: return "OpSubgroupAvcRefSetBidirectionalMixDisableINTEL";
    case OpSubgroupAvcRefSetBilinearFilterEnableINTEL: return "OpSubgroupAvcRefSetBilinearFilterEnableINTEL";
    case OpSubgroupAvcRefEvaluateWithSingleReferenceINTEL: return "OpSubgroupAvcRefEvaluateWithSingleReferenceINTEL";
    case OpSubgroupAvcRefEvaluateWithDualReferenceINTEL: return "OpSubgroupAvcRefEvaluateWithDualReferenceINTEL";
    case OpSubgroupAvcRefEvaluateWithMultiReferenceINTEL: return "OpSubgroupAvcRefEvaluateWithMultiReferenceINTEL";
    case OpSubgroupAvcRefEvaluateWithMultiReferenceInterlacedINTEL: return "OpSubgroupAvcRefEvaluateWithMultiReferenceInterlacedINTEL";
    case OpSubgroupAvcRefConvertToMceResultINTEL: return "OpSubgroupAvcRefConvertToMceResultINTEL";
    case OpSubgroupAvcSicInitializeINTEL: return "OpSubgroupAvcSicInitializeINTEL";
    case OpSubgroupAvcSicConfigureSkcINTEL: return "OpSubgroupAvcSicConfigureSkcINTEL";
    case OpSubgroupAvcSicConfigureIpeLumaINTEL: return "OpSubgroupAvcSicConfigureIpeLumaINTEL";
    case OpSubgroupAvcSicConfigureIpeLumaChromaINTEL: return "OpSubgroupAvcSicConfigureIpeLumaChromaINTEL";
    case OpSubgroupAvcSicGetMotionVectorMaskINTEL: return "OpSubgroupAvcSicGetMotionVectorMaskINTEL";
    case OpSubgroupAvcSicConvertToMcePayloadINTEL: return "OpSubgroupAvcSicConvertToMcePayloadINTEL";
    case OpSubgroupAvcSicSetIntraLumaShapePenaltyINTEL: return "OpSubgroupAvcSicSetIntraLumaShapePenaltyINTEL";
    case OpSubgroupAvcSicSetIntraLumaModeCostFunctionINTEL: return "OpSubgroupAvcSicSetIntraLumaModeCostFunctionINTEL";
    case OpSubgroupAvcSicSetIntraChromaModeCostFunctionINTEL: return "OpSubgroupAvcSicSetIntraChromaModeCostFunctionINTEL";
    case OpSubgroupAvcSicSetBilinearFilterEnableINTEL: return "OpSubgroupAvcSicSetBilinearFilterEnableINTEL";
    case OpSubgroupAvcSicSetSkcForwardTransformEnableINTEL: return "OpSubgroupAvcSicSetSkcForwardTransformEnableINTEL";
    case OpSubgroupAvcSicSetBlockBasedRawSkipSadINTEL: return "OpSubgroupAvcSicSetBlockBasedRawSkipSadINTEL";
    case OpSubgroupAvcSicEvaluateIpeINTEL: return "OpSubgroupAvcSicEvaluateIpeINTEL";
    case OpSubgroupAvcSicEvaluateWithSingleReferenceINTEL: return "OpSubgroupAvcSicEvaluateWithSingleReferenceINTEL";
    case OpSubgroupAvcSicEvaluateWithDualReferenceINTEL: return "OpSubgroupAvcSicEvaluateWithDualReferenceINTEL";
    case OpSubgroupAvcSicEvaluateWithMultiReferenceINTEL: return "OpSubgroupAvcSicEvaluateWithMultiReferenceINTEL";
    case OpSubgroupAvcSicEvaluateWithMultiReferenceInterlacedINTEL: return "OpSubgroupAvcSicEvaluateWithMultiReferenceInterlacedINTEL";
    case OpSubgroupAvcSicConvertToMceResultINTEL: return "OpSubgroupAvcSicConvertToMceResultINTEL";
    case OpSubgroupAvcSicGetIpeLumaShapeINTEL: return "OpSubgroupAvcSicGetIpeLumaShapeINTEL";
    case OpSubgroupAvcSicGetBestIpeLumaDistortionINTEL: return "OpSubgroupAvcSicGetBestIpeLumaDistortionINTEL";
    case OpSubgroupAvcSicGetBestIpeChromaDistortionINTEL: return "OpSubgroupAvcSicGetBestIpeChromaDistortionINTEL";
    case OpSubgroupAvcSicGetPackedIpeLumaModesINTEL: return "OpSubgroupAvcSicGetPackedIpeLumaModesINTEL";
    case OpSubgroupAvcSicGetIpeChromaModeINTEL: return "OpSubgroupAvcSicGetIpeChromaModeINTEL";
    case OpSubgroupAvcSicGetPackedSkcLumaCountThresholdINTEL: return "OpSubgroupAvcSicGetPackedSkcLumaCountThresholdINTEL";
    case OpSubgroupAvcSicGetPackedSkcLumaSumThresholdINTEL: return "OpSubgroupAvcSicGetPackedSkcLumaSumThresholdINTEL";
    case OpSubgroupAvcSicGetInterRawSadsINTEL: return "OpSubgroupAvcSicGetInterRawSadsINTEL";
    case OpVariableLengthArrayINTEL: return "OpVariableLengthArrayINTEL";
    case OpSaveMemoryINTEL: return "OpSaveMemoryINTEL";
    case OpRestoreMemoryINTEL: return "OpRestoreMemoryINTEL";
    case OpArbitraryFloatSinCosPiINTEL: return "OpArbitraryFloatSinCosPiINTEL";
    case OpArbitraryFloatCastINTEL: return "OpArbitraryFloatCastINTEL";
    case OpArbitraryFloatCastFromIntINTEL: return "OpArbitraryFloatCastFromIntINTEL";
    case OpArbitraryFloatCastToIntINTEL: return "OpArbitraryFloatCastToIntINTEL";
    case OpArbitraryFloatAddINTEL: return "OpArbitraryFloatAddINTEL";
    case OpArbitraryFloatSubINTEL: return "OpArbitraryFloatSubINTEL";
    case OpArbitraryFloatMulINTEL: return "OpArbitraryFloatMulINTEL";
    case OpArbitraryFloatDivINTEL: return "OpArbitraryFloatDivINTEL";
    case OpArbitraryFloatGTINTEL: return "OpArbitraryFloatGTINTEL";
    case OpArbitraryFloatGEINTEL: return "OpArbitraryFloatGEINTEL";
    case OpArbitraryFloatLTINTEL: return "OpArbitraryFloatLTINTEL";
    case OpArbitraryFloatLEINTEL: return "OpArbitraryFloatLEINTEL";
    case OpArbitraryFloatEQINTEL: return "OpArbitraryFloatEQINTEL";
    case OpArbitraryFloatRecipINTEL: return "OpArbitraryFloatRecipINTEL";
    case OpArbitraryFloatRSqrtINTEL: return "OpArbitraryFloatRSqrtINTEL";
    case OpArbitraryFloatCbrtINTEL: return "OpArbitraryFloatCbrtINTEL";
    case OpArbitraryFloatHypotINTEL: return "OpArbitraryFloatHypotINTEL";
    case OpArbitraryFloatSqrtINTEL: return "OpArbitraryFloatSqrtINTEL";
    case OpArbitraryFloatLogINTEL: return "OpArbitraryFloatLogINTEL";
    case OpArbitraryFloatLog2INTEL: return "OpArbitraryFloatLog2INTEL";
    case OpArbitraryFloatLog10INTEL: return "OpArbitraryFloatLog10INTEL";
    case OpArbitraryFloatLog1pINTEL: return "OpArbitraryFloatLog1pINTEL";
    case OpArbitraryFloatExpINTEL: return "OpArbitraryFloatExpINTEL";
    case OpArbitraryFloatExp2INTEL: return "OpArbitraryFloatExp2INTEL";
    case OpArbitraryFloatExp10INTEL: return "OpArbitraryFloatExp10INTEL";
    case OpArbitraryFloatExpm1INTEL: return "OpArbitraryFloatExpm1INTEL";
    case OpArbitraryFloatSinINTEL: return "OpArbitraryFloatSinINTEL";
    case OpArbitraryFloatCosINTEL: return "OpArbitraryFloatCosINTEL";
    case OpArbitraryFloatSinCosINTEL: return "OpArbitraryFloatSinCosINTEL";
    case OpArbitraryFloatSinPiINTEL: return "OpArbitraryFloatSinPiINTEL";
    case OpArbitraryFloatCosPiINTEL: return "OpArbitraryFloatCosPiINTEL";
    case OpArbitraryFloatASinINTEL: return "OpArbitraryFloatASinINTEL";
    case OpArbitraryFloatASinPiINTEL: return "OpArbitraryFloatASinPiINTEL";
    case OpArbitraryFloatACosINTEL: return "OpArbitraryFloatACosINTEL";
    case OpArbitraryFloatACosPiINTEL: return "OpArbitraryFloatACosPiINTEL";
    case OpArbitraryFloatATanINTEL: return "OpArbitraryFloatATanINTEL";
    case OpArbitraryFloatATanPiINTEL: return "OpArbitraryFloatATanPiINTEL";
    case OpArbitraryFloatATan2INTEL: return "OpArbitraryFloatATan2INTEL";
    case OpArbitraryFloatPowINTEL: return "OpArbitraryFloatPowINTEL";
    case OpArbitraryFloatPowRINTEL: return "OpArbitraryFloatPowRINTEL";
    case OpArbitraryFloatPowNINTEL: return "OpArbitraryFloatPowNINTEL";
    case OpLoopControlINTEL: return "OpLoopControlINTEL";
    case OpAliasDomainDeclINTEL: return "OpAliasDomainDeclINTEL";
    case OpAliasScopeDeclINTEL: return "OpAliasScopeDeclINTEL";
    case OpAliasScopeListDeclINTEL: return "OpAliasScopeListDeclINTEL";
    case OpFixedSqrtINTEL: return "OpFixedSqrtINTEL";
    case OpFixedRecipINTEL: return "OpFixedRecipINTEL";
    case OpFixedRsqrtINTEL: return "OpFixedRsqrtINTEL";
    case OpFixedSinINTEL: return "OpFixedSinINTEL";
    case OpFixedCosINTEL: return "OpFixedCosINTEL";
    case OpFixedSinCosINTEL: return "OpFixedSinCosINTEL";
    case OpFixedSinPiINTEL: return "OpFixedSinPiINTEL";
    case OpFixedCosPiINTEL: return "OpFixedCosPiINTEL";
    case OpFixedSinCosPiINTEL: return "OpFixedSinCosPiINTEL";
    case OpFixedLogINTEL: return "OpFixedLogINTEL";
    case OpFixedExpINTEL: return "OpFixedExpINTEL";
    case OpPtrCastToCrossWorkgroupINTEL: return "OpPtrCastToCrossWorkgroupINTEL";
    case OpCrossWorkgroupCastToPtrINTEL: return "OpCrossWorkgroupCastToPtrINTEL";
    case OpReadPipeBlockingINTEL: return "OpReadPipeBlockingINTEL";
    case OpWritePipeBlockingINTEL: return "OpWritePipeBlockingINTEL";
    case OpFPGARegINTEL: return "OpFPGARegINTEL";
    case OpRayQueryGetRayTMinKHR: return "OpRayQueryGetRayTMinKHR";
    case OpRayQueryGetRayFlagsKHR: return "OpRayQueryGetRayFlagsKHR";
    case OpRayQueryGetIntersectionTKHR: return "OpRayQueryGetIntersectionTKHR";
    case OpRayQueryGetIntersectionInstanceCustomIndexKHR: return "OpRayQueryGetIntersectionInstanceCustomIndexKHR";
    case OpRayQueryGetIntersectionInstanceIdKHR: return "OpRayQueryGetIntersectionInstanceIdKHR";
    case OpRayQueryGetIntersectionInstanceShaderBindingTableRecordOffsetKHR: return "OpRayQueryGetIntersectionInstanceShaderBindingTableRecordOffsetKHR";
    case OpRayQueryGetIntersectionGeometryIndexKHR: return "OpRayQueryGetIntersectionGeometryIndexKHR";
    case OpRayQueryGetIntersectionPrimitiveIndexKHR: return "OpRayQueryGetIntersectionPrimitiveIndexKHR";
    case OpRayQueryGetIntersectionBarycentricsKHR: return "OpRayQueryGetIntersectionBarycentricsKHR";
    case OpRayQueryGetIntersectionFrontFaceKHR: return "OpRayQueryGetIntersectionFrontFaceKHR";
    case OpRayQueryGetIntersectionCandidateAABBOpaqueKHR: return "OpRayQueryGetIntersectionCandidateAABBOpaqueKHR";
    case OpRayQueryGetIntersectionObjectRayDirectionKHR: return "OpRayQueryGetIntersectionObjectRayDirectionKHR";
    case OpRayQueryGetIntersectionObjectRayOriginKHR: return "OpRayQueryGetIntersectionObjectRayOriginKHR";
    case OpRayQueryGetWorldRayDirectionKHR: return "OpRayQueryGetWorldRayDirectionKHR";
    case OpRayQueryGetWorldRayOriginKHR: return "OpRayQueryGetWorldRayOriginKHR";
    case OpRayQueryGetIntersectionObjectToWorldKHR: return "OpRayQueryGetIntersectionObjectToWorldKHR";
    case OpRayQueryGetIntersectionWorldToObjectKHR: return "OpRayQueryGetIntersectionWorldToObjectKHR";
    case OpAtomicFAddEXT: return "OpAtomicFAddEXT";
    case OpTypeBufferSurfaceINTEL: return "OpTypeBufferSurfaceINTEL";
    case OpTypeStructContinuedINTEL: return "OpTypeStructContinuedINTEL";
    case OpConstantCompositeContinuedINTEL: return "OpConstantCompositeContinuedINTEL";
    case OpSpecConstantCompositeContinuedINTEL: return "OpSpecConstantCompositeContinuedINTEL";
    case OpCompositeConstructContinuedINTEL: return "OpCompositeConstructContinuedINTEL";
    case OpConvertFToBF16INTEL: return "OpConvertFToBF16INTEL";
    case OpConvertBF16ToFINTEL: return "OpConvertBF16ToFINTEL";
    case OpControlBarrierArriveINTEL: return "OpControlBarrierArriveINTEL";
    case OpControlBarrierWaitINTEL: return "OpControlBarrierWaitINTEL";
    case OpGroupIMulKHR: return "OpGroupIMulKHR";
    case OpGroupFMulKHR: return "OpGroupFMulKHR";
    case OpGroupBitwiseAndKHR: return "OpGroupBitwiseAndKHR";
    case OpGroupBitwiseOrKHR: return "OpGroupBitwiseOrKHR";
    case OpGroupBitwiseXorKHR: return "OpGroupBitwiseXorKHR";
    case OpGroupLogicalAndKHR: return "OpGroupLogicalAndKHR";
    case OpGroupLogicalOrKHR: return "OpGroupLogicalOrKHR";
    case OpGroupLogicalXorKHR: return "OpGroupLogicalXorKHR";
    case OpMaskedGatherINTEL: return "OpMaskedGatherINTEL";
    case OpMaskedScatterINTEL: return "OpMaskedScatterINTEL";
    default: return "Unknown";
    }
}

#endif /* SPV_ENABLE_UTILITY_CODE */

// Overload bitwise operators for mask bit combining

constexpr ImageOperandsMask operator|(ImageOperandsMask a, ImageOperandsMask b) { return ImageOperandsMask(unsigned(a) | unsigned(b)); }
constexpr ImageOperandsMask operator&(ImageOperandsMask a, ImageOperandsMask b) { return ImageOperandsMask(unsigned(a) & unsigned(b)); }
constexpr ImageOperandsMask operator^(ImageOperandsMask a, ImageOperandsMask b) { return ImageOperandsMask(unsigned(a) ^ unsigned(b)); }
constexpr ImageOperandsMask operator~(ImageOperandsMask a) { return ImageOperandsMask(~unsigned(a)); }
constexpr FPFastMathModeMask operator|(FPFastMathModeMask a, FPFastMathModeMask b) { return FPFastMathModeMask(unsigned(a) | unsigned(b)); }
constexpr FPFastMathModeMask operator&(FPFastMathModeMask a, FPFastMathModeMask b) { return FPFastMathModeMask(unsigned(a) & unsigned(b)); }
constexpr FPFastMathModeMask operator^(FPFastMathModeMask a, FPFastMathModeMask b) { return FPFastMathModeMask(unsigned(a) ^ unsigned(b)); }
constexpr FPFastMathModeMask operator~(FPFastMathModeMask a) { return FPFastMathModeMask(~unsigned(a)); }
constexpr SelectionControlMask operator|(SelectionControlMask a, SelectionControlMask b) { return SelectionControlMask(unsigned(a) | unsigned(b)); }
constexpr SelectionControlMask operator&(SelectionControlMask a, SelectionControlMask b) { return SelectionControlMask(unsigned(a) & unsigned(b)); }
constexpr SelectionControlMask operator^(SelectionControlMask a, SelectionControlMask b) { return SelectionControlMask(unsigned(a) ^ unsigned(b)); }
constexpr SelectionControlMask operator~(SelectionControlMask a) { return SelectionControlMask(~unsigned(a)); }
constexpr LoopControlMask operator|(LoopControlMask a, LoopControlMask b) { return LoopControlMask(unsigned(a) | unsigned(b)); }
constexpr LoopControlMask operator&(LoopControlMask a, LoopControlMask b) { return LoopControlMask(unsigned(a) & unsigned(b)); }
constexpr LoopControlMask operator^(LoopControlMask a, LoopControlMask b) { return LoopControlMask(unsigned(a) ^ unsigned(b)); }
constexpr LoopControlMask operator~(LoopControlMask a) { return LoopControlMask(~unsigned(a)); }
constexpr FunctionControlMask operator|(FunctionControlMask a, FunctionControlMask b) { return FunctionControlMask(unsigned(a) | unsigned(b)); }
constexpr FunctionControlMask operator&(FunctionControlMask a, FunctionControlMask b) { return FunctionControlMask(unsigned(a) & unsigned(b)); }
constexpr FunctionControlMask operator^(FunctionControlMask a, FunctionControlMask b) { return FunctionControlMask(unsigned(a) ^ unsigned(b)); }
constexpr FunctionControlMask operator~(FunctionControlMask a) { return FunctionControlMask(~unsigned(a)); }
constexpr MemorySemanticsMask operator|(MemorySemanticsMask a, MemorySemanticsMask b) { return MemorySemanticsMask(unsigned(a) | unsigned(b)); }
constexpr MemorySemanticsMask operator&(MemorySemanticsMask a, MemorySemanticsMask b) { return MemorySemanticsMask(unsigned(a) & unsigned(b)); }
constexpr MemorySemanticsMask operator^(MemorySemanticsMask a, MemorySemanticsMask b) { return MemorySemanticsMask(unsigned(a) ^ unsigned(b)); }
constexpr MemorySemanticsMask operator~(MemorySemanticsMask a) { return MemorySemanticsMask(~unsigned(a)); }
constexpr MemoryAccessMask operator|(MemoryAccessMask a, MemoryAccessMask b) { return MemoryAccessMask(unsigned(a) | unsigned(b)); }
constexpr MemoryAccessMask operator&(MemoryAccessMask a, MemoryAccessMask b) { return MemoryAccessMask(unsigned(a) & unsigned(b)); }
constexpr MemoryAccessMask operator^(MemoryAccessMask a, MemoryAccessMask b) { return MemoryAccessMask(unsigned(a) ^ unsigned(b)); }
constexpr MemoryAccessMask operator~(MemoryAccessMask a) { return MemoryAccessMask(~unsigned(a)); }
constexpr KernelProfilingInfoMask operator|(KernelProfilingInfoMask a, KernelProfilingInfoMask b) { return KernelProfilingInfoMask(unsigned(a) | unsigned(b)); }
constexpr KernelProfilingInfoMask operator&(KernelProfilingInfoMask a, KernelProfilingInfoMask b) { return KernelProfilingInfoMask(unsigned(a) & unsigned(b)); }
constexpr KernelProfilingInfoMask operator^(KernelProfilingInfoMask a, KernelProfilingInfoMask b) { return KernelProfilingInfoMask(unsigned(a) ^ unsigned(b)); }
constexpr KernelProfilingInfoMask operator~(KernelProfilingInfoMask a) { return KernelProfilingInfoMask(~unsigned(a)); }
constexpr RayFlagsMask operator|(RayFlagsMask a, RayFlagsMask b) { return RayFlagsMask(unsigned(a) | unsigned(b)); }
constexpr RayFlagsMask operator&(RayFlagsMask a, RayFlagsMask b) { return RayFlagsMask(unsigned(a) & unsigned(b)); }
constexpr RayFlagsMask operator^(RayFlagsMask a, RayFlagsMask b) { return RayFlagsMask(unsigned(a) ^ unsigned(b)); }
constexpr RayFlagsMask operator~(RayFlagsMask a) { return RayFlagsMask(~unsigned(a)); }
constexpr FragmentShadingRateMask operator|(FragmentShadingRateMask a, FragmentShadingRateMask b) { return FragmentShadingRateMask(unsigned(a) | unsigned(b)); }
constexpr FragmentShadingRateMask operator&(FragmentShadingRateMask a, FragmentShadingRateMask b) { return FragmentShadingRateMask(unsigned(a) & unsigned(b)); }
constexpr FragmentShadingRateMask operator^(FragmentShadingRateMask a, FragmentShadingRateMask b) { return FragmentShadingRateMask(unsigned(a) ^ unsigned(b)); }
constexpr FragmentShadingRateMask operator~(FragmentShadingRateMask a) { return FragmentShadingRateMask(~unsigned(a)); }
constexpr CooperativeMatrixOperandsMask operator|(CooperativeMatrixOperandsMask a, CooperativeMatrixOperandsMask b) { return CooperativeMatrixOperandsMask(unsigned(a) | unsigned(b)); }
constexpr CooperativeMatrixOperandsMask operator&(CooperativeMatrixOperandsMask a, CooperativeMatrixOperandsMask b) { return CooperativeMatrixOperandsMask(unsigned(a) & unsigned(b)); }
constexpr CooperativeMatrixOperandsMask operator^(CooperativeMatrixOperandsMask a, CooperativeMatrixOperandsMask b) { return CooperativeMatrixOperandsMask(unsigned(a) ^ unsigned(b)); }
constexpr CooperativeMatrixOperandsMask operator~(CooperativeMatrixOperandsMask a) { return CooperativeMatrixOperandsMask(~unsigned(a)); }
constexpr RawAccessChainOperandsMask operator|(RawAccessChainOperandsMask a, RawAccessChainOperandsMask b) { return RawAccessChainOperandsMask(unsigned(a) | unsigned(b)); }
constexpr RawAccessChainOperandsMask operator&(RawAccessChainOperandsMask a, RawAccessChainOperandsMask b) { return RawAccessChainOperandsMask(unsigned(a) & unsigned(b)); }
constexpr RawAccessChainOperandsMask operator^(RawAccessChainOperandsMask a, RawAccessChainOperandsMask b) { return RawAccessChainOperandsMask(unsigned(a) ^ unsigned(b)); }
constexpr RawAccessChainOperandsMask operator~(RawAccessChainOperandsMask a) { return RawAccessChainOperandsMask(~unsigned(a)); }

}  // end namespace spv

#endif  // #ifndef spirv_HPP

