<?xml version="1.0" encoding="UTF-8"?>
<registry>
    <comment>
Copyright (c) 2015-2019 The Khronos Group Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

---- Exceptions to the Apache 2.0 License: ----

As an exception, if you use this Software to generate code and portions of
this Software are embedded into the generated code as a result, you may
redistribute such product without providing attribution as would otherwise
be required by Sections 4(a), 4(b) and 4(d) of the License.

In addition, if you combine or link code generated by this Software with
software that is licensed under the GPLv2 or the LGPL v2.0 or 2.1
("`Combined Software`") and if a court of competent jurisdiction determines
that the patent provision (Section 3), the indemnity provision (Section 9)
or other Section of the License conflicts with the conditions of the
applicable GPL or LGPL license, you may retroactively and prospectively
choose to deem waived or otherwise exclude such Section(s) of the License,
but only in their entirety and only with respect to the Combined Software.
    </comment>

    <comment>
This file, vk.xml, is the Vulkan API Registry. It is a critically important
and normative part of the Vulkan Specification, including a canonical
machine-readable definition of the API, parameter and member validation
language incorporated into the Specification and reference pages, and other
material which is registered by Khronos, such as tags used by extension and
layer authors. The authoritative public version of vk.xml is maintained in
the master branch of the Khronos Vulkan GitHub project. The authoritative
private version is maintained in the master branch of the member gitlab
server.
    </comment>

    <platforms comment="Vulkan platform names, reserved for use with platform- and window system-specific extensions">
        <platform name="xlib" protect="VK_USE_PLATFORM_XLIB_KHR" comment="X Window System, Xlib client library"/>
        <platform name="xlib_xrandr" protect="VK_USE_PLATFORM_XLIB_XRANDR_EXT" comment="X Window System, Xlib client library, XRandR extension"/>
        <platform name="xcb" protect="VK_USE_PLATFORM_XCB_KHR" comment="X Window System, Xcb client library"/>
        <platform name="wayland" protect="VK_USE_PLATFORM_WAYLAND_KHR" comment="Wayland display server protocol"/>
        <platform name="android" protect="VK_USE_PLATFORM_ANDROID_KHR" comment="Android OS"/>
        <platform name="win32" protect="VK_USE_PLATFORM_WIN32_KHR" comment="Microsoft Win32 API (also refers to Win64 apps)"/>
        <platform name="vi" protect="VK_USE_PLATFORM_VI_NN" comment="Nintendo Vi"/>
        <platform name="ios" protect="VK_USE_PLATFORM_IOS_MVK" comment="Apple IOS"/>
        <platform name="macos" protect="VK_USE_PLATFORM_MACOS_MVK" comment="Apple MacOS"/>
        <platform name="metal" protect="VK_USE_PLATFORM_METAL_EXT" comment="Metal on CoreAnimation on Apple platforms"/>
        <platform name="fuchsia" protect="VK_USE_PLATFORM_FUCHSIA" comment="Fuchsia"/>
        <platform name="ggp" protect="VK_USE_PLATFORM_GGP" comment="Google Games Platform"/>
    </platforms>

    <tags comment="Vulkan vendor/author tags for extensions and layers">
        <tag name="IMG"         author="Imagination Technologies"      contact="Michael Worcester @michaelworcester"/>
        <tag name="AMD"         author="Advanced Micro Devices, Inc."  contact="Daniel Rakos @drakos-amd"/>
        <tag name="AMDX"        author="Advanced Micro Devices, Inc."  contact="Daniel Rakos @drakos-amd"/>
        <tag name="ARM"         author="ARM Limited"                   contact="Jan-Harald Fredriksen @janharaldfredriksen-arm"/>
        <tag name="FSL"         author="Freescale Semiconductor, Inc." contact="Norbert Nopper @FslNopper"/>
        <tag name="BRCM"        author="Broadcom Corporation"          contact="Graeme Leese @gnl21"/>
        <tag name="NXP"         author="NXP Semiconductors N.V."       contact="Norbert Nopper @FslNopper"/>
        <tag name="NV"          author="NVIDIA Corporation"            contact="Daniel Koch @dgkoch"/>
        <tag name="NVX"         author="NVIDIA Corporation"            contact="Daniel Koch @dgkoch"/>
        <tag name="VIV"         author="Vivante Corporation"           contact="Yanjun Zhang gitlab:@yanjunzhang"/>
        <tag name="VSI"         author="VeriSilicon Holdings Co., Ltd." contact="Yanjun Zhang gitlab:@yanjunzhang"/>
        <tag name="KDAB"        author="KDAB"                          contact="Sean Harmer @seanharmer"/>
        <tag name="ANDROID"     author="Google LLC"                    contact="Jesse Hall @critsec"/>
        <tag name="CHROMIUM"    author="Google LLC"                    contact="Jesse Hall @critsec"/>
        <tag name="FUCHSIA"     author="Google LLC"                    contact="Craig Stout @cdotstout, Jesse Hall @critsec"/>
        <tag name="GGP"         author="Google, LLC"                   contact="Jean-Francois Roy @jfroy, Hai Nguyen @chaoticbob, Jesse Hall @critsec"/>
        <tag name="GOOGLE"      author="Google LLC"                    contact="Jesse Hall @critsec"/>
        <tag name="QCOM"        author="Qualcomm Technologies, Inc."   contact="Maurice Ribble @mribble"/>
        <tag name="LUNARG"      author="LunarG, Inc."                  contact="Karen Ghavam @karenghavam-lunarg"/>
        <tag name="SAMSUNG"     author="Samsung Electronics Co., Ltd." contact="Alon Or-bach @alonorbach"/>
        <tag name="SEC"         author="Samsung Electronics Co., Ltd." contact="Alon Or-bach @alonorbach"/>
        <tag name="TIZEN"       author="Samsung Electronics Co., Ltd." contact="Alon Or-bach @alonorbach"/>
        <tag name="RENDERDOC"   author="RenderDoc (renderdoc.org)"     contact="Baldur Karlsson @baldurk"/>
        <tag name="NN"          author="Nintendo Co., Ltd."            contact="Yasuhiro Yoshioka gitlab:@yoshioka_yasuhiro"/>
        <tag name="MVK"         author="The Brenwill Workshop Ltd."    contact="Bill Hollings @billhollings"/>
        <tag name="KHR"         author="Khronos"                       contact="Tom Olson @tomolson"/>
        <tag name="KHX"         author="Khronos"                       contact="Tom Olson @tomolson"/>
        <tag name="EXT"         author="Multivendor"                   contact="Jon Leech @oddhack"/>
        <tag name="MESA"        author="Mesa open source project"      contact="Chad Versace @chadversary, Daniel Stone @fooishbar, David Airlie @airlied, Jason Ekstrand @jekstrand"/>
        <tag name="INTEL"       author="Intel Corporation"             contact="Slawek Grajewski @sgrajewski"/>
    </tags>

    <types comment="Vulkan type definitions">
        <type name="vk_platform" category="include">#include "vk_platform.h"</type>

            <comment>WSI extensions</comment>

        <type category="include" name="X11/Xlib.h"/>
        <type category="include" name="X11/extensions/Xrandr.h"/>
        <type category="include" name="wayland-client.h"/>
        <type category="include" name="windows.h"/>
        <type category="include" name="xcb/xcb.h"/>
        <type category="include" name="zircon/types.h"/>
        <type category="include" name="ggp_c/vulkan_types.h"/>
            <comment>
                In the current header structure, each platform's interfaces
                are confined to a platform-specific header (vulkan_xlib.h,
                vulkan_win32.h, etc.). These headers are not self-contained,
                and should not include native headers (X11/Xlib.h,
                windows.h, etc.). Code should either include vulkan.h after
                defining the appropriate VK_USE_PLATFORM_platform
                macros, or include the required native headers prior to
                explicitly including the corresponding platform header.

                To accomplish this, the dependencies of native types require
                native headers, but the XML defines the content for those
                native headers as empty. The actual native header includes
                can be restored by modifying the native header tags above
                to #include the header file in the 'name' attribute.
            </comment>

        <type requires="X11/Xlib.h" name="Display"/>
        <type requires="X11/Xlib.h" name="VisualID"/>
        <type requires="X11/Xlib.h" name="Window"/>
        <type requires="X11/extensions/Xrandr.h" name="RROutput"/>
        <type requires="wayland-client.h" name="wl_display"/>
        <type requires="wayland-client.h" name="wl_surface"/>
        <type requires="windows.h" name="HINSTANCE"/>
        <type requires="windows.h" name="HWND"/>
        <type requires="windows.h" name="HMONITOR"/>
        <type requires="windows.h" name="HANDLE"/>
        <type requires="windows.h" name="SECURITY_ATTRIBUTES"/>
        <type requires="windows.h" name="DWORD"/>
        <type requires="windows.h" name="LPCWSTR"/>
        <type requires="xcb/xcb.h" name="xcb_connection_t"/>
        <type requires="xcb/xcb.h" name="xcb_visualid_t"/>
        <type requires="xcb/xcb.h" name="xcb_window_t"/>
        <type requires="zircon/types.h" name="zx_handle_t"/>
        <type requires="ggp_c/vulkan_types.h" name="GgpStreamDescriptor"/>
        <type requires="ggp_c/vulkan_types.h" name="GgpFrameToken"/>

        <type category="define">#define <name>VK_MAKE_VERSION</name>(major, minor, patch) \
    (((major) &lt;&lt; 22) | ((minor) &lt;&lt; 12) | (patch))</type>
        <type category="define">#define <name>VK_VERSION_MAJOR</name>(version) ((uint32_t)(version) &gt;&gt; 22)</type>
        <type category="define">#define <name>VK_VERSION_MINOR</name>(version) (((uint32_t)(version) &gt;&gt; 12) &amp; 0x3ff)</type>
        <type category="define">#define <name>VK_VERSION_PATCH</name>(version) ((uint32_t)(version) &amp; 0xfff)</type>

        <type category="define">// DEPRECATED: This define has been removed. Specific version defines (e.g. VK_API_VERSION_1_0), or the VK_MAKE_VERSION macro, should be used instead.
//#define <name>VK_API_VERSION</name> <type>VK_MAKE_VERSION</type>(1, 0, 0) // Patch version should always be set to 0</type>
        <type category="define">// Vulkan 1.0 version number
#define <name>VK_API_VERSION_1_0</name> <type>VK_MAKE_VERSION</type>(1, 0, 0)// Patch version should always be set to 0</type>
        <type category="define">// Vulkan 1.1 version number
#define <name>VK_API_VERSION_1_1</name> <type>VK_MAKE_VERSION</type>(1, 1, 0)// Patch version should always be set to 0</type>
        <type category="define">// Version of this file
#define <name>VK_HEADER_VERSION</name> 113</type>

        <type category="define">
#define <name>VK_DEFINE_HANDLE</name>(object) typedef struct object##_T* object;</type>

        <type category="define" name="VK_DEFINE_NON_DISPATCHABLE_HANDLE">
#if !defined(VK_DEFINE_NON_DISPATCHABLE_HANDLE)
#if defined(__LP64__) || defined(_WIN64) || (defined(__x86_64__) &amp;&amp; !defined(__ILP32__) ) || defined(_M_X64) || defined(__ia64) || defined (_M_IA64) || defined(__aarch64__) || defined(__powerpc64__)
        #define VK_DEFINE_NON_DISPATCHABLE_HANDLE(object) typedef struct object##_T *object;
#else
        #define VK_DEFINE_NON_DISPATCHABLE_HANDLE(object) typedef uint64_t object;
#endif
#endif</type>

        <type category="define">
#define <name>VK_NULL_HANDLE</name> 0</type>

        <type category="define">struct <name>ANativeWindow</name>;</type>
        <type category="define">struct <name>AHardwareBuffer</name>;</type>
        <type category="define">
#ifdef __OBJC__
@class CAMetalLayer;
#else
typedef void <name>CAMetalLayer</name>;
#endif</type>

        <type category="basetype">typedef <type>uint32_t</type> <name>VkSampleMask</name>;</type>
        <type category="basetype">typedef <type>uint32_t</type> <name>VkBool32</name>;</type>
        <type category="basetype">typedef <type>uint32_t</type> <name>VkFlags</name>;</type>
        <type category="basetype">typedef <type>uint64_t</type> <name>VkDeviceSize</name>;</type>
        <type category="basetype">typedef <type>uint64_t</type> <name>VkDeviceAddress</name>;</type>

            <comment>Basic C types, pulled in via vk_platform.h</comment>
        <type requires="vk_platform" name="void"/>
        <type requires="vk_platform" name="char"/>
        <type requires="vk_platform" name="float"/>
        <type requires="vk_platform" name="uint8_t"/>
        <type requires="vk_platform" name="uint16_t"/>
        <type requires="vk_platform" name="uint32_t"/>
        <type requires="vk_platform" name="uint64_t"/>
        <type requires="vk_platform" name="int32_t"/>
        <type requires="vk_platform" name="size_t"/>
        <type name="int"/>

            <comment>Bitmask types</comment>
        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkFramebufferCreateFlags</name>;</type>
        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkQueryPoolCreateFlags</name>;</type>
        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkRenderPassCreateFlags</name>;</type>
        <type requires="VkSamplerCreateFlagBits"          category="bitmask">typedef <type>VkFlags</type> <name>VkSamplerCreateFlags</name>;</type>
        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkPipelineLayoutCreateFlags</name>;</type>
        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkPipelineCacheCreateFlags</name>;</type>
        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkPipelineDepthStencilStateCreateFlags</name>;</type>
        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkPipelineDynamicStateCreateFlags</name>;</type>
        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkPipelineColorBlendStateCreateFlags</name>;</type>
        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkPipelineMultisampleStateCreateFlags</name>;</type>
        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkPipelineRasterizationStateCreateFlags</name>;</type>
        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkPipelineViewportStateCreateFlags</name>;</type>
        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkPipelineTessellationStateCreateFlags</name>;</type>
        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkPipelineInputAssemblyStateCreateFlags</name>;</type>
        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkPipelineVertexInputStateCreateFlags</name>;</type>
        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkPipelineShaderStageCreateFlags</name>;</type>
        <type requires="VkDescriptorSetLayoutCreateFlagBits" category="bitmask">typedef <type>VkFlags</type> <name>VkDescriptorSetLayoutCreateFlags</name>;</type>
        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkBufferViewCreateFlags</name>;</type>
        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkInstanceCreateFlags</name>;</type>
        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkDeviceCreateFlags</name>;</type>
        <type requires="VkDeviceQueueCreateFlagBits"      category="bitmask">typedef <type>VkFlags</type> <name>VkDeviceQueueCreateFlags</name>;</type>
        <type requires="VkQueueFlagBits"                  category="bitmask">typedef <type>VkFlags</type> <name>VkQueueFlags</name>;</type>
        <type requires="VkMemoryPropertyFlagBits"         category="bitmask">typedef <type>VkFlags</type> <name>VkMemoryPropertyFlags</name>;</type>
        <type requires="VkMemoryHeapFlagBits"             category="bitmask">typedef <type>VkFlags</type> <name>VkMemoryHeapFlags</name>;</type>
        <type requires="VkAccessFlagBits"                 category="bitmask">typedef <type>VkFlags</type> <name>VkAccessFlags</name>;</type>
        <type requires="VkBufferUsageFlagBits"            category="bitmask">typedef <type>VkFlags</type> <name>VkBufferUsageFlags</name>;</type>
        <type requires="VkBufferCreateFlagBits"           category="bitmask">typedef <type>VkFlags</type> <name>VkBufferCreateFlags</name>;</type>
        <type requires="VkShaderStageFlagBits"            category="bitmask">typedef <type>VkFlags</type> <name>VkShaderStageFlags</name>;</type>
        <type requires="VkImageUsageFlagBits"             category="bitmask">typedef <type>VkFlags</type> <name>VkImageUsageFlags</name>;</type>
        <type requires="VkImageCreateFlagBits"            category="bitmask">typedef <type>VkFlags</type> <name>VkImageCreateFlags</name>;</type>
        <type requires="VkImageViewCreateFlagBits"        category="bitmask">typedef <type>VkFlags</type> <name>VkImageViewCreateFlags</name>;</type>
        <type requires="VkPipelineCreateFlagBits"         category="bitmask">typedef <type>VkFlags</type> <name>VkPipelineCreateFlags</name>;</type>
        <type requires="VkColorComponentFlagBits"         category="bitmask">typedef <type>VkFlags</type> <name>VkColorComponentFlags</name>;</type>
        <type requires="VkFenceCreateFlagBits"            category="bitmask">typedef <type>VkFlags</type> <name>VkFenceCreateFlags</name>;</type>
        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkSemaphoreCreateFlags</name>;</type>
        <type requires="VkFormatFeatureFlagBits"          category="bitmask">typedef <type>VkFlags</type> <name>VkFormatFeatureFlags</name>;</type>
        <type requires="VkQueryControlFlagBits"           category="bitmask">typedef <type>VkFlags</type> <name>VkQueryControlFlags</name>;</type>
        <type requires="VkQueryResultFlagBits"            category="bitmask">typedef <type>VkFlags</type> <name>VkQueryResultFlags</name>;</type>
        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkShaderModuleCreateFlags</name>;</type>
        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkEventCreateFlags</name>;</type>
        <type requires="VkCommandPoolCreateFlagBits"          category="bitmask">typedef <type>VkFlags</type> <name>VkCommandPoolCreateFlags</name>;</type>
        <type requires="VkCommandPoolResetFlagBits"           category="bitmask">typedef <type>VkFlags</type> <name>VkCommandPoolResetFlags</name>;</type>
        <type requires="VkCommandBufferResetFlagBits"         category="bitmask">typedef <type>VkFlags</type> <name>VkCommandBufferResetFlags</name>;</type>
        <type requires="VkCommandBufferUsageFlagBits"         category="bitmask">typedef <type>VkFlags</type> <name>VkCommandBufferUsageFlags</name>;</type>
        <type requires="VkQueryPipelineStatisticFlagBits" category="bitmask">typedef <type>VkFlags</type> <name>VkQueryPipelineStatisticFlags</name>;</type>
        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkMemoryMapFlags</name>;</type>
        <type requires="VkImageAspectFlagBits"            category="bitmask">typedef <type>VkFlags</type> <name>VkImageAspectFlags</name>;</type>
        <type requires="VkSparseMemoryBindFlagBits"       category="bitmask">typedef <type>VkFlags</type> <name>VkSparseMemoryBindFlags</name>;</type>
        <type requires="VkSparseImageFormatFlagBits"      category="bitmask">typedef <type>VkFlags</type> <name>VkSparseImageFormatFlags</name>;</type>
        <type requires="VkSubpassDescriptionFlagBits"     category="bitmask">typedef <type>VkFlags</type> <name>VkSubpassDescriptionFlags</name>;</type>
        <type requires="VkPipelineStageFlagBits"          category="bitmask">typedef <type>VkFlags</type> <name>VkPipelineStageFlags</name>;</type>
        <type requires="VkSampleCountFlagBits"            category="bitmask">typedef <type>VkFlags</type> <name>VkSampleCountFlags</name>;</type>
        <type requires="VkAttachmentDescriptionFlagBits"  category="bitmask">typedef <type>VkFlags</type> <name>VkAttachmentDescriptionFlags</name>;</type>
        <type requires="VkStencilFaceFlagBits"            category="bitmask">typedef <type>VkFlags</type> <name>VkStencilFaceFlags</name>;</type>
        <type requires="VkCullModeFlagBits"               category="bitmask">typedef <type>VkFlags</type> <name>VkCullModeFlags</name>;</type>
        <type requires="VkDescriptorPoolCreateFlagBits"   category="bitmask">typedef <type>VkFlags</type> <name>VkDescriptorPoolCreateFlags</name>;</type>
        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkDescriptorPoolResetFlags</name>;</type>
        <type requires="VkDependencyFlagBits"             category="bitmask">typedef <type>VkFlags</type> <name>VkDependencyFlags</name>;</type>
        <type requires="VkSubgroupFeatureFlagBits"        category="bitmask">typedef <type>VkFlags</type> <name>VkSubgroupFeatureFlags</name>;</type>
        <type requires="VkIndirectCommandsLayoutUsageFlagBitsNVX"  category="bitmask">typedef <type>VkFlags</type> <name>VkIndirectCommandsLayoutUsageFlagsNVX</name>;</type>
        <type requires="VkObjectEntryUsageFlagBitsNVX"             category="bitmask">typedef <type>VkFlags</type> <name>VkObjectEntryUsageFlagsNVX</name>;</type>
        <type requires="VkGeometryFlagBitsNV"            category="bitmask">typedef <type>VkFlags</type> <name>VkGeometryFlagsNV</name>;</type>
        <type requires="VkGeometryInstanceFlagBitsNV"    category="bitmask">typedef <type>VkFlags</type> <name>VkGeometryInstanceFlagsNV</name>;</type>
        <type requires="VkBuildAccelerationStructureFlagBitsNV" category="bitmask">typedef <type>VkFlags</type> <name>VkBuildAccelerationStructureFlagsNV</name>;</type>

        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkDescriptorUpdateTemplateCreateFlags</name>;</type>
        <type                                             category="bitmask" name="VkDescriptorUpdateTemplateCreateFlagsKHR" alias="VkDescriptorUpdateTemplateCreateFlags"/>
        <type requires="VkPipelineCreationFeedbackFlagBitsEXT" category="bitmask">typedef <type>VkFlags</type> <name>VkPipelineCreationFeedbackFlagsEXT</name>;</type>

            <comment>WSI extensions</comment>
        <type requires="VkCompositeAlphaFlagBitsKHR"      category="bitmask">typedef <type>VkFlags</type> <name>VkCompositeAlphaFlagsKHR</name>;</type>
        <type requires="VkDisplayPlaneAlphaFlagBitsKHR"   category="bitmask">typedef <type>VkFlags</type> <name>VkDisplayPlaneAlphaFlagsKHR</name>;</type>
        <type requires="VkSurfaceTransformFlagBitsKHR"    category="bitmask">typedef <type>VkFlags</type> <name>VkSurfaceTransformFlagsKHR</name>;</type>
        <type requires="VkSwapchainCreateFlagBitsKHR"     category="bitmask">typedef <type>VkFlags</type> <name>VkSwapchainCreateFlagsKHR</name>;</type>
        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkDisplayModeCreateFlagsKHR</name>;</type>
        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkDisplaySurfaceCreateFlagsKHR</name>;</type>
        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkAndroidSurfaceCreateFlagsKHR</name>;</type>
        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkViSurfaceCreateFlagsNN</name>;</type>
        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkWaylandSurfaceCreateFlagsKHR</name>;</type>
        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkWin32SurfaceCreateFlagsKHR</name>;</type>
        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkXlibSurfaceCreateFlagsKHR</name>;</type>
        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkXcbSurfaceCreateFlagsKHR</name>;</type>
        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkIOSSurfaceCreateFlagsMVK</name>;</type>
        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkMacOSSurfaceCreateFlagsMVK</name>;</type>
        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkMetalSurfaceCreateFlagsEXT</name>;</type>
        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkImagePipeSurfaceCreateFlagsFUCHSIA</name>;</type>
        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkStreamDescriptorSurfaceCreateFlagsGGP</name>;</type>
        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkHeadlessSurfaceCreateFlagsEXT</name>;</type>
        <type requires="VkPeerMemoryFeatureFlagBits"   category="bitmask">typedef <type>VkFlags</type> <name>VkPeerMemoryFeatureFlags</name>;</type>
        <type                                             category="bitmask" name="VkPeerMemoryFeatureFlagsKHR"               alias="VkPeerMemoryFeatureFlags"/>
        <type requires="VkMemoryAllocateFlagBits"      category="bitmask">typedef <type>VkFlags</type> <name>VkMemoryAllocateFlags</name>;</type>
        <type                                             category="bitmask" name="VkMemoryAllocateFlagsKHR"                  alias="VkMemoryAllocateFlags"/>
        <type requires="VkDeviceGroupPresentModeFlagBitsKHR" category="bitmask">typedef <type>VkFlags</type> <name>VkDeviceGroupPresentModeFlagsKHR</name>;</type>

        <type requires="VkDebugReportFlagBitsEXT"      category="bitmask">typedef <type>VkFlags</type> <name>VkDebugReportFlagsEXT</name>;</type>
        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkCommandPoolTrimFlags</name>;</type>
        <type                                             category="bitmask" name="VkCommandPoolTrimFlagsKHR"                 alias="VkCommandPoolTrimFlags"/>
        <type requires="VkExternalMemoryHandleTypeFlagBitsNV" category="bitmask">typedef <type>VkFlags</type> <name>VkExternalMemoryHandleTypeFlagsNV</name>;</type>
        <type requires="VkExternalMemoryFeatureFlagBitsNV" category="bitmask">typedef <type>VkFlags</type> <name>VkExternalMemoryFeatureFlagsNV</name>;</type>
        <type requires="VkExternalMemoryHandleTypeFlagBits" category="bitmask">typedef <type>VkFlags</type> <name>VkExternalMemoryHandleTypeFlags</name>;</type>
        <type                                             category="bitmask" name="VkExternalMemoryHandleTypeFlagsKHR"        alias="VkExternalMemoryHandleTypeFlags"/>
        <type requires="VkExternalMemoryFeatureFlagBits" category="bitmask">typedef <type>VkFlags</type> <name>VkExternalMemoryFeatureFlags</name>;</type>
        <type                                             category="bitmask" name="VkExternalMemoryFeatureFlagsKHR"           alias="VkExternalMemoryFeatureFlags"/>
        <type requires="VkExternalSemaphoreHandleTypeFlagBits" category="bitmask">typedef <type>VkFlags</type> <name>VkExternalSemaphoreHandleTypeFlags</name>;</type>
        <type                                             category="bitmask" name="VkExternalSemaphoreHandleTypeFlagsKHR"     alias="VkExternalSemaphoreHandleTypeFlags"/>
        <type requires="VkExternalSemaphoreFeatureFlagBits" category="bitmask">typedef <type>VkFlags</type> <name>VkExternalSemaphoreFeatureFlags</name>;</type>
        <type                                             category="bitmask" name="VkExternalSemaphoreFeatureFlagsKHR"        alias="VkExternalSemaphoreFeatureFlags"/>
        <type requires="VkSemaphoreImportFlagBits" category="bitmask">typedef <type>VkFlags</type> <name>VkSemaphoreImportFlags</name>;</type>
        <type                                             category="bitmask" name="VkSemaphoreImportFlagsKHR"                 alias="VkSemaphoreImportFlags"/>
        <type requires="VkExternalFenceHandleTypeFlagBits" category="bitmask">typedef <type>VkFlags</type> <name>VkExternalFenceHandleTypeFlags</name>;</type>
        <type                                             category="bitmask" name="VkExternalFenceHandleTypeFlagsKHR"         alias="VkExternalFenceHandleTypeFlags"/>
        <type requires="VkExternalFenceFeatureFlagBits" category="bitmask">typedef <type>VkFlags</type> <name>VkExternalFenceFeatureFlags</name>;</type>
        <type                                             category="bitmask" name="VkExternalFenceFeatureFlagsKHR"            alias="VkExternalFenceFeatureFlags"/>
        <type requires="VkFenceImportFlagBits" category="bitmask">typedef <type>VkFlags</type> <name>VkFenceImportFlags</name>;</type>
        <type                                             category="bitmask" name="VkFenceImportFlagsKHR"                     alias="VkFenceImportFlags"/>
        <type requires="VkSurfaceCounterFlagBitsEXT"      category="bitmask">typedef <type>VkFlags</type> <name>VkSurfaceCounterFlagsEXT</name>;</type>
        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkPipelineViewportSwizzleStateCreateFlagsNV</name>;</type>
        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkPipelineDiscardRectangleStateCreateFlagsEXT</name>;</type>
        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkPipelineCoverageToColorStateCreateFlagsNV</name>;</type>
        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkPipelineCoverageModulationStateCreateFlagsNV</name>;</type>
        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkPipelineCoverageReductionStateCreateFlagsNV</name>;</type>
        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkValidationCacheCreateFlagsEXT</name>;</type>
        <type requires="VkDebugUtilsMessageSeverityFlagBitsEXT"  category="bitmask">typedef <type>VkFlags</type> <name>VkDebugUtilsMessageSeverityFlagsEXT</name>;</type>
        <type requires="VkDebugUtilsMessageTypeFlagBitsEXT"      category="bitmask">typedef <type>VkFlags</type> <name>VkDebugUtilsMessageTypeFlagsEXT</name>;</type>
        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkDebugUtilsMessengerCreateFlagsEXT</name>;</type>
        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkDebugUtilsMessengerCallbackDataFlagsEXT</name>;</type>
        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkPipelineRasterizationConservativeStateCreateFlagsEXT</name>;</type>
        <type requires="VkDescriptorBindingFlagBitsEXT" category="bitmask">typedef <type>VkFlags</type> <name>VkDescriptorBindingFlagsEXT</name>;</type>
        <type requires="VkConditionalRenderingFlagBitsEXT"   category="bitmask">typedef <type>VkFlags</type> <name>VkConditionalRenderingFlagsEXT</name>;</type>
        <type requires="VkResolveModeFlagBitsKHR"         category="bitmask">typedef <type>VkFlags</type> <name>VkResolveModeFlagsKHR</name>;</type>
        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkPipelineRasterizationStateStreamCreateFlagsEXT</name>;</type>
        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkPipelineRasterizationDepthClipStateCreateFlagsEXT</name>;</type>


            <comment>Types which can be void pointers or class pointers, selected at compile time</comment>
        <type category="handle"><type>VK_DEFINE_HANDLE</type>(<name>VkInstance</name>)</type>
        <type category="handle" parent="VkInstance"><type>VK_DEFINE_HANDLE</type>(<name>VkPhysicalDevice</name>)</type>
        <type category="handle" parent="VkPhysicalDevice"><type>VK_DEFINE_HANDLE</type>(<name>VkDevice</name>)</type>
        <type category="handle" parent="VkDevice"><type>VK_DEFINE_HANDLE</type>(<name>VkQueue</name>)</type>
        <type category="handle" parent="VkCommandPool"><type>VK_DEFINE_HANDLE</type>(<name>VkCommandBuffer</name>)</type>
        <type category="handle" parent="VkDevice"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkDeviceMemory</name>)</type>
        <type category="handle" parent="VkDevice"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkCommandPool</name>)</type>
        <type category="handle" parent="VkDevice"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkBuffer</name>)</type>
        <type category="handle" parent="VkDevice"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkBufferView</name>)</type>
        <type category="handle" parent="VkDevice"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkImage</name>)</type>
        <type category="handle" parent="VkDevice"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkImageView</name>)</type>
        <type category="handle" parent="VkDevice"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkShaderModule</name>)</type>
        <type category="handle" parent="VkDevice"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkPipeline</name>)</type>
        <type category="handle" parent="VkDevice"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkPipelineLayout</name>)</type>
        <type category="handle" parent="VkDevice"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkSampler</name>)</type>
        <type category="handle" parent="VkDescriptorPool"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkDescriptorSet</name>)</type>
        <type category="handle" parent="VkDevice"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkDescriptorSetLayout</name>)</type>
        <type category="handle" parent="VkDevice"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkDescriptorPool</name>)</type>
        <type category="handle" parent="VkDevice"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkFence</name>)</type>
        <type category="handle" parent="VkDevice"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkSemaphore</name>)</type>
        <type category="handle" parent="VkDevice"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkEvent</name>)</type>
        <type category="handle" parent="VkDevice"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkQueryPool</name>)</type>
        <type category="handle" parent="VkDevice"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkFramebuffer</name>)</type>
        <type category="handle" parent="VkDevice"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkRenderPass</name>)</type>
        <type category="handle" parent="VkDevice"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkPipelineCache</name>)</type>
        <type category="handle" parent="VkDevice"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkObjectTableNVX</name>)</type>
        <type category="handle" parent="VkDevice"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkIndirectCommandsLayoutNVX</name>)</type>
        <type category="handle" parent="VkDevice"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkDescriptorUpdateTemplate</name>)</type>
        <type category="handle" name="VkDescriptorUpdateTemplateKHR" alias="VkDescriptorUpdateTemplate"/>
        <type category="handle" parent="VkDevice"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkSamplerYcbcrConversion</name>)</type>
        <type category="handle" name="VkSamplerYcbcrConversionKHR"   alias="VkSamplerYcbcrConversion"/>
        <type category="handle" parent="VkDevice"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkValidationCacheEXT</name>)</type>
        <type category="handle" parent="VkDevice"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkAccelerationStructureNV</name>)</type>
        <type category="handle" parent="VkDevice"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkPerformanceConfigurationINTEL</name>)</type>

            <comment>WSI extensions</comment>
        <type category="handle"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkDisplayKHR</name>)</type>
        <type category="handle" parent="VkPhysicalDevice,VkDisplayKHR"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkDisplayModeKHR</name>)</type>
        <type category="handle" parent="VkInstance"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkSurfaceKHR</name>)</type>
        <type category="handle" parent="VkSurfaceKHR"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkSwapchainKHR</name>)</type>
        <type category="handle" parent="VkInstance"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkDebugReportCallbackEXT</name>)</type>
        <type category="handle" parent="VkInstance"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkDebugUtilsMessengerEXT</name>)</type>

            <comment>Types generated from corresponding enums tags below</comment>
        <type name="VkAttachmentLoadOp" category="enum"/>
        <type name="VkAttachmentStoreOp" category="enum"/>
        <type name="VkBlendFactor" category="enum"/>
        <type name="VkBlendOp" category="enum"/>
        <type name="VkBorderColor" category="enum"/>
        <type name="VkFramebufferCreateFlagBits" category="enum"/>
        <type name="VkQueryPoolCreateFlagBits" category="enum"/>
        <type name="VkRenderPassCreateFlagBits" category="enum"/>
        <type name="VkSamplerCreateFlagBits" category="enum"/>
        <type name="VkPipelineCacheHeaderVersion" category="enum"/>
        <type name="VkPipelineLayoutCreateFlagBits" category="enum"/>
        <type name="VkPipelineCacheCreateFlagBits" category="enum"/>
        <type name="VkPipelineDepthStencilStateCreateFlagBits" category="enum"/>
        <type name="VkPipelineDynamicStateCreateFlagBits" category="enum"/>
        <type name="VkPipelineColorBlendStateCreateFlagBits" category="enum"/>
        <type name="VkPipelineMultisampleStateCreateFlagBits" category="enum"/>
        <type name="VkPipelineRasterizationStateCreateFlagBits" category="enum"/>
        <type name="VkPipelineViewportStateCreateFlagBits" category="enum"/>
        <type name="VkPipelineTessellationStateCreateFlagBits" category="enum"/>
        <type name="VkPipelineInputAssemblyStateCreateFlagBits" category="enum"/>
        <type name="VkPipelineVertexInputStateCreateFlagBits" category="enum"/>
        <type name="VkPipelineShaderStageCreateFlagBits" category="enum"/>
        <type name="VkDescriptorSetLayoutCreateFlagBits" category="enum"/>
        <type name="VkBufferViewCreateFlagBits" category="enum"/>
        <type name="VkInstanceCreateFlagBits" category="enum"/>
        <type name="VkDeviceQueueCreateFlagBits" category="enum"/>
        <type name="VkBufferCreateFlagBits" category="enum"/>
        <type name="VkBufferUsageFlagBits" category="enum"/>
        <type name="VkColorComponentFlagBits" category="enum"/>
        <type name="VkComponentSwizzle" category="enum"/>
        <type name="VkCommandPoolCreateFlagBits" category="enum"/>
        <type name="VkCommandPoolResetFlagBits" category="enum"/>
        <type name="VkCommandBufferResetFlagBits" category="enum"/>
        <type name="VkCommandBufferLevel" category="enum"/>
        <type name="VkCommandBufferUsageFlagBits" category="enum"/>
        <type name="VkCompareOp" category="enum"/>
        <type name="VkCullModeFlagBits" category="enum"/>
        <type name="VkDescriptorType" category="enum"/>
        <type name="VkDeviceCreateFlagBits" category="enum"/>
        <type name="VkDynamicState" category="enum"/>
        <type name="VkFenceCreateFlagBits" category="enum"/>
        <type name="VkPolygonMode" category="enum"/>
        <type name="VkFormat" category="enum"/>
        <type name="VkFormatFeatureFlagBits" category="enum"/>
        <type name="VkFrontFace" category="enum"/>
        <type name="VkImageAspectFlagBits" category="enum"/>
        <type name="VkImageCreateFlagBits" category="enum"/>
        <type name="VkImageLayout" category="enum"/>
        <type name="VkImageTiling" category="enum"/>
        <type name="VkImageType" category="enum"/>
        <type name="VkImageUsageFlagBits" category="enum"/>
        <type name="VkImageViewCreateFlagBits" category="enum"/>
        <type name="VkImageViewType" category="enum"/>
        <type name="VkSharingMode" category="enum"/>
        <type name="VkIndexType" category="enum"/>
        <type name="VkLogicOp" category="enum"/>
        <type name="VkMemoryHeapFlagBits" category="enum"/>
        <type name="VkAccessFlagBits" category="enum"/>
        <type name="VkMemoryPropertyFlagBits" category="enum"/>
        <type name="VkPhysicalDeviceType" category="enum"/>
        <type name="VkPipelineBindPoint" category="enum"/>
        <type name="VkPipelineCreateFlagBits" category="enum"/>
        <type name="VkPrimitiveTopology" category="enum"/>
        <type name="VkQueryControlFlagBits" category="enum"/>
        <type name="VkQueryPipelineStatisticFlagBits" category="enum"/>
        <type name="VkQueryResultFlagBits" category="enum"/>
        <type name="VkQueryType" category="enum"/>
        <type name="VkQueueFlagBits" category="enum"/>
        <type name="VkSubpassContents" category="enum"/>
        <type name="VkResult" category="enum"/>
        <type name="VkShaderStageFlagBits" category="enum"/>
        <type name="VkSparseMemoryBindFlagBits" category="enum"/>
        <type name="VkStencilFaceFlagBits" category="enum"/>
        <type name="VkStencilOp" category="enum"/>
        <type name="VkStructureType" category="enum"/>
        <type name="VkSystemAllocationScope" category="enum"/>
        <type name="VkInternalAllocationType" category="enum"/>
        <type name="VkSamplerAddressMode" category="enum"/>
        <type name="VkFilter" category="enum"/>
        <type name="VkSamplerMipmapMode" category="enum"/>
        <type name="VkVertexInputRate" category="enum"/>
        <type name="VkPipelineStageFlagBits" category="enum"/>
        <type name="VkSparseImageFormatFlagBits" category="enum"/>
        <type name="VkSampleCountFlagBits" category="enum"/>
        <type name="VkAttachmentDescriptionFlagBits" category="enum"/>
        <type name="VkDescriptorPoolCreateFlagBits" category="enum"/>
        <type name="VkDependencyFlagBits" category="enum"/>
        <type name="VkObjectType" category="enum"/>
        <type name="VkDescriptorBindingFlagBitsEXT" category="enum"/>
        <type name="VkConditionalRenderingFlagBitsEXT" category="enum"/>

        <comment>Extensions</comment>
        <type name="VkIndirectCommandsLayoutUsageFlagBitsNVX" category="enum"/>
        <type name="VkIndirectCommandsTokenTypeNVX" category="enum"/>
        <type name="VkObjectEntryUsageFlagBitsNVX" category="enum"/>
        <type name="VkObjectEntryTypeNVX" category="enum"/>
        <type name="VkDescriptorUpdateTemplateType" category="enum"/>
        <type category="enum" name="VkDescriptorUpdateTemplateTypeKHR"             alias="VkDescriptorUpdateTemplateType"/>
        <type name="VkViewportCoordinateSwizzleNV" category="enum"/>
        <type name="VkDiscardRectangleModeEXT" category="enum"/>
        <type name="VkSubpassDescriptionFlagBits" category="enum"/>
        <type name="VkPointClippingBehavior" category="enum"/>
        <type category="enum" name="VkPointClippingBehaviorKHR"                    alias="VkPointClippingBehavior"/>
        <type name="VkCoverageModulationModeNV" category="enum"/>
        <type name="VkCoverageReductionModeNV" category="enum"/>
        <type name="VkValidationCacheHeaderVersionEXT" category="enum"/>
        <type name="VkShaderInfoTypeAMD" category="enum"/>
        <type name="VkQueueGlobalPriorityEXT" category="enum"/>
        <type name="VkTimeDomainEXT" category="enum"/>
        <type name="VkConservativeRasterizationModeEXT" category="enum"/>
        <type name="VkResolveModeFlagBitsKHR" category="enum"/>
        <type name="VkGeometryFlagBitsNV" category="enum"/>
        <type name="VkGeometryInstanceFlagBitsNV" category="enum"/>
        <type name="VkBuildAccelerationStructureFlagBitsNV" category="enum"/>
        <type name="VkCopyAccelerationStructureModeNV" category="enum"/>
        <type name="VkAccelerationStructureTypeNV" category="enum"/>
        <type name="VkGeometryTypeNV" category="enum"/>
        <type name="VkRayTracingShaderGroupTypeNV" category="enum"/>
        <type name="VkAccelerationStructureMemoryRequirementsTypeNV" category="enum"/>
        <type name="VkMemoryOverallocationBehaviorAMD" category="enum"/>
        <type name="VkScopeNV" category="enum"/>
        <type name="VkComponentTypeNV" category="enum"/>
        <type name="VkPipelineCreationFeedbackFlagBitsEXT" category="enum"/>
        <type name="VkPerformanceConfigurationTypeINTEL" category="enum"/>
        <type name="VkQueryPoolSamplingModeINTEL" category="enum"/>
        <type name="VkPerformanceOverrideTypeINTEL" category="enum"/>
        <type name="VkPerformanceParameterTypeINTEL" category="enum"/>
        <type name="VkPerformanceValueTypeINTEL" category="enum"/>

            <comment>WSI extensions</comment>
        <type name="VkColorSpaceKHR" category="enum"/>
        <type name="VkCompositeAlphaFlagBitsKHR" category="enum"/>
        <type name="VkDisplayPlaneAlphaFlagBitsKHR" category="enum"/>
        <type name="VkPresentModeKHR" category="enum"/>
        <type name="VkSurfaceTransformFlagBitsKHR" category="enum"/>
        <type name="VkDebugReportFlagBitsEXT" category="enum"/>
        <type name="VkDebugReportObjectTypeEXT" category="enum"/>
        <type name="VkRasterizationOrderAMD" category="enum"/>
        <type name="VkExternalMemoryHandleTypeFlagBitsNV" category="enum"/>
        <type name="VkExternalMemoryFeatureFlagBitsNV" category="enum"/>
        <type name="VkValidationCheckEXT" category="enum"/>
        <type name="VkValidationFeatureEnableEXT" category="enum"/>
        <type name="VkValidationFeatureDisableEXT" category="enum"/>
        <type name="VkExternalMemoryHandleTypeFlagBits" category="enum"/>
        <type category="enum" name="VkExternalMemoryHandleTypeFlagBitsKHR"         alias="VkExternalMemoryHandleTypeFlagBits"/>
        <type name="VkExternalMemoryFeatureFlagBits" category="enum"/>
        <type category="enum" name="VkExternalMemoryFeatureFlagBitsKHR"            alias="VkExternalMemoryFeatureFlagBits"/>
        <type name="VkExternalSemaphoreHandleTypeFlagBits" category="enum"/>
        <type category="enum" name="VkExternalSemaphoreHandleTypeFlagBitsKHR"      alias="VkExternalSemaphoreHandleTypeFlagBits"/>
        <type name="VkExternalSemaphoreFeatureFlagBits" category="enum"/>
        <type category="enum" name="VkExternalSemaphoreFeatureFlagBitsKHR"         alias="VkExternalSemaphoreFeatureFlagBits"/>
        <type name="VkSemaphoreImportFlagBits" category="enum"/>
        <type category="enum" name="VkSemaphoreImportFlagBitsKHR"                  alias="VkSemaphoreImportFlagBits"/>
        <type name="VkExternalFenceHandleTypeFlagBits" category="enum"/>
        <type category="enum" name="VkExternalFenceHandleTypeFlagBitsKHR"          alias="VkExternalFenceHandleTypeFlagBits"/>
        <type name="VkExternalFenceFeatureFlagBits" category="enum"/>
        <type category="enum" name="VkExternalFenceFeatureFlagBitsKHR"             alias="VkExternalFenceFeatureFlagBits"/>
        <type name="VkFenceImportFlagBits" category="enum"/>
        <type category="enum" name="VkFenceImportFlagBitsKHR"                      alias="VkFenceImportFlagBits"/>
        <type name="VkSurfaceCounterFlagBitsEXT" category="enum"/>
        <type name="VkDisplayPowerStateEXT" category="enum"/>
        <type name="VkDeviceEventTypeEXT" category="enum"/>
        <type name="VkDisplayEventTypeEXT" category="enum"/>
        <type name="VkPeerMemoryFeatureFlagBits" category="enum"/>
        <type category="enum" name="VkPeerMemoryFeatureFlagBitsKHR"                alias="VkPeerMemoryFeatureFlagBits"/>
        <type name="VkMemoryAllocateFlagBits" category="enum"/>
        <type category="enum" name="VkMemoryAllocateFlagBitsKHR"                   alias="VkMemoryAllocateFlagBits"/>
        <type name="VkDeviceGroupPresentModeFlagBitsKHR" category="enum"/>
        <type name="VkSwapchainCreateFlagBitsKHR" category="enum"/>
        <type name="VkSubgroupFeatureFlagBits" category="enum"/>
        <type name="VkTessellationDomainOrigin" category="enum"/>
        <type category="enum" name="VkTessellationDomainOriginKHR"                 alias="VkTessellationDomainOrigin"/>
        <type name="VkSamplerYcbcrModelConversion" category="enum"/>
        <type category="enum" name="VkSamplerYcbcrModelConversionKHR"              alias="VkSamplerYcbcrModelConversion"/>
        <type name="VkSamplerYcbcrRange" category="enum"/>
        <type category="enum" name="VkSamplerYcbcrRangeKHR"                        alias="VkSamplerYcbcrRange"/>
        <type name="VkChromaLocation" category="enum"/>
        <type category="enum" name="VkChromaLocationKHR"                           alias="VkChromaLocation"/>
        <type name="VkSamplerReductionModeEXT" category="enum"/>
        <type name="VkBlendOverlapEXT" category="enum"/>
        <type name="VkDebugUtilsMessageSeverityFlagBitsEXT" category="enum"/>
        <type name="VkDebugUtilsMessageTypeFlagBitsEXT" category="enum"/>
        <type name="VkFullScreenExclusiveEXT" category="enum"/>

            <comment>Enumerated types in the header, but not used by the API</comment>
        <type name="VkVendorId" category="enum"/>
        <type name="VkDriverIdKHR" category="enum"/>
        <type name="VkShadingRatePaletteEntryNV" category="enum"/>
        <type name="VkCoarseSampleOrderTypeNV" category="enum"/>

        <comment>The PFN_vk*Function types are used by VkAllocationCallbacks below</comment>
        <type category="funcpointer">typedef void (VKAPI_PTR *<name>PFN_vkInternalAllocationNotification</name>)(
    <type>void</type>*                                       pUserData,
    <type>size_t</type>                                      size,
    <type>VkInternalAllocationType</type>                    allocationType,
    <type>VkSystemAllocationScope</type>                     allocationScope);</type>
        <type category="funcpointer">typedef void (VKAPI_PTR *<name>PFN_vkInternalFreeNotification</name>)(
    <type>void</type>*                                       pUserData,
    <type>size_t</type>                                      size,
    <type>VkInternalAllocationType</type>                    allocationType,
    <type>VkSystemAllocationScope</type>                     allocationScope);</type>
        <type category="funcpointer">typedef void* (VKAPI_PTR *<name>PFN_vkReallocationFunction</name>)(
    <type>void</type>*                                       pUserData,
    <type>void</type>*                                       pOriginal,
    <type>size_t</type>                                      size,
    <type>size_t</type>                                      alignment,
    <type>VkSystemAllocationScope</type>                     allocationScope);</type>
        <type category="funcpointer">typedef void* (VKAPI_PTR *<name>PFN_vkAllocationFunction</name>)(
    <type>void</type>*                                       pUserData,
    <type>size_t</type>                                      size,
    <type>size_t</type>                                      alignment,
    <type>VkSystemAllocationScope</type>                     allocationScope);</type>
        <type category="funcpointer">typedef void (VKAPI_PTR *<name>PFN_vkFreeFunction</name>)(
    <type>void</type>*                                       pUserData,
    <type>void</type>*                                       pMemory);</type>

            <comment>The PFN_vkVoidFunction type are used by VkGet*ProcAddr below</comment>
        <type category="funcpointer">typedef void (VKAPI_PTR *<name>PFN_vkVoidFunction</name>)(void);</type>

            <comment>The PFN_vkDebugReportCallbackEXT type are used by the DEBUG_REPORT extension</comment>
        <type category="funcpointer">typedef VkBool32 (VKAPI_PTR *<name>PFN_vkDebugReportCallbackEXT</name>)(
    <type>VkDebugReportFlagsEXT</type>                       flags,
    <type>VkDebugReportObjectTypeEXT</type>                  objectType,
    <type>uint64_t</type>                                    object,
    <type>size_t</type>                                      location,
    <type>int32_t</type>                                     messageCode,
    const <type>char</type>*                                 pLayerPrefix,
    const <type>char</type>*                                 pMessage,
    <type>void</type>*                                       pUserData);</type>

            <comment>The PFN_vkDebugUtilsMessengerCallbackEXT type are used by the VK_EXT_debug_utils extension</comment>
        <type category="funcpointer" requires="VkDebugUtilsMessengerCallbackDataEXT">typedef VkBool32 (VKAPI_PTR *<name>PFN_vkDebugUtilsMessengerCallbackEXT</name>)(
    <type>VkDebugUtilsMessageSeverityFlagBitsEXT</type>           messageSeverity,
    <type>VkDebugUtilsMessageTypeFlagsEXT</type>                  messageTypes,
    const <type>VkDebugUtilsMessengerCallbackDataEXT</type>*      pCallbackData,
    <type>void</type>*                                            pUserData);</type>

            <comment>Struct types</comment>
        <type category="struct" name="VkBaseOutStructure">
            <member><type>VkStructureType</type> <name>sType</name></member>
            <member>struct <type>VkBaseOutStructure</type>* <name>pNext</name></member>
        </type>
        <type category="struct" name="VkBaseInStructure">
            <member><type>VkStructureType</type> <name>sType</name></member>
            <member>const struct <type>VkBaseInStructure</type>* <name>pNext</name></member>
        </type>
        <type category="struct" name="VkOffset2D">
            <member><type>int32_t</type>        <name>x</name></member>
            <member><type>int32_t</type>        <name>y</name></member>
        </type>
        <type category="struct" name="VkOffset3D">
            <member><type>int32_t</type>        <name>x</name></member>
            <member><type>int32_t</type>        <name>y</name></member>
            <member><type>int32_t</type>        <name>z</name></member>
        </type>
        <type category="struct" name="VkExtent2D">
            <member><type>uint32_t</type>        <name>width</name></member>
            <member><type>uint32_t</type>        <name>height</name></member>
        </type>
        <type category="struct" name="VkExtent3D">
            <member><type>uint32_t</type>        <name>width</name></member>
            <member><type>uint32_t</type>        <name>height</name></member>
            <member><type>uint32_t</type>        <name>depth</name></member>
        </type>
        <type category="struct" name="VkViewport">
            <member noautovalidity="true"><type>float</type> <name>x</name></member>
            <member noautovalidity="true"><type>float</type> <name>y</name></member>
            <member noautovalidity="true"><type>float</type> <name>width</name></member>
            <member noautovalidity="true"><type>float</type> <name>height</name></member>
            <member><type>float</type>                       <name>minDepth</name></member>
            <member><type>float</type>                       <name>maxDepth</name></member>
        </type>
        <type category="struct" name="VkRect2D">
            <member><type>VkOffset2D</type>     <name>offset</name></member>
            <member><type>VkExtent2D</type>     <name>extent</name></member>
        </type>
        <type category="struct" name="VkClearRect">
            <member><type>VkRect2D</type>       <name>rect</name></member>
            <member><type>uint32_t</type>       <name>baseArrayLayer</name></member>
            <member><type>uint32_t</type>       <name>layerCount</name></member>
        </type>
        <type category="struct" name="VkComponentMapping">
            <member><type>VkComponentSwizzle</type> <name>r</name></member>
            <member><type>VkComponentSwizzle</type> <name>g</name></member>
            <member><type>VkComponentSwizzle</type> <name>b</name></member>
            <member><type>VkComponentSwizzle</type> <name>a</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceProperties" returnedonly="true">
            <member><type>uint32_t</type>       <name>apiVersion</name></member>
            <member><type>uint32_t</type>       <name>driverVersion</name></member>
            <member><type>uint32_t</type>       <name>vendorID</name></member>
            <member><type>uint32_t</type>       <name>deviceID</name></member>
            <member><type>VkPhysicalDeviceType</type> <name>deviceType</name></member>
            <member><type>char</type>           <name>deviceName</name>[<enum>VK_MAX_PHYSICAL_DEVICE_NAME_SIZE</enum>]</member>
            <member><type>uint8_t</type>        <name>pipelineCacheUUID</name>[<enum>VK_UUID_SIZE</enum>]</member>
            <member><type>VkPhysicalDeviceLimits</type> <name>limits</name></member>
            <member><type>VkPhysicalDeviceSparseProperties</type> <name>sparseProperties</name></member>
        </type>
        <type category="struct" name="VkExtensionProperties" returnedonly="true">
            <member><type>char</type>            <name>extensionName</name>[<enum>VK_MAX_EXTENSION_NAME_SIZE</enum>]<comment>extension name</comment></member>
            <member><type>uint32_t</type>        <name>specVersion</name><comment>version of the extension specification implemented</comment></member>
        </type>
        <type category="struct" name="VkLayerProperties" returnedonly="true">
            <member><type>char</type>            <name>layerName</name>[<enum>VK_MAX_EXTENSION_NAME_SIZE</enum>]<comment>layer name</comment></member>
            <member><type>uint32_t</type>        <name>specVersion</name><comment>version of the layer specification implemented</comment></member>
            <member><type>uint32_t</type>        <name>implementationVersion</name><comment>build or release version of the layer's library</comment></member>
            <member><type>char</type>            <name>description</name>[<enum>VK_MAX_DESCRIPTION_SIZE</enum>]<comment>Free-form description of the layer</comment></member>
        </type>
        <type category="struct" name="VkApplicationInfo">
            <member values="VK_STRUCTURE_TYPE_APPLICATION_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*     <name>pNext</name></member>
            <member optional="true" len="null-terminated">const <type>char</type>*     <name>pApplicationName</name></member>
            <member><type>uint32_t</type>        <name>applicationVersion</name></member>
            <member optional="true" len="null-terminated">const <type>char</type>*     <name>pEngineName</name></member>
            <member><type>uint32_t</type>        <name>engineVersion</name></member>
            <member><type>uint32_t</type>        <name>apiVersion</name></member>
        </type>
        <type category="struct" name="VkAllocationCallbacks">
            <member optional="true"><type>void</type>*           <name>pUserData</name></member>
            <member noautovalidity="true"><type>PFN_vkAllocationFunction</type>   <name>pfnAllocation</name></member>
            <member noautovalidity="true"><type>PFN_vkReallocationFunction</type> <name>pfnReallocation</name></member>
            <member noautovalidity="true"><type>PFN_vkFreeFunction</type>    <name>pfnFree</name></member>
            <member optional="true" noautovalidity="true"><type>PFN_vkInternalAllocationNotification</type> <name>pfnInternalAllocation</name></member>
            <member optional="true" noautovalidity="true"><type>PFN_vkInternalFreeNotification</type> <name>pfnInternalFree</name></member>
        </type>
        <type category="struct" name="VkDeviceQueueCreateInfo">
            <member values="VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*     <name>pNext</name></member>
            <member optional="true"><type>VkDeviceQueueCreateFlags</type>    <name>flags</name></member>
            <member><type>uint32_t</type>        <name>queueFamilyIndex</name></member>
            <member><type>uint32_t</type>        <name>queueCount</name></member>
            <member len="queueCount">const <type>float</type>*    <name>pQueuePriorities</name></member>
        </type>
        <type category="struct" name="VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*     <name>pNext</name></member>
            <member optional="true"><type>VkDeviceCreateFlags</type>    <name>flags</name></member>
            <member><type>uint32_t</type>        <name>queueCreateInfoCount</name></member>
            <member len="queueCreateInfoCount">const <type>VkDeviceQueueCreateInfo</type>* <name>pQueueCreateInfos</name></member>
            <member optional="true"><type>uint32_t</type>               <name>enabledLayerCount</name></member>
            <member len="enabledLayerCount,null-terminated">const <type>char</type>* const*      <name>ppEnabledLayerNames</name><comment>Ordered list of layer names to be enabled</comment></member>
            <member optional="true"><type>uint32_t</type>               <name>enabledExtensionCount</name></member>
            <member len="enabledExtensionCount,null-terminated">const <type>char</type>* const*      <name>ppEnabledExtensionNames</name></member>
            <member optional="true">const <type>VkPhysicalDeviceFeatures</type>* <name>pEnabledFeatures</name></member>
        </type>
        <type category="struct" name="VkInstanceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*     <name>pNext</name></member>
            <member optional="true"><type>VkInstanceCreateFlags</type>  <name>flags</name></member>
            <member optional="true">const <type>VkApplicationInfo</type>* <name>pApplicationInfo</name></member>
            <member optional="true"><type>uint32_t</type>               <name>enabledLayerCount</name></member>
            <member len="enabledLayerCount,null-terminated">const <type>char</type>* const*      <name>ppEnabledLayerNames</name><comment>Ordered list of layer names to be enabled</comment></member>
            <member optional="true"><type>uint32_t</type>               <name>enabledExtensionCount</name></member>
            <member len="enabledExtensionCount,null-terminated">const <type>char</type>* const*      <name>ppEnabledExtensionNames</name><comment>Extension names to be enabled</comment></member>
        </type>
        <type category="struct" name="VkQueueFamilyProperties" returnedonly="true">
            <member optional="true"><type>VkQueueFlags</type>           <name>queueFlags</name><comment>Queue flags</comment></member>
            <member><type>uint32_t</type>               <name>queueCount</name></member>
            <member><type>uint32_t</type>               <name>timestampValidBits</name></member>
            <member><type>VkExtent3D</type>             <name>minImageTransferGranularity</name><comment>Minimum alignment requirement for image transfers</comment></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceMemoryProperties" returnedonly="true">
            <member><type>uint32_t</type>               <name>memoryTypeCount</name></member>
            <member><type>VkMemoryType</type>           <name>memoryTypes</name>[<enum>VK_MAX_MEMORY_TYPES</enum>]</member>
            <member><type>uint32_t</type>               <name>memoryHeapCount</name></member>
            <member><type>VkMemoryHeap</type>           <name>memoryHeaps</name>[<enum>VK_MAX_MEMORY_HEAPS</enum>]</member>
        </type>
        <type category="struct" name="VkMemoryAllocateInfo">
            <member values="VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*            <name>pNext</name></member>
            <member><type>VkDeviceSize</type>           <name>allocationSize</name><comment>Size of memory allocation</comment></member>
            <member><type>uint32_t</type>               <name>memoryTypeIndex</name><comment>Index of the of the memory type to allocate from</comment></member>
        </type>
        <type category="struct" name="VkMemoryRequirements" returnedonly="true">
            <member><type>VkDeviceSize</type>           <name>size</name><comment>Specified in bytes</comment></member>
            <member><type>VkDeviceSize</type>           <name>alignment</name><comment>Specified in bytes</comment></member>
            <member><type>uint32_t</type>               <name>memoryTypeBits</name><comment>Bitmask of the allowed memory type indices into memoryTypes[] for this object</comment></member>
        </type>
        <type category="struct" name="VkSparseImageFormatProperties" returnedonly="true">
            <member optional="true"><type>VkImageAspectFlags</type>     <name>aspectMask</name></member>
            <member><type>VkExtent3D</type>             <name>imageGranularity</name></member>
            <member optional="true"><type>VkSparseImageFormatFlags</type> <name>flags</name></member>
        </type>
        <type category="struct" name="VkSparseImageMemoryRequirements" returnedonly="true">
            <member><type>VkSparseImageFormatProperties</type> <name>formatProperties</name></member>
            <member><type>uint32_t</type>               <name>imageMipTailFirstLod</name></member>
            <member><type>VkDeviceSize</type>           <name>imageMipTailSize</name><comment>Specified in bytes, must be a multiple of sparse block size in bytes / alignment</comment></member>
            <member><type>VkDeviceSize</type>           <name>imageMipTailOffset</name><comment>Specified in bytes, must be a multiple of sparse block size in bytes / alignment</comment></member>
            <member><type>VkDeviceSize</type>           <name>imageMipTailStride</name><comment>Specified in bytes, must be a multiple of sparse block size in bytes / alignment</comment></member>
        </type>
        <type category="struct" name="VkMemoryType" returnedonly="true">
            <member optional="true"><type>VkMemoryPropertyFlags</type>  <name>propertyFlags</name><comment>Memory properties of this memory type</comment></member>
            <member><type>uint32_t</type>               <name>heapIndex</name><comment>Index of the memory heap allocations of this memory type are taken from</comment></member>
        </type>
        <type category="struct" name="VkMemoryHeap" returnedonly="true">
            <member><type>VkDeviceSize</type>           <name>size</name><comment>Available memory in the heap</comment></member>
            <member optional="true"><type>VkMemoryHeapFlags</type>      <name>flags</name><comment>Flags for the heap</comment></member>
        </type>
        <type category="struct" name="VkMappedMemoryRange">
            <member values="VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*            <name>pNext</name></member>
            <member><type>VkDeviceMemory</type>         <name>memory</name><comment>Mapped memory object</comment></member>
            <member><type>VkDeviceSize</type>           <name>offset</name><comment>Offset within the memory object where the range starts</comment></member>
            <member><type>VkDeviceSize</type>           <name>size</name><comment>Size of the range within the memory object</comment></member>
        </type>
        <type category="struct" name="VkFormatProperties" returnedonly="true">
            <member optional="true"><type>VkFormatFeatureFlags</type>   <name>linearTilingFeatures</name><comment>Format features in case of linear tiling</comment></member>
            <member optional="true"><type>VkFormatFeatureFlags</type>   <name>optimalTilingFeatures</name><comment>Format features in case of optimal tiling</comment></member>
            <member optional="true"><type>VkFormatFeatureFlags</type>   <name>bufferFeatures</name><comment>Format features supported by buffers</comment></member>
        </type>
        <type category="struct" name="VkImageFormatProperties" returnedonly="true">
            <member><type>VkExtent3D</type>             <name>maxExtent</name><comment>max image dimensions for this resource type</comment></member>
            <member><type>uint32_t</type>               <name>maxMipLevels</name><comment>max number of mipmap levels for this resource type</comment></member>
            <member><type>uint32_t</type>               <name>maxArrayLayers</name><comment>max array size for this resource type</comment></member>
            <member optional="true"><type>VkSampleCountFlags</type>     <name>sampleCounts</name><comment>supported sample counts for this resource type</comment></member>
            <member><type>VkDeviceSize</type>           <name>maxResourceSize</name><comment>max size (in bytes) of this resource type</comment></member>
        </type>
        <type category="struct" name="VkDescriptorBufferInfo">
            <member><type>VkBuffer</type>               <name>buffer</name><comment>Buffer used for this descriptor slot.</comment></member>
            <member><type>VkDeviceSize</type>           <name>offset</name><comment>Base offset from buffer start in bytes to update in the descriptor set.</comment></member>
            <member><type>VkDeviceSize</type>           <name>range</name><comment>Size in bytes of the buffer resource for this descriptor update.</comment></member>
        </type>
        <type category="struct" name="VkDescriptorImageInfo">
            <member noautovalidity="true"><type>VkSampler</type>       <name>sampler</name><comment>Sampler to write to the descriptor in case it is a SAMPLER or COMBINED_IMAGE_SAMPLER descriptor. Ignored otherwise.</comment></member>
            <member noautovalidity="true"><type>VkImageView</type>     <name>imageView</name><comment>Image view to write to the descriptor in case it is a SAMPLED_IMAGE, STORAGE_IMAGE, COMBINED_IMAGE_SAMPLER, or INPUT_ATTACHMENT descriptor. Ignored otherwise.</comment></member>
            <member noautovalidity="true"><type>VkImageLayout</type>   <name>imageLayout</name><comment>Layout the image is expected to be in when accessed using this descriptor (only used if imageView is not VK_NULL_HANDLE).</comment></member>
        </type>
        <type category="struct" name="VkWriteDescriptorSet">
            <member values="VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*            <name>pNext</name></member>
            <member noautovalidity="true"><type>VkDescriptorSet</type>        <name>dstSet</name><comment>Destination descriptor set</comment></member>
            <member><type>uint32_t</type>               <name>dstBinding</name><comment>Binding within the destination descriptor set to write</comment></member>
            <member><type>uint32_t</type>               <name>dstArrayElement</name><comment>Array element within the destination binding to write</comment></member>
            <member><type>uint32_t</type>               <name>descriptorCount</name><comment>Number of descriptors to write (determines the size of the array pointed by pDescriptors)</comment></member>
            <member><type>VkDescriptorType</type>       <name>descriptorType</name><comment>Descriptor type to write (determines which members of the array pointed by pDescriptors are going to be used)</comment></member>
            <member noautovalidity="true" len="descriptorCount">const <type>VkDescriptorImageInfo</type>* <name>pImageInfo</name><comment>Sampler, image view, and layout for SAMPLER, COMBINED_IMAGE_SAMPLER, {SAMPLED,STORAGE}_IMAGE, and INPUT_ATTACHMENT descriptor types.</comment></member>
            <member noautovalidity="true" len="descriptorCount">const <type>VkDescriptorBufferInfo</type>* <name>pBufferInfo</name><comment>Raw buffer, size, and offset for {UNIFORM,STORAGE}_BUFFER[_DYNAMIC] descriptor types.</comment></member>
            <member noautovalidity="true" len="descriptorCount">const <type>VkBufferView</type>*    <name>pTexelBufferView</name><comment>Buffer view to write to the descriptor for {UNIFORM,STORAGE}_TEXEL_BUFFER descriptor types.</comment></member>
        </type>
        <type category="struct" name="VkCopyDescriptorSet">
            <member values="VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*            <name>pNext</name></member>
            <member><type>VkDescriptorSet</type>        <name>srcSet</name><comment>Source descriptor set</comment></member>
            <member><type>uint32_t</type>               <name>srcBinding</name><comment>Binding within the source descriptor set to copy from</comment></member>
            <member><type>uint32_t</type>               <name>srcArrayElement</name><comment>Array element within the source binding to copy from</comment></member>
            <member><type>VkDescriptorSet</type>        <name>dstSet</name><comment>Destination descriptor set</comment></member>
            <member><type>uint32_t</type>               <name>dstBinding</name><comment>Binding within the destination descriptor set to copy to</comment></member>
            <member><type>uint32_t</type>               <name>dstArrayElement</name><comment>Array element within the destination binding to copy to</comment></member>
            <member><type>uint32_t</type>               <name>descriptorCount</name><comment>Number of descriptors to write (determines the size of the array pointed by pDescriptors)</comment></member>
        </type>
        <type category="struct" name="VkBufferCreateInfo">
            <member values="VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*            <name>pNext</name></member>
            <member optional="true"><type>VkBufferCreateFlags</type>    <name>flags</name><comment>Buffer creation flags</comment></member>
            <member><type>VkDeviceSize</type>           <name>size</name><comment>Specified in bytes</comment></member>
            <member><type>VkBufferUsageFlags</type>     <name>usage</name><comment>Buffer usage flags</comment></member>
            <member><type>VkSharingMode</type>          <name>sharingMode</name></member>
            <member optional="true"><type>uint32_t</type>               <name>queueFamilyIndexCount</name></member>
            <member noautovalidity="true" len="queueFamilyIndexCount">const <type>uint32_t</type>*        <name>pQueueFamilyIndices</name></member>
        </type>
        <type category="struct" name="VkBufferViewCreateInfo">
            <member values="VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*            <name>pNext</name></member>
            <member optional="true"><type>VkBufferViewCreateFlags</type><name>flags</name></member>
            <member><type>VkBuffer</type>               <name>buffer</name></member>
            <member><type>VkFormat</type>               <name>format</name><comment>Optionally specifies format of elements</comment></member>
            <member><type>VkDeviceSize</type>           <name>offset</name><comment>Specified in bytes</comment></member>
            <member><type>VkDeviceSize</type>           <name>range</name><comment>View size specified in bytes</comment></member>
        </type>
        <type category="struct" name="VkImageSubresource">
            <member><type>VkImageAspectFlags</type>     <name>aspectMask</name></member>
            <member><type>uint32_t</type>               <name>mipLevel</name></member>
            <member><type>uint32_t</type>               <name>arrayLayer</name></member>
        </type>
        <type category="struct" name="VkImageSubresourceLayers">
            <member><type>VkImageAspectFlags</type>     <name>aspectMask</name></member>
            <member><type>uint32_t</type>               <name>mipLevel</name></member>
            <member><type>uint32_t</type>               <name>baseArrayLayer</name></member>
            <member><type>uint32_t</type>               <name>layerCount</name></member>
        </type>
        <type category="struct" name="VkImageSubresourceRange">
            <member><type>VkImageAspectFlags</type>     <name>aspectMask</name></member>
            <member><type>uint32_t</type>               <name>baseMipLevel</name></member>
            <member><type>uint32_t</type>               <name>levelCount</name></member>
            <member><type>uint32_t</type>               <name>baseArrayLayer</name></member>
            <member><type>uint32_t</type>               <name>layerCount</name></member>
        </type>
        <type category="struct" name="VkMemoryBarrier">
            <member values="VK_STRUCTURE_TYPE_MEMORY_BARRIER"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*            <name>pNext</name></member>
            <member optional="true"><type>VkAccessFlags</type>          <name>srcAccessMask</name><comment>Memory accesses from the source of the dependency to synchronize</comment></member>
            <member optional="true"><type>VkAccessFlags</type>          <name>dstAccessMask</name><comment>Memory accesses from the destination of the dependency to synchronize</comment></member>
        </type>
        <type category="struct" name="VkBufferMemoryBarrier">
            <member values="VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*            <name>pNext</name></member>
            <member optional="true"><type>VkAccessFlags</type>          <name>srcAccessMask</name><comment>Memory accesses from the source of the dependency to synchronize</comment></member>
            <member optional="true"><type>VkAccessFlags</type>          <name>dstAccessMask</name><comment>Memory accesses from the destination of the dependency to synchronize</comment></member>
            <member><type>uint32_t</type>               <name>srcQueueFamilyIndex</name><comment>Queue family to transition ownership from</comment></member>
            <member><type>uint32_t</type>               <name>dstQueueFamilyIndex</name><comment>Queue family to transition ownership to</comment></member>
            <member><type>VkBuffer</type>               <name>buffer</name><comment>Buffer to sync</comment></member>
            <member><type>VkDeviceSize</type>           <name>offset</name><comment>Offset within the buffer to sync</comment></member>
            <member><type>VkDeviceSize</type>           <name>size</name><comment>Amount of bytes to sync</comment></member>
        </type>
        <type category="struct" name="VkImageMemoryBarrier">
            <member values="VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*            <name>pNext</name></member>
            <member optional="true"><type>VkAccessFlags</type>          <name>srcAccessMask</name><comment>Memory accesses from the source of the dependency to synchronize</comment></member>
            <member optional="true"><type>VkAccessFlags</type>          <name>dstAccessMask</name><comment>Memory accesses from the destination of the dependency to synchronize</comment></member>
            <member><type>VkImageLayout</type>          <name>oldLayout</name><comment>Current layout of the image</comment></member>
            <member><type>VkImageLayout</type>          <name>newLayout</name><comment>New layout to transition the image to</comment></member>
            <member><type>uint32_t</type>               <name>srcQueueFamilyIndex</name><comment>Queue family to transition ownership from</comment></member>
            <member><type>uint32_t</type>               <name>dstQueueFamilyIndex</name><comment>Queue family to transition ownership to</comment></member>
            <member><type>VkImage</type>                <name>image</name><comment>Image to sync</comment></member>
            <member><type>VkImageSubresourceRange</type> <name>subresourceRange</name><comment>Subresource range to sync</comment></member>
        </type>
        <type category="struct" name="VkImageCreateInfo">
            <member values="VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*            <name>pNext</name></member>
            <member optional="true"><type>VkImageCreateFlags</type>     <name>flags</name><comment>Image creation flags</comment></member>
            <member><type>VkImageType</type>            <name>imageType</name></member>
            <member><type>VkFormat</type>               <name>format</name></member>
            <member><type>VkExtent3D</type>             <name>extent</name></member>
            <member><type>uint32_t</type>               <name>mipLevels</name></member>
            <member><type>uint32_t</type>               <name>arrayLayers</name></member>
            <member><type>VkSampleCountFlagBits</type>  <name>samples</name></member>
            <member><type>VkImageTiling</type>          <name>tiling</name></member>
            <member><type>VkImageUsageFlags</type>      <name>usage</name><comment>Image usage flags</comment></member>
            <member><type>VkSharingMode</type>          <name>sharingMode</name><comment>Cross-queue-family sharing mode</comment></member>
            <member optional="true"><type>uint32_t</type>               <name>queueFamilyIndexCount</name><comment>Number of queue families to share across</comment></member>
            <member noautovalidity="true" len="queueFamilyIndexCount">const <type>uint32_t</type>*        <name>pQueueFamilyIndices</name><comment>Array of queue family indices to share across</comment></member>
            <member><type>VkImageLayout</type>          <name>initialLayout</name><comment>Initial image layout for all subresources</comment></member>
        </type>
        <type category="struct" name="VkSubresourceLayout" returnedonly="true">
            <member><type>VkDeviceSize</type>           <name>offset</name><comment>Specified in bytes</comment></member>
            <member><type>VkDeviceSize</type>           <name>size</name><comment>Specified in bytes</comment></member>
            <member><type>VkDeviceSize</type>           <name>rowPitch</name><comment>Specified in bytes</comment></member>
            <member><type>VkDeviceSize</type>           <name>arrayPitch</name><comment>Specified in bytes</comment></member>
            <member><type>VkDeviceSize</type>           <name>depthPitch</name><comment>Specified in bytes</comment></member>
        </type>
        <type category="struct" name="VkImageViewCreateInfo">
            <member values="VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*            <name>pNext</name></member>
            <member optional="true"><type>VkImageViewCreateFlags</type> <name>flags</name></member>
            <member><type>VkImage</type>                <name>image</name></member>
            <member><type>VkImageViewType</type>        <name>viewType</name></member>
            <member><type>VkFormat</type>               <name>format</name></member>
            <member><type>VkComponentMapping</type>     <name>components</name></member>
            <member><type>VkImageSubresourceRange</type> <name>subresourceRange</name></member>
        </type>
        <type category="struct" name="VkBufferCopy">
            <member><type>VkDeviceSize</type>                       <name>srcOffset</name><comment>Specified in bytes</comment></member>
            <member><type>VkDeviceSize</type>                       <name>dstOffset</name><comment>Specified in bytes</comment></member>
            <member noautovalidity="true"><type>VkDeviceSize</type> <name>size</name><comment>Specified in bytes</comment></member>
        </type>
        <type category="struct" name="VkSparseMemoryBind">
            <member><type>VkDeviceSize</type>           <name>resourceOffset</name><comment>Specified in bytes</comment></member>
            <member><type>VkDeviceSize</type>           <name>size</name><comment>Specified in bytes</comment></member>
            <member optional="true"><type>VkDeviceMemory</type>         <name>memory</name></member>
            <member><type>VkDeviceSize</type>           <name>memoryOffset</name><comment>Specified in bytes</comment></member>
            <member optional="true"><type>VkSparseMemoryBindFlags</type><name>flags</name></member>
        </type>
        <type category="struct" name="VkSparseImageMemoryBind">
            <member><type>VkImageSubresource</type>     <name>subresource</name></member>
            <member><type>VkOffset3D</type>             <name>offset</name></member>
            <member><type>VkExtent3D</type>             <name>extent</name></member>
            <member optional="true"><type>VkDeviceMemory</type>         <name>memory</name></member>
            <member><type>VkDeviceSize</type>           <name>memoryOffset</name><comment>Specified in bytes</comment></member>
            <member optional="true"><type>VkSparseMemoryBindFlags</type><name>flags</name></member>
        </type>
        <type category="struct" name="VkSparseBufferMemoryBindInfo">
            <member><type>VkBuffer</type> <name>buffer</name></member>
            <member><type>uint32_t</type>               <name>bindCount</name></member>
            <member len="bindCount">const <type>VkSparseMemoryBind</type>* <name>pBinds</name></member>
        </type>
        <type category="struct" name="VkSparseImageOpaqueMemoryBindInfo">
            <member><type>VkImage</type> <name>image</name></member>
            <member><type>uint32_t</type>               <name>bindCount</name></member>
            <member len="bindCount">const <type>VkSparseMemoryBind</type>* <name>pBinds</name></member>
        </type>
        <type category="struct" name="VkSparseImageMemoryBindInfo">
            <member><type>VkImage</type> <name>image</name></member>
            <member><type>uint32_t</type>               <name>bindCount</name></member>
            <member len="bindCount">const <type>VkSparseImageMemoryBind</type>* <name>pBinds</name></member>
        </type>
        <type category="struct" name="VkBindSparseInfo">
            <member values="VK_STRUCTURE_TYPE_BIND_SPARSE_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*            <name>pNext</name></member>
            <member optional="true"><type>uint32_t</type>               <name>waitSemaphoreCount</name></member>
            <member len="waitSemaphoreCount">const <type>VkSemaphore</type>*     <name>pWaitSemaphores</name></member>
            <member optional="true"><type>uint32_t</type>               <name>bufferBindCount</name></member>
            <member len="bufferBindCount">const <type>VkSparseBufferMemoryBindInfo</type>* <name>pBufferBinds</name></member>
            <member optional="true"><type>uint32_t</type>               <name>imageOpaqueBindCount</name></member>
            <member len="imageOpaqueBindCount">const <type>VkSparseImageOpaqueMemoryBindInfo</type>* <name>pImageOpaqueBinds</name></member>
            <member optional="true"><type>uint32_t</type>               <name>imageBindCount</name></member>
            <member len="imageBindCount">const <type>VkSparseImageMemoryBindInfo</type>* <name>pImageBinds</name></member>
            <member optional="true"><type>uint32_t</type>               <name>signalSemaphoreCount</name></member>
            <member len="signalSemaphoreCount">const <type>VkSemaphore</type>*     <name>pSignalSemaphores</name></member>
        </type>
        <type category="struct" name="VkImageCopy">
            <member><type>VkImageSubresourceLayers</type> <name>srcSubresource</name></member>
            <member><type>VkOffset3D</type>             <name>srcOffset</name><comment>Specified in pixels for both compressed and uncompressed images</comment></member>
            <member><type>VkImageSubresourceLayers</type> <name>dstSubresource</name></member>
            <member><type>VkOffset3D</type>             <name>dstOffset</name><comment>Specified in pixels for both compressed and uncompressed images</comment></member>
            <member><type>VkExtent3D</type>             <name>extent</name><comment>Specified in pixels for both compressed and uncompressed images</comment></member>
        </type>
        <type category="struct" name="VkImageBlit">
            <member><type>VkImageSubresourceLayers</type> <name>srcSubresource</name></member>
            <member><type>VkOffset3D</type>             <name>srcOffsets</name>[2]<comment>Specified in pixels for both compressed and uncompressed images</comment></member>
            <member><type>VkImageSubresourceLayers</type> <name>dstSubresource</name></member>
            <member><type>VkOffset3D</type>             <name>dstOffsets</name>[2]<comment>Specified in pixels for both compressed and uncompressed images</comment></member>
        </type>
        <type category="struct" name="VkBufferImageCopy">
            <member><type>VkDeviceSize</type>           <name>bufferOffset</name><comment>Specified in bytes</comment></member>
            <member><type>uint32_t</type>               <name>bufferRowLength</name><comment>Specified in texels</comment></member>
            <member><type>uint32_t</type>               <name>bufferImageHeight</name></member>
            <member><type>VkImageSubresourceLayers</type> <name>imageSubresource</name></member>
            <member><type>VkOffset3D</type>             <name>imageOffset</name><comment>Specified in pixels for both compressed and uncompressed images</comment></member>
            <member><type>VkExtent3D</type>             <name>imageExtent</name><comment>Specified in pixels for both compressed and uncompressed images</comment></member>
        </type>
        <type category="struct" name="VkImageResolve">
            <member><type>VkImageSubresourceLayers</type> <name>srcSubresource</name></member>
            <member><type>VkOffset3D</type>             <name>srcOffset</name></member>
            <member><type>VkImageSubresourceLayers</type> <name>dstSubresource</name></member>
            <member><type>VkOffset3D</type>             <name>dstOffset</name></member>
            <member><type>VkExtent3D</type>             <name>extent</name></member>
        </type>
        <type category="struct" name="VkShaderModuleCreateInfo">
            <member values="VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*            <name>pNext</name></member>
            <member optional="true"><type>VkShaderModuleCreateFlags</type> <name>flags</name></member>
            <member><type>size_t</type>                 <name>codeSize</name><comment>Specified in bytes</comment></member>
            <member len="latexmath:[\textrm{codeSize} \over 4]" altlen="codeSize / 4">const <type>uint32_t</type>*            <name>pCode</name><comment>Binary code of size codeSize</comment></member>
        </type>
        <type category="struct" name="VkDescriptorSetLayoutBinding">
            <member><type>uint32_t</type>               <name>binding</name><comment>Binding number for this entry</comment></member>
            <member><type>VkDescriptorType</type>       <name>descriptorType</name><comment>Type of the descriptors in this binding</comment></member>
            <member optional="true"><type>uint32_t</type> <name>descriptorCount</name><comment>Number of descriptors in this binding</comment></member>
            <member noautovalidity="true"><type>VkShaderStageFlags</type>     <name>stageFlags</name><comment>Shader stages this binding is visible to</comment></member>
            <member noautovalidity="true" optional="true" len="descriptorCount">const <type>VkSampler</type>*       <name>pImmutableSamplers</name><comment>Immutable samplers (used if descriptor type is SAMPLER or COMBINED_IMAGE_SAMPLER, is either NULL or contains count number of elements)</comment></member>
        </type>
        <type category="struct" name="VkDescriptorSetLayoutCreateInfo">
            <member values="VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*            <name>pNext</name></member>
            <member optional="true"><type>VkDescriptorSetLayoutCreateFlags</type>    <name>flags</name></member>
            <member optional="true"><type>uint32_t</type>               <name>bindingCount</name><comment>Number of bindings in the descriptor set layout</comment></member>
            <member len="bindingCount">const <type>VkDescriptorSetLayoutBinding</type>* <name>pBindings</name><comment>Array of descriptor set layout bindings</comment></member>
        </type>
        <type category="struct" name="VkDescriptorPoolSize">
            <member><type>VkDescriptorType</type>       <name>type</name></member>
            <member><type>uint32_t</type>               <name>descriptorCount</name></member>
        </type>
        <type category="struct" name="VkDescriptorPoolCreateInfo">
            <member values="VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*            <name>pNext</name></member>
            <member optional="true"><type>VkDescriptorPoolCreateFlags</type>  <name>flags</name></member>
            <member><type>uint32_t</type>               <name>maxSets</name></member>
            <member><type>uint32_t</type>               <name>poolSizeCount</name></member>
            <member len="poolSizeCount">const <type>VkDescriptorPoolSize</type>* <name>pPoolSizes</name></member>
        </type>
        <type category="struct" name="VkDescriptorSetAllocateInfo">
            <member values="VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*            <name>pNext</name></member>
            <member><type>VkDescriptorPool</type>       <name>descriptorPool</name></member>
            <member><type>uint32_t</type>               <name>descriptorSetCount</name></member>
            <member len="descriptorSetCount">const <type>VkDescriptorSetLayout</type>* <name>pSetLayouts</name></member>
        </type>
        <type category="struct" name="VkSpecializationMapEntry">
            <member><type>uint32_t</type>                     <name>constantID</name><comment>The SpecConstant ID specified in the BIL</comment></member>
            <member><type>uint32_t</type>                     <name>offset</name><comment>Offset of the value in the data block</comment></member>
            <member noautovalidity="true"><type>size_t</type> <name>size</name><comment>Size in bytes of the SpecConstant</comment></member>
        </type>
        <type category="struct" name="VkSpecializationInfo">
            <member optional="true"><type>uint32_t</type>               <name>mapEntryCount</name><comment>Number of entries in the map</comment></member>
            <member len="mapEntryCount">const <type>VkSpecializationMapEntry</type>* <name>pMapEntries</name><comment>Array of map entries</comment></member>
            <member optional="true"><type>size_t</type>                 <name>dataSize</name><comment>Size in bytes of pData</comment></member>
            <member len="dataSize">const <type>void</type>*            <name>pData</name><comment>Pointer to SpecConstant data</comment></member>
        </type>
        <type category="struct" name="VkPipelineShaderStageCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*            <name>pNext</name></member>
            <member optional="true"><type>VkPipelineShaderStageCreateFlags</type>    <name>flags</name></member>
            <member><type>VkShaderStageFlagBits</type>  <name>stage</name><comment>Shader stage</comment></member>
            <member><type>VkShaderModule</type>         <name>module</name><comment>Module containing entry point</comment></member>
            <member len="null-terminated">const <type>char</type>*            <name>pName</name><comment>Null-terminated entry point name</comment></member>
            <member optional="true">const <type>VkSpecializationInfo</type>* <name>pSpecializationInfo</name></member>
        </type>
        <type category="struct" name="VkComputePipelineCreateInfo">
            <member values="VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*            <name>pNext</name></member>
            <member optional="true"><type>VkPipelineCreateFlags</type>  <name>flags</name><comment>Pipeline creation flags</comment></member>
            <member><type>VkPipelineShaderStageCreateInfo</type> <name>stage</name></member>
            <member><type>VkPipelineLayout</type>       <name>layout</name><comment>Interface layout of the pipeline</comment></member>
            <member noautovalidity="true" optional="true"><type>VkPipeline</type>      <name>basePipelineHandle</name><comment>If VK_PIPELINE_CREATE_DERIVATIVE_BIT is set and this value is nonzero, it specifies the handle of the base pipeline this is a derivative of</comment></member>
            <member><type>int32_t</type>                <name>basePipelineIndex</name><comment>If VK_PIPELINE_CREATE_DERIVATIVE_BIT is set and this value is not -1, it specifies an index into pCreateInfos of the base pipeline this is a derivative of</comment></member>
        </type>
        <type category="struct" name="VkVertexInputBindingDescription">
            <member><type>uint32_t</type>               <name>binding</name><comment>Vertex buffer binding id</comment></member>
            <member><type>uint32_t</type>               <name>stride</name><comment>Distance between vertices in bytes (0 = no advancement)</comment></member>
            <member><type>VkVertexInputRate</type>      <name>inputRate</name><comment>The rate at which the vertex data is consumed</comment></member>
        </type>
        <type category="struct" name="VkVertexInputAttributeDescription">
            <member><type>uint32_t</type>               <name>location</name><comment>location of the shader vertex attrib</comment></member>
            <member><type>uint32_t</type>               <name>binding</name><comment>Vertex buffer binding id</comment></member>
            <member><type>VkFormat</type>               <name>format</name><comment>format of source data</comment></member>
            <member><type>uint32_t</type>               <name>offset</name><comment>Offset of first element in bytes from base of vertex</comment></member>
        </type>
        <type category="struct" name="VkPipelineVertexInputStateCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*            <name>pNext</name></member>
            <member optional="true"><type>VkPipelineVertexInputStateCreateFlags</type>    <name>flags</name></member>
            <member optional="true"><type>uint32_t</type>               <name>vertexBindingDescriptionCount</name><comment>number of bindings</comment></member>
            <member len="vertexBindingDescriptionCount">const <type>VkVertexInputBindingDescription</type>* <name>pVertexBindingDescriptions</name></member>
            <member optional="true"><type>uint32_t</type>               <name>vertexAttributeDescriptionCount</name><comment>number of attributes</comment></member>
            <member len="vertexAttributeDescriptionCount">const <type>VkVertexInputAttributeDescription</type>* <name>pVertexAttributeDescriptions</name></member>
        </type>
        <type category="struct" name="VkPipelineInputAssemblyStateCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*            <name>pNext</name></member>
            <member optional="true"><type>VkPipelineInputAssemblyStateCreateFlags</type>    <name>flags</name></member>
            <member><type>VkPrimitiveTopology</type>    <name>topology</name></member>
            <member><type>VkBool32</type>               <name>primitiveRestartEnable</name></member>
        </type>
        <type category="struct" name="VkPipelineTessellationStateCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*            <name>pNext</name></member>
            <member optional="true"><type>VkPipelineTessellationStateCreateFlags</type>    <name>flags</name></member>
            <member><type>uint32_t</type>               <name>patchControlPoints</name></member>
        </type>
        <type category="struct" name="VkPipelineViewportStateCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*            <name>pNext</name></member>
            <member optional="true"><type>VkPipelineViewportStateCreateFlags</type>    <name>flags</name></member>
            <member><type>uint32_t</type>               <name>viewportCount</name></member>
            <member noautovalidity="true" optional="true" len="viewportCount">const <type>VkViewport</type>*      <name>pViewports</name></member>
            <member><type>uint32_t</type>               <name>scissorCount</name></member>
            <member noautovalidity="true" optional="true" len="scissorCount">const <type>VkRect2D</type>*        <name>pScissors</name></member>
        </type>
        <type category="struct" name="VkPipelineRasterizationStateCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>* <name>pNext</name></member>
            <member optional="true"><type>VkPipelineRasterizationStateCreateFlags</type>    <name>flags</name></member>
            <member><type>VkBool32</type>               <name>depthClampEnable</name></member>
            <member><type>VkBool32</type>               <name>rasterizerDiscardEnable</name></member>
            <member><type>VkPolygonMode</type>          <name>polygonMode</name><comment>optional (GL45)</comment></member>
            <member optional="true"><type>VkCullModeFlags</type>        <name>cullMode</name></member>
            <member><type>VkFrontFace</type>            <name>frontFace</name></member>
            <member><type>VkBool32</type>               <name>depthBiasEnable</name></member>
            <member><type>float</type>                  <name>depthBiasConstantFactor</name></member>
            <member><type>float</type>                  <name>depthBiasClamp</name></member>
            <member><type>float</type>                  <name>depthBiasSlopeFactor</name></member>
            <member><type>float</type>                  <name>lineWidth</name></member>
        </type>
        <type category="struct" name="VkPipelineMultisampleStateCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*            <name>pNext</name></member>
            <member optional="true"><type>VkPipelineMultisampleStateCreateFlags</type>    <name>flags</name></member>
            <member><type>VkSampleCountFlagBits</type>  <name>rasterizationSamples</name><comment>Number of samples used for rasterization</comment></member>
            <member><type>VkBool32</type>               <name>sampleShadingEnable</name><comment>optional (GL45)</comment></member>
            <member><type>float</type>                  <name>minSampleShading</name><comment>optional (GL45)</comment></member>
            <member optional="true" len="latexmath:[\lceil{\mathit{rasterizationSamples} \over 32}\rceil]" altlen="(rasterizationSamples + 31) / 32">const <type>VkSampleMask</type>*    <name>pSampleMask</name><comment>Array of sampleMask words</comment></member>
            <member><type>VkBool32</type>               <name>alphaToCoverageEnable</name></member>
            <member><type>VkBool32</type>               <name>alphaToOneEnable</name></member>
        </type>
        <type category="struct" name="VkPipelineColorBlendAttachmentState">
            <member><type>VkBool32</type>               <name>blendEnable</name></member>
            <member><type>VkBlendFactor</type>          <name>srcColorBlendFactor</name></member>
            <member><type>VkBlendFactor</type>          <name>dstColorBlendFactor</name></member>
            <member><type>VkBlendOp</type>              <name>colorBlendOp</name></member>
            <member><type>VkBlendFactor</type>          <name>srcAlphaBlendFactor</name></member>
            <member><type>VkBlendFactor</type>          <name>dstAlphaBlendFactor</name></member>
            <member><type>VkBlendOp</type>              <name>alphaBlendOp</name></member>
            <member optional="true"><type>VkColorComponentFlags</type>  <name>colorWriteMask</name></member>
        </type>
        <type category="struct" name="VkPipelineColorBlendStateCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*            <name>pNext</name></member>
            <member optional="true"><type>VkPipelineColorBlendStateCreateFlags</type>    <name>flags</name></member>
            <member><type>VkBool32</type>               <name>logicOpEnable</name></member>
            <member noautovalidity="true"><type>VkLogicOp</type>              <name>logicOp</name></member>
            <member optional="true"><type>uint32_t</type>               <name>attachmentCount</name><comment># of pAttachments</comment></member>
            <member len="attachmentCount">const <type>VkPipelineColorBlendAttachmentState</type>* <name>pAttachments</name></member>
            <member><type>float</type>                  <name>blendConstants</name>[4]</member>
        </type>
        <type category="struct" name="VkPipelineDynamicStateCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*            <name>pNext</name></member>
            <member optional="true"><type>VkPipelineDynamicStateCreateFlags</type>    <name>flags</name></member>
            <member optional="true"><type>uint32_t</type>               <name>dynamicStateCount</name></member>
            <member len="dynamicStateCount">const <type>VkDynamicState</type>*  <name>pDynamicStates</name></member>
        </type>
        <type category="struct" name="VkStencilOpState">
            <member><type>VkStencilOp</type>            <name>failOp</name></member>
            <member><type>VkStencilOp</type>            <name>passOp</name></member>
            <member><type>VkStencilOp</type>            <name>depthFailOp</name></member>
            <member><type>VkCompareOp</type>            <name>compareOp</name></member>
            <member><type>uint32_t</type>               <name>compareMask</name></member>
            <member><type>uint32_t</type>               <name>writeMask</name></member>
            <member><type>uint32_t</type>               <name>reference</name></member>
        </type>
        <type category="struct" name="VkPipelineDepthStencilStateCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*            <name>pNext</name></member>
            <member optional="true"><type>VkPipelineDepthStencilStateCreateFlags</type>    <name>flags</name></member>
            <member><type>VkBool32</type>               <name>depthTestEnable</name></member>
            <member><type>VkBool32</type>               <name>depthWriteEnable</name></member>
            <member><type>VkCompareOp</type>            <name>depthCompareOp</name></member>
            <member><type>VkBool32</type>               <name>depthBoundsTestEnable</name><comment>optional (depth_bounds_test)</comment></member>
            <member><type>VkBool32</type>               <name>stencilTestEnable</name></member>
            <member><type>VkStencilOpState</type>       <name>front</name></member>
            <member><type>VkStencilOpState</type>       <name>back</name></member>
            <member><type>float</type>                  <name>minDepthBounds</name></member>
            <member><type>float</type>                  <name>maxDepthBounds</name></member>
        </type>
        <type category="struct" name="VkGraphicsPipelineCreateInfo">
            <member values="VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*            <name>pNext</name></member>
            <member optional="true"><type>VkPipelineCreateFlags</type>  <name>flags</name><comment>Pipeline creation flags</comment></member>
            <member><type>uint32_t</type>               <name>stageCount</name></member>
            <member len="stageCount">const <type>VkPipelineShaderStageCreateInfo</type>* <name>pStages</name><comment>One entry for each active shader stage</comment></member>
            <member noautovalidity="true" optional="true">const <type>VkPipelineVertexInputStateCreateInfo</type>* <name>pVertexInputState</name></member>
            <member noautovalidity="true" optional="true">const <type>VkPipelineInputAssemblyStateCreateInfo</type>* <name>pInputAssemblyState</name></member>
            <member noautovalidity="true" optional="true">const <type>VkPipelineTessellationStateCreateInfo</type>* <name>pTessellationState</name></member>
            <member noautovalidity="true" optional="true">const <type>VkPipelineViewportStateCreateInfo</type>* <name>pViewportState</name></member>
            <member>const <type>VkPipelineRasterizationStateCreateInfo</type>* <name>pRasterizationState</name></member>
            <member noautovalidity="true" optional="true">const <type>VkPipelineMultisampleStateCreateInfo</type>* <name>pMultisampleState</name></member>
            <member noautovalidity="true" optional="true">const <type>VkPipelineDepthStencilStateCreateInfo</type>* <name>pDepthStencilState</name></member>
            <member noautovalidity="true" optional="true">const <type>VkPipelineColorBlendStateCreateInfo</type>* <name>pColorBlendState</name></member>
            <member optional="true">const <type>VkPipelineDynamicStateCreateInfo</type>* <name>pDynamicState</name></member>
            <member><type>VkPipelineLayout</type>       <name>layout</name><comment>Interface layout of the pipeline</comment></member>
            <member><type>VkRenderPass</type>           <name>renderPass</name></member>
            <member><type>uint32_t</type>               <name>subpass</name></member>
            <member noautovalidity="true" optional="true"><type>VkPipeline</type>      <name>basePipelineHandle</name><comment>If VK_PIPELINE_CREATE_DERIVATIVE_BIT is set and this value is nonzero, it specifies the handle of the base pipeline this is a derivative of</comment></member>
            <member><type>int32_t</type>                <name>basePipelineIndex</name><comment>If VK_PIPELINE_CREATE_DERIVATIVE_BIT is set and this value is not -1, it specifies an index into pCreateInfos of the base pipeline this is a derivative of</comment></member>
        </type>
        <type category="struct" name="VkPipelineCacheCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*            <name>pNext</name></member>
            <member optional="true"><type>VkPipelineCacheCreateFlags</type>    <name>flags</name></member>
            <member optional="true"><type>size_t</type>                 <name>initialDataSize</name><comment>Size of initial data to populate cache, in bytes</comment></member>
            <member len="initialDataSize">const <type>void</type>*            <name>pInitialData</name><comment>Initial data to populate cache</comment></member>
        </type>
        <type category="struct" name="VkPushConstantRange">
            <member><type>VkShaderStageFlags</type>     <name>stageFlags</name><comment>Which stages use the range</comment></member>
            <member><type>uint32_t</type>               <name>offset</name><comment>Start of the range, in bytes</comment></member>
            <member><type>uint32_t</type>               <name>size</name><comment>Size of the range, in bytes</comment></member>
        </type>
        <type category="struct" name="VkPipelineLayoutCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*            <name>pNext</name></member>
            <member optional="true"><type>VkPipelineLayoutCreateFlags</type>    <name>flags</name></member>
            <member optional="true"><type>uint32_t</type>               <name>setLayoutCount</name><comment>Number of descriptor sets interfaced by the pipeline</comment></member>
            <member len="setLayoutCount">const <type>VkDescriptorSetLayout</type>* <name>pSetLayouts</name><comment>Array of setCount number of descriptor set layout objects defining the layout of the</comment></member>
            <member optional="true"><type>uint32_t</type>               <name>pushConstantRangeCount</name><comment>Number of push-constant ranges used by the pipeline</comment></member>
            <member len="pushConstantRangeCount">const <type>VkPushConstantRange</type>* <name>pPushConstantRanges</name><comment>Array of pushConstantRangeCount number of ranges used by various shader stages</comment></member>
        </type>
        <type category="struct" name="VkSamplerCreateInfo">
            <member values="VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*            <name>pNext</name></member>
            <member optional="true"><type>VkSamplerCreateFlags</type>   <name>flags</name></member>
            <member><type>VkFilter</type>               <name>magFilter</name><comment>Filter mode for magnification</comment></member>
            <member><type>VkFilter</type>               <name>minFilter</name><comment>Filter mode for minifiation</comment></member>
            <member><type>VkSamplerMipmapMode</type>    <name>mipmapMode</name><comment>Mipmap selection mode</comment></member>
            <member><type>VkSamplerAddressMode</type>   <name>addressModeU</name></member>
            <member><type>VkSamplerAddressMode</type>   <name>addressModeV</name></member>
            <member><type>VkSamplerAddressMode</type>   <name>addressModeW</name></member>
            <member><type>float</type>                  <name>mipLodBias</name></member>
            <member><type>VkBool32</type>               <name>anisotropyEnable</name></member>
            <member><type>float</type>                  <name>maxAnisotropy</name></member>
            <member><type>VkBool32</type>               <name>compareEnable</name></member>
            <member noautovalidity="true"><type>VkCompareOp</type>            <name>compareOp</name></member>
            <member><type>float</type>                  <name>minLod</name></member>
            <member><type>float</type>                  <name>maxLod</name></member>
            <member noautovalidity="true"><type>VkBorderColor</type>          <name>borderColor</name></member>
            <member><type>VkBool32</type>               <name>unnormalizedCoordinates</name></member>
        </type>
        <type category="struct" name="VkCommandPoolCreateInfo">
            <member values="VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*            <name>pNext</name></member>
            <member optional="true"><type>VkCommandPoolCreateFlags</type>   <name>flags</name><comment>Command pool creation flags</comment></member>
            <member><type>uint32_t</type>               <name>queueFamilyIndex</name></member>
        </type>
        <type category="struct" name="VkCommandBufferAllocateInfo">
            <member values="VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*            <name>pNext</name></member>
            <member><type>VkCommandPool</type>          <name>commandPool</name></member>
            <member><type>VkCommandBufferLevel</type>   <name>level</name></member>
            <member><type>uint32_t</type>               <name>commandBufferCount</name></member>
        </type>
        <type category="struct" name="VkCommandBufferInheritanceInfo">
            <member values="VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*            <name>pNext</name></member>
            <member optional="true" noautovalidity="true"><type>VkRenderPass</type>    <name>renderPass</name><comment>Render pass for secondary command buffers</comment></member>
            <member><type>uint32_t</type>               <name>subpass</name></member>
            <member optional="true" noautovalidity="true"><type>VkFramebuffer</type>   <name>framebuffer</name><comment>Framebuffer for secondary command buffers</comment></member>
            <member><type>VkBool32</type>               <name>occlusionQueryEnable</name><comment>Whether this secondary command buffer may be executed during an occlusion query</comment></member>
            <member optional="true" noautovalidity="true"><type>VkQueryControlFlags</type>    <name>queryFlags</name><comment>Query flags used by this secondary command buffer, if executed during an occlusion query</comment></member>
            <member optional="true" noautovalidity="true"><type>VkQueryPipelineStatisticFlags</type> <name>pipelineStatistics</name><comment>Pipeline statistics that may be counted for this secondary command buffer</comment></member>
        </type>
        <type category="struct" name="VkCommandBufferBeginInfo">
            <member values="VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*            <name>pNext</name></member>
            <member optional="true"><type>VkCommandBufferUsageFlags</type>  <name>flags</name><comment>Command buffer usage flags</comment></member>
            <member optional="true" noautovalidity="true">const <type>VkCommandBufferInheritanceInfo</type>*       <name>pInheritanceInfo</name><comment>Pointer to inheritance info for secondary command buffers</comment></member>
        </type>
        <type category="struct" name="VkRenderPassBeginInfo">
            <member values="VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*            <name>pNext</name></member>
            <member><type>VkRenderPass</type>           <name>renderPass</name></member>
            <member><type>VkFramebuffer</type>          <name>framebuffer</name></member>
            <member><type>VkRect2D</type>               <name>renderArea</name></member>
            <member optional="true"><type>uint32_t</type>               <name>clearValueCount</name></member>
            <member len="clearValueCount">const <type>VkClearValue</type>*    <name>pClearValues</name></member>
        </type>
        <type category="union" name="VkClearColorValue" comment="// Union allowing specification of floating point, integer, or unsigned integer color data. Actual value selected is based on image/attachment being cleared.">
            <member><type>float</type>                  <name>float32</name>[4]</member>
            <member><type>int32_t</type>                <name>int32</name>[4]</member>
            <member><type>uint32_t</type>               <name>uint32</name>[4]</member>
        </type>
        <type category="struct" name="VkClearDepthStencilValue">
            <member><type>float</type>                  <name>depth</name></member>
            <member><type>uint32_t</type>               <name>stencil</name></member>
        </type>
        <type category="union" name="VkClearValue" comment="// Union allowing specification of color or depth and stencil values. Actual value selected is based on attachment being cleared.">
            <member><type>VkClearColorValue</type>      <name>color</name></member>
            <member><type>VkClearDepthStencilValue</type> <name>depthStencil</name></member>
        </type>
        <type category="struct" name="VkClearAttachment">
            <member><type>VkImageAspectFlags</type>     <name>aspectMask</name></member>
            <member><type>uint32_t</type>               <name>colorAttachment</name></member>
            <member><type>VkClearValue</type>           <name>clearValue</name></member>
        </type>
        <type category="struct" name="VkAttachmentDescription">
            <member optional="true"><type>VkAttachmentDescriptionFlags</type> <name>flags</name></member>
            <member><type>VkFormat</type>               <name>format</name></member>
            <member><type>VkSampleCountFlagBits</type>  <name>samples</name></member>
            <member><type>VkAttachmentLoadOp</type>     <name>loadOp</name><comment>Load operation for color or depth data</comment></member>
            <member><type>VkAttachmentStoreOp</type>    <name>storeOp</name><comment>Store operation for color or depth data</comment></member>
            <member><type>VkAttachmentLoadOp</type>     <name>stencilLoadOp</name><comment>Load operation for stencil data</comment></member>
            <member><type>VkAttachmentStoreOp</type>    <name>stencilStoreOp</name><comment>Store operation for stencil data</comment></member>
            <member><type>VkImageLayout</type>          <name>initialLayout</name></member>
            <member><type>VkImageLayout</type>          <name>finalLayout</name></member>
        </type>
        <type category="struct" name="VkAttachmentReference">
            <member><type>uint32_t</type>               <name>attachment</name></member>
            <member><type>VkImageLayout</type>          <name>layout</name></member>
        </type>
        <type category="struct" name="VkSubpassDescription">
            <member optional="true"><type>VkSubpassDescriptionFlags</type> <name>flags</name></member>
            <member><type>VkPipelineBindPoint</type>    <name>pipelineBindPoint</name><comment>Must be VK_PIPELINE_BIND_POINT_GRAPHICS for now</comment></member>
            <member optional="true"><type>uint32_t</type>               <name>inputAttachmentCount</name></member>
            <member len="inputAttachmentCount">const <type>VkAttachmentReference</type>* <name>pInputAttachments</name></member>
            <member optional="true"><type>uint32_t</type>               <name>colorAttachmentCount</name></member>
            <member len="colorAttachmentCount">const <type>VkAttachmentReference</type>* <name>pColorAttachments</name></member>
            <member optional="true" len="colorAttachmentCount">const <type>VkAttachmentReference</type>* <name>pResolveAttachments</name></member>
            <member optional="true">const <type>VkAttachmentReference</type>* <name>pDepthStencilAttachment</name></member>
            <member optional="true"><type>uint32_t</type>               <name>preserveAttachmentCount</name></member>
            <member len="preserveAttachmentCount">const <type>uint32_t</type>* <name>pPreserveAttachments</name></member>
        </type>
        <type category="struct" name="VkSubpassDependency">
            <member><type>uint32_t</type>               <name>srcSubpass</name></member>
            <member><type>uint32_t</type>               <name>dstSubpass</name></member>
            <member><type>VkPipelineStageFlags</type>   <name>srcStageMask</name></member>
            <member><type>VkPipelineStageFlags</type>   <name>dstStageMask</name></member>
            <member optional="true"><type>VkAccessFlags</type>          <name>srcAccessMask</name><comment>Memory accesses from the source of the dependency to synchronize</comment></member>
            <member optional="true"><type>VkAccessFlags</type>          <name>dstAccessMask</name><comment>Memory accesses from the destination of the dependency to synchronize</comment></member>
            <member optional="true"><type>VkDependencyFlags</type>      <name>dependencyFlags</name></member>
        </type>
        <type category="struct" name="VkRenderPassCreateInfo">
            <member values="VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*            <name>pNext</name></member>
            <member optional="true" noautovalidity="true"><type>VkRenderPassCreateFlags</type>    <name>flags</name></member>
            <member optional="true"><type>uint32_t</type>   <name>attachmentCount</name></member>
            <member len="attachmentCount">const <type>VkAttachmentDescription</type>* <name>pAttachments</name></member>
            <member><type>uint32_t</type>               <name>subpassCount</name></member>
            <member len="subpassCount">const <type>VkSubpassDescription</type>* <name>pSubpasses</name></member>
            <member optional="true"><type>uint32_t</type>       <name>dependencyCount</name></member>
            <member len="dependencyCount">const <type>VkSubpassDependency</type>* <name>pDependencies</name></member>
        </type>
        <type category="struct" name="VkEventCreateInfo">
            <member values="VK_STRUCTURE_TYPE_EVENT_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*            <name>pNext</name></member>
            <member optional="true"><type>VkEventCreateFlags</type>     <name>flags</name><comment>Event creation flags</comment></member>
        </type>
        <type category="struct" name="VkFenceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_FENCE_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*            <name>pNext</name></member>
            <member optional="true"><type>VkFenceCreateFlags</type>     <name>flags</name><comment>Fence creation flags</comment></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceFeatures">
            <member><type>VkBool32</type>               <name>robustBufferAccess</name><comment>out of bounds buffer accesses are well defined</comment></member>
            <member><type>VkBool32</type>               <name>fullDrawIndexUint32</name><comment>full 32-bit range of indices for indexed draw calls</comment></member>
            <member><type>VkBool32</type>               <name>imageCubeArray</name><comment>image views which are arrays of cube maps</comment></member>
            <member><type>VkBool32</type>               <name>independentBlend</name><comment>blending operations are controlled per-attachment</comment></member>
            <member><type>VkBool32</type>               <name>geometryShader</name><comment>geometry stage</comment></member>
            <member><type>VkBool32</type>               <name>tessellationShader</name><comment>tessellation control and evaluation stage</comment></member>
            <member><type>VkBool32</type>               <name>sampleRateShading</name><comment>per-sample shading and interpolation</comment></member>
            <member><type>VkBool32</type>               <name>dualSrcBlend</name><comment>blend operations which take two sources</comment></member>
            <member><type>VkBool32</type>               <name>logicOp</name><comment>logic operations</comment></member>
            <member><type>VkBool32</type>               <name>multiDrawIndirect</name><comment>multi draw indirect</comment></member>
            <member><type>VkBool32</type>               <name>drawIndirectFirstInstance</name><comment>indirect draws can use non-zero firstInstance</comment></member>
            <member><type>VkBool32</type>               <name>depthClamp</name><comment>depth clamping</comment></member>
            <member><type>VkBool32</type>               <name>depthBiasClamp</name><comment>depth bias clamping</comment></member>
            <member><type>VkBool32</type>               <name>fillModeNonSolid</name><comment>point and wireframe fill modes</comment></member>
            <member><type>VkBool32</type>               <name>depthBounds</name><comment>depth bounds test</comment></member>
            <member><type>VkBool32</type>               <name>wideLines</name><comment>lines with width greater than 1</comment></member>
            <member><type>VkBool32</type>               <name>largePoints</name><comment>points with size greater than 1</comment></member>
            <member><type>VkBool32</type>               <name>alphaToOne</name><comment>the fragment alpha component can be forced to maximum representable alpha value</comment></member>
            <member><type>VkBool32</type>               <name>multiViewport</name><comment>viewport arrays</comment></member>
            <member><type>VkBool32</type>               <name>samplerAnisotropy</name><comment>anisotropic sampler filtering</comment></member>
            <member><type>VkBool32</type>               <name>textureCompressionETC2</name><comment>ETC texture compression formats</comment></member>
            <member><type>VkBool32</type>               <name>textureCompressionASTC_LDR</name><comment>ASTC LDR texture compression formats</comment></member>
            <member><type>VkBool32</type>               <name>textureCompressionBC</name><comment>BC1-7 texture compressed formats</comment></member>
            <member><type>VkBool32</type>               <name>occlusionQueryPrecise</name><comment>precise occlusion queries returning actual sample counts</comment></member>
            <member><type>VkBool32</type>               <name>pipelineStatisticsQuery</name><comment>pipeline statistics query</comment></member>
            <member><type>VkBool32</type>               <name>vertexPipelineStoresAndAtomics</name><comment>stores and atomic ops on storage buffers and images are supported in vertex, tessellation, and geometry stages</comment></member>
            <member><type>VkBool32</type>               <name>fragmentStoresAndAtomics</name><comment>stores and atomic ops on storage buffers and images are supported in the fragment stage</comment></member>
            <member><type>VkBool32</type>               <name>shaderTessellationAndGeometryPointSize</name><comment>tessellation and geometry stages can export point size</comment></member>
            <member><type>VkBool32</type>               <name>shaderImageGatherExtended</name><comment>image gather with run-time values and independent offsets</comment></member>
            <member><type>VkBool32</type>               <name>shaderStorageImageExtendedFormats</name><comment>the extended set of formats can be used for storage images</comment></member>
            <member><type>VkBool32</type>               <name>shaderStorageImageMultisample</name><comment>multisample images can be used for storage images</comment></member>
            <member><type>VkBool32</type>               <name>shaderStorageImageReadWithoutFormat</name><comment>read from storage image does not require format qualifier</comment></member>
            <member><type>VkBool32</type>               <name>shaderStorageImageWriteWithoutFormat</name><comment>write to storage image does not require format qualifier</comment></member>
            <member><type>VkBool32</type>               <name>shaderUniformBufferArrayDynamicIndexing</name><comment>arrays of uniform buffers can be accessed with dynamically uniform indices</comment></member>
            <member><type>VkBool32</type>               <name>shaderSampledImageArrayDynamicIndexing</name><comment>arrays of sampled images can be accessed with dynamically uniform indices</comment></member>
            <member><type>VkBool32</type>               <name>shaderStorageBufferArrayDynamicIndexing</name><comment>arrays of storage buffers can be accessed with dynamically uniform indices</comment></member>
            <member><type>VkBool32</type>               <name>shaderStorageImageArrayDynamicIndexing</name><comment>arrays of storage images can be accessed with dynamically uniform indices</comment></member>
            <member><type>VkBool32</type>               <name>shaderClipDistance</name><comment>clip distance in shaders</comment></member>
            <member><type>VkBool32</type>               <name>shaderCullDistance</name><comment>cull distance in shaders</comment></member>
            <member><type>VkBool32</type>               <name>shaderFloat64</name><comment>64-bit floats (doubles) in shaders</comment></member>
            <member><type>VkBool32</type>               <name>shaderInt64</name><comment>64-bit integers in shaders</comment></member>
            <member><type>VkBool32</type>               <name>shaderInt16</name><comment>16-bit integers in shaders</comment></member>
            <member><type>VkBool32</type>               <name>shaderResourceResidency</name><comment>shader can use texture operations that return resource residency information (requires sparseNonResident support)</comment></member>
            <member><type>VkBool32</type>               <name>shaderResourceMinLod</name><comment>shader can use texture operations that specify minimum resource LOD</comment></member>
            <member><type>VkBool32</type>               <name>sparseBinding</name><comment>Sparse resources support: Resource memory can be managed at opaque page level rather than object level</comment></member>
            <member><type>VkBool32</type>               <name>sparseResidencyBuffer</name><comment>Sparse resources support: GPU can access partially resident buffers </comment></member>
            <member><type>VkBool32</type>               <name>sparseResidencyImage2D</name><comment>Sparse resources support: GPU can access partially resident 2D (non-MSAA non-depth/stencil) images </comment></member>
            <member><type>VkBool32</type>               <name>sparseResidencyImage3D</name><comment>Sparse resources support: GPU can access partially resident 3D images </comment></member>
            <member><type>VkBool32</type>               <name>sparseResidency2Samples</name><comment>Sparse resources support: GPU can access partially resident MSAA 2D images with 2 samples</comment></member>
            <member><type>VkBool32</type>               <name>sparseResidency4Samples</name><comment>Sparse resources support: GPU can access partially resident MSAA 2D images with 4 samples</comment></member>
            <member><type>VkBool32</type>               <name>sparseResidency8Samples</name><comment>Sparse resources support: GPU can access partially resident MSAA 2D images with 8 samples</comment></member>
            <member><type>VkBool32</type>               <name>sparseResidency16Samples</name><comment>Sparse resources support: GPU can access partially resident MSAA 2D images with 16 samples</comment></member>
            <member><type>VkBool32</type>               <name>sparseResidencyAliased</name><comment>Sparse resources support: GPU can correctly access data aliased into multiple locations (opt-in)</comment></member>
            <member><type>VkBool32</type>               <name>variableMultisampleRate</name><comment>multisample rate must be the same for all pipelines in a subpass</comment></member>
            <member><type>VkBool32</type>               <name>inheritedQueries</name><comment>Queries may be inherited from primary to secondary command buffers</comment></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceSparseProperties" returnedonly="true">
            <member><type>VkBool32</type>               <name>residencyStandard2DBlockShape</name><comment>Sparse resources support: GPU will access all 2D (single sample) sparse resources using the standard sparse image block shapes (based on pixel format)</comment></member>
            <member><type>VkBool32</type>               <name>residencyStandard2DMultisampleBlockShape</name><comment>Sparse resources support: GPU will access all 2D (multisample) sparse resources using the standard sparse image block shapes (based on pixel format)</comment></member>
            <member><type>VkBool32</type>               <name>residencyStandard3DBlockShape</name><comment>Sparse resources support: GPU will access all 3D sparse resources using the standard sparse image block shapes (based on pixel format)</comment></member>
            <member><type>VkBool32</type>               <name>residencyAlignedMipSize</name><comment>Sparse resources support: Images with mip level dimensions that are NOT a multiple of the sparse image block dimensions will be placed in the mip tail</comment></member>
            <member><type>VkBool32</type>               <name>residencyNonResidentStrict</name><comment>Sparse resources support: GPU can consistently access non-resident regions of a resource, all reads return as if data is 0, writes are discarded</comment></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceLimits" returnedonly="true">
                <comment>resource maximum sizes</comment>
            <member><type>uint32_t</type>               <name>maxImageDimension1D</name><comment>max 1D image dimension</comment></member>
            <member><type>uint32_t</type>               <name>maxImageDimension2D</name><comment>max 2D image dimension</comment></member>
            <member><type>uint32_t</type>               <name>maxImageDimension3D</name><comment>max 3D image dimension</comment></member>
            <member><type>uint32_t</type>               <name>maxImageDimensionCube</name><comment>max cubemap image dimension</comment></member>
            <member><type>uint32_t</type>               <name>maxImageArrayLayers</name><comment>max layers for image arrays</comment></member>
            <member><type>uint32_t</type>               <name>maxTexelBufferElements</name><comment>max texel buffer size (fstexels)</comment></member>
            <member><type>uint32_t</type>               <name>maxUniformBufferRange</name><comment>max uniform buffer range (bytes)</comment></member>
            <member><type>uint32_t</type>               <name>maxStorageBufferRange</name><comment>max storage buffer range (bytes)</comment></member>
            <member><type>uint32_t</type>               <name>maxPushConstantsSize</name><comment>max size of the push constants pool (bytes)</comment></member>
                <comment>memory limits</comment>
            <member><type>uint32_t</type>               <name>maxMemoryAllocationCount</name><comment>max number of device memory allocations supported</comment></member>
            <member><type>uint32_t</type>               <name>maxSamplerAllocationCount</name><comment>max number of samplers that can be allocated on a device</comment></member>
            <member><type>VkDeviceSize</type>           <name>bufferImageGranularity</name><comment>Granularity (in bytes) at which buffers and images can be bound to adjacent memory for simultaneous usage</comment></member>
            <member><type>VkDeviceSize</type>           <name>sparseAddressSpaceSize</name><comment>Total address space available for sparse allocations (bytes)</comment></member>
                <comment>descriptor set limits</comment>
            <member><type>uint32_t</type>               <name>maxBoundDescriptorSets</name><comment>max number of descriptors sets that can be bound to a pipeline</comment></member>
            <member><type>uint32_t</type>               <name>maxPerStageDescriptorSamplers</name><comment>max number of samplers allowed per-stage in a descriptor set</comment></member>
            <member><type>uint32_t</type>               <name>maxPerStageDescriptorUniformBuffers</name><comment>max number of uniform buffers allowed per-stage in a descriptor set</comment></member>
            <member><type>uint32_t</type>               <name>maxPerStageDescriptorStorageBuffers</name><comment>max number of storage buffers allowed per-stage in a descriptor set</comment></member>
            <member><type>uint32_t</type>               <name>maxPerStageDescriptorSampledImages</name><comment>max number of sampled images allowed per-stage in a descriptor set</comment></member>
            <member><type>uint32_t</type>               <name>maxPerStageDescriptorStorageImages</name><comment>max number of storage images allowed per-stage in a descriptor set</comment></member>
            <member><type>uint32_t</type>               <name>maxPerStageDescriptorInputAttachments</name><comment>max number of input attachments allowed per-stage in a descriptor set</comment></member>
            <member><type>uint32_t</type>               <name>maxPerStageResources</name><comment>max number of resources allowed by a single stage</comment></member>
            <member><type>uint32_t</type>               <name>maxDescriptorSetSamplers</name><comment>max number of samplers allowed in all stages in a descriptor set</comment></member>
            <member><type>uint32_t</type>               <name>maxDescriptorSetUniformBuffers</name><comment>max number of uniform buffers allowed in all stages in a descriptor set</comment></member>
            <member><type>uint32_t</type>               <name>maxDescriptorSetUniformBuffersDynamic</name><comment>max number of dynamic uniform buffers allowed in all stages in a descriptor set</comment></member>
            <member><type>uint32_t</type>               <name>maxDescriptorSetStorageBuffers</name><comment>max number of storage buffers allowed in all stages in a descriptor set</comment></member>
            <member><type>uint32_t</type>               <name>maxDescriptorSetStorageBuffersDynamic</name><comment>max number of dynamic storage buffers allowed in all stages in a descriptor set</comment></member>
            <member><type>uint32_t</type>               <name>maxDescriptorSetSampledImages</name><comment>max number of sampled images allowed in all stages in a descriptor set</comment></member>
            <member><type>uint32_t</type>               <name>maxDescriptorSetStorageImages</name><comment>max number of storage images allowed in all stages in a descriptor set</comment></member>
            <member><type>uint32_t</type>               <name>maxDescriptorSetInputAttachments</name><comment>max number of input attachments allowed in all stages in a descriptor set</comment></member>
                <comment>vertex stage limits</comment>
            <member><type>uint32_t</type>               <name>maxVertexInputAttributes</name><comment>max number of vertex input attribute slots</comment></member>
            <member><type>uint32_t</type>               <name>maxVertexInputBindings</name><comment>max number of vertex input binding slots</comment></member>
            <member><type>uint32_t</type>               <name>maxVertexInputAttributeOffset</name><comment>max vertex input attribute offset added to vertex buffer offset</comment></member>
            <member><type>uint32_t</type>               <name>maxVertexInputBindingStride</name><comment>max vertex input binding stride</comment></member>
            <member><type>uint32_t</type>               <name>maxVertexOutputComponents</name><comment>max number of output components written by vertex shader</comment></member>
                <comment>tessellation control stage limits</comment>
            <member><type>uint32_t</type>               <name>maxTessellationGenerationLevel</name><comment>max level supported by tessellation primitive generator</comment></member>
            <member><type>uint32_t</type>               <name>maxTessellationPatchSize</name><comment>max patch size (vertices)</comment></member>
            <member><type>uint32_t</type>               <name>maxTessellationControlPerVertexInputComponents</name><comment>max number of input components per-vertex in TCS</comment></member>
            <member><type>uint32_t</type>               <name>maxTessellationControlPerVertexOutputComponents</name><comment>max number of output components per-vertex in TCS</comment></member>
            <member><type>uint32_t</type>               <name>maxTessellationControlPerPatchOutputComponents</name><comment>max number of output components per-patch in TCS</comment></member>
            <member><type>uint32_t</type>               <name>maxTessellationControlTotalOutputComponents</name><comment>max total number of per-vertex and per-patch output components in TCS</comment></member>
                <comment>tessellation evaluation stage limits</comment>
            <member><type>uint32_t</type>               <name>maxTessellationEvaluationInputComponents</name><comment>max number of input components per vertex in TES</comment></member>
            <member><type>uint32_t</type>               <name>maxTessellationEvaluationOutputComponents</name><comment>max number of output components per vertex in TES</comment></member>
                <comment>geometry stage limits</comment>
            <member><type>uint32_t</type>               <name>maxGeometryShaderInvocations</name><comment>max invocation count supported in geometry shader</comment></member>
            <member><type>uint32_t</type>               <name>maxGeometryInputComponents</name><comment>max number of input components read in geometry stage</comment></member>
            <member><type>uint32_t</type>               <name>maxGeometryOutputComponents</name><comment>max number of output components written in geometry stage</comment></member>
            <member><type>uint32_t</type>               <name>maxGeometryOutputVertices</name><comment>max number of vertices that can be emitted in geometry stage</comment></member>
            <member><type>uint32_t</type>               <name>maxGeometryTotalOutputComponents</name><comment>max total number of components (all vertices) written in geometry stage</comment></member>
                <comment>fragment stage limits</comment>
            <member><type>uint32_t</type>               <name>maxFragmentInputComponents</name><comment>max number of input components read in fragment stage</comment></member>
            <member><type>uint32_t</type>               <name>maxFragmentOutputAttachments</name><comment>max number of output attachments written in fragment stage</comment></member>
            <member><type>uint32_t</type>               <name>maxFragmentDualSrcAttachments</name><comment>max number of output attachments written when using dual source blending</comment></member>
            <member><type>uint32_t</type>               <name>maxFragmentCombinedOutputResources</name><comment>max total number of storage buffers, storage images and output buffers</comment></member>
                <comment>compute stage limits</comment>
            <member><type>uint32_t</type>               <name>maxComputeSharedMemorySize</name><comment>max total storage size of work group local storage (bytes)</comment></member>
            <member><type>uint32_t</type>               <name>maxComputeWorkGroupCount</name>[3]<comment>max num of compute work groups that may be dispatched by a single command (x,y,z)</comment></member>
            <member><type>uint32_t</type>               <name>maxComputeWorkGroupInvocations</name><comment>max total compute invocations in a single local work group</comment></member>
            <member><type>uint32_t</type>               <name>maxComputeWorkGroupSize</name>[3]<comment>max local size of a compute work group (x,y,z)</comment></member>
            <member><type>uint32_t</type>               <name>subPixelPrecisionBits</name><comment>number bits of subpixel precision in screen x and y</comment></member>
            <member><type>uint32_t</type>               <name>subTexelPrecisionBits</name><comment>number bits of precision for selecting texel weights</comment></member>
            <member><type>uint32_t</type>               <name>mipmapPrecisionBits</name><comment>number bits of precision for selecting mipmap weights</comment></member>
            <member><type>uint32_t</type>               <name>maxDrawIndexedIndexValue</name><comment>max index value for indexed draw calls (for 32-bit indices)</comment></member>
            <member><type>uint32_t</type>               <name>maxDrawIndirectCount</name><comment>max draw count for indirect draw calls</comment></member>
            <member><type>float</type>                  <name>maxSamplerLodBias</name><comment>max absolute sampler LOD bias</comment></member>
            <member><type>float</type>                  <name>maxSamplerAnisotropy</name><comment>max degree of sampler anisotropy</comment></member>
            <member><type>uint32_t</type>               <name>maxViewports</name><comment>max number of active viewports</comment></member>
            <member><type>uint32_t</type>               <name>maxViewportDimensions</name>[2]<comment>max viewport dimensions (x,y)</comment></member>
            <member><type>float</type>                  <name>viewportBoundsRange</name>[2]<comment>viewport bounds range (min,max)</comment></member>
            <member><type>uint32_t</type>               <name>viewportSubPixelBits</name><comment>number bits of subpixel precision for viewport</comment></member>
            <member><type>size_t</type>                 <name>minMemoryMapAlignment</name><comment>min required alignment of pointers returned by MapMemory (bytes)</comment></member>
            <member><type>VkDeviceSize</type>           <name>minTexelBufferOffsetAlignment</name><comment>min required alignment for texel buffer offsets (bytes) </comment></member>
            <member><type>VkDeviceSize</type>           <name>minUniformBufferOffsetAlignment</name><comment>min required alignment for uniform buffer sizes and offsets (bytes)</comment></member>
            <member><type>VkDeviceSize</type>           <name>minStorageBufferOffsetAlignment</name><comment>min required alignment for storage buffer offsets (bytes)</comment></member>
            <member><type>int32_t</type>                <name>minTexelOffset</name><comment>min texel offset for OpTextureSampleOffset</comment></member>
            <member><type>uint32_t</type>               <name>maxTexelOffset</name><comment>max texel offset for OpTextureSampleOffset</comment></member>
            <member><type>int32_t</type>                <name>minTexelGatherOffset</name><comment>min texel offset for OpTextureGatherOffset</comment></member>
            <member><type>uint32_t</type>               <name>maxTexelGatherOffset</name><comment>max texel offset for OpTextureGatherOffset</comment></member>
            <member><type>float</type>                  <name>minInterpolationOffset</name><comment>furthest negative offset for interpolateAtOffset</comment></member>
            <member><type>float</type>                  <name>maxInterpolationOffset</name><comment>furthest positive offset for interpolateAtOffset</comment></member>
            <member><type>uint32_t</type>               <name>subPixelInterpolationOffsetBits</name><comment>number of subpixel bits for interpolateAtOffset</comment></member>
            <member><type>uint32_t</type>               <name>maxFramebufferWidth</name><comment>max width for a framebuffer</comment></member>
            <member><type>uint32_t</type>               <name>maxFramebufferHeight</name><comment>max height for a framebuffer</comment></member>
            <member><type>uint32_t</type>               <name>maxFramebufferLayers</name><comment>max layer count for a layered framebuffer</comment></member>
            <member optional="true"><type>VkSampleCountFlags</type>     <name>framebufferColorSampleCounts</name><comment>supported color sample counts for a framebuffer</comment></member>
            <member optional="true"><type>VkSampleCountFlags</type>     <name>framebufferDepthSampleCounts</name><comment>supported depth sample counts for a framebuffer</comment></member>
            <member optional="true"><type>VkSampleCountFlags</type>     <name>framebufferStencilSampleCounts</name><comment>supported stencil sample counts for a framebuffer</comment></member>
            <member optional="true"><type>VkSampleCountFlags</type>     <name>framebufferNoAttachmentsSampleCounts</name><comment>supported sample counts for a framebuffer with no attachments</comment></member>
            <member><type>uint32_t</type>               <name>maxColorAttachments</name><comment>max number of color attachments per subpass</comment></member>
            <member optional="true"><type>VkSampleCountFlags</type>     <name>sampledImageColorSampleCounts</name><comment>supported color sample counts for a non-integer sampled image</comment></member>
            <member optional="true"><type>VkSampleCountFlags</type>     <name>sampledImageIntegerSampleCounts</name><comment>supported sample counts for an integer image</comment></member>
            <member optional="true"><type>VkSampleCountFlags</type>     <name>sampledImageDepthSampleCounts</name><comment>supported depth sample counts for a sampled image</comment></member>
            <member optional="true"><type>VkSampleCountFlags</type>     <name>sampledImageStencilSampleCounts</name><comment>supported stencil sample counts for a sampled image</comment></member>
            <member optional="true"><type>VkSampleCountFlags</type>     <name>storageImageSampleCounts</name><comment>supported sample counts for a storage image</comment></member>
            <member><type>uint32_t</type>               <name>maxSampleMaskWords</name><comment>max number of sample mask words</comment></member>
            <member><type>VkBool32</type>               <name>timestampComputeAndGraphics</name><comment>timestamps on graphics and compute queues</comment></member>
            <member><type>float</type>                  <name>timestampPeriod</name><comment>number of nanoseconds it takes for timestamp query value to increment by 1</comment></member>
            <member><type>uint32_t</type>               <name>maxClipDistances</name><comment>max number of clip distances</comment></member>
            <member><type>uint32_t</type>               <name>maxCullDistances</name><comment>max number of cull distances</comment></member>
            <member><type>uint32_t</type>               <name>maxCombinedClipAndCullDistances</name><comment>max combined number of user clipping</comment></member>
            <member><type>uint32_t</type>               <name>discreteQueuePriorities</name><comment>distinct queue priorities available </comment></member>
            <member><type>float</type>                  <name>pointSizeRange</name>[2]<comment>range (min,max) of supported point sizes</comment></member>
            <member><type>float</type>                  <name>lineWidthRange</name>[2]<comment>range (min,max) of supported line widths</comment></member>
            <member><type>float</type>                  <name>pointSizeGranularity</name><comment>granularity of supported point sizes</comment></member>
            <member><type>float</type>                  <name>lineWidthGranularity</name><comment>granularity of supported line widths</comment></member>
            <member><type>VkBool32</type>               <name>strictLines</name><comment>line rasterization follows preferred rules</comment></member>
            <member><type>VkBool32</type>               <name>standardSampleLocations</name><comment>supports standard sample locations for all supported sample counts</comment></member>
            <member><type>VkDeviceSize</type>           <name>optimalBufferCopyOffsetAlignment</name><comment>optimal offset of buffer copies</comment></member>
            <member><type>VkDeviceSize</type>           <name>optimalBufferCopyRowPitchAlignment</name><comment>optimal pitch of buffer copies</comment></member>
            <member><type>VkDeviceSize</type>           <name>nonCoherentAtomSize</name><comment>minimum size and alignment for non-coherent host-mapped device memory access</comment></member>
        </type>
        <type category="struct" name="VkSemaphoreCreateInfo">
            <member values="VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*            <name>pNext</name></member>
            <member optional="true"><type>VkSemaphoreCreateFlags</type> <name>flags</name><comment>Semaphore creation flags</comment></member>
        </type>
        <type category="struct" name="VkQueryPoolCreateInfo">
            <member values="VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*            <name>pNext</name></member>
            <member optional="true"><type>VkQueryPoolCreateFlags</type> <name>flags</name></member>
            <member><type>VkQueryType</type>            <name>queryType</name></member>
            <member><type>uint32_t</type>               <name>queryCount</name></member>
            <member optional="true" noautovalidity="true"><type>VkQueryPipelineStatisticFlags</type> <name>pipelineStatistics</name><comment>Optional</comment></member>
        </type>
        <type category="struct" name="VkFramebufferCreateInfo">
            <member values="VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*            <name>pNext</name></member>
            <member optional="true"><type>VkFramebufferCreateFlags</type>    <name>flags</name></member>
            <member><type>VkRenderPass</type>           <name>renderPass</name></member>
            <member optional="true"><type>uint32_t</type>               <name>attachmentCount</name></member>
            <member len="attachmentCount">const <type>VkImageView</type>*     <name>pAttachments</name></member>
            <member><type>uint32_t</type>               <name>width</name></member>
            <member><type>uint32_t</type>               <name>height</name></member>
            <member><type>uint32_t</type>               <name>layers</name></member>
        </type>
        <type category="struct" name="VkDrawIndirectCommand">
            <member><type>uint32_t</type>                       <name>vertexCount</name></member>
            <member><type>uint32_t</type>                       <name>instanceCount</name></member>
            <member><type>uint32_t</type>                       <name>firstVertex</name></member>
            <member noautovalidity="true"><type>uint32_t</type> <name>firstInstance</name></member>
        </type>
        <type category="struct" name="VkDrawIndexedIndirectCommand">
            <member><type>uint32_t</type>                       <name>indexCount</name></member>
            <member><type>uint32_t</type>                       <name>instanceCount</name></member>
            <member><type>uint32_t</type>                       <name>firstIndex</name></member>
            <member><type>int32_t</type>                        <name>vertexOffset</name></member>
            <member noautovalidity="true"><type>uint32_t</type> <name>firstInstance</name></member>
        </type>
        <type category="struct" name="VkDispatchIndirectCommand">
            <member noautovalidity="true"><type>uint32_t</type> <name>x</name></member>
            <member noautovalidity="true"><type>uint32_t</type> <name>y</name></member>
            <member noautovalidity="true"><type>uint32_t</type> <name>z</name></member>
        </type>
        <type category="struct" name="VkSubmitInfo">
            <member values="VK_STRUCTURE_TYPE_SUBMIT_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>* <name>pNext</name></member>
            <member optional="true"><type>uint32_t</type>       <name>waitSemaphoreCount</name></member>
            <member len="waitSemaphoreCount">const <type>VkSemaphore</type>*     <name>pWaitSemaphores</name></member>
            <member len="waitSemaphoreCount">const <type>VkPipelineStageFlags</type>*           <name>pWaitDstStageMask</name></member>
            <member optional="true"><type>uint32_t</type>       <name>commandBufferCount</name></member>
            <member len="commandBufferCount">const <type>VkCommandBuffer</type>*     <name>pCommandBuffers</name></member>
            <member optional="true"><type>uint32_t</type>       <name>signalSemaphoreCount</name></member>
            <member len="signalSemaphoreCount">const <type>VkSemaphore</type>*     <name>pSignalSemaphores</name></member>
        </type>
            <comment>WSI extensions</comment>
        <type category="struct" name="VkDisplayPropertiesKHR" returnedonly="true">
            <member><type>VkDisplayKHR</type>                     <name>display</name><comment>Handle of the display object</comment></member>
            <member len="null-terminated">const <type>char</type>*                      <name>displayName</name><comment>Name of the display</comment></member>
            <member><type>VkExtent2D</type>                       <name>physicalDimensions</name><comment>In millimeters?</comment></member>
            <member><type>VkExtent2D</type>                       <name>physicalResolution</name><comment>Max resolution for CRT?</comment></member>
            <member optional="true"><type>VkSurfaceTransformFlagsKHR</type>       <name>supportedTransforms</name><comment>one or more bits from VkSurfaceTransformFlagsKHR</comment></member>
            <member><type>VkBool32</type>                         <name>planeReorderPossible</name><comment>VK_TRUE if the overlay plane's z-order can be changed on this display.</comment></member>
            <member><type>VkBool32</type>                         <name>persistentContent</name><comment>VK_TRUE if this is a "smart" display that supports self-refresh/internal buffering.</comment></member>
        </type>
        <type category="struct" name="VkDisplayPlanePropertiesKHR" returnedonly="true">
            <member><type>VkDisplayKHR</type>                     <name>currentDisplay</name><comment>Display the plane is currently associated with.  Will be VK_NULL_HANDLE if the plane is not in use.</comment></member>
            <member><type>uint32_t</type>                         <name>currentStackIndex</name><comment>Current z-order of the plane.</comment></member>
        </type>
        <type category="struct" name="VkDisplayModeParametersKHR">
            <member><type>VkExtent2D</type>                       <name>visibleRegion</name><comment>Visible scanout region.</comment></member>
            <member noautovalidity="true"><type>uint32_t</type>   <name>refreshRate</name><comment>Number of times per second the display is updated.</comment></member>
        </type>
        <type category="struct" name="VkDisplayModePropertiesKHR" returnedonly="true">
            <member><type>VkDisplayModeKHR</type>                 <name>displayMode</name><comment>Handle of this display mode.</comment></member>
            <member><type>VkDisplayModeParametersKHR</type>       <name>parameters</name><comment>The parameters this mode uses.</comment></member>
        </type>
        <type category="struct" name="VkDisplayModeCreateInfoKHR">
            <member values="VK_STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*                      <name>pNext</name></member>
            <member optional="true"><type>VkDisplayModeCreateFlagsKHR</type>      <name>flags</name></member>
            <member><type>VkDisplayModeParametersKHR</type>       <name>parameters</name><comment>The parameters this mode uses.</comment></member>
        </type>
        <type category="struct" name="VkDisplayPlaneCapabilitiesKHR" returnedonly="true">
            <member optional="true"><type>VkDisplayPlaneAlphaFlagsKHR</type>      <name>supportedAlpha</name><comment>Types of alpha blending supported, if any.</comment></member>
            <member><type>VkOffset2D</type>                       <name>minSrcPosition</name><comment>Does the plane have any position and extent restrictions?</comment></member>
            <member><type>VkOffset2D</type>                       <name>maxSrcPosition</name></member>
            <member><type>VkExtent2D</type>                       <name>minSrcExtent</name></member>
            <member><type>VkExtent2D</type>                       <name>maxSrcExtent</name></member>
            <member><type>VkOffset2D</type>                       <name>minDstPosition</name></member>
            <member><type>VkOffset2D</type>                       <name>maxDstPosition</name></member>
            <member><type>VkExtent2D</type>                       <name>minDstExtent</name></member>
            <member><type>VkExtent2D</type>                       <name>maxDstExtent</name></member>
        </type>
        <type category="struct" name="VkDisplaySurfaceCreateInfoKHR">
            <member values="VK_STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*                      <name>pNext</name></member>
            <member optional="true"><type>VkDisplaySurfaceCreateFlagsKHR</type>   <name>flags</name></member>
            <member><type>VkDisplayModeKHR</type>                 <name>displayMode</name><comment>The mode to use when displaying this surface</comment></member>
            <member><type>uint32_t</type>                         <name>planeIndex</name><comment>The plane on which this surface appears.  Must be between 0 and the value returned by vkGetPhysicalDeviceDisplayPlanePropertiesKHR() in pPropertyCount.</comment></member>
            <member><type>uint32_t</type>                         <name>planeStackIndex</name><comment>The z-order of the plane.</comment></member>
            <member><type>VkSurfaceTransformFlagBitsKHR</type>    <name>transform</name><comment>Transform to apply to the images as part of the scanout operation</comment></member>
            <member><type>float</type>                            <name>globalAlpha</name><comment>Global alpha value.  Must be between 0 and 1, inclusive.  Ignored if alphaMode is not VK_DISPLAY_PLANE_ALPHA_GLOBAL_BIT_KHR</comment></member>
            <member><type>VkDisplayPlaneAlphaFlagBitsKHR</type>   <name>alphaMode</name><comment>What type of alpha blending to use.  Must be a bit from vkGetDisplayPlanePropertiesKHR::supportedAlpha.</comment></member>
            <member><type>VkExtent2D</type>                       <name>imageExtent</name><comment>size of the images to use with this surface</comment></member>
        </type>
        <type category="struct" name="VkDisplayPresentInfoKHR" structextends="VkPresentInfoKHR">
            <member values="VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*                      <name>pNext</name></member>
            <member><type>VkRect2D</type>                         <name>srcRect</name><comment>Rectangle within the presentable image to read pixel data from when presenting to the display.</comment></member>
            <member><type>VkRect2D</type>                         <name>dstRect</name><comment>Rectangle within the current display mode's visible region to display srcRectangle in.</comment></member>
            <member><type>VkBool32</type>                         <name>persistent</name><comment>For smart displays, use buffered mode.  If the display properties member "persistentMode" is VK_FALSE, this member must always be VK_FALSE.</comment></member>
        </type>
        <type category="struct" name="VkSurfaceCapabilitiesKHR" returnedonly="true">
            <member><type>uint32_t</type>                         <name>minImageCount</name><comment>Supported minimum number of images for the surface</comment></member>
            <member><type>uint32_t</type>                         <name>maxImageCount</name><comment>Supported maximum number of images for the surface, 0 for unlimited</comment></member>
            <member><type>VkExtent2D</type>                       <name>currentExtent</name><comment>Current image width and height for the surface, (0, 0) if undefined</comment></member>
            <member><type>VkExtent2D</type>                       <name>minImageExtent</name><comment>Supported minimum image width and height for the surface</comment></member>
            <member><type>VkExtent2D</type>                       <name>maxImageExtent</name><comment>Supported maximum image width and height for the surface</comment></member>
            <member><type>uint32_t</type>                         <name>maxImageArrayLayers</name><comment>Supported maximum number of image layers for the surface</comment></member>
            <member optional="true"><type>VkSurfaceTransformFlagsKHR</type>       <name>supportedTransforms</name><comment>1 or more bits representing the transforms supported</comment></member>
            <member><type>VkSurfaceTransformFlagBitsKHR</type>    <name>currentTransform</name><comment>The surface's current transform relative to the device's natural orientation</comment></member>
            <member optional="true"><type>VkCompositeAlphaFlagsKHR</type>         <name>supportedCompositeAlpha</name><comment>1 or more bits representing the alpha compositing modes supported</comment></member>
            <member optional="true"><type>VkImageUsageFlags</type>                <name>supportedUsageFlags</name><comment>Supported image usage flags for the surface</comment></member>
        </type>
        <type category="struct" name="VkAndroidSurfaceCreateInfoKHR">
            <member values="VK_STRUCTURE_TYPE_ANDROID_SURFACE_CREATE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*                                    <name>pNext</name></member>
            <member optional="true"><type>VkAndroidSurfaceCreateFlagsKHR</type> <name>flags</name></member>
            <member noautovalidity="true">struct <type>ANativeWindow</type>*    <name>window</name></member>
        </type>
        <type category="struct" name="VkViSurfaceCreateInfoNN">
            <member values="VK_STRUCTURE_TYPE_VI_SURFACE_CREATE_INFO_NN"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*                      <name>pNext</name></member>
            <member optional="true"><type>VkViSurfaceCreateFlagsNN</type>   <name>flags</name></member>
            <member noautovalidity="true"><type>void</type>*                            <name>window</name></member>
        </type>
        <type category="struct" name="VkWaylandSurfaceCreateInfoKHR">
            <member values="VK_STRUCTURE_TYPE_WAYLAND_SURFACE_CREATE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*                      <name>pNext</name></member>
            <member optional="true"><type>VkWaylandSurfaceCreateFlagsKHR</type>   <name>flags</name></member>
            <member noautovalidity="true">struct <type>wl_display</type>*               <name>display</name></member>
            <member noautovalidity="true">struct <type>wl_surface</type>*               <name>surface</name></member>
        </type>
        <type category="struct" name="VkWin32SurfaceCreateInfoKHR">
            <member values="VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*                      <name>pNext</name></member>
            <member optional="true"><type>VkWin32SurfaceCreateFlagsKHR</type>   <name>flags</name></member>
            <member><type>HINSTANCE</type>                        <name>hinstance</name></member>
            <member><type>HWND</type>                             <name>hwnd</name></member>
        </type>
        <type category="struct" name="VkXlibSurfaceCreateInfoKHR">
            <member values="VK_STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*                      <name>pNext</name></member>
            <member optional="true"><type>VkXlibSurfaceCreateFlagsKHR</type>   <name>flags</name></member>
            <member noautovalidity="true"><type>Display</type>*                         <name>dpy</name></member>
            <member><type>Window</type>                           <name>window</name></member>
        </type>
        <type category="struct" name="VkXcbSurfaceCreateInfoKHR">
            <member values="VK_STRUCTURE_TYPE_XCB_SURFACE_CREATE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*                      <name>pNext</name></member>
            <member optional="true"><type>VkXcbSurfaceCreateFlagsKHR</type>   <name>flags</name></member>
            <member noautovalidity="true"><type>xcb_connection_t</type>*                <name>connection</name></member>
            <member><type>xcb_window_t</type>                     <name>window</name></member>
        </type>
        <type category="struct" name="VkImagePipeSurfaceCreateInfoFUCHSIA">
            <member values="VK_STRUCTURE_TYPE_IMAGEPIPE_SURFACE_CREATE_INFO_FUCHSIA"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*                      <name>pNext</name></member>
            <member optional="true"><type>VkImagePipeSurfaceCreateFlagsFUCHSIA</type>   <name>flags</name></member>
            <member><type>zx_handle_t</type>                      <name>imagePipeHandle</name></member>
        </type>
        <type category="struct" name="VkStreamDescriptorSurfaceCreateInfoGGP">
            <member values="VK_STRUCTURE_TYPE_STREAM_DESCRIPTOR_SURFACE_CREATE_INFO_GGP"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*                      <name>pNext</name></member>
            <member optional="true"><type>VkStreamDescriptorSurfaceCreateFlagsGGP</type> <name>flags</name></member>
            <member><type>GgpStreamDescriptor</type>              <name>streamDescriptor</name></member>
        </type>
        <type category="struct" name="VkSurfaceFormatKHR" returnedonly="true">
            <member><type>VkFormat</type>                         <name>format</name><comment>Supported pair of rendering format</comment></member>
            <member><type>VkColorSpaceKHR</type>                  <name>colorSpace</name><comment>and color space for the surface</comment></member>
        </type>
        <type category="struct" name="VkSwapchainCreateInfoKHR">
            <member values="VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*                      <name>pNext</name></member>
            <member optional="true"><type>VkSwapchainCreateFlagsKHR</type>        <name>flags</name></member>
            <member><type>VkSurfaceKHR</type>                     <name>surface</name><comment>The swapchain's target surface</comment></member>
            <member><type>uint32_t</type>                         <name>minImageCount</name><comment>Minimum number of presentation images the application needs</comment></member>
            <member><type>VkFormat</type>                         <name>imageFormat</name><comment>Format of the presentation images</comment></member>
            <member><type>VkColorSpaceKHR</type>                  <name>imageColorSpace</name><comment>Colorspace of the presentation images</comment></member>
            <member><type>VkExtent2D</type>                       <name>imageExtent</name><comment>Dimensions of the presentation images</comment></member>
            <member><type>uint32_t</type>                         <name>imageArrayLayers</name><comment>Determines the number of views for multiview/stereo presentation</comment></member>
            <member><type>VkImageUsageFlags</type>                <name>imageUsage</name><comment>Bits indicating how the presentation images will be used</comment></member>
            <member><type>VkSharingMode</type>                    <name>imageSharingMode</name><comment>Sharing mode used for the presentation images</comment></member>
            <member optional="true"><type>uint32_t</type>         <name>queueFamilyIndexCount</name><comment>Number of queue families having access to the images in case of concurrent sharing mode</comment></member>
            <member noautovalidity="true" len="queueFamilyIndexCount">const <type>uint32_t</type>*                  <name>pQueueFamilyIndices</name><comment>Array of queue family indices having access to the images in case of concurrent sharing mode</comment></member>
            <member><type>VkSurfaceTransformFlagBitsKHR</type>    <name>preTransform</name><comment>The transform, relative to the device's natural orientation, applied to the image content prior to presentation</comment></member>
            <member><type>VkCompositeAlphaFlagBitsKHR</type>      <name>compositeAlpha</name><comment>The alpha blending mode used when compositing this surface with other surfaces in the window system</comment></member>
            <member><type>VkPresentModeKHR</type>                 <name>presentMode</name><comment>Which presentation mode to use for presents on this swap chain</comment></member>
            <member><type>VkBool32</type>                         <name>clipped</name><comment>Specifies whether presentable images may be affected by window clip regions</comment></member>
            <member optional="true"><type>VkSwapchainKHR</type>   <name>oldSwapchain</name><comment>Existing swap chain to replace, if any</comment></member>
        </type>
        <type category="struct" name="VkPresentInfoKHR">
            <member values="VK_STRUCTURE_TYPE_PRESENT_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*  <name>pNext</name></member>
            <member optional="true"><type>uint32_t</type>         <name>waitSemaphoreCount</name><comment>Number of semaphores to wait for before presenting</comment></member>
            <member len="waitSemaphoreCount">const <type>VkSemaphore</type>* <name>pWaitSemaphores</name><comment>Semaphores to wait for before presenting</comment></member>
            <member><type>uint32_t</type>                         <name>swapchainCount</name><comment>Number of swapchains to present in this call</comment></member>
            <member len="swapchainCount">const <type>VkSwapchainKHR</type>* <name>pSwapchains</name><comment>Swapchains to present an image from</comment></member>
            <member len="swapchainCount">const <type>uint32_t</type>* <name>pImageIndices</name><comment>Indices of which presentable images to present</comment></member>
            <member optional="true" len="swapchainCount"><type>VkResult</type>* <name>pResults</name><comment>Optional (i.e. if non-NULL) VkResult for each swapchain</comment></member>
        </type>
        <type category="struct" name="VkDebugReportCallbackCreateInfoEXT" structextends="VkInstanceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*                      <name>pNext</name></member>
            <member optional="true"><type>VkDebugReportFlagsEXT</type>            <name>flags</name><comment>Indicates which events call this callback</comment></member>
            <member><type>PFN_vkDebugReportCallbackEXT</type>     <name>pfnCallback</name><comment>Function pointer of a callback function</comment></member>
            <member optional="true"><type>void</type>*            <name>pUserData</name><comment>User data provided to callback function</comment></member>
        </type>
        <type category="struct" name="VkValidationFlagsEXT" structextends="VkInstanceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_VALIDATION_FLAGS_EXT"><type>VkStructureType</type>                  <name>sType</name><comment>Must be VK_STRUCTURE_TYPE_VALIDATION_FLAGS_EXT</comment></member>
            <member>const <type>void</type>*                      <name>pNext</name></member>
            <member><type>uint32_t</type>                         <name>disabledValidationCheckCount</name><comment>Number of validation checks to disable</comment></member>
            <member len="disabledValidationCheckCount">const <type>VkValidationCheckEXT</type>* <name>pDisabledValidationChecks</name><comment>Validation checks to disable</comment></member>
        </type>
        <type category="struct" name="VkValidationFeaturesEXT" structextends="VkInstanceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_VALIDATION_FEATURES_EXT"><type>VkStructureType</type>  <name>sType</name><comment>Must be VK_STRUCTURE_TYPE_VALIDATION_FEATURES_EXT</comment></member>
            <member>const <type>void</type>*                      <name>pNext</name></member>
            <member optional="true"><type>uint32_t</type>                         <name>enabledValidationFeatureCount</name><comment>Number of validation features to enable</comment></member>
            <member len="enabledValidationFeatureCount">const <type>VkValidationFeatureEnableEXT</type>* <name>pEnabledValidationFeatures</name><comment>Validation features to enable</comment></member>
            <member optional="true"><type>uint32_t</type>                         <name>disabledValidationFeatureCount</name><comment>Number of validation features to disable</comment></member>
            <member len="disabledValidationFeatureCount">const <type>VkValidationFeatureDisableEXT</type>* <name>pDisabledValidationFeatures</name><comment>Validation features to disable</comment></member>
        </type>
        <type category="struct" name="VkPipelineRasterizationStateRasterizationOrderAMD" structextends="VkPipelineRasterizationStateCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*                      <name>pNext</name></member>
            <member><type>VkRasterizationOrderAMD</type>          <name>rasterizationOrder</name><comment>Rasterization order to use for the pipeline</comment></member>
        </type>
        <type category="struct" name="VkDebugMarkerObjectNameInfoEXT">
            <member values="VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_NAME_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*                      <name>pNext</name></member>
            <member><type>VkDebugReportObjectTypeEXT</type>       <name>objectType</name><comment>The type of the object</comment></member>
            <member><type>uint64_t</type>                         <name>object</name><comment>The handle of the object, cast to uint64_t</comment></member>
            <member len="null-terminated">const <type>char</type>* <name>pObjectName</name><comment>Name to apply to the object</comment></member>
        </type>
        <type category="struct" name="VkDebugMarkerObjectTagInfoEXT">
            <member values="VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_TAG_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*                      <name>pNext</name></member>
            <member><type>VkDebugReportObjectTypeEXT</type>       <name>objectType</name><comment>The type of the object</comment></member>
            <member><type>uint64_t</type>                         <name>object</name><comment>The handle of the object, cast to uint64_t</comment></member>
            <member><type>uint64_t</type>                         <name>tagName</name><comment>The name of the tag to set on the object</comment></member>
            <member><type>size_t</type>                           <name>tagSize</name><comment>The length in bytes of the tag data</comment></member>
            <member len="tagSize">const <type>void</type>*        <name>pTag</name><comment>Tag data to attach to the object</comment></member>
        </type>
        <type category="struct" name="VkDebugMarkerMarkerInfoEXT">
            <member values="VK_STRUCTURE_TYPE_DEBUG_MARKER_MARKER_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*                      <name>pNext</name></member>
            <member len="null-terminated">const <type>char</type>* <name>pMarkerName</name><comment>Name of the debug marker</comment></member>
            <member optional="true"><type>float</type>            <name>color</name>[4]<comment>Optional color for debug marker</comment></member>
        </type>
        <type category="struct" name="VkDedicatedAllocationImageCreateInfoNV" structextends="VkImageCreateInfo">
            <member values="VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*                      <name>pNext</name></member>
            <member><type>VkBool32</type>                         <name>dedicatedAllocation</name><comment>Whether this image uses a dedicated allocation</comment></member>
        </type>
        <type category="struct" name="VkDedicatedAllocationBufferCreateInfoNV" structextends="VkBufferCreateInfo">
            <member values="VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*                      <name>pNext</name></member>
            <member><type>VkBool32</type>                         <name>dedicatedAllocation</name><comment>Whether this buffer uses a dedicated allocation</comment></member>
        </type>
        <type category="struct" name="VkDedicatedAllocationMemoryAllocateInfoNV" structextends="VkMemoryAllocateInfo">
            <member values="VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*                      <name>pNext</name></member>
            <member optional="true"><type>VkImage</type>          <name>image</name><comment>Image that this allocation will be bound to</comment></member>
            <member optional="true"><type>VkBuffer</type>         <name>buffer</name><comment>Buffer that this allocation will be bound to</comment></member>
        </type>
        <type category="struct" name="VkExternalImageFormatPropertiesNV" returnedonly="true">
            <member><type>VkImageFormatProperties</type>          <name>imageFormatProperties</name></member>
            <member optional="true"><type>VkExternalMemoryFeatureFlagsNV</type>   <name>externalMemoryFeatures</name></member>
            <member optional="true"><type>VkExternalMemoryHandleTypeFlagsNV</type> <name>exportFromImportedHandleTypes</name></member>
            <member optional="true"><type>VkExternalMemoryHandleTypeFlagsNV</type> <name>compatibleHandleTypes</name></member>
        </type>
        <type category="struct" name="VkExternalMemoryImageCreateInfoNV" structextends="VkImageCreateInfo">
            <member values="VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*                      <name>pNext</name></member>
            <member optional="true"><type>VkExternalMemoryHandleTypeFlagsNV</type> <name>handleTypes</name></member>
        </type>
        <type category="struct" name="VkExportMemoryAllocateInfoNV" structextends="VkMemoryAllocateInfo">
            <member values="VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*                      <name>pNext</name></member>
            <member optional="true"><type>VkExternalMemoryHandleTypeFlagsNV</type> <name>handleTypes</name></member>
        </type>
        <type category="struct" name="VkImportMemoryWin32HandleInfoNV" structextends="VkMemoryAllocateInfo">
            <member values="VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*                      <name>pNext</name></member>
            <member optional="true"><type>VkExternalMemoryHandleTypeFlagsNV</type> <name>handleType</name></member>
            <member optional="true"><type>HANDLE</type>                           <name>handle</name></member>
        </type>
        <type category="struct" name="VkExportMemoryWin32HandleInfoNV" structextends="VkMemoryAllocateInfo">
            <member values="VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*                      <name>pNext</name></member>
            <member optional="true">const <type>SECURITY_ATTRIBUTES</type>*       <name>pAttributes</name></member>
            <member optional="true"><type>DWORD</type>                            <name>dwAccess</name></member>
        </type>
        <type category="struct" name="VkWin32KeyedMutexAcquireReleaseInfoNV" structextends="VkSubmitInfo">
            <member values="VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*                      <name>pNext</name></member>
            <member optional="true"><type>uint32_t</type>                         <name>acquireCount</name></member>
            <member len="acquireCount">const <type>VkDeviceMemory</type>*            <name>pAcquireSyncs</name></member>
            <member len="acquireCount">const <type>uint64_t</type>*                  <name>pAcquireKeys</name></member>
            <member len="acquireCount">const <type>uint32_t</type>*                  <name>pAcquireTimeoutMilliseconds</name></member>
            <member optional="true"><type>uint32_t</type>                         <name>releaseCount</name></member>
            <member len="releaseCount">const <type>VkDeviceMemory</type>*            <name>pReleaseSyncs</name></member>
            <member len="releaseCount">const <type>uint64_t</type>*                  <name>pReleaseKeys</name></member>
        </type>
        <type category="struct" name="VkDeviceGeneratedCommandsFeaturesNVX">
            <member values="VK_STRUCTURE_TYPE_DEVICE_GENERATED_COMMANDS_FEATURES_NVX"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*                      <name>pNext</name></member>
            <member><type>VkBool32</type>                         <name>computeBindingPointSupport</name></member>
        </type>
        <type category="struct" name="VkDeviceGeneratedCommandsLimitsNVX">
            <member values="VK_STRUCTURE_TYPE_DEVICE_GENERATED_COMMANDS_LIMITS_NVX"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*                      <name>pNext</name></member>
            <member><type>uint32_t</type>                         <name>maxIndirectCommandsLayoutTokenCount</name></member>
            <member><type>uint32_t</type>                         <name>maxObjectEntryCounts</name></member>
            <member><type>uint32_t</type>                         <name>minSequenceCountBufferOffsetAlignment</name></member>
            <member><type>uint32_t</type>                         <name>minSequenceIndexBufferOffsetAlignment</name></member>
            <member><type>uint32_t</type>                         <name>minCommandsTokenBufferOffsetAlignment</name></member>
        </type>
        <type category="struct" name="VkIndirectCommandsTokenNVX">
            <member><type>VkIndirectCommandsTokenTypeNVX</type>      <name>tokenType</name></member>
            <member><type>VkBuffer</type>                         <name>buffer</name><comment>buffer containing tableEntries and additional data for indirectCommands</comment></member>
            <member><type>VkDeviceSize</type>                     <name>offset</name><comment>offset from the base address of the buffer</comment></member>
        </type>
        <type category="struct" name="VkIndirectCommandsLayoutTokenNVX">
            <member><type>VkIndirectCommandsTokenTypeNVX</type>      <name>tokenType</name></member>
            <member><type>uint32_t</type>                         <name>bindingUnit</name><comment>Binding unit for vertex attribute / descriptor set, offset for pushconstants</comment></member>
            <member><type>uint32_t</type>                         <name>dynamicCount</name><comment>Number of variable dynamic values for descriptor set / push constants</comment></member>
            <member><type>uint32_t</type>                         <name>divisor</name><comment>Rate the which the array is advanced per element (must be power of 2, minimum 1)</comment></member>
        </type>
        <type category="struct" name="VkIndirectCommandsLayoutCreateInfoNVX">
            <member values="VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_NVX"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*                      <name>pNext</name></member>
            <member><type>VkPipelineBindPoint</type>                      <name>pipelineBindPoint</name></member>
            <member><type>VkIndirectCommandsLayoutUsageFlagsNVX</type>    <name>flags</name></member>
            <member><type>uint32_t</type>                                 <name>tokenCount</name></member>
            <member len="tokenCount">const <type>VkIndirectCommandsLayoutTokenNVX</type>*  <name>pTokens</name></member>
        </type>
        <type category="struct" name="VkCmdProcessCommandsInfoNVX">
            <member values="VK_STRUCTURE_TYPE_CMD_PROCESS_COMMANDS_INFO_NVX"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*                      <name>pNext</name></member>
            <member externsync="true"><type>VkObjectTableNVX</type>                                         <name>objectTable</name></member>
            <member><type>VkIndirectCommandsLayoutNVX</type>                              <name>indirectCommandsLayout</name></member>
            <member><type>uint32_t</type>                                                 <name>indirectCommandsTokenCount</name></member>
            <member len="indirectCommandsTokenCount">const <type>VkIndirectCommandsTokenNVX</type>*       <name>pIndirectCommandsTokens</name></member>
            <member><type>uint32_t</type>                                                 <name>maxSequencesCount</name></member>
            <member optional="true" externsync="true"><type>VkCommandBuffer</type>                          <name>targetCommandBuffer</name></member>
            <member optional="true"><type>VkBuffer</type>                                 <name>sequencesCountBuffer</name></member>
            <member optional="true"><type>VkDeviceSize</type>                             <name>sequencesCountOffset</name></member>
            <member optional="true"><type>VkBuffer</type>                                 <name>sequencesIndexBuffer</name></member>
            <member optional="true"><type>VkDeviceSize</type>                             <name>sequencesIndexOffset</name></member>
        </type>
        <type category="struct" name="VkCmdReserveSpaceForCommandsInfoNVX">
            <member values="VK_STRUCTURE_TYPE_CMD_RESERVE_SPACE_FOR_COMMANDS_INFO_NVX"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*                      <name>pNext</name></member>
            <member externsync="true"><type>VkObjectTableNVX</type>                                         <name>objectTable</name></member>
            <member><type>VkIndirectCommandsLayoutNVX</type>                              <name>indirectCommandsLayout</name></member>
            <member><type>uint32_t</type>                                                 <name>maxSequencesCount</name></member>
        </type>
        <type category="struct" name="VkObjectTableCreateInfoNVX">
            <member values="VK_STRUCTURE_TYPE_OBJECT_TABLE_CREATE_INFO_NVX"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*                      <name>pNext</name></member>
            <member><type>uint32_t</type>                                          <name>objectCount</name></member>
            <member len="objectCount">const <type>VkObjectEntryTypeNVX</type>*       <name>pObjectEntryTypes</name></member>
            <member len="objectCount">const <type>uint32_t</type>*                   <name>pObjectEntryCounts</name></member>
            <member len="objectCount">const <type>VkObjectEntryUsageFlagsNVX</type>* <name>pObjectEntryUsageFlags</name></member>

            <member><type>uint32_t</type> <name>maxUniformBuffersPerDescriptor</name></member>
            <member><type>uint32_t</type> <name>maxStorageBuffersPerDescriptor</name></member>
            <member><type>uint32_t</type> <name>maxStorageImagesPerDescriptor</name></member>
            <member><type>uint32_t</type> <name>maxSampledImagesPerDescriptor</name></member>
            <member><type>uint32_t</type> <name>maxPipelineLayouts</name></member>
        </type>
        <type category="struct" name="VkObjectTableEntryNVX">
            <member><type>VkObjectEntryTypeNVX</type>         <name>type</name></member>
            <member><type>VkObjectEntryUsageFlagsNVX</type>   <name>flags</name></member>
        </type>
        <type category="struct" name="VkObjectTablePipelineEntryNVX">
            <member><type>VkObjectEntryTypeNVX</type>         <name>type</name></member>
            <member><type>VkObjectEntryUsageFlagsNVX</type>   <name>flags</name></member>
            <member><type>VkPipeline</type>                   <name>pipeline</name></member>
        </type>
        <type category="struct" name="VkObjectTableDescriptorSetEntryNVX">
            <member><type>VkObjectEntryTypeNVX</type>         <name>type</name></member>
            <member><type>VkObjectEntryUsageFlagsNVX</type>   <name>flags</name></member>
            <member><type>VkPipelineLayout</type>             <name>pipelineLayout</name></member>
            <member><type>VkDescriptorSet</type>              <name>descriptorSet</name></member>
        </type>
        <type category="struct" name="VkObjectTableVertexBufferEntryNVX">
            <member><type>VkObjectEntryTypeNVX</type>         <name>type</name></member>
            <member><type>VkObjectEntryUsageFlagsNVX</type>   <name>flags</name></member>
            <member><type>VkBuffer</type>                     <name>buffer</name></member>
        </type>
        <type category="struct" name="VkObjectTableIndexBufferEntryNVX">
            <member><type>VkObjectEntryTypeNVX</type>         <name>type</name></member>
            <member><type>VkObjectEntryUsageFlagsNVX</type>   <name>flags</name></member>
            <member><type>VkBuffer</type>                     <name>buffer</name></member>
            <member><type>VkIndexType</type>                  <name>indexType</name></member>
        </type>
        <type category="struct" name="VkObjectTablePushConstantEntryNVX">
            <member><type>VkObjectEntryTypeNVX</type>         <name>type</name></member>
            <member><type>VkObjectEntryUsageFlagsNVX</type>   <name>flags</name></member>
            <member><type>VkPipelineLayout</type>             <name>pipelineLayout</name></member>
            <member><type>VkShaderStageFlags</type>           <name>stageFlags</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceFeatures2" structextends="VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2"><type>VkStructureType</type> <name>sType</name></member>
            <member><type>void</type>*                            <name>pNext</name></member>
            <member><type>VkPhysicalDeviceFeatures</type>         <name>features</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceFeatures2KHR"                            alias="VkPhysicalDeviceFeatures2"/>
        <type category="struct" name="VkPhysicalDeviceProperties2" returnedonly="true">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2"><type>VkStructureType</type> <name>sType</name></member>
            <member><type>void</type>*                            <name>pNext</name></member>
            <member><type>VkPhysicalDeviceProperties</type>       <name>properties</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceProperties2KHR"                          alias="VkPhysicalDeviceProperties2"/>
        <type category="struct" name="VkFormatProperties2" returnedonly="true">
            <member values="VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2"><type>VkStructureType</type> <name>sType</name></member>
            <member><type>void</type>*                            <name>pNext</name></member>
            <member><type>VkFormatProperties</type>               <name>formatProperties</name></member>
        </type>
        <type category="struct" name="VkFormatProperties2KHR"                                  alias="VkFormatProperties2"/>
        <type category="struct" name="VkImageFormatProperties2" returnedonly="true">
            <member values="VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2"><type>VkStructureType</type> <name>sType</name></member>
            <member><type>void</type>* <name>pNext</name></member>
            <member><type>VkImageFormatProperties</type>          <name>imageFormatProperties</name></member>
        </type>
        <type category="struct" name="VkImageFormatProperties2KHR"                             alias="VkImageFormatProperties2"/>
        <type category="struct" name="VkPhysicalDeviceImageFormatInfo2">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>* <name>pNext</name></member>
            <member><type>VkFormat</type>                         <name>format</name></member>
            <member><type>VkImageType</type>                      <name>type</name></member>
            <member><type>VkImageTiling</type>                    <name>tiling</name></member>
            <member><type>VkImageUsageFlags</type>                <name>usage</name></member>
            <member optional="true"><type>VkImageCreateFlags</type> <name>flags</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceImageFormatInfo2KHR"                     alias="VkPhysicalDeviceImageFormatInfo2"/>
        <type category="struct" name="VkQueueFamilyProperties2" returnedonly="true">
            <member values="VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2"><type>VkStructureType</type> <name>sType</name></member>
            <member><type>void</type>*                            <name>pNext</name></member>
            <member><type>VkQueueFamilyProperties</type>          <name>queueFamilyProperties</name></member>
        </type>
        <type category="struct" name="VkQueueFamilyProperties2KHR"                             alias="VkQueueFamilyProperties2"/>
        <type category="struct" name="VkPhysicalDeviceMemoryProperties2" returnedonly="true">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2"><type>VkStructureType</type> <name>sType</name></member>
            <member><type>void</type>*                            <name>pNext</name></member>
            <member><type>VkPhysicalDeviceMemoryProperties</type> <name>memoryProperties</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceMemoryProperties2KHR"                    alias="VkPhysicalDeviceMemoryProperties2"/>
        <type category="struct" name="VkSparseImageFormatProperties2" returnedonly="true">
            <member values="VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2"><type>VkStructureType</type> <name>sType</name></member>
            <member><type>void</type>*                            <name>pNext</name></member>
            <member><type>VkSparseImageFormatProperties</type>    <name>properties</name></member>
        </type>
        <type category="struct" name="VkSparseImageFormatProperties2KHR"                       alias="VkSparseImageFormatProperties2"/>
        <type category="struct" name="VkPhysicalDeviceSparseImageFormatInfo2">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*                      <name>pNext</name></member>
            <member><type>VkFormat</type>                         <name>format</name></member>
            <member><type>VkImageType</type>                      <name>type</name></member>
            <member><type>VkSampleCountFlagBits</type>            <name>samples</name></member>
            <member><type>VkImageUsageFlags</type>                <name>usage</name></member>
            <member><type>VkImageTiling</type>                    <name>tiling</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceSparseImageFormatInfo2KHR"               alias="VkPhysicalDeviceSparseImageFormatInfo2"/>
        <type category="struct" name="VkPhysicalDevicePushDescriptorPropertiesKHR" returnedonly="true" structextends="VkPhysicalDeviceProperties2">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member><type>void</type>*                            <name>pNext</name></member>
            <member><type>uint32_t</type>                         <name>maxPushDescriptors</name></member>
        </type>
        <type category="struct" name="VkConformanceVersionKHR">
            <member><type>uint8_t</type>                          <name>major</name></member>
            <member><type>uint8_t</type>                          <name>minor</name></member>
            <member><type>uint8_t</type>                          <name>subminor</name></member>
            <member><type>uint8_t</type>                          <name>patch</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceDriverPropertiesKHR" structextends="VkPhysicalDeviceProperties2" returnedonly="true">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member><type>void</type>*                            <name>pNext</name></member>
            <member><type>VkDriverIdKHR</type>                    <name>driverID</name></member>
            <member><type>char</type>                             <name>driverName</name>[<enum>VK_MAX_DRIVER_NAME_SIZE_KHR</enum>]</member>
            <member><type>char</type>                             <name>driverInfo</name>[<enum>VK_MAX_DRIVER_INFO_SIZE_KHR</enum>]</member>
            <member><type>VkConformanceVersionKHR</type>          <name>conformanceVersion</name></member>
        </type>
        <type category="struct" name="VkPresentRegionsKHR" structextends="VkPresentInfoKHR">
            <member values="VK_STRUCTURE_TYPE_PRESENT_REGIONS_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*                      <name>pNext</name></member>
            <member><type>uint32_t</type>                         <name>swapchainCount</name><comment>Copy of VkPresentInfoKHR::swapchainCount</comment></member>
            <member len="swapchainCount" optional="true">const <type>VkPresentRegionKHR</type>*   <name>pRegions</name><comment>The regions that have changed</comment></member>
        </type>
        <type category="struct" name="VkPresentRegionKHR">
            <member optional="true"><type>uint32_t</type>         <name>rectangleCount</name><comment>Number of rectangles in pRectangles</comment></member>
            <member optional="true" len="rectangleCount">const <type>VkRectLayerKHR</type>*   <name>pRectangles</name><comment>Array of rectangles that have changed in a swapchain's image(s)</comment></member>
        </type>
        <type category="struct" name="VkRectLayerKHR">
            <member><type>VkOffset2D</type>                       <name>offset</name><comment>upper-left corner of a rectangle that has not changed, in pixels of a presentation images</comment></member>
            <member noautovalidity="true"><type>VkExtent2D</type> <name>extent</name><comment>Dimensions of a rectangle that has not changed, in pixels of a presentation images</comment></member>
            <member><type>uint32_t</type>                         <name>layer</name><comment>Layer of a swapchain's image(s), for stereoscopic-3D images</comment></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceVariablePointersFeatures" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES"><type>VkStructureType</type> <name>sType</name></member>
            <member><type>void</type>*                            <name>pNext</name></member>
            <member><type>VkBool32</type>                         <name>variablePointersStorageBuffer</name></member>
            <member><type>VkBool32</type>                         <name>variablePointers</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceVariablePointersFeaturesKHR"             alias="VkPhysicalDeviceVariablePointersFeatures"/>
        <type category="struct" name="VkPhysicalDeviceVariablePointerFeaturesKHR"              alias="VkPhysicalDeviceVariablePointersFeatures"/>
        <type category="struct" name="VkPhysicalDeviceVariablePointerFeatures"                 alias="VkPhysicalDeviceVariablePointersFeatures"/>
        <type category="struct" name="VkExternalMemoryProperties" returnedonly="true">
            <member><type>VkExternalMemoryFeatureFlags</type>  <name>externalMemoryFeatures</name></member>
            <member optional="true"><type>VkExternalMemoryHandleTypeFlags</type> <name>exportFromImportedHandleTypes</name></member>
            <member><type>VkExternalMemoryHandleTypeFlags</type> <name>compatibleHandleTypes</name></member>
        </type>
        <type category="struct" name="VkExternalMemoryPropertiesKHR"                           alias="VkExternalMemoryProperties"/>
        <type category="struct" name="VkPhysicalDeviceExternalImageFormatInfo"  structextends="VkPhysicalDeviceImageFormatInfo2">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*                      <name>pNext</name></member>
            <member optional="true"><type>VkExternalMemoryHandleTypeFlagBits</type> <name>handleType</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceExternalImageFormatInfoKHR"              alias="VkPhysicalDeviceExternalImageFormatInfo"/>
        <type category="struct" name="VkExternalImageFormatProperties" returnedonly="true" structextends="VkImageFormatProperties2">
            <member values="VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES"><type>VkStructureType</type> <name>sType</name></member>
            <member><type>void</type>*                            <name>pNext</name></member>
            <member><type>VkExternalMemoryProperties</type> <name>externalMemoryProperties</name></member>
        </type>
        <type category="struct" name="VkExternalImageFormatPropertiesKHR"                      alias="VkExternalImageFormatProperties"/>
        <type category="struct" name="VkPhysicalDeviceExternalBufferInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*                      <name>pNext</name></member>
            <member optional="true"><type>VkBufferCreateFlags</type> <name>flags</name></member>
            <member><type>VkBufferUsageFlags</type>               <name>usage</name></member>
            <member><type>VkExternalMemoryHandleTypeFlagBits</type> <name>handleType</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceExternalBufferInfoKHR"                   alias="VkPhysicalDeviceExternalBufferInfo"/>
        <type category="struct" name="VkExternalBufferProperties" returnedonly="true">
            <member values="VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES"><type>VkStructureType</type> <name>sType</name></member>
            <member><type>void</type>*                            <name>pNext</name></member>
            <member><type>VkExternalMemoryProperties</type>    <name>externalMemoryProperties</name></member>
        </type>
        <type category="struct" name="VkExternalBufferPropertiesKHR"                           alias="VkExternalBufferProperties"/>
        <type category="struct" name="VkPhysicalDeviceIDProperties" returnedonly="true" structextends="VkPhysicalDeviceProperties2">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES"><type>VkStructureType</type> <name>sType</name></member>
            <member><type>void</type>*                            <name>pNext</name></member>
            <member><type>uint8_t</type>                          <name>deviceUUID</name>[<enum>VK_UUID_SIZE</enum>]</member>
            <member><type>uint8_t</type>                          <name>driverUUID</name>[<enum>VK_UUID_SIZE</enum>]</member>
            <member><type>uint8_t</type>                          <name>deviceLUID</name>[<enum>VK_LUID_SIZE</enum>]</member>
            <member><type>uint32_t</type>                         <name>deviceNodeMask</name></member>
            <member><type>VkBool32</type>                         <name>deviceLUIDValid</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceIDPropertiesKHR"                         alias="VkPhysicalDeviceIDProperties"/>
        <type category="struct" name="VkExternalMemoryImageCreateInfo" structextends="VkImageCreateInfo">
            <member values="VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*                      <name>pNext</name></member>
            <member><type>VkExternalMemoryHandleTypeFlags</type> <name>handleTypes</name></member>
        </type>
        <type category="struct" name="VkExternalMemoryImageCreateInfoKHR"                      alias="VkExternalMemoryImageCreateInfo"/>
        <type category="struct" name="VkExternalMemoryBufferCreateInfo" structextends="VkBufferCreateInfo">
            <member values="VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*                      <name>pNext</name></member>
            <member optional="true"><type>VkExternalMemoryHandleTypeFlags</type> <name>handleTypes</name></member>
        </type>
        <type category="struct" name="VkExternalMemoryBufferCreateInfoKHR"                     alias="VkExternalMemoryBufferCreateInfo"/>
        <type category="struct" name="VkExportMemoryAllocateInfo" structextends="VkMemoryAllocateInfo">
            <member values="VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*                      <name>pNext</name></member>
            <member optional="true"><type>VkExternalMemoryHandleTypeFlags</type> <name>handleTypes</name></member>
        </type>
        <type category="struct" name="VkExportMemoryAllocateInfoKHR"                           alias="VkExportMemoryAllocateInfo"/>
        <type category="struct" name="VkImportMemoryWin32HandleInfoKHR" structextends="VkMemoryAllocateInfo">
            <member values="VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*                      <name>pNext</name></member>
            <member optional="true"><type>VkExternalMemoryHandleTypeFlagBits</type> <name>handleType</name></member>
            <member optional="true"><type>HANDLE</type>           <name>handle</name></member>
            <member optional="true"><type>LPCWSTR</type>          <name>name</name></member>
        </type>
        <type category="struct" name="VkExportMemoryWin32HandleInfoKHR" structextends="VkMemoryAllocateInfo">
            <member values="VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*                      <name>pNext</name></member>
            <member optional="true">const <type>SECURITY_ATTRIBUTES</type>* <name>pAttributes</name></member>
            <member><type>DWORD</type>                            <name>dwAccess</name></member>
            <member><type>LPCWSTR</type>                          <name>name</name></member>
        </type>
        <type category="struct" name="VkMemoryWin32HandlePropertiesKHR" returnedonly="true">
            <member values="VK_STRUCTURE_TYPE_MEMORY_WIN32_HANDLE_PROPERTIES_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member><type>void</type>*                            <name>pNext</name></member>
            <member><type>uint32_t</type>                         <name>memoryTypeBits</name></member>
        </type>
        <type category="struct" name="VkMemoryGetWin32HandleInfoKHR">
            <member values="VK_STRUCTURE_TYPE_MEMORY_GET_WIN32_HANDLE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*                      <name>pNext</name></member>
            <member><type>VkDeviceMemory</type>                   <name>memory</name></member>
            <member><type>VkExternalMemoryHandleTypeFlagBits</type> <name>handleType</name></member>
        </type>
        <type category="struct" name="VkImportMemoryFdInfoKHR" structextends="VkMemoryAllocateInfo">
            <member values="VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*                      <name>pNext</name></member>
            <member optional="true"><type>VkExternalMemoryHandleTypeFlagBits</type> <name>handleType</name></member>
            <member><type>int</type>                              <name>fd</name></member>
        </type>
        <type category="struct" name="VkMemoryFdPropertiesKHR" returnedonly="true">
            <member values="VK_STRUCTURE_TYPE_MEMORY_FD_PROPERTIES_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member><type>void</type>*                            <name>pNext</name></member>
            <member><type>uint32_t</type>                         <name>memoryTypeBits</name></member>
        </type>
        <type category="struct" name="VkMemoryGetFdInfoKHR">
            <member values="VK_STRUCTURE_TYPE_MEMORY_GET_FD_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*                      <name>pNext</name></member>
            <member><type>VkDeviceMemory</type>                   <name>memory</name></member>
            <member><type>VkExternalMemoryHandleTypeFlagBits</type> <name>handleType</name></member>
        </type>
        <type category="struct" name="VkWin32KeyedMutexAcquireReleaseInfoKHR" structextends="VkSubmitInfo">
            <member values="VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*                      <name>pNext</name></member>
            <member optional="true"><type>uint32_t</type>         <name>acquireCount</name></member>
            <member len="acquireCount">const <type>VkDeviceMemory</type>* <name>pAcquireSyncs</name></member>
            <member len="acquireCount">const <type>uint64_t</type>* <name>pAcquireKeys</name></member>
            <member len="acquireCount">const <type>uint32_t</type>* <name>pAcquireTimeouts</name></member>
            <member optional="true"><type>uint32_t</type>         <name>releaseCount</name></member>
            <member len="releaseCount">const <type>VkDeviceMemory</type>* <name>pReleaseSyncs</name></member>
            <member len="releaseCount">const <type>uint64_t</type>* <name>pReleaseKeys</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceExternalSemaphoreInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*                      <name>pNext</name></member>
            <member><type>VkExternalSemaphoreHandleTypeFlagBits</type> <name>handleType</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceExternalSemaphoreInfoKHR"                alias="VkPhysicalDeviceExternalSemaphoreInfo"/>
        <type category="struct" name="VkExternalSemaphoreProperties" returnedonly="true">
            <member values="VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES"><type>VkStructureType</type> <name>sType</name></member>
            <member><type>void</type>*                            <name>pNext</name></member>
            <member><type>VkExternalSemaphoreHandleTypeFlags</type> <name>exportFromImportedHandleTypes</name></member>
            <member><type>VkExternalSemaphoreHandleTypeFlags</type> <name>compatibleHandleTypes</name></member>
            <member optional="true"><type>VkExternalSemaphoreFeatureFlags</type> <name>externalSemaphoreFeatures</name></member>
        </type>
        <type category="struct" name="VkExternalSemaphorePropertiesKHR"                        alias="VkExternalSemaphoreProperties"/>
        <type category="struct" name="VkExportSemaphoreCreateInfo" structextends="VkSemaphoreCreateInfo">
            <member values="VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*                      <name>pNext</name></member>
            <member optional="true"><type>VkExternalSemaphoreHandleTypeFlags</type> <name>handleTypes</name></member>
        </type>
        <type category="struct" name="VkExportSemaphoreCreateInfoKHR"                          alias="VkExportSemaphoreCreateInfo"/>
        <type category="struct" name="VkImportSemaphoreWin32HandleInfoKHR">
            <member values="VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*                      <name>pNext</name></member>
            <member externsync="true"><type>VkSemaphore</type>    <name>semaphore</name></member>
            <member optional="true"><type>VkSemaphoreImportFlags</type> <name>flags</name></member>
            <member optional="true"><type>VkExternalSemaphoreHandleTypeFlagBits</type> <name>handleType</name></member>
            <member optional="true"><type>HANDLE</type>           <name>handle</name></member>
            <member optional="true"><type>LPCWSTR</type>          <name>name</name></member>
        </type>
        <type category="struct" name="VkExportSemaphoreWin32HandleInfoKHR" structextends="VkSemaphoreCreateInfo">
            <member values="VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*                      <name>pNext</name></member>
            <member optional="true">const <type>SECURITY_ATTRIBUTES</type>*       <name>pAttributes</name></member>
            <member><type>DWORD</type>                            <name>dwAccess</name></member>
            <member><type>LPCWSTR</type>                          <name>name</name></member>
        </type>
        <type category="struct" name="VkD3D12FenceSubmitInfoKHR" structextends="VkSubmitInfo">
            <member values="VK_STRUCTURE_TYPE_D3D12_FENCE_SUBMIT_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*                      <name>pNext</name></member>
            <member optional="true"><type>uint32_t</type>         <name>waitSemaphoreValuesCount</name></member>
            <member optional="true" len="waitSemaphoreValuesCount">const <type>uint64_t</type>* <name>pWaitSemaphoreValues</name></member>
            <member optional="true"><type>uint32_t</type>         <name>signalSemaphoreValuesCount</name></member>
            <member optional="true" len="signalSemaphoreValuesCount">const <type>uint64_t</type>* <name>pSignalSemaphoreValues</name></member>
        </type>
        <type category="struct" name="VkSemaphoreGetWin32HandleInfoKHR">
            <member values="VK_STRUCTURE_TYPE_SEMAPHORE_GET_WIN32_HANDLE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*                      <name>pNext</name></member>
            <member><type>VkSemaphore</type>                      <name>semaphore</name></member>
            <member><type>VkExternalSemaphoreHandleTypeFlagBits</type> <name>handleType</name></member>
        </type>
        <type category="struct" name="VkImportSemaphoreFdInfoKHR">
            <member values="VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_FD_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*                      <name>pNext</name></member>
            <member externsync="true"><type>VkSemaphore</type>    <name>semaphore</name></member>
            <member optional="true"><type>VkSemaphoreImportFlags</type> <name>flags</name></member>
            <member><type>VkExternalSemaphoreHandleTypeFlagBits</type> <name>handleType</name></member>
            <member><type>int</type>                              <name>fd</name></member>
        </type>
        <type category="struct" name="VkSemaphoreGetFdInfoKHR">
            <member values="VK_STRUCTURE_TYPE_SEMAPHORE_GET_FD_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*                      <name>pNext</name></member>
            <member><type>VkSemaphore</type>                      <name>semaphore</name></member>
            <member><type>VkExternalSemaphoreHandleTypeFlagBits</type> <name>handleType</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceExternalFenceInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*                      <name>pNext</name></member>
            <member><type>VkExternalFenceHandleTypeFlagBits</type> <name>handleType</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceExternalFenceInfoKHR"                    alias="VkPhysicalDeviceExternalFenceInfo"/>
        <type category="struct" name="VkExternalFenceProperties" returnedonly="true">
            <member values="VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES"><type>VkStructureType</type> <name>sType</name></member>
            <member><type>void</type>*                            <name>pNext</name></member>
            <member><type>VkExternalFenceHandleTypeFlags</type> <name>exportFromImportedHandleTypes</name></member>
            <member><type>VkExternalFenceHandleTypeFlags</type> <name>compatibleHandleTypes</name></member>
            <member optional="true"><type>VkExternalFenceFeatureFlags</type> <name>externalFenceFeatures</name></member>
        </type>
        <type category="struct" name="VkExternalFencePropertiesKHR"                            alias="VkExternalFenceProperties"/>
        <type category="struct" name="VkExportFenceCreateInfo" structextends="VkFenceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*                      <name>pNext</name></member>
            <member optional="true"><type>VkExternalFenceHandleTypeFlags</type> <name>handleTypes</name></member>
        </type>
        <type category="struct" name="VkExportFenceCreateInfoKHR"                              alias="VkExportFenceCreateInfo"/>
        <type category="struct" name="VkImportFenceWin32HandleInfoKHR">
            <member values="VK_STRUCTURE_TYPE_IMPORT_FENCE_WIN32_HANDLE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*                                        <name>pNext</name></member>
            <member externsync="true"><type>VkFence</type>                          <name>fence</name></member>
            <member optional="true"><type>VkFenceImportFlags</type>              <name>flags</name></member>
            <member optional="true"><type>VkExternalFenceHandleTypeFlagBits</type>  <name>handleType</name></member>
            <member optional="true"><type>HANDLE</type>                             <name>handle</name></member>
            <member optional="true"><type>LPCWSTR</type>                            <name>name</name></member>
        </type>
        <type category="struct" name="VkExportFenceWin32HandleInfoKHR" structextends="VkFenceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_EXPORT_FENCE_WIN32_HANDLE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*                                <name>pNext</name></member>
            <member optional="true">const <type>SECURITY_ATTRIBUTES</type>* <name>pAttributes</name></member>
            <member><type>DWORD</type>                                      <name>dwAccess</name></member>
            <member><type>LPCWSTR</type>                                    <name>name</name></member>
        </type>
        <type category="struct" name="VkFenceGetWin32HandleInfoKHR">
            <member values="VK_STRUCTURE_TYPE_FENCE_GET_WIN32_HANDLE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*                            <name>pNext</name></member>
            <member><type>VkFence</type>                                <name>fence</name></member>
            <member><type>VkExternalFenceHandleTypeFlagBits</type>   <name>handleType</name></member>
        </type>
        <type category="struct" name="VkImportFenceFdInfoKHR">
            <member values="VK_STRUCTURE_TYPE_IMPORT_FENCE_FD_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*                            <name>pNext</name></member>
            <member externsync="true"><type>VkFence</type>              <name>fence</name></member>
            <member optional="true"><type>VkFenceImportFlags</type>  <name>flags</name></member>
            <member><type>VkExternalFenceHandleTypeFlagBits</type>   <name>handleType</name></member>
            <member><type>int</type>                                    <name>fd</name></member>
        </type>
        <type category="struct" name="VkFenceGetFdInfoKHR">
            <member values="VK_STRUCTURE_TYPE_FENCE_GET_FD_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*                            <name>pNext</name></member>
            <member><type>VkFence</type>                                <name>fence</name></member>
            <member><type>VkExternalFenceHandleTypeFlagBits</type>   <name>handleType</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceMultiviewFeatures" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES"><type>VkStructureType</type> <name>sType</name></member>
            <member noautovalidity="true"><type>void</type>*                            <name>pNext</name></member>
            <member><type>VkBool32</type>                         <name>multiview</name><comment>Multiple views in a renderpass</comment></member>
            <member><type>VkBool32</type>                         <name>multiviewGeometryShader</name><comment>Multiple views in a renderpass w/ geometry shader</comment></member>
            <member><type>VkBool32</type>                         <name>multiviewTessellationShader</name><comment>Multiple views in a renderpass w/ tessellation shader</comment></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceMultiviewFeaturesKHR"                    alias="VkPhysicalDeviceMultiviewFeatures"/>
        <type category="struct" name="VkPhysicalDeviceMultiviewProperties" returnedonly="true" structextends="VkPhysicalDeviceProperties2">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES"><type>VkStructureType</type> <name>sType</name></member>
            <member><type>void</type>*                            <name>pNext</name></member>
            <member><type>uint32_t</type>                         <name>maxMultiviewViewCount</name><comment>max number of views in a subpass</comment></member>
            <member><type>uint32_t</type>                         <name>maxMultiviewInstanceIndex</name><comment>max instance index for a draw in a multiview subpass</comment></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceMultiviewPropertiesKHR"                  alias="VkPhysicalDeviceMultiviewProperties"/>
        <type category="struct" name="VkRenderPassMultiviewCreateInfo" structextends="VkRenderPassCreateInfo">
            <member values="VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO"><type>VkStructureType</type>        <name>sType</name></member>
            <member>const <type>void</type>*            <name>pNext</name></member>
            <member optional="true"><type>uint32_t</type>               <name>subpassCount</name></member>
            <member len="subpassCount">const <type>uint32_t</type>*     <name>pViewMasks</name></member>
            <member optional="true"><type>uint32_t</type>               <name>dependencyCount</name></member>
            <member len="dependencyCount">const <type>int32_t</type>*   <name>pViewOffsets</name></member>
            <member optional="true"><type>uint32_t</type>               <name>correlationMaskCount</name></member>
            <member len="correlationMaskCount">const <type>uint32_t</type>* <name>pCorrelationMasks</name></member>
        </type>
        <type category="struct" name="VkRenderPassMultiviewCreateInfoKHR"                      alias="VkRenderPassMultiviewCreateInfo"/>
        <type category="struct" name="VkSurfaceCapabilities2EXT" returnedonly="true">
            <member values="VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member><type>void</type>*                            <name>pNext</name></member>
            <member><type>uint32_t</type>                         <name>minImageCount</name><comment>Supported minimum number of images for the surface</comment></member>
            <member><type>uint32_t</type>                         <name>maxImageCount</name><comment>Supported maximum number of images for the surface, 0 for unlimited</comment></member>
            <member><type>VkExtent2D</type>                       <name>currentExtent</name><comment>Current image width and height for the surface, (0, 0) if undefined</comment></member>
            <member><type>VkExtent2D</type>                       <name>minImageExtent</name><comment>Supported minimum image width and height for the surface</comment></member>
            <member><type>VkExtent2D</type>                       <name>maxImageExtent</name><comment>Supported maximum image width and height for the surface</comment></member>
            <member><type>uint32_t</type>                         <name>maxImageArrayLayers</name><comment>Supported maximum number of image layers for the surface</comment></member>
            <member optional="true"><type>VkSurfaceTransformFlagsKHR</type>       <name>supportedTransforms</name><comment>1 or more bits representing the transforms supported</comment></member>
            <member><type>VkSurfaceTransformFlagBitsKHR</type>    <name>currentTransform</name><comment>The surface's current transform relative to the device's natural orientation</comment></member>
            <member optional="true"><type>VkCompositeAlphaFlagsKHR</type>         <name>supportedCompositeAlpha</name><comment>1 or more bits representing the alpha compositing modes supported</comment></member>
            <member optional="true"><type>VkImageUsageFlags</type>                <name>supportedUsageFlags</name><comment>Supported image usage flags for the surface</comment></member>
            <member optional="true"><type>VkSurfaceCounterFlagsEXT</type> <name>supportedSurfaceCounters</name></member>
        </type>
        <type category="struct" name="VkDisplayPowerInfoEXT">
            <member values="VK_STRUCTURE_TYPE_DISPLAY_POWER_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*                      <name>pNext</name></member>
            <member><type>VkDisplayPowerStateEXT</type>           <name>powerState</name></member>
        </type>
        <type category="struct" name="VkDeviceEventInfoEXT">
            <member values="VK_STRUCTURE_TYPE_DEVICE_EVENT_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*                      <name>pNext</name></member>
            <member><type>VkDeviceEventTypeEXT</type>             <name>deviceEvent</name></member>
        </type>
        <type category="struct" name="VkDisplayEventInfoEXT">
            <member values="VK_STRUCTURE_TYPE_DISPLAY_EVENT_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*                      <name>pNext</name></member>
            <member><type>VkDisplayEventTypeEXT</type>            <name>displayEvent</name></member>
        </type>
        <type category="struct" name="VkSwapchainCounterCreateInfoEXT" structextends="VkSwapchainCreateInfoKHR">
            <member values="VK_STRUCTURE_TYPE_SWAPCHAIN_COUNTER_CREATE_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*                      <name>pNext</name></member>
            <member optional="true"><type>VkSurfaceCounterFlagsEXT</type>         <name>surfaceCounters</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceGroupProperties" returnedonly="true">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES"><type>VkStructureType</type> <name>sType</name></member>
            <member><type>void</type>*                            <name>pNext</name></member>
            <member><type>uint32_t</type>                         <name>physicalDeviceCount</name></member>
            <member><type>VkPhysicalDevice</type>                 <name>physicalDevices</name>[<enum>VK_MAX_DEVICE_GROUP_SIZE</enum>]</member>
            <member><type>VkBool32</type>                         <name>subsetAllocation</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceGroupPropertiesKHR"                      alias="VkPhysicalDeviceGroupProperties"/>
        <type category="struct" name="VkMemoryAllocateFlagsInfo" structextends="VkMemoryAllocateInfo">
            <member values="VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*                      <name>pNext</name></member>
            <member optional="true"><type>VkMemoryAllocateFlags</type> <name>flags</name></member>
            <member><type>uint32_t</type>                         <name>deviceMask</name></member>
        </type>
        <type category="struct" name="VkMemoryAllocateFlagsInfoKHR"                            alias="VkMemoryAllocateFlagsInfo"/>
        <type category="struct" name="VkBindBufferMemoryInfo">
            <member values="VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*                      <name>pNext</name></member>
            <member><type>VkBuffer</type>                         <name>buffer</name></member>
            <member><type>VkDeviceMemory</type>                   <name>memory</name></member>
            <member><type>VkDeviceSize</type>                     <name>memoryOffset</name></member>
        </type>
        <type category="struct" name="VkBindBufferMemoryInfoKHR"                               alias="VkBindBufferMemoryInfo"/>
        <type category="struct" name="VkBindBufferMemoryDeviceGroupInfo" structextends="VkBindBufferMemoryInfo">
            <member values="VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*                      <name>pNext</name></member>
            <member optional="true"><type>uint32_t</type>         <name>deviceIndexCount</name></member>
            <member len="deviceIndexCount">const <type>uint32_t</type>*  <name>pDeviceIndices</name></member>
        </type>
        <type category="struct" name="VkBindBufferMemoryDeviceGroupInfoKHR"                    alias="VkBindBufferMemoryDeviceGroupInfo"/>
        <type category="struct" name="VkBindImageMemoryInfo">
            <member values="VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*                      <name>pNext</name></member>
            <member><type>VkImage</type>                          <name>image</name></member>
            <member noautovalidity="true"><type>VkDeviceMemory</type>                   <name>memory</name></member>
            <member><type>VkDeviceSize</type>                     <name>memoryOffset</name></member>
        </type>
        <type category="struct" name="VkBindImageMemoryInfoKHR"                                alias="VkBindImageMemoryInfo"/>
        <type category="struct" name="VkBindImageMemoryDeviceGroupInfo" structextends="VkBindImageMemoryInfo">
            <member values="VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*                      <name>pNext</name></member>
            <member optional="true"><type>uint32_t</type>         <name>deviceIndexCount</name></member>
            <member len="deviceIndexCount">const <type>uint32_t</type>*  <name>pDeviceIndices</name></member>
            <member optional="true"><type>uint32_t</type>         <name>splitInstanceBindRegionCount</name></member>
            <member len="splitInstanceBindRegionCount">const <type>VkRect2D</type>*  <name>pSplitInstanceBindRegions</name></member>
        </type>
        <type category="struct" name="VkBindImageMemoryDeviceGroupInfoKHR"                     alias="VkBindImageMemoryDeviceGroupInfo"/>
        <type category="struct" name="VkDeviceGroupRenderPassBeginInfo" structextends="VkRenderPassBeginInfo">
            <member values="VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*                      <name>pNext</name></member>
            <member><type>uint32_t</type>                         <name>deviceMask</name></member>
            <member optional="true"><type>uint32_t</type>         <name>deviceRenderAreaCount</name></member>
            <member len="deviceRenderAreaCount">const <type>VkRect2D</type>*  <name>pDeviceRenderAreas</name></member>
        </type>
        <type category="struct" name="VkDeviceGroupRenderPassBeginInfoKHR"                     alias="VkDeviceGroupRenderPassBeginInfo"/>
        <type category="struct" name="VkDeviceGroupCommandBufferBeginInfo" structextends="VkCommandBufferBeginInfo">
            <member values="VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*                      <name>pNext</name></member>
            <member><type>uint32_t</type>                         <name>deviceMask</name></member>
        </type>
        <type category="struct" name="VkDeviceGroupCommandBufferBeginInfoKHR"                  alias="VkDeviceGroupCommandBufferBeginInfo"/>
        <type category="struct" name="VkDeviceGroupSubmitInfo" structextends="VkSubmitInfo">
            <member values="VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*                      <name>pNext</name></member>
            <member optional="true"><type>uint32_t</type>         <name>waitSemaphoreCount</name></member>
            <member len="waitSemaphoreCount">const <type>uint32_t</type>*    <name>pWaitSemaphoreDeviceIndices</name></member>
            <member optional="true"><type>uint32_t</type>         <name>commandBufferCount</name></member>
            <member len="commandBufferCount">const <type>uint32_t</type>*    <name>pCommandBufferDeviceMasks</name></member>
            <member optional="true"><type>uint32_t</type>         <name>signalSemaphoreCount</name></member>
            <member len="signalSemaphoreCount">const <type>uint32_t</type>*  <name>pSignalSemaphoreDeviceIndices</name></member>
        </type>
        <type category="struct" name="VkDeviceGroupSubmitInfoKHR"                              alias="VkDeviceGroupSubmitInfo"/>
        <type category="struct" name="VkDeviceGroupBindSparseInfo" structextends="VkBindSparseInfo">
            <member values="VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*                      <name>pNext</name></member>
            <member><type>uint32_t</type>                         <name>resourceDeviceIndex</name></member>
            <member><type>uint32_t</type>                         <name>memoryDeviceIndex</name></member>
        </type>
        <type category="struct" name="VkDeviceGroupBindSparseInfoKHR"                          alias="VkDeviceGroupBindSparseInfo"/>
        <type category="struct" name="VkDeviceGroupPresentCapabilitiesKHR" returnedonly="true">
            <member values="VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_CAPABILITIES_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*                      <name>pNext</name></member>
            <member><type>uint32_t</type>                         <name>presentMask</name>[<enum>VK_MAX_DEVICE_GROUP_SIZE</enum>]</member>
            <member><type>VkDeviceGroupPresentModeFlagsKHR</type> <name>modes</name></member>
        </type>
        <type category="struct" name="VkImageSwapchainCreateInfoKHR" structextends="VkImageCreateInfo">
            <member values="VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*                      <name>pNext</name></member>
            <member optional="true"><type>VkSwapchainKHR</type>   <name>swapchain</name></member>
        </type>
        <type category="struct" name="VkBindImageMemorySwapchainInfoKHR" structextends="VkBindImageMemoryInfo">
            <member values="VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*                      <name>pNext</name></member>
            <member externsync="true"><type>VkSwapchainKHR</type> <name>swapchain</name></member>
            <member><type>uint32_t</type>                         <name>imageIndex</name></member>
        </type>
        <type category="struct" name="VkAcquireNextImageInfoKHR">
            <member values="VK_STRUCTURE_TYPE_ACQUIRE_NEXT_IMAGE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*                      <name>pNext</name></member>
            <member externsync="true"><type>VkSwapchainKHR</type> <name>swapchain</name></member>
            <member><type>uint64_t</type>                         <name>timeout</name></member>
            <member optional="true" externsync="true"><type>VkSemaphore</type> <name>semaphore</name></member>
            <member optional="true" externsync="true"><type>VkFence</type> <name>fence</name></member>
            <member><type>uint32_t</type>                         <name>deviceMask</name></member>
        </type>
        <type category="struct" name="VkDeviceGroupPresentInfoKHR" structextends="VkPresentInfoKHR">
            <member values="VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*                      <name>pNext</name></member>
            <member optional="true"><type>uint32_t</type>         <name>swapchainCount</name></member>
            <member len="swapchainCount">const <type>uint32_t</type>* <name>pDeviceMasks</name></member>
            <member><type>VkDeviceGroupPresentModeFlagBitsKHR</type> <name>mode</name></member>
        </type>
        <type category="struct" name="VkDeviceGroupDeviceCreateInfo" structextends="VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*                      <name>pNext</name></member>
            <member optional="true"><type>uint32_t</type>                         <name>physicalDeviceCount</name></member>
            <member len="physicalDeviceCount">const <type>VkPhysicalDevice</type>*  <name>pPhysicalDevices</name></member>
        </type>
        <type category="struct" name="VkDeviceGroupDeviceCreateInfoKHR"                        alias="VkDeviceGroupDeviceCreateInfo"/>
        <type category="struct" name="VkDeviceGroupSwapchainCreateInfoKHR" structextends="VkSwapchainCreateInfoKHR">
            <member values="VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*                      <name>pNext</name></member>
            <member><type>VkDeviceGroupPresentModeFlagsKHR</type>                         <name>modes</name></member>
        </type>
        <type category="struct" name="VkDescriptorUpdateTemplateEntry">
            <member><type>uint32_t</type>                         <name>dstBinding</name><comment>Binding within the destination descriptor set to write</comment></member>
            <member><type>uint32_t</type>                         <name>dstArrayElement</name><comment>Array element within the destination binding to write</comment></member>
            <member><type>uint32_t</type>                         <name>descriptorCount</name><comment>Number of descriptors to write</comment></member>
            <member><type>VkDescriptorType</type>                 <name>descriptorType</name><comment>Descriptor type to write</comment></member>
            <member><type>size_t</type>                           <name>offset</name><comment>Offset into pData where the descriptors to update are stored</comment></member>
            <member><type>size_t</type>                           <name>stride</name><comment>Stride between two descriptors in pData when writing more than one descriptor</comment></member>
        </type>
        <type category="struct" name="VkDescriptorUpdateTemplateEntryKHR"                      alias="VkDescriptorUpdateTemplateEntry"/>
        <type category="struct" name="VkDescriptorUpdateTemplateCreateInfo">
            <member values="VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*                               <name>pNext</name></member>
            <member optional="true"><type>VkDescriptorUpdateTemplateCreateFlags</type>    <name>flags</name></member>
            <member><type>uint32_t</type>                 <name>descriptorUpdateEntryCount</name><comment>Number of descriptor update entries to use for the update template</comment></member>
            <member len="descriptorUpdateEntryCount">const <type>VkDescriptorUpdateTemplateEntry</type>* <name>pDescriptorUpdateEntries</name><comment>Descriptor update entries for the template</comment></member>
            <member><type>VkDescriptorUpdateTemplateType</type> <name>templateType</name></member>
            <member optional="true"><type>VkDescriptorSetLayout</type> <name>descriptorSetLayout</name></member>
            <member noautovalidity="true"><type>VkPipelineBindPoint</type> <name>pipelineBindPoint</name></member>
            <member noautovalidity="true"><type>VkPipelineLayout</type><name>pipelineLayout</name><comment>If used for push descriptors, this is the only allowed layout</comment></member>
            <member noautovalidity="true"><type>uint32_t</type> <name>set</name></member>
        </type>
        <type category="struct" name="VkDescriptorUpdateTemplateCreateInfoKHR"                 alias="VkDescriptorUpdateTemplateCreateInfo"/>
        <type category="struct" name="VkXYColorEXT" comment="Chromaticity coordinate">
            <member><type>float</type>   <name>x</name></member>
            <member><type>float</type>   <name>y</name></member>
        </type>
        <type category="struct" name="VkHdrMetadataEXT">
                <comment>Display primary in chromaticity coordinates</comment>
            <member values="VK_STRUCTURE_TYPE_HDR_METADATA_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*    <name>pNext</name></member>
                <comment> From SMPTE 2086</comment>
            <member noautovalidity="true"><type>VkXYColorEXT</type>   <name>displayPrimaryRed</name><comment>Display primary's Red</comment></member>
            <member noautovalidity="true"><type>VkXYColorEXT</type>   <name>displayPrimaryGreen</name><comment>Display primary's Green</comment></member>
            <member noautovalidity="true"><type>VkXYColorEXT</type>   <name>displayPrimaryBlue</name><comment>Display primary's Blue</comment></member>
            <member noautovalidity="true"><type>VkXYColorEXT</type>   <name>whitePoint</name><comment>Display primary's Blue</comment></member>
            <member noautovalidity="true"><type>float</type>          <name>maxLuminance</name><comment>Display maximum luminance</comment></member>
            <member noautovalidity="true"><type>float</type>          <name>minLuminance</name><comment>Display minimum luminance</comment></member>
                <comment> From CTA 861.3</comment>
            <member noautovalidity="true"><type>float</type>          <name>maxContentLightLevel</name><comment>Content maximum luminance</comment></member>
            <member noautovalidity="true"><type>float</type>          <name>maxFrameAverageLightLevel</name></member>
        </type>
        <type category="struct" name="VkDisplayNativeHdrSurfaceCapabilitiesAMD" returnedonly="true" structextends="VkSurfaceCapabilities2KHR">
            <member values="VK_STRUCTURE_TYPE_DISPLAY_NATIVE_HDR_SURFACE_CAPABILITIES_AMD"><type>VkStructureType</type> <name>sType</name></member>
            <member><type>void</type>*          <name>pNext</name></member>
            <member><type>VkBool32</type>       <name>localDimmingSupport</name></member>
        </type>
        <type category="struct" name="VkSwapchainDisplayNativeHdrCreateInfoAMD" structextends="VkSwapchainCreateInfoKHR">
            <member values="VK_STRUCTURE_TYPE_SWAPCHAIN_DISPLAY_NATIVE_HDR_CREATE_INFO_AMD"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*    <name>pNext</name></member>
            <member><type>VkBool32</type>       <name>localDimmingEnable</name></member>
        </type>
        <type category="struct" name="VkRefreshCycleDurationGOOGLE" returnedonly="true">
            <member><type>uint64_t</type>                         <name>refreshDuration</name><comment>Number of nanoseconds from the start of one refresh cycle to the next</comment></member>
        </type>
        <type category="struct" name="VkPastPresentationTimingGOOGLE" returnedonly="true">
            <member><type>uint32_t</type>                         <name>presentID</name><comment>Application-provided identifier, previously given to vkQueuePresentKHR</comment></member>
            <member><type>uint64_t</type>                         <name>desiredPresentTime</name><comment>Earliest time an image should have been presented, previously given to vkQueuePresentKHR</comment></member>
            <member><type>uint64_t</type>                         <name>actualPresentTime</name><comment>Time the image was actually displayed</comment></member>
            <member><type>uint64_t</type>                         <name>earliestPresentTime</name><comment>Earliest time the image could have been displayed</comment></member>
            <member><type>uint64_t</type>                         <name>presentMargin</name><comment>How early vkQueuePresentKHR was processed vs. how soon it needed to be and make earliestPresentTime</comment></member>
        </type>
        <type category="struct" name="VkPresentTimesInfoGOOGLE" structextends="VkPresentInfoKHR">
            <member values="VK_STRUCTURE_TYPE_PRESENT_TIMES_INFO_GOOGLE"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*                      <name>pNext</name></member>
            <member><type>uint32_t</type>                         <name>swapchainCount</name><comment>Copy of VkPresentInfoKHR::swapchainCount</comment></member>
            <member len="swapchainCount" optional="true">const <type>VkPresentTimeGOOGLE</type>*   <name>pTimes</name><comment>The earliest times to present images</comment></member>
        </type>
        <type category="struct" name="VkPresentTimeGOOGLE">
            <member><type>uint32_t</type>                         <name>presentID</name><comment>Application-provided identifier</comment></member>
            <member><type>uint64_t</type>                         <name>desiredPresentTime</name><comment>Earliest time an image should be presented</comment></member>
        </type>
        <type category="struct" name="VkIOSSurfaceCreateInfoMVK">
            <member values="VK_STRUCTURE_TYPE_IOS_SURFACE_CREATE_INFO_MVK"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*                                    <name>pNext</name></member>
            <member optional="true"><type>VkIOSSurfaceCreateFlagsMVK</type>     <name>flags</name></member>
            <member noautovalidity="true">const <type>void</type>*                                    <name>pView</name></member>
        </type>
        <type category="struct" name="VkMacOSSurfaceCreateInfoMVK">
            <member values="VK_STRUCTURE_TYPE_MACOS_SURFACE_CREATE_INFO_MVK"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*                                    <name>pNext</name></member>
            <member optional="true"><type>VkMacOSSurfaceCreateFlagsMVK</type>   <name>flags</name></member>
            <member noautovalidity="true">const <type>void</type>*                                    <name>pView</name></member>
        </type>
        <type category="struct" name="VkMetalSurfaceCreateInfoEXT">
            <member values="VK_STRUCTURE_TYPE_METAL_SURFACE_CREATE_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*                                    <name>pNext</name></member>
            <member optional="true"><type>VkMetalSurfaceCreateFlagsEXT</type>   <name>flags</name></member>
            <member noautovalidity="true">const <type>CAMetalLayer</type>*      <name>pLayer</name></member>
        </type>
        <type category="struct" name="VkViewportWScalingNV">
            <member><type>float</type>          <name>xcoeff</name></member>
            <member><type>float</type>          <name>ycoeff</name></member>
        </type>
        <type category="struct" name="VkPipelineViewportWScalingStateCreateInfoNV" structextends="VkPipelineViewportStateCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*                      <name>pNext</name></member>
            <member><type>VkBool32</type>               <name>viewportWScalingEnable</name></member>
            <member><type>uint32_t</type>               <name>viewportCount</name></member>
            <member noautovalidity="true" optional="true" len="viewportCount">const <type>VkViewportWScalingNV</type>*      <name>pViewportWScalings</name></member>
        </type>
        <type category="struct" name="VkViewportSwizzleNV">
            <member><type>VkViewportCoordinateSwizzleNV</type>          <name>x</name></member>
            <member><type>VkViewportCoordinateSwizzleNV</type>          <name>y</name></member>
            <member><type>VkViewportCoordinateSwizzleNV</type>          <name>z</name></member>
            <member><type>VkViewportCoordinateSwizzleNV</type>          <name>w</name></member>
        </type>
        <type category="struct" name="VkPipelineViewportSwizzleStateCreateInfoNV" structextends="VkPipelineViewportStateCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*            <name>pNext</name></member>
            <member optional="true"><type>VkPipelineViewportSwizzleStateCreateFlagsNV</type>    <name>flags</name></member>
            <member><type>uint32_t</type>               <name>viewportCount</name></member>
            <member len="viewportCount">const <type>VkViewportSwizzleNV</type>*      <name>pViewportSwizzles</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceDiscardRectanglePropertiesEXT" returnedonly="true" structextends="VkPhysicalDeviceProperties2">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member><type>void</type>*                  <name>pNext</name></member>
            <member><type>uint32_t</type>               <name>maxDiscardRectangles</name><comment>max number of active discard rectangles</comment></member>
        </type>
        <type category="struct" name="VkPipelineDiscardRectangleStateCreateInfoEXT" structextends="VkGraphicsPipelineCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*                                                                      <name>pNext</name></member>
            <member optional="true"><type>VkPipelineDiscardRectangleStateCreateFlagsEXT</type>                    <name>flags</name></member>
            <member><type>VkDiscardRectangleModeEXT</type>                                                        <name>discardRectangleMode</name></member>
            <member optional="true"><type>uint32_t</type>                                                         <name>discardRectangleCount</name></member>
            <member noautovalidity="true" optional="true" len="discardRectangleCount">const <type>VkRect2D</type>* <name>pDiscardRectangles</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX" returnedonly="true" structextends="VkPhysicalDeviceProperties2">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_ATTRIBUTES_PROPERTIES_NVX"><type>VkStructureType</type> <name>sType</name></member>
            <member noautovalidity="true"><type>void</type>*                            <name>pNext</name></member>
            <member><type>VkBool32</type>                         <name>perViewPositionAllComponents</name></member>
        </type>
        <type category="struct" name="VkInputAttachmentAspectReference">
            <member><type>uint32_t</type>                        <name>subpass</name></member>
            <member><type>uint32_t</type>                        <name>inputAttachmentIndex</name></member>
            <member><type>VkImageAspectFlags</type>              <name>aspectMask</name></member>
        </type>
        <type category="struct" name="VkInputAttachmentAspectReferenceKHR"                     alias="VkInputAttachmentAspectReference"/>
        <type category="struct" name="VkRenderPassInputAttachmentAspectCreateInfo" structextends="VkRenderPassCreateInfo">
            <member values="VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*                     <name>pNext</name></member>
            <member><type>uint32_t</type>                        <name>aspectReferenceCount</name></member>
            <member len="aspectReferenceCount">const <type>VkInputAttachmentAspectReference</type>* <name>pAspectReferences</name></member>
        </type>
        <type category="struct" name="VkRenderPassInputAttachmentAspectCreateInfoKHR"          alias="VkRenderPassInputAttachmentAspectCreateInfo"/>
        <type category="struct" name="VkPhysicalDeviceSurfaceInfo2KHR">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SURFACE_INFO_2_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>* <name>pNext</name></member>
            <member><type>VkSurfaceKHR</type> <name>surface</name></member>
        </type>
        <type category="struct" name="VkSurfaceCapabilities2KHR" returnedonly="true">
            <member values="VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member><type>void</type>*   <name>pNext</name></member>
            <member><type>VkSurfaceCapabilitiesKHR</type> <name>surfaceCapabilities</name></member>
        </type>
        <type category="struct" name="VkSurfaceFormat2KHR" returnedonly="true">
            <member values="VK_STRUCTURE_TYPE_SURFACE_FORMAT_2_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member><type>void</type>* <name>pNext</name></member>
            <member><type>VkSurfaceFormatKHR</type> <name>surfaceFormat</name></member>
        </type>
        <type category="struct" name="VkDisplayProperties2KHR" returnedonly="true">
            <member values="VK_STRUCTURE_TYPE_DISPLAY_PROPERTIES_2_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member><type>void</type>* <name>pNext</name></member>
            <member><type>VkDisplayPropertiesKHR</type> <name>displayProperties</name></member>
        </type>
        <type category="struct" name="VkDisplayPlaneProperties2KHR" returnedonly="true">
            <member values="VK_STRUCTURE_TYPE_DISPLAY_PLANE_PROPERTIES_2_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member><type>void</type>* <name>pNext</name></member>
            <member><type>VkDisplayPlanePropertiesKHR</type> <name>displayPlaneProperties</name></member>
        </type>
        <type category="struct" name="VkDisplayModeProperties2KHR" returnedonly="true">
            <member values="VK_STRUCTURE_TYPE_DISPLAY_MODE_PROPERTIES_2_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member><type>void</type>* <name>pNext</name></member>
            <member><type>VkDisplayModePropertiesKHR</type> <name>displayModeProperties</name></member>
        </type>
        <type category="struct" name="VkDisplayPlaneInfo2KHR">
            <member values="VK_STRUCTURE_TYPE_DISPLAY_PLANE_INFO_2_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>* <name>pNext</name></member>
            <member externsync="true"><type>VkDisplayModeKHR</type> <name>mode</name></member>
            <member><type>uint32_t</type> <name>planeIndex</name></member>
        </type>
        <type category="struct" name="VkDisplayPlaneCapabilities2KHR" returnedonly="true">
            <member values="VK_STRUCTURE_TYPE_DISPLAY_PLANE_CAPABILITIES_2_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member><type>void</type>* <name>pNext</name></member>
            <member><type>VkDisplayPlaneCapabilitiesKHR</type> <name>capabilities</name></member>
        </type>
        <type category="struct" name="VkSharedPresentSurfaceCapabilitiesKHR" returnedonly="true" structextends="VkSurfaceCapabilities2KHR">
            <member values="VK_STRUCTURE_TYPE_SHARED_PRESENT_SURFACE_CAPABILITIES_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member noautovalidity="true"><type>void</type>*                            <name>pNext</name></member>
            <member optional="true"><type>VkImageUsageFlags</type> <name>sharedPresentSupportedUsageFlags</name><comment>Supported image usage flags if swapchain created using a shared present mode</comment></member>
        </type>
        <type category="struct" name="VkPhysicalDevice16BitStorageFeatures" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES"><type>VkStructureType</type> <name>sType</name></member>
            <member noautovalidity="true"><type>void</type>*      <name>pNext</name></member>
            <member><type>VkBool32</type>                         <name>storageBuffer16BitAccess</name><comment>16-bit integer/floating-point variables supported in BufferBlock</comment></member>
            <member><type>VkBool32</type>                         <name>uniformAndStorageBuffer16BitAccess</name><comment>16-bit integer/floating-point variables supported in BufferBlock and Block</comment></member>
            <member><type>VkBool32</type>                         <name>storagePushConstant16</name><comment>16-bit integer/floating-point variables supported in PushConstant</comment></member>
            <member><type>VkBool32</type>                         <name>storageInputOutput16</name><comment>16-bit integer/floating-point variables supported in shader inputs and outputs</comment></member>
        </type>
        <type category="struct" name="VkPhysicalDevice16BitStorageFeaturesKHR"                 alias="VkPhysicalDevice16BitStorageFeatures"/>
        <type category="struct" name="VkPhysicalDeviceSubgroupProperties" returnedonly="true" structextends="VkPhysicalDeviceProperties2">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES"><type>VkStructureType</type> <name>sType</name></member>
            <member><type>void</type>*                   <name>pNext</name></member>
            <member noautovalidity="true"><type>uint32_t</type>                      <name>subgroupSize</name><comment>The size of a subgroup for this queue.</comment></member>
            <member noautovalidity="true"><type>VkShaderStageFlags</type>            <name>supportedStages</name><comment>Bitfield of what shader stages support subgroup operations</comment></member>
            <member noautovalidity="true"><type>VkSubgroupFeatureFlags</type>        <name>supportedOperations</name><comment>Bitfield of what subgroup operations are supported.</comment></member>
            <member noautovalidity="true"><type>VkBool32</type> <name>quadOperationsInAllStages</name><comment>Flag to specify whether quad operations are available in all stages.</comment></member>
        </type>
        <type category="struct" name="VkBufferMemoryRequirementsInfo2">
            <member values="VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*                                                          <name>pNext</name></member>
            <member><type>VkBuffer</type>                                                             <name>buffer</name></member>
        </type>
        <type category="struct" name="VkBufferMemoryRequirementsInfo2KHR"                      alias="VkBufferMemoryRequirementsInfo2"/>
        <type category="struct" name="VkImageMemoryRequirementsInfo2">
            <member values="VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*                                                          <name>pNext</name></member>
            <member><type>VkImage</type>                                                              <name>image</name></member>
        </type>
        <type category="struct" name="VkImageMemoryRequirementsInfo2KHR"                       alias="VkImageMemoryRequirementsInfo2"/>
        <type category="struct" name="VkImageSparseMemoryRequirementsInfo2">
            <member values="VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*                                                          <name>pNext</name></member>
            <member><type>VkImage</type>                                                              <name>image</name></member>
        </type>
        <type category="struct" name="VkImageSparseMemoryRequirementsInfo2KHR"                 alias="VkImageSparseMemoryRequirementsInfo2"/>
        <type category="struct" name="VkMemoryRequirements2" returnedonly="true">
            <member values="VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2"><type>VkStructureType</type> <name>sType</name></member>
            <member><type>void</type>* <name>pNext</name></member>
            <member><type>VkMemoryRequirements</type>                                                 <name>memoryRequirements</name></member>
        </type>
        <type category="struct" name="VkMemoryRequirements2KHR"                                alias="VkMemoryRequirements2"/>
        <type category="struct" name="VkSparseImageMemoryRequirements2" returnedonly="true">
            <member values="VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2"><type>VkStructureType</type> <name>sType</name></member>
            <member><type>void</type>*                                       <name>pNext</name></member>
            <member><type>VkSparseImageMemoryRequirements</type>                                      <name>memoryRequirements</name></member>
        </type>
        <type category="struct" name="VkSparseImageMemoryRequirements2KHR"                     alias="VkSparseImageMemoryRequirements2"/>
        <type category="struct" name="VkPhysicalDevicePointClippingProperties" returnedonly="true" structextends="VkPhysicalDeviceProperties2">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES"><type>VkStructureType</type> <name>sType</name></member>
            <member><type>void</type>*                            <name>pNext</name></member>
            <member><type>VkPointClippingBehavior</type>      <name>pointClippingBehavior</name></member>
        </type>
        <type category="struct" name="VkPhysicalDevicePointClippingPropertiesKHR"              alias="VkPhysicalDevicePointClippingProperties"/>
        <type category="struct" name="VkMemoryDedicatedRequirements" returnedonly="true" structextends="VkMemoryRequirements2">
            <member values="VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS"><type>VkStructureType</type> <name>sType</name></member>
            <member><type>void</type>*                            <name>pNext</name></member>
            <member><type>VkBool32</type>                         <name>prefersDedicatedAllocation</name></member>
            <member><type>VkBool32</type>                         <name>requiresDedicatedAllocation</name></member>
        </type>
        <type category="struct" name="VkMemoryDedicatedRequirementsKHR"                        alias="VkMemoryDedicatedRequirements"/>
        <type category="struct" name="VkMemoryDedicatedAllocateInfo" structextends="VkMemoryAllocateInfo">
            <member values="VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*                      <name>pNext</name></member>
            <member optional="true"><type>VkImage</type>          <name>image</name><comment>Image that this allocation will be bound to</comment></member>
            <member optional="true"><type>VkBuffer</type>         <name>buffer</name><comment>Buffer that this allocation will be bound to</comment></member>
        </type>
        <type category="struct" name="VkMemoryDedicatedAllocateInfoKHR"                        alias="VkMemoryDedicatedAllocateInfo"/>
        <type category="struct" name="VkImageViewUsageCreateInfo" structextends="VkImageViewCreateInfo">
            <member values="VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>* <name>pNext</name></member>
            <member><type>VkImageUsageFlags</type> <name>usage</name></member>
        </type>
        <type category="struct" name="VkImageViewUsageCreateInfoKHR"                           alias="VkImageViewUsageCreateInfo"/>
        <type category="struct" name="VkPipelineTessellationDomainOriginStateCreateInfo" structextends="VkPipelineTessellationStateCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*                      <name>pNext</name></member>
            <member><type>VkTessellationDomainOrigin</type>    <name>domainOrigin</name></member>
        </type>
        <type category="struct" name="VkPipelineTessellationDomainOriginStateCreateInfoKHR"    alias="VkPipelineTessellationDomainOriginStateCreateInfo"/>
        <type category="struct" name="VkSamplerYcbcrConversionInfo" structextends="VkSamplerCreateInfo,VkImageViewCreateInfo">
            <member values="VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*                      <name>pNext</name></member>
            <member><type>VkSamplerYcbcrConversion</type>      <name>conversion</name></member>
        </type>
        <type category="struct" name="VkSamplerYcbcrConversionInfoKHR"                         alias="VkSamplerYcbcrConversionInfo"/>
        <type category="struct" name="VkSamplerYcbcrConversionCreateInfo">
            <member values="VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*                      <name>pNext</name></member>
            <member><type>VkFormat</type>                         <name>format</name></member>
            <member><type>VkSamplerYcbcrModelConversion</type> <name>ycbcrModel</name></member>
            <member><type>VkSamplerYcbcrRange</type>           <name>ycbcrRange</name></member>
            <member><type>VkComponentMapping</type>               <name>components</name></member>
            <member><type>VkChromaLocation</type>              <name>xChromaOffset</name></member>
            <member><type>VkChromaLocation</type>              <name>yChromaOffset</name></member>
            <member><type>VkFilter</type>                         <name>chromaFilter</name></member>
            <member><type>VkBool32</type>                         <name>forceExplicitReconstruction</name></member>
        </type>
        <type category="struct" name="VkSamplerYcbcrConversionCreateInfoKHR"                   alias="VkSamplerYcbcrConversionCreateInfo"/>
        <type category="struct" name="VkBindImagePlaneMemoryInfo" structextends="VkBindImageMemoryInfo">
            <member values="VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*                      <name>pNext</name></member>
            <member><type>VkImageAspectFlagBits</type>            <name>planeAspect</name></member>
        </type>
        <type category="struct" name="VkBindImagePlaneMemoryInfoKHR"                           alias="VkBindImagePlaneMemoryInfo"/>
        <type category="struct" name="VkImagePlaneMemoryRequirementsInfo" structextends="VkImageMemoryRequirementsInfo2">
            <member values="VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*                      <name>pNext</name></member>
            <member><type>VkImageAspectFlagBits</type>            <name>planeAspect</name></member>
        </type>
        <type category="struct" name="VkImagePlaneMemoryRequirementsInfoKHR"                   alias="VkImagePlaneMemoryRequirementsInfo"/>
        <type category="struct" name="VkPhysicalDeviceSamplerYcbcrConversionFeatures" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES"><type>VkStructureType</type> <name>sType</name></member>
            <member noautovalidity="true"><type>void</type>*      <name>pNext</name></member>
            <member><type>VkBool32</type>                         <name>samplerYcbcrConversion</name><comment>Sampler color conversion supported</comment></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR"       alias="VkPhysicalDeviceSamplerYcbcrConversionFeatures"/>
        <type category="struct" name="VkSamplerYcbcrConversionImageFormatProperties" returnedonly="true" structextends="VkImageFormatProperties2">
            <member values="VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES"><type>VkStructureType</type> <name>sType</name></member>
            <member noautovalidity="true"><type>void</type>*      <name>pNext</name></member>
            <member><type>uint32_t</type>                         <name>combinedImageSamplerDescriptorCount</name></member>
        </type>
        <type category="struct" name="VkSamplerYcbcrConversionImageFormatPropertiesKHR"        alias="VkSamplerYcbcrConversionImageFormatProperties"/>
        <type category="struct" name="VkTextureLODGatherFormatPropertiesAMD" returnedonly="true" structextends="VkImageFormatProperties2">
            <member values="VK_STRUCTURE_TYPE_TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD"><type>VkStructureType</type> <name>sType</name></member>
            <member><type>void</type>*                            <name>pNext</name></member>
            <member><type>VkBool32</type>                         <name>supportsTextureGatherLODBiasAMD</name></member>
        </type>
        <type category="struct" name="VkConditionalRenderingBeginInfoEXT">
            <member values="VK_STRUCTURE_TYPE_CONDITIONAL_RENDERING_BEGIN_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*                      <name>pNext</name></member>
            <member><type>VkBuffer</type>                         <name>buffer</name></member>
            <member><type>VkDeviceSize</type>                     <name>offset</name></member>
            <member optional="true"><type>VkConditionalRenderingFlagsEXT</type>    <name>flags</name></member>
        </type>
        <type category="struct" name="VkProtectedSubmitInfo" structextends="VkSubmitInfo">
            <member values="VK_STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*                     <name>pNext</name></member>
            <member><type>VkBool32</type>                        <name>protectedSubmit</name><comment>Submit protected command buffers</comment></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceProtectedMemoryFeatures" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES"><type>VkStructureType</type> <name>sType</name></member>
            <member><type>void</type>*                               <name>pNext</name></member>
            <member><type>VkBool32</type>                            <name>protectedMemory</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceProtectedMemoryProperties" returnedonly="true" structextends="VkPhysicalDeviceProperties2">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES"><type>VkStructureType</type> <name>sType</name></member>
            <member><type>void</type>*                               <name>pNext</name></member>
            <member><type>VkBool32</type>                            <name>protectedNoFault</name></member>
        </type>
        <type category="struct" name="VkDeviceQueueInfo2">
            <member values="VK_STRUCTURE_TYPE_DEVICE_QUEUE_INFO_2"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*                         <name>pNext</name></member>
            <member><type>VkDeviceQueueCreateFlags</type>            <name>flags</name></member>
            <member><type>uint32_t</type>                            <name>queueFamilyIndex</name></member>
            <member><type>uint32_t</type>                            <name>queueIndex</name></member>
        </type>
        <type category="struct" name="VkPipelineCoverageToColorStateCreateInfoNV" structextends="VkPipelineMultisampleStateCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*                                                                      <name>pNext</name></member>
            <member optional="true"><type>VkPipelineCoverageToColorStateCreateFlagsNV</type>                    <name>flags</name></member>
            <member><type>VkBool32</type>                         <name>coverageToColorEnable</name></member>
            <member optional="true"><type>uint32_t</type>         <name>coverageToColorLocation</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT" returnedonly="true" structextends="VkPhysicalDeviceProperties2">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member><type>void</type>*                  <name>pNext</name></member>
            <member><type>VkBool32</type>               <name>filterMinmaxSingleComponentFormats</name></member>
            <member><type>VkBool32</type>               <name>filterMinmaxImageComponentMapping</name></member>
        </type>
        <type category="struct" name="VkSampleLocationEXT">
            <member><type>float</type>                            <name>x</name></member>
            <member><type>float</type>                            <name>y</name></member>
        </type>
        <type category="struct" name="VkSampleLocationsInfoEXT" structextends="VkImageMemoryBarrier">
            <member values="VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*                            <name>pNext</name></member>
            <member optional="true"><type>VkSampleCountFlagBits</type>  <name>sampleLocationsPerPixel</name></member>
            <member><type>VkExtent2D</type>                             <name>sampleLocationGridSize</name></member>
            <member optional="true"><type>uint32_t</type>               <name>sampleLocationsCount</name></member>
            <member len="sampleLocationsCount">const <type>VkSampleLocationEXT</type>* <name>pSampleLocations</name></member>
        </type>
        <type category="struct" name="VkAttachmentSampleLocationsEXT">
            <member><type>uint32_t</type>                         <name>attachmentIndex</name></member>
            <member><type>VkSampleLocationsInfoEXT</type>         <name>sampleLocationsInfo</name></member>
        </type>
        <type category="struct" name="VkSubpassSampleLocationsEXT">
            <member><type>uint32_t</type>                         <name>subpassIndex</name></member>
            <member><type>VkSampleLocationsInfoEXT</type>         <name>sampleLocationsInfo</name></member>
        </type>
        <type category="struct" name="VkRenderPassSampleLocationsBeginInfoEXT" structextends="VkRenderPassBeginInfo">
            <member values="VK_STRUCTURE_TYPE_RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*                      <name>pNext</name></member>
            <member optional="true"><type>uint32_t</type>         <name>attachmentInitialSampleLocationsCount</name></member>
            <member len="attachmentInitialSampleLocationsCount">const <type>VkAttachmentSampleLocationsEXT</type>* <name>pAttachmentInitialSampleLocations</name></member>
            <member optional="true"><type>uint32_t</type>         <name>postSubpassSampleLocationsCount</name></member>
            <member len="postSubpassSampleLocationsCount">const <type>VkSubpassSampleLocationsEXT</type>* <name>pPostSubpassSampleLocations</name></member>
        </type>
        <type category="struct" name="VkPipelineSampleLocationsStateCreateInfoEXT" structextends="VkPipelineMultisampleStateCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*                      <name>pNext</name></member>
            <member><type>VkBool32</type>                         <name>sampleLocationsEnable</name></member>
            <member><type>VkSampleLocationsInfoEXT</type>         <name>sampleLocationsInfo</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceSampleLocationsPropertiesEXT" returnedonly="true" structextends="VkPhysicalDeviceProperties2">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member><type>void</type>*                            <name>pNext</name></member>
            <member><type>VkSampleCountFlags</type>               <name>sampleLocationSampleCounts</name></member>
            <member><type>VkExtent2D</type>                       <name>maxSampleLocationGridSize</name></member>
            <member><type>float</type>                            <name>sampleLocationCoordinateRange</name>[2]</member>
            <member><type>uint32_t</type>                         <name>sampleLocationSubPixelBits</name></member>
            <member><type>VkBool32</type>                         <name>variableSampleLocations</name></member>
        </type>
        <type category="struct" name="VkMultisamplePropertiesEXT" returnedonly="true">
            <member values="VK_STRUCTURE_TYPE_MULTISAMPLE_PROPERTIES_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member><type>void</type>*                            <name>pNext</name></member>
            <member><type>VkExtent2D</type>                       <name>maxSampleLocationGridSize</name></member>
        </type>
        <type category="struct" name="VkSamplerReductionModeCreateInfoEXT" structextends="VkSamplerCreateInfo">
            <member values="VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*            <name>pNext</name></member>
            <member><type>VkSamplerReductionModeEXT</type> <name>reductionMode</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member noautovalidity="true"><type>void</type>*                            <name>pNext</name></member>
            <member><type>VkBool32</type>                         <name>advancedBlendCoherentOperations</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT" returnedonly="true" structextends="VkPhysicalDeviceProperties2">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member noautovalidity="true"><type>void</type>*                            <name>pNext</name></member>
            <member><type>uint32_t</type>                         <name>advancedBlendMaxColorAttachments</name></member>
            <member><type>VkBool32</type>                         <name>advancedBlendIndependentBlend</name></member>
            <member><type>VkBool32</type>                         <name>advancedBlendNonPremultipliedSrcColor</name></member>
            <member><type>VkBool32</type>                         <name>advancedBlendNonPremultipliedDstColor</name></member>
            <member><type>VkBool32</type>                         <name>advancedBlendCorrelatedOverlap</name></member>
            <member><type>VkBool32</type>                         <name>advancedBlendAllOperations</name></member>
        </type>
        <type category="struct" name="VkPipelineColorBlendAdvancedStateCreateInfoEXT" structextends="VkPipelineColorBlendStateCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*            <name>pNext</name></member>
            <member><type>VkBool32</type>               <name>srcPremultiplied</name></member>
            <member><type>VkBool32</type>               <name>dstPremultiplied</name></member>
            <member><type>VkBlendOverlapEXT</type>      <name>blendOverlap</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceInlineUniformBlockFeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member><type>void</type>*                  <name>pNext</name></member>
            <member><type>VkBool32</type>               <name>inlineUniformBlock</name></member>
            <member><type>VkBool32</type>               <name>descriptorBindingInlineUniformBlockUpdateAfterBind</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceInlineUniformBlockPropertiesEXT" returnedonly="true" structextends="VkPhysicalDeviceProperties2">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member><type>void</type>*                  <name>pNext</name></member>
            <member><type>uint32_t</type>               <name>maxInlineUniformBlockSize</name></member>
            <member><type>uint32_t</type>               <name>maxPerStageDescriptorInlineUniformBlocks</name></member>
            <member><type>uint32_t</type>               <name>maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks</name></member>
            <member><type>uint32_t</type>               <name>maxDescriptorSetInlineUniformBlocks</name></member>
            <member><type>uint32_t</type>               <name>maxDescriptorSetUpdateAfterBindInlineUniformBlocks</name></member>
        </type>
        <type category="struct" name="VkWriteDescriptorSetInlineUniformBlockEXT" structextends="VkWriteDescriptorSet">
            <member values="VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*            <name>pNext</name></member>
            <member><type>uint32_t</type>               <name>dataSize</name></member>
            <member len="dataSize">const <type>void</type>* <name>pData</name></member>
        </type>
        <type category="struct" name="VkDescriptorPoolInlineUniformBlockCreateInfoEXT" structextends="VkDescriptorPoolCreateInfo">
            <member values="VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*            <name>pNext</name></member>
            <member><type>uint32_t</type>               <name>maxInlineUniformBlockBindings</name></member>
        </type>
        <type category="struct" name="VkPipelineCoverageModulationStateCreateInfoNV" structextends="VkPipelineMultisampleStateCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*                                                                      <name>pNext</name></member>
            <member optional="true"><type>VkPipelineCoverageModulationStateCreateFlagsNV</type>                   <name>flags</name></member>
            <member><type>VkCoverageModulationModeNV</type>                                                       <name>coverageModulationMode</name></member>
            <member><type>VkBool32</type>                                                                         <name>coverageModulationTableEnable</name></member>
            <member optional="true"><type>uint32_t</type>                                                         <name>coverageModulationTableCount</name></member>
            <member noautovalidity="true" optional="true" len="coverageModulationTableCount">const <type>float</type>* <name>pCoverageModulationTable</name></member>
        </type>
        <type category="struct" name="VkImageFormatListCreateInfoKHR" structextends="VkImageCreateInfo,VkSwapchainCreateInfoKHR,VkPhysicalDeviceImageFormatInfo2">
            <member values="VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*            <name>pNext</name></member>
            <member optional="true"><type>uint32_t</type>               <name>viewFormatCount</name></member>
            <member len="viewFormatCount">const <type>VkFormat</type>*      <name>pViewFormats</name></member>
        </type>
        <type category="struct" name="VkValidationCacheCreateInfoEXT">
            <member values="VK_STRUCTURE_TYPE_VALIDATION_CACHE_CREATE_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*            <name>pNext</name></member>
            <member optional="true"><type>VkValidationCacheCreateFlagsEXT</type>    <name>flags</name></member>
            <member optional="true"><type>size_t</type>                 <name>initialDataSize</name></member>
            <member len="initialDataSize">const <type>void</type>*            <name>pInitialData</name></member>
        </type>
        <type category="struct" name="VkShaderModuleValidationCacheCreateInfoEXT" structextends="VkShaderModuleCreateInfo">
            <member values="VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*            <name>pNext</name></member>
            <member><type>VkValidationCacheEXT</type>    <name>validationCache</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceMaintenance3Properties" returnedonly="true" structextends="VkPhysicalDeviceProperties2">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES"><type>VkStructureType</type> <name>sType</name></member>
            <member><type>void</type>*                            <name>pNext</name></member>
            <member><type>uint32_t</type>                         <name>maxPerSetDescriptors</name></member>
            <member><type>VkDeviceSize</type>                     <name>maxMemoryAllocationSize</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceMaintenance3PropertiesKHR"               alias="VkPhysicalDeviceMaintenance3Properties"/>
        <type category="struct" name="VkDescriptorSetLayoutSupport" returnedonly="true">
            <member values="VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT"><type>VkStructureType</type> <name>sType</name></member>
            <member><type>void</type>*            <name>pNext</name></member>
            <member><type>VkBool32</type>         <name>supported</name></member>
        </type>
        <type category="struct" name="VkDescriptorSetLayoutSupportKHR"                         alias="VkDescriptorSetLayoutSupport"/>
        <type category="struct" name="VkPhysicalDeviceShaderDrawParametersFeatures" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES"><type>VkStructureType</type> <name>sType</name></member>
            <member noautovalidity="true"><type>void</type>*                            <name>pNext</name></member>
            <member><type>VkBool32</type>                         <name>shaderDrawParameters</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceShaderDrawParameterFeatures"             alias="VkPhysicalDeviceShaderDrawParametersFeatures"/>
        <type category="struct" name="VkPhysicalDeviceFloat16Int8FeaturesKHR" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT16_INT8_FEATURES_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member noautovalidity="true"><type>void</type>*      <name>pNext</name></member>                            <!-- Pointer to next structure -->
            <member><type>VkBool32</type>                         <name>shaderFloat16</name></member>                 <!-- 16-bit floats (halfs) in shaders -->
            <member><type>VkBool32</type>                         <name>shaderInt8</name></member>                    <!-- 8-bit integers in shaders -->
        </type>
        <type category="struct" name="VkPhysicalDeviceFloatControlsPropertiesKHR" returnedonly="true" structextends="VkPhysicalDeviceProperties2">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member><type>void</type>*                            <name>pNext</name></member>
            <member><type>VkBool32</type>                         <name>separateDenormSettings</name></member>
            <member><type>VkBool32</type>                         <name>separateRoundingModeSettings</name></member>
            <member><type>VkBool32</type>                         <name>shaderSignedZeroInfNanPreserveFloat16</name></member>  <!-- An implementation can preserve signed zero, nan, inf -->
            <member><type>VkBool32</type>                         <name>shaderSignedZeroInfNanPreserveFloat32</name></member>  <!-- An implementation can preserve signed zero, nan, inf -->
            <member><type>VkBool32</type>                         <name>shaderSignedZeroInfNanPreserveFloat64</name></member>  <!-- An implementation can preserve signed zero, nan, inf -->
            <member><type>VkBool32</type>                         <name>shaderDenormPreserveFloat16</name></member>            <!-- An implementation can preserve  denormals -->
            <member><type>VkBool32</type>                         <name>shaderDenormPreserveFloat32</name></member>            <!-- An implementation can preserve  denormals -->
            <member><type>VkBool32</type>                         <name>shaderDenormPreserveFloat64</name></member>            <!-- An implementation can preserve  denormals -->
            <member><type>VkBool32</type>                         <name>shaderDenormFlushToZeroFloat16</name></member>         <!-- An implementation can flush to zero  denormals -->
            <member><type>VkBool32</type>                         <name>shaderDenormFlushToZeroFloat32</name></member>         <!-- An implementation can flush to zero  denormals -->
            <member><type>VkBool32</type>                         <name>shaderDenormFlushToZeroFloat64</name></member>         <!-- An implementation can flush to zero  denormals -->
            <member><type>VkBool32</type>                         <name>shaderRoundingModeRTEFloat16</name></member>           <!-- An implementation can support RTE -->
            <member><type>VkBool32</type>                         <name>shaderRoundingModeRTEFloat32</name></member>           <!-- An implementation can support RTE -->
            <member><type>VkBool32</type>                         <name>shaderRoundingModeRTEFloat64</name></member>           <!-- An implementation can support RTE -->
            <member><type>VkBool32</type>                         <name>shaderRoundingModeRTZFloat16</name></member>           <!-- An implementation can support RTZ -->
            <member><type>VkBool32</type>                         <name>shaderRoundingModeRTZFloat32</name></member>           <!-- An implementation can support RTZ -->
            <member><type>VkBool32</type>                         <name>shaderRoundingModeRTZFloat64</name></member>           <!-- An implementation can support RTZ -->
        </type>
        <type category="struct" name="VkPhysicalDeviceHostQueryResetFeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member noautovalidity="true"><type>void</type>*        <name>pNext</name></member>
            <member><type>VkBool32</type>                           <name>hostQueryReset</name></member>
        </type>
        <type category="struct" name="VkNativeBufferANDROID">
            <member values="VK_STRUCTURE_TYPE_NATIVE_BUFFER_ANDROID"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>* <name>pNext</name></member>
            <member>const <type>void</type>* <name>handle</name></member>
            <member><type>int</type> <name>stride</name></member>
            <member><type>int</type> <name>format</name></member>
            <member><type>int</type> <name>usage</name></member>
        </type>
        <type category="struct" name="VkShaderResourceUsageAMD" returnedonly="true">
            <member><type>uint32_t</type> <name>numUsedVgprs</name></member>
            <member><type>uint32_t</type> <name>numUsedSgprs</name></member>
            <member><type>uint32_t</type> <name>ldsSizePerLocalWorkGroup</name></member>
            <member><type>size_t</type> <name>ldsUsageSizeInBytes</name></member>
            <member><type>size_t</type> <name>scratchMemUsageInBytes</name></member>
        </type>
        <type category="struct" name="VkShaderStatisticsInfoAMD" returnedonly="true">
            <member><type>VkShaderStageFlags</type> <name>shaderStageMask</name></member>
            <member><type>VkShaderResourceUsageAMD</type> <name>resourceUsage</name></member>
            <member><type>uint32_t</type> <name>numPhysicalVgprs</name></member>
            <member><type>uint32_t</type> <name>numPhysicalSgprs</name></member>
            <member><type>uint32_t</type> <name>numAvailableVgprs</name></member>
            <member><type>uint32_t</type> <name>numAvailableSgprs</name></member>
            <member><type>uint32_t</type> <name>computeWorkGroupSize</name>[3]</member>
        </type>
        <type category="struct" name="VkDeviceQueueGlobalPriorityCreateInfoEXT" structextends="VkDeviceQueueCreateInfo">
            <member values="VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*                    <name>pNext</name></member>
            <member><type>VkQueueGlobalPriorityEXT</type>       <name>globalPriority</name></member>
        </type>
        <type category="struct" name="VkDebugUtilsObjectNameInfoEXT">
            <member values="VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*                                            <name>pNext</name></member>
            <member><type>VkObjectType</type>                                           <name>objectType</name></member>
            <member><type>uint64_t</type>                                               <name>objectHandle</name></member>
            <member optional="true" len="null-terminated">const <type>char</type>*      <name>pObjectName</name></member>
        </type>
        <type category="struct" name="VkDebugUtilsObjectTagInfoEXT">
            <member values="VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_TAG_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*                            <name>pNext</name></member>
            <member><type>VkObjectType</type>                           <name>objectType</name></member>
            <member><type>uint64_t</type>                               <name>objectHandle</name></member>
            <member><type>uint64_t</type>                               <name>tagName</name></member>
            <member><type>size_t</type>                                 <name>tagSize</name></member>
            <member len="tagSize">const <type>void</type>*              <name>pTag</name></member>
        </type>
        <type category="struct" name="VkDebugUtilsLabelEXT">
            <member values="VK_STRUCTURE_TYPE_DEBUG_UTILS_LABEL_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*                            <name>pNext</name></member>
            <member len="null-terminated">const <type>char</type>*      <name>pLabelName</name></member>
            <member optional="true"><type>float</type>                  <name>color</name>[4]</member>
        </type>
        <type category="struct" name="VkDebugUtilsMessengerCreateInfoEXT" structextends="VkInstanceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*                                          <name>pNext</name></member>
            <member optional="true"><type>VkDebugUtilsMessengerCreateFlagsEXT</type>  <name>flags</name></member>
            <member><type>VkDebugUtilsMessageSeverityFlagsEXT</type>                  <name>messageSeverity</name></member>
            <member><type>VkDebugUtilsMessageTypeFlagsEXT</type>                      <name>messageType</name></member>
            <member><type>PFN_vkDebugUtilsMessengerCallbackEXT</type>                 <name>pfnUserCallback</name></member>
            <member optional="true"><type>void</type>*                                <name>pUserData</name></member>
        </type>
        <type category="struct" name="VkDebugUtilsMessengerCallbackDataEXT">
            <member values="VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CALLBACK_DATA_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                                                        <name>pNext</name></member>
            <member optional="true"><type>VkDebugUtilsMessengerCallbackDataFlagsEXT</type>                          <name>flags</name></member>
            <member optional="true" len="null-terminated">const <type>char</type>*                                  <name>pMessageIdName</name></member>
            <member optional="true"><type>int32_t</type>                                                            <name>messageIdNumber</name></member>
            <member len="null-terminated">const <type>char</type>*                                                  <name>pMessage</name></member>
            <member optional="true"><type>uint32_t</type>                                                           <name>queueLabelCount</name></member>
            <member len="queueLabelCount">const <type>VkDebugUtilsLabelEXT</type>*                  <name>pQueueLabels</name></member>
            <member optional="true"><type>uint32_t</type>                                                           <name>cmdBufLabelCount</name></member>
            <member len="cmdBufLabelCount">const <type>VkDebugUtilsLabelEXT</type>*                 <name>pCmdBufLabels</name></member>
            <member optional="true"><type>uint32_t</type>                                                           <name>objectCount</name></member>
            <member len="objectCount">const <type>VkDebugUtilsObjectNameInfoEXT</type>*             <name>pObjects</name></member>
        </type>
        <type category="struct" name="VkImportMemoryHostPointerInfoEXT" structextends="VkMemoryAllocateInfo">
            <member values="VK_STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>* <name>pNext</name></member>
            <member><type>VkExternalMemoryHandleTypeFlagBits</type> <name>handleType</name></member>
            <member optional="false"><type>void</type>* <name>pHostPointer</name></member>
        </type>
        <type category="struct" name="VkMemoryHostPointerPropertiesEXT" returnedonly="true">
            <member values="VK_STRUCTURE_TYPE_MEMORY_HOST_POINTER_PROPERTIES_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member><type>void</type>* <name>pNext</name></member>
            <member><type>uint32_t</type> <name>memoryTypeBits</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceExternalMemoryHostPropertiesEXT" returnedonly="true" structextends="VkPhysicalDeviceProperties2">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member><type>void</type>* <name>pNext</name></member>
            <member><type>VkDeviceSize</type> <name>minImportedHostPointerAlignment</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceConservativeRasterizationPropertiesEXT" returnedonly="true" structextends="VkPhysicalDeviceProperties2">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member><type>void</type>*                  <name>pNext</name><comment>Pointer to next structure</comment></member>
            <member><type>float</type>                  <name>primitiveOverestimationSize</name><comment>The size in pixels the primitive is enlarged at each edge during conservative rasterization</comment></member>
            <member><type>float</type>                  <name>maxExtraPrimitiveOverestimationSize</name><comment>The maximum additional overestimation the client can specify in the pipeline state</comment></member>
            <member><type>float</type>                  <name>extraPrimitiveOverestimationSizeGranularity</name><comment>The granularity of extra overestimation sizes the implementations supports between 0 and maxExtraOverestimationSize</comment></member>
            <member><type>VkBool32</type>               <name>primitiveUnderestimation</name><comment>true if the implementation supports conservative rasterization underestimation mode</comment></member>
            <member><type>VkBool32</type>               <name>conservativePointAndLineRasterization</name><comment>true if conservative rasterization also applies to points and lines</comment></member>
            <member><type>VkBool32</type>               <name>degenerateTrianglesRasterized</name><comment>true if degenerate triangles (those with zero area after snap) are rasterized</comment></member>
            <member><type>VkBool32</type>               <name>degenerateLinesRasterized</name><comment>true if degenerate lines (those with zero length after snap) are rasterized</comment></member>
            <member><type>VkBool32</type>               <name>fullyCoveredFragmentShaderInputVariable</name><comment>true if the implementation supports the FullyCoveredEXT SPIR-V builtin fragment shader input variable</comment></member>
            <member><type>VkBool32</type>               <name>conservativeRasterizationPostDepthCoverage</name><comment>true if the implementation supports both conservative rasterization and post depth coverage sample coverage mask</comment></member>
        </type>
        <type category="struct" name="VkCalibratedTimestampInfoEXT">
            <member values="VK_STRUCTURE_TYPE_CALIBRATED_TIMESTAMP_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*            <name>pNext</name></member>
            <member><type>VkTimeDomainEXT</type>        <name>timeDomain</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceShaderCorePropertiesAMD" returnedonly="true" structextends="VkPhysicalDeviceProperties2">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD"><type>VkStructureType</type> <name>sType</name></member>
            <member><type>void</type>*    <name>pNext</name><comment>Pointer to next structure</comment></member>
            <member><type>uint32_t</type> <name>shaderEngineCount</name><comment>number of shader engines</comment></member>
            <member><type>uint32_t</type> <name>shaderArraysPerEngineCount</name><comment>number of shader arrays</comment></member>
            <member><type>uint32_t</type> <name>computeUnitsPerShaderArray</name><comment>number of physical CUs per shader array</comment></member>
            <member><type>uint32_t</type> <name>simdPerComputeUnit</name><comment>number of SIMDs per compute unit</comment></member>
            <member><type>uint32_t</type> <name>wavefrontsPerSimd</name><comment>number of wavefront slots in each SIMD</comment></member>
            <member><type>uint32_t</type> <name>wavefrontSize</name><comment>maximum number of threads per wavefront</comment></member>
            <member><type>uint32_t</type> <name>sgprsPerSimd</name><comment>number of physical SGPRs per SIMD</comment></member>
            <member><type>uint32_t</type> <name>minSgprAllocation</name><comment>minimum number of SGPRs that can be allocated by a wave</comment></member>
            <member><type>uint32_t</type> <name>maxSgprAllocation</name><comment>number of available SGPRs</comment></member>
            <member><type>uint32_t</type> <name>sgprAllocationGranularity</name><comment>SGPRs are allocated in groups of this size</comment></member>
            <member><type>uint32_t</type> <name>vgprsPerSimd</name><comment>number of physical VGPRs per SIMD</comment></member>
            <member><type>uint32_t</type> <name>minVgprAllocation</name><comment>minimum number of VGPRs that can be allocated by a wave</comment></member>
            <member><type>uint32_t</type> <name>maxVgprAllocation</name><comment>number of available VGPRs</comment></member>
            <member><type>uint32_t</type> <name>vgprAllocationGranularity</name><comment>VGPRs are allocated in groups of this size</comment></member>
        </type>
        <type category="struct" name="VkPipelineRasterizationConservativeStateCreateInfoEXT" structextends="VkPipelineRasterizationStateCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*                                                                      <name>pNext</name></member>                 <!-- Pointer to next structure -->
            <member optional="true"><type>VkPipelineRasterizationConservativeStateCreateFlagsEXT</type>           <name>flags</name></member>                 <!-- Reserved -->
            <member><type>VkConservativeRasterizationModeEXT</type>                                               <name>conservativeRasterizationMode</name></member>      <!-- Conservative rasterization mode -->
            <member><type>float</type>                                                                            <name>extraPrimitiveOverestimationSize</name></member>   <!-- Extra overestimation to add to the primitive -->
        </type>
        <type category="struct" name="VkPhysicalDeviceDescriptorIndexingFeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member noautovalidity="true"><type>void</type>*                            <name>pNext</name></member>
            <member><type>VkBool32</type>               <name>shaderInputAttachmentArrayDynamicIndexing</name></member>
            <member><type>VkBool32</type>               <name>shaderUniformTexelBufferArrayDynamicIndexing</name></member>
            <member><type>VkBool32</type>               <name>shaderStorageTexelBufferArrayDynamicIndexing</name></member>
            <member><type>VkBool32</type>               <name>shaderUniformBufferArrayNonUniformIndexing</name></member>
            <member><type>VkBool32</type>               <name>shaderSampledImageArrayNonUniformIndexing</name></member>
            <member><type>VkBool32</type>               <name>shaderStorageBufferArrayNonUniformIndexing</name></member>
            <member><type>VkBool32</type>               <name>shaderStorageImageArrayNonUniformIndexing</name></member>
            <member><type>VkBool32</type>               <name>shaderInputAttachmentArrayNonUniformIndexing</name></member>
            <member><type>VkBool32</type>               <name>shaderUniformTexelBufferArrayNonUniformIndexing</name></member>
            <member><type>VkBool32</type>               <name>shaderStorageTexelBufferArrayNonUniformIndexing</name></member>
            <member><type>VkBool32</type>               <name>descriptorBindingUniformBufferUpdateAfterBind</name></member>
            <member><type>VkBool32</type>               <name>descriptorBindingSampledImageUpdateAfterBind</name></member>
            <member><type>VkBool32</type>               <name>descriptorBindingStorageImageUpdateAfterBind</name></member>
            <member><type>VkBool32</type>               <name>descriptorBindingStorageBufferUpdateAfterBind</name></member>
            <member><type>VkBool32</type>               <name>descriptorBindingUniformTexelBufferUpdateAfterBind</name></member>
            <member><type>VkBool32</type>               <name>descriptorBindingStorageTexelBufferUpdateAfterBind</name></member>
            <member><type>VkBool32</type>               <name>descriptorBindingUpdateUnusedWhilePending</name></member>
            <member><type>VkBool32</type>               <name>descriptorBindingPartiallyBound</name></member>
            <member><type>VkBool32</type>               <name>descriptorBindingVariableDescriptorCount</name></member>
            <member><type>VkBool32</type>               <name>runtimeDescriptorArray</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceDescriptorIndexingPropertiesEXT" returnedonly="true" structextends="VkPhysicalDeviceProperties2">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member noautovalidity="true"><type>void</type>*                            <name>pNext</name></member>
            <member><type>uint32_t</type>               <name>maxUpdateAfterBindDescriptorsInAllPools</name></member>
            <member><type>VkBool32</type>               <name>shaderUniformBufferArrayNonUniformIndexingNative</name></member>
            <member><type>VkBool32</type>               <name>shaderSampledImageArrayNonUniformIndexingNative</name></member>
            <member><type>VkBool32</type>               <name>shaderStorageBufferArrayNonUniformIndexingNative</name></member>
            <member><type>VkBool32</type>               <name>shaderStorageImageArrayNonUniformIndexingNative</name></member>
            <member><type>VkBool32</type>               <name>shaderInputAttachmentArrayNonUniformIndexingNative</name></member>
            <member><type>VkBool32</type>               <name>robustBufferAccessUpdateAfterBind</name></member>
            <member><type>VkBool32</type>               <name>quadDivergentImplicitLod</name></member>
            <member><type>uint32_t</type>               <name>maxPerStageDescriptorUpdateAfterBindSamplers</name></member>
            <member><type>uint32_t</type>               <name>maxPerStageDescriptorUpdateAfterBindUniformBuffers</name></member>
            <member><type>uint32_t</type>               <name>maxPerStageDescriptorUpdateAfterBindStorageBuffers</name></member>
            <member><type>uint32_t</type>               <name>maxPerStageDescriptorUpdateAfterBindSampledImages</name></member>
            <member><type>uint32_t</type>               <name>maxPerStageDescriptorUpdateAfterBindStorageImages</name></member>
            <member><type>uint32_t</type>               <name>maxPerStageDescriptorUpdateAfterBindInputAttachments</name></member>
            <member><type>uint32_t</type>               <name>maxPerStageUpdateAfterBindResources</name></member>
            <member><type>uint32_t</type>               <name>maxDescriptorSetUpdateAfterBindSamplers</name></member>
            <member><type>uint32_t</type>               <name>maxDescriptorSetUpdateAfterBindUniformBuffers</name></member>
            <member><type>uint32_t</type>               <name>maxDescriptorSetUpdateAfterBindUniformBuffersDynamic</name></member>
            <member><type>uint32_t</type>               <name>maxDescriptorSetUpdateAfterBindStorageBuffers</name></member>
            <member><type>uint32_t</type>               <name>maxDescriptorSetUpdateAfterBindStorageBuffersDynamic</name></member>
            <member><type>uint32_t</type>               <name>maxDescriptorSetUpdateAfterBindSampledImages</name></member>
            <member><type>uint32_t</type>               <name>maxDescriptorSetUpdateAfterBindStorageImages</name></member>
            <member><type>uint32_t</type>               <name>maxDescriptorSetUpdateAfterBindInputAttachments</name></member>
        </type>
        <type category="struct" name="VkDescriptorSetLayoutBindingFlagsCreateInfoEXT" structextends="VkDescriptorSetLayoutCreateInfo">
            <member values="VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*            <name>pNext</name></member>
            <member optional="true"><type>uint32_t</type>               <name>bindingCount</name></member>
            <member len="bindingCount" optional="true">const <type>VkDescriptorBindingFlagsEXT</type>* <name>pBindingFlags</name></member>
        </type>
        <type category="struct" name="VkDescriptorSetVariableDescriptorCountAllocateInfoEXT" structextends="VkDescriptorSetAllocateInfo">
            <member values="VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*            <name>pNext</name></member>
            <member optional="true"><type>uint32_t</type>               <name>descriptorSetCount</name></member>
            <member len="descriptorSetCount">const <type>uint32_t</type>* <name>pDescriptorCounts</name></member>
        </type>
        <type category="struct" name="VkDescriptorSetVariableDescriptorCountLayoutSupportEXT" structextends="VkDescriptorSetLayoutSupport" returnedonly="true">
            <member values="VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member><type>void</type>*            <name>pNext</name></member>
            <member><type>uint32_t</type>         <name>maxVariableDescriptorCount</name></member>
        </type>
        <type category="struct" name="VkAttachmentDescription2KHR">
            <member values="VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member noautovalidity="true">const <type>void</type>*            <name>pNext</name></member>
            <member optional="true"><type>VkAttachmentDescriptionFlags</type> <name>flags</name></member>
            <member><type>VkFormat</type>                                     <name>format</name></member>
            <member><type>VkSampleCountFlagBits</type>                        <name>samples</name></member>
            <member><type>VkAttachmentLoadOp</type>                           <name>loadOp</name><comment>Load operation for color or depth data</comment></member>
            <member><type>VkAttachmentStoreOp</type>                          <name>storeOp</name><comment>Store operation for color or depth data</comment></member>
            <member><type>VkAttachmentLoadOp</type>                           <name>stencilLoadOp</name><comment>Load operation for stencil data</comment></member>
            <member><type>VkAttachmentStoreOp</type>                          <name>stencilStoreOp</name><comment>Store operation for stencil data</comment></member>
            <member><type>VkImageLayout</type>                                <name>initialLayout</name></member>
            <member><type>VkImageLayout</type>                                <name>finalLayout</name></member>
        </type>
        <type category="struct" name="VkAttachmentReference2KHR">
            <member values="VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member noautovalidity="true">const <type>void</type>* <name>pNext</name></member>
            <member><type>uint32_t</type>                          <name>attachment</name></member>
            <member><type>VkImageLayout</type>                     <name>layout</name></member>
            <member noautovalidity="true"><type>VkImageAspectFlags</type> <name>aspectMask</name></member>
        </type>
        <type category="struct" name="VkSubpassDescription2KHR">
            <member values="VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member noautovalidity="true">const <type>void</type>*                           <name>pNext</name></member>
            <member optional="true"><type>VkSubpassDescriptionFlags</type>                   <name>flags</name></member>
            <member><type>VkPipelineBindPoint</type>                                         <name>pipelineBindPoint</name></member>
            <member><type>uint32_t</type>                                                    <name>viewMask</name></member>
            <member optional="true"><type>uint32_t</type>                                    <name>inputAttachmentCount</name></member>
            <member len="inputAttachmentCount">const <type>VkAttachmentReference2KHR</type>* <name>pInputAttachments</name></member>
            <member optional="true"><type>uint32_t</type>                                    <name>colorAttachmentCount</name></member>
            <member len="colorAttachmentCount">const <type>VkAttachmentReference2KHR</type>* <name>pColorAttachments</name></member>
            <member optional="true" len="colorAttachmentCount">const <type>VkAttachmentReference2KHR</type>* <name>pResolveAttachments</name></member>
            <member optional="true">const <type>VkAttachmentReference2KHR</type>*            <name>pDepthStencilAttachment</name></member>
            <member optional="true"><type>uint32_t</type>                                    <name>preserveAttachmentCount</name></member>
            <member len="preserveAttachmentCount">const <type>uint32_t</type>*               <name>pPreserveAttachments</name></member>
        </type>
        <type category="struct" name="VkSubpassDependency2KHR">
            <member values="VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member noautovalidity="true">const <type>void</type>* <name>pNext</name></member>
            <member><type>uint32_t</type>                          <name>srcSubpass</name></member>
            <member><type>uint32_t</type>                          <name>dstSubpass</name></member>
            <member><type>VkPipelineStageFlags</type>              <name>srcStageMask</name></member>
            <member><type>VkPipelineStageFlags</type>              <name>dstStageMask</name></member>
            <member optional="true"><type>VkAccessFlags</type>     <name>srcAccessMask</name></member>
            <member optional="true"><type>VkAccessFlags</type>     <name>dstAccessMask</name></member>
            <member optional="true"><type>VkDependencyFlags</type> <name>dependencyFlags</name></member>
            <member optional="true"><type>int32_t</type>           <name>viewOffset</name></member>
        </type>
        <type category="struct" name="VkRenderPassCreateInfo2KHR">
            <member values="VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*                                              <name>pNext</name></member>
            <member optional="true" noautovalidity="true"><type>VkRenderPassCreateFlags</type> <name>flags</name></member>
            <member optional="true"><type>uint32_t</type>                                 <name>attachmentCount</name></member>
            <member len="attachmentCount">const <type>VkAttachmentDescription2KHR</type>* <name>pAttachments</name></member>
            <member><type>uint32_t</type>                                                 <name>subpassCount</name></member>
            <member len="subpassCount">const <type>VkSubpassDescription2KHR</type>*       <name>pSubpasses</name></member>
            <member optional="true"><type>uint32_t</type>                                 <name>dependencyCount</name></member>
            <member len="dependencyCount">const <type>VkSubpassDependency2KHR</type>*     <name>pDependencies</name></member>
            <member optional="true"><type>uint32_t</type>                                 <name>correlatedViewMaskCount</name></member>
            <member len="correlatedViewMaskCount">const <type>uint32_t</type>*            <name>pCorrelatedViewMasks</name></member>
        </type>
        <type category="struct" name="VkSubpassBeginInfoKHR">
            <member values="VK_STRUCTURE_TYPE_SUBPASS_BEGIN_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*            <name>pNext</name></member>
            <member><type>VkSubpassContents</type>      <name>contents</name></member>
        </type>
        <type category="struct" name="VkSubpassEndInfoKHR">
            <member values="VK_STRUCTURE_TYPE_SUBPASS_END_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*            <name>pNext</name></member>
        </type>
        <type category="struct" name="VkVertexInputBindingDivisorDescriptionEXT">
            <member><type>uint32_t</type>          <name>binding</name></member>
            <member><type>uint32_t</type>          <name>divisor</name></member>
        </type>
        <type category="struct" name="VkPipelineVertexInputDivisorStateCreateInfoEXT" structextends="VkPipelineVertexInputStateCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*                         <name>pNext</name></member>
            <member><type>uint32_t</type>                            <name>vertexBindingDivisorCount</name></member>
            <member len="vertexBindingDivisorCount">const <type>VkVertexInputBindingDivisorDescriptionEXT</type>*      <name>pVertexBindingDivisors</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT" returnedonly="true" structextends="VkPhysicalDeviceProperties2">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member><type>void</type>*                  <name>pNext</name></member>
            <member><type>uint32_t</type>               <name>maxVertexAttribDivisor</name><comment>max value of vertex attribute divisor</comment></member>
        </type>
        <type category="struct" name="VkPhysicalDevicePCIBusInfoPropertiesEXT" structextends="VkPhysicalDeviceProperties2" returnedonly="true">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PCI_BUS_INFO_PROPERTIES_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member><type>void</type>*                  <name>pNext</name></member>
            <member><type>uint32_t</type>               <name>pciDomain</name></member>
            <member><type>uint32_t</type>               <name>pciBus</name></member>
            <member><type>uint32_t</type>               <name>pciDevice</name></member>
            <member><type>uint32_t</type>               <name>pciFunction</name></member>
        </type>
        <type category="struct" name="VkImportAndroidHardwareBufferInfoANDROID" structextends="VkMemoryAllocateInfo">
            <member values="VK_STRUCTURE_TYPE_IMPORT_ANDROID_HARDWARE_BUFFER_INFO_ANDROID"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*                        <name>pNext</name></member>
            <member>struct <type>AHardwareBuffer</type>*            <name>buffer</name></member>
        </type>
        <type category="struct" name="VkAndroidHardwareBufferUsageANDROID" structextends="VkImageFormatProperties2" returnedonly="true">
            <member values="VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_USAGE_ANDROID"><type>VkStructureType</type> <name>sType</name></member>
            <member><type>void</type>*                              <name>pNext</name></member>
            <member><type>uint64_t</type>                           <name>androidHardwareBufferUsage</name></member>
        </type>
        <type category="struct" name="VkAndroidHardwareBufferPropertiesANDROID" returnedonly="true">
            <member values="VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_PROPERTIES_ANDROID"><type>VkStructureType</type> <name>sType</name></member>
            <member><type>void</type>*                              <name>pNext</name></member>
            <member><type>VkDeviceSize</type>                       <name>allocationSize</name></member>
            <member><type>uint32_t</type>                           <name>memoryTypeBits</name></member>
        </type>
        <type category="struct" name="VkMemoryGetAndroidHardwareBufferInfoANDROID">
            <member values="VK_STRUCTURE_TYPE_MEMORY_GET_ANDROID_HARDWARE_BUFFER_INFO_ANDROID"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*                        <name>pNext</name></member>
            <member><type>VkDeviceMemory</type>                     <name>memory</name></member>
        </type>
        <type category="struct" name="VkAndroidHardwareBufferFormatPropertiesANDROID" structextends="VkAndroidHardwareBufferPropertiesANDROID" returnedonly="true">
            <member values="VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_ANDROID"><type>VkStructureType</type> <name>sType</name></member>
            <member><type>void</type>*                              <name>pNext</name></member>
            <member><type>VkFormat</type>                           <name>format</name></member>
            <member><type>uint64_t</type>                           <name>externalFormat</name></member>
            <member><type>VkFormatFeatureFlags</type>               <name>formatFeatures</name></member>
            <member><type>VkComponentMapping</type>                 <name>samplerYcbcrConversionComponents</name></member>
            <member><type>VkSamplerYcbcrModelConversion</type>      <name>suggestedYcbcrModel</name></member>
            <member><type>VkSamplerYcbcrRange</type>                <name>suggestedYcbcrRange</name></member>
            <member><type>VkChromaLocation</type>                   <name>suggestedXChromaOffset</name></member>
            <member><type>VkChromaLocation</type>                   <name>suggestedYChromaOffset</name></member>
        </type>
        <type category="struct" name="VkCommandBufferInheritanceConditionalRenderingInfoEXT" structextends="VkCommandBufferInheritanceInfo">
            <member values="VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_CONDITIONAL_RENDERING_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*                         <name>pNext</name></member>
            <member><type>VkBool32</type>                            <name>conditionalRenderingEnable</name><comment>Whether this secondary command buffer may be executed during an active conditional rendering</comment></member>
        </type>
        <type category="struct" name="VkExternalFormatANDROID" structextends="VkImageCreateInfo,VkSamplerYcbcrConversionCreateInfo">
            <member values="VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_ANDROID"><type>VkStructureType</type> <name>sType</name></member>
            <member><type>void</type>*                              <name>pNext</name></member>
            <member><type>uint64_t</type>                           <name>externalFormat</name></member>
        </type>
        <type category="struct" name="VkPhysicalDevice8BitStorageFeaturesKHR" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member noautovalidity="true"><type>void</type>*      <name>pNext</name></member>
            <member><type>VkBool32</type>                         <name>storageBuffer8BitAccess</name><comment>8-bit integer variables supported in StorageBuffer</comment></member>
            <member><type>VkBool32</type>                         <name>uniformAndStorageBuffer8BitAccess</name><comment>8-bit integer variables supported in StorageBuffer and Uniform</comment></member>
            <member><type>VkBool32</type>                         <name>storagePushConstant8</name><comment>8-bit integer variables supported in PushConstant</comment></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceConditionalRenderingFeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member noautovalidity="true"><type>void</type>*        <name>pNext</name></member>
            <member><type>VkBool32</type>                           <name>conditionalRendering</name></member>
            <member><type>VkBool32</type>                           <name>inheritedConditionalRendering</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceVulkanMemoryModelFeaturesKHR" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member noautovalidity="true"><type>void</type>*      <name>pNext</name></member>
            <member><type>VkBool32</type>                         <name>vulkanMemoryModel</name></member>
            <member><type>VkBool32</type>                         <name>vulkanMemoryModelDeviceScope</name></member>
            <member><type>VkBool32</type>                         <name>vulkanMemoryModelAvailabilityVisibilityChains</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceShaderAtomicInt64FeaturesKHR" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member><type>void</type>*                               <name>pNext</name></member>
            <member><type>VkBool32</type>                            <name>shaderBufferInt64Atomics</name></member>
            <member><type>VkBool32</type>                            <name>shaderSharedInt64Atomics</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member noautovalidity="true"><type>void</type>*        <name>pNext</name></member>
            <member><type>VkBool32</type>                           <name>vertexAttributeInstanceRateDivisor</name></member>
            <member><type>VkBool32</type>                           <name>vertexAttributeInstanceRateZeroDivisor</name></member>
        </type>
        <type category="struct" name="VkQueueFamilyCheckpointPropertiesNV" structextends="VkQueueFamilyProperties2" returnedonly="true">
            <member values="VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member><type>void</type>*           <name>pNext</name></member>
            <member><type>VkPipelineStageFlags</type> <name>checkpointExecutionStageMask</name></member>
        </type>
        <type category="struct" name="VkCheckpointDataNV" returnedonly="true">
            <member values="VK_STRUCTURE_TYPE_CHECKPOINT_DATA_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member><type>void</type>*                  <name>pNext</name></member>
            <member><type>VkPipelineStageFlagBits</type>   <name>stage</name></member>
            <member noautovalidity="true"><type>void</type>* <name>pCheckpointMarker</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceDepthStencilResolvePropertiesKHR" structextends="VkPhysicalDeviceProperties2" returnedonly="true">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member><type>void</type>*                                <name>pNext</name></member>
            <member><type>VkResolveModeFlagsKHR</type>                <name>supportedDepthResolveModes</name><comment>supported depth resolve modes</comment></member>
            <member><type>VkResolveModeFlagsKHR</type>                <name>supportedStencilResolveModes</name><comment>supported stencil resolve modes</comment></member>
            <member><type>VkBool32</type>                             <name>independentResolveNone</name><comment>depth and stencil resolve modes can be set independently if one of them is none</comment></member>
            <member><type>VkBool32</type>                             <name>independentResolve</name><comment>depth and stencil resolve modes can be set independently</comment></member>
        </type>
        <type category="struct" name="VkSubpassDescriptionDepthStencilResolveKHR" structextends="VkSubpassDescription2KHR">
            <member values="VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*                                              <name>pNext</name></member>
            <member><type>VkResolveModeFlagBitsKHR</type>                                 <name>depthResolveMode</name><comment>depth resolve mode</comment></member>
            <member><type>VkResolveModeFlagBitsKHR</type>                                 <name>stencilResolveMode</name><comment>stencil resolve mode</comment></member>
            <member optional="true">const <type>VkAttachmentReference2KHR</type>*         <name>pDepthStencilResolveAttachment</name><comment>depth/stencil resolve attachment</comment></member>
        </type>
        <type category="struct" name="VkImageViewASTCDecodeModeEXT" structextends="VkImageViewCreateInfo">
            <member values="VK_STRUCTURE_TYPE_IMAGE_VIEW_ASTC_DECODE_MODE_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*                      <name>pNext</name></member>
            <member><type>VkFormat</type>                         <name>decodeMode</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceASTCDecodeFeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member noautovalidity="true"><type>void</type>*      <name>pNext</name></member>
            <member><type>VkBool32</type>                         <name>decodeModeSharedExponent</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceTransformFeedbackFeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member><type>void</type>*                  <name>pNext</name></member>
            <member><type>VkBool32</type>               <name>transformFeedback</name></member>
            <member><type>VkBool32</type>               <name>geometryStreams</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceTransformFeedbackPropertiesEXT" structextends="VkPhysicalDeviceProperties2" returnedonly="true">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_PROPERTIES_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member><type>void</type>*                  <name>pNext</name></member>
            <member><type>uint32_t</type>               <name>maxTransformFeedbackStreams</name></member>
            <member><type>uint32_t</type>               <name>maxTransformFeedbackBuffers</name></member>
            <member><type>VkDeviceSize</type>           <name>maxTransformFeedbackBufferSize</name></member>
            <member><type>uint32_t</type>               <name>maxTransformFeedbackStreamDataSize</name></member>
            <member><type>uint32_t</type>               <name>maxTransformFeedbackBufferDataSize</name></member>
            <member><type>uint32_t</type>               <name>maxTransformFeedbackBufferDataStride</name></member>
            <member><type>VkBool32</type>               <name>transformFeedbackQueries</name></member>
            <member><type>VkBool32</type>               <name>transformFeedbackStreamsLinesTriangles</name></member>
            <member><type>VkBool32</type>               <name>transformFeedbackRasterizationStreamSelect</name></member>
            <member><type>VkBool32</type>               <name>transformFeedbackDraw</name></member>
        </type>
        <type category="struct" name="VkPipelineRasterizationStateStreamCreateInfoEXT" structextends="VkPipelineRasterizationStateCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_STREAM_CREATE_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*                                                                      <name>pNext</name></member>
            <member optional="true"><type>VkPipelineRasterizationStateStreamCreateFlagsEXT</type>                 <name>flags</name></member>
            <member><type>uint32_t</type>                                                                         <name>rasterizationStream</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_REPRESENTATIVE_FRAGMENT_TEST_FEATURES_NV"><type>VkStructureType</type><name>sType</name></member>
            <member noautovalidity="true"><type>void</type>*    <name>pNext</name></member>
            <member><type>VkBool32</type>                       <name>representativeFragmentTest</name></member>
        </type>
        <type category="struct" name="VkPipelineRepresentativeFragmentTestStateCreateInfoNV" structextends="VkGraphicsPipelineCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PIPELINE_REPRESENTATIVE_FRAGMENT_TEST_STATE_CREATE_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*    <name>pNext</name></member>
            <member><type>VkBool32</type>       <name>representativeFragmentTestEnable</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceExclusiveScissorFeaturesNV" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXCLUSIVE_SCISSOR_FEATURES_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member><type>void</type>*                            <name>pNext</name></member>
            <member><type>VkBool32</type>                         <name>exclusiveScissor</name></member>
        </type>
        <type category="struct" name="VkPipelineViewportExclusiveScissorStateCreateInfoNV" structextends="VkPipelineViewportStateCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_EXCLUSIVE_SCISSOR_STATE_CREATE_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*                                                    <name>pNext</name></member>
            <member optional="true"><type>uint32_t</type>                                       <name>exclusiveScissorCount</name></member>
            <member len="exclusiveScissorCount" optional="true">const <type>VkRect2D</type>*    <name>pExclusiveScissors</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceCornerSampledImageFeaturesNV" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CORNER_SAMPLED_IMAGE_FEATURES_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member><type>void</type>*                              <name>pNext</name></member>
            <member><type>VkBool32</type>                           <name>cornerSampledImage</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceComputeShaderDerivativesFeaturesNV" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member><type>void</type>*                            <name>pNext</name></member>
            <member><type>VkBool32</type>                         <name>computeDerivativeGroupQuads</name></member>
            <member><type>VkBool32</type>                         <name>computeDerivativeGroupLinear</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member><type>void</type>*                            <name>pNext</name></member>
            <member><type>VkBool32</type>                         <name>fragmentShaderBarycentric</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceShaderImageFootprintFeaturesNV" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_FOOTPRINT_FEATURES_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member><type>void</type>*                              <name>pNext</name></member>
            <member><type>VkBool32</type>                           <name>imageFootprint</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEDICATED_ALLOCATION_IMAGE_ALIASING_FEATURES_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member><type>void</type>*                            <name>pNext</name></member>
            <member><type>VkBool32</type>                         <name>dedicatedAllocationImageAliasing</name></member>
        </type>
        <type category="struct" name="VkShadingRatePaletteNV">
            <member><type>uint32_t</type>                                                               <name>shadingRatePaletteEntryCount</name></member>
            <member len="shadingRatePaletteEntryCount">const <type>VkShadingRatePaletteEntryNV</type>*  <name>pShadingRatePaletteEntries</name></member>
        </type>
        <type category="struct" name="VkPipelineViewportShadingRateImageStateCreateInfoNV" structextends="VkPipelineViewportStateCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SHADING_RATE_IMAGE_STATE_CREATE_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*                                                            <name>pNext</name></member>
            <member><type>VkBool32</type>                                                               <name>shadingRateImageEnable</name></member>
            <member optional="true"><type>uint32_t</type>                                                               <name>viewportCount</name></member>
            <member len="viewportCount" optional="true">const <type>VkShadingRatePaletteNV</type>*      <name>pShadingRatePalettes</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceShadingRateImageFeaturesNV" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_FEATURES_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member><type>void</type>*                               <name>pNext</name></member>
            <member><type>VkBool32</type>                            <name>shadingRateImage</name></member>
            <member><type>VkBool32</type>                            <name>shadingRateCoarseSampleOrder</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceShadingRateImagePropertiesNV" structextends="VkPhysicalDeviceProperties2" returnedonly="true">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_PROPERTIES_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member><type>void</type>*                               <name>pNext</name></member>
            <member><type>VkExtent2D</type>                          <name>shadingRateTexelSize</name></member>
            <member><type>uint32_t</type>                            <name>shadingRatePaletteSize</name></member>
            <member><type>uint32_t</type>                            <name>shadingRateMaxCoarseSamples</name></member>
        </type>
        <type category="struct" name="VkCoarseSampleLocationNV">
            <member><type>uint32_t</type>                            <name>pixelX</name></member>
            <member><type>uint32_t</type>                            <name>pixelY</name></member>
            <member><type>uint32_t</type>                            <name>sample</name></member>
        </type>
        <type category="struct" name="VkCoarseSampleOrderCustomNV">
            <member><type>VkShadingRatePaletteEntryNV</type>         <name>shadingRate</name></member>
            <member><type>uint32_t</type>                            <name>sampleCount</name></member>
            <member><type>uint32_t</type>                            <name>sampleLocationCount</name></member>
            <member len="sampleLocationCount">const <type>VkCoarseSampleLocationNV</type>* <name>pSampleLocations</name></member>
        </type>
        <type category="struct" name="VkPipelineViewportCoarseSampleOrderStateCreateInfoNV" structextends="VkPipelineViewportStateCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_COARSE_SAMPLE_ORDER_STATE_CREATE_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*                                                            <name>pNext</name></member>
            <member><type>VkCoarseSampleOrderTypeNV</type>                                              <name>sampleOrderType</name></member>
            <member optional="true"><type>uint32_t</type>                                               <name>customSampleOrderCount</name></member>
            <member len="customSampleOrderCount">const <type>VkCoarseSampleOrderCustomNV</type>*        <name>pCustomSampleOrders</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceMeshShaderFeaturesNV" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member><type>void</type>*                               <name>pNext</name></member>
            <member><type>VkBool32</type>                            <name>taskShader</name></member>
            <member><type>VkBool32</type>                            <name>meshShader</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceMeshShaderPropertiesNV" returnedonly="true" structextends="VkPhysicalDeviceProperties2">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member><type>void</type>*                               <name>pNext</name></member>
            <member><type>uint32_t</type>                            <name>maxDrawMeshTasksCount</name></member>
            <member><type>uint32_t</type>                            <name>maxTaskWorkGroupInvocations</name></member>
            <member><type>uint32_t</type>                            <name>maxTaskWorkGroupSize</name>[3]</member>
            <member><type>uint32_t</type>                            <name>maxTaskTotalMemorySize</name></member>
            <member><type>uint32_t</type>                            <name>maxTaskOutputCount</name></member>
            <member><type>uint32_t</type>                            <name>maxMeshWorkGroupInvocations</name></member>
            <member><type>uint32_t</type>                            <name>maxMeshWorkGroupSize</name>[3]</member>
            <member><type>uint32_t</type>                            <name>maxMeshTotalMemorySize</name></member>
            <member><type>uint32_t</type>                            <name>maxMeshOutputVertices</name></member>
            <member><type>uint32_t</type>                            <name>maxMeshOutputPrimitives</name></member>
            <member><type>uint32_t</type>                            <name>maxMeshMultiviewViewCount</name></member>
            <member><type>uint32_t</type>                            <name>meshOutputPerVertexGranularity</name></member>
            <member><type>uint32_t</type>                            <name>meshOutputPerPrimitiveGranularity</name></member>
        </type>
        <type category="struct" name="VkDrawMeshTasksIndirectCommandNV">
            <member><type>uint32_t</type>               <name>taskCount</name></member>
            <member><type>uint32_t</type>               <name>firstTask</name></member>
        </type>
        <type category="struct" name="VkRayTracingShaderGroupCreateInfoNV">
            <member values="VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*            <name>pNext</name></member>
            <member><type>VkRayTracingShaderGroupTypeNV</type> <name>type</name></member>
            <member><type>uint32_t</type>               <name>generalShader</name></member>
            <member><type>uint32_t</type>               <name>closestHitShader</name></member>
            <member><type>uint32_t</type>               <name>anyHitShader</name></member>
            <member><type>uint32_t</type>               <name>intersectionShader</name></member>
        </type>
        <type category="struct" name="VkRayTracingPipelineCreateInfoNV">
            <member values="VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*            <name>pNext</name></member>
            <member optional="true"><type>VkPipelineCreateFlags</type>  <name>flags</name><comment>Pipeline creation flags</comment></member>
            <member><type>uint32_t</type>               <name>stageCount</name></member>
            <member len="stageCount">const <type>VkPipelineShaderStageCreateInfo</type>* <name>pStages</name><comment>One entry for each active shader stage</comment></member>
            <member><type>uint32_t</type>               <name>groupCount</name></member>
            <member len="groupCount">const <type>VkRayTracingShaderGroupCreateInfoNV</type>* <name>pGroups</name></member>
            <member><type>uint32_t</type>               <name>maxRecursionDepth</name></member>
            <member><type>VkPipelineLayout</type>       <name>layout</name><comment>Interface layout of the pipeline</comment></member>
            <member noautovalidity="true" optional="true"><type>VkPipeline</type>      <name>basePipelineHandle</name><comment>If VK_PIPELINE_CREATE_DERIVATIVE_BIT is set and this value is nonzero, it specifies the handle of the base pipeline this is a derivative of</comment></member>
            <member><type>int32_t</type>                <name>basePipelineIndex</name><comment>If VK_PIPELINE_CREATE_DERIVATIVE_BIT is set and this value is not -1, it specifies an index into pCreateInfos of the base pipeline this is a derivative of</comment></member>
        </type>
        <type category="struct" name="VkGeometryTrianglesNV">
            <member values="VK_STRUCTURE_TYPE_GEOMETRY_TRIANGLES_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*                <name>pNext</name></member>
            <member optional="true"><type>VkBuffer</type>   <name>vertexData</name></member>
            <member><type>VkDeviceSize</type>               <name>vertexOffset</name></member>
            <member><type>uint32_t</type>                   <name>vertexCount</name></member>
            <member><type>VkDeviceSize</type>               <name>vertexStride</name></member>
            <member><type>VkFormat</type>                   <name>vertexFormat</name></member>
            <member optional="true"><type>VkBuffer</type>   <name>indexData</name></member>
            <member><type>VkDeviceSize</type>               <name>indexOffset</name></member>
            <member><type>uint32_t</type>                   <name>indexCount</name></member>
            <member><type>VkIndexType</type>                <name>indexType</name></member>
            <member optional="true"><type>VkBuffer</type>   <name>transformData</name><comment>Optional reference to array of floats representing a 3x4 row major affine transformation matrix.</comment></member>
            <member><type>VkDeviceSize</type>               <name>transformOffset</name></member>
        </type>
        <type category="struct" name="VkGeometryAABBNV">
            <member values="VK_STRUCTURE_TYPE_GEOMETRY_AABB_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*                <name>pNext</name></member>
            <member optional="true"><type>VkBuffer</type>   <name>aabbData</name></member>
            <member><type>uint32_t</type>                   <name>numAABBs</name></member>
            <member><type>uint32_t</type>                   <name>stride</name><comment>Stride in bytes between AABBs</comment></member>
            <member><type>VkDeviceSize</type>               <name>offset</name><comment>Offset in bytes of the first AABB in aabbData</comment></member>
        </type>
        <type category="struct" name="VkGeometryDataNV">
            <member><type>VkGeometryTrianglesNV</type>                  <name>triangles</name></member>
            <member><type>VkGeometryAABBNV</type>                       <name>aabbs</name></member>
        </type>
        <type category="struct" name="VkGeometryNV">
            <member values="VK_STRUCTURE_TYPE_GEOMETRY_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*                        <name>pNext</name></member>
            <member><type>VkGeometryTypeNV</type>                  <name>geometryType</name></member>
            <member><type>VkGeometryDataNV</type>                  <name>geometry</name></member>
            <member optional="true"><type>VkGeometryFlagsNV</type> <name>flags</name></member>
        </type>
        <type category="struct" name="VkAccelerationStructureInfoNV">
            <member values="VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*                            <name>pNext</name></member>
            <member><type>VkAccelerationStructureTypeNV</type>         <name>type</name></member>
            <member optional="true"><type>VkBuildAccelerationStructureFlagsNV</type><name>flags</name></member>
            <member optional="true"><type>uint32_t</type>               <name>instanceCount</name></member>
            <member optional="true"><type>uint32_t</type>               <name>geometryCount</name></member>
            <member len="geometryCount">const <type>VkGeometryNV</type>* <name>pGeometries</name></member>
        </type>
        <type category="struct" name="VkAccelerationStructureCreateInfoNV">
            <member values="VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*                            <name>pNext</name></member>
            <member><type>VkDeviceSize</type>                           <name>compactedSize</name></member>
            <member><type>VkAccelerationStructureInfoNV</type>          <name>info</name></member>
        </type>
        <type category="struct" name="VkBindAccelerationStructureMemoryInfoNV">
            <member values="VK_STRUCTURE_TYPE_BIND_ACCELERATION_STRUCTURE_MEMORY_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*                      <name>pNext</name></member>
            <member><type>VkAccelerationStructureNV</type>        <name>accelerationStructure</name></member>
            <member><type>VkDeviceMemory</type>                   <name>memory</name></member>
            <member><type>VkDeviceSize</type>                     <name>memoryOffset</name></member>
            <member optional="true"><type>uint32_t</type>         <name>deviceIndexCount</name></member>
            <member len="deviceIndexCount">const <type>uint32_t</type>*  <name>pDeviceIndices</name></member>
        </type>
        <type category="struct" name="VkWriteDescriptorSetAccelerationStructureNV" structextends="VkWriteDescriptorSet">
            <member values="VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*                      <name>pNext</name></member>
            <member><type>uint32_t</type>                         <name>accelerationStructureCount</name></member>
            <member len="accelerationStructureCount">const <type>VkAccelerationStructureNV</type>* <name>pAccelerationStructures</name></member>
        </type>
        <type category="struct" name="VkAccelerationStructureMemoryRequirementsInfoNV">
            <member values="VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*                                                          <name>pNext</name></member>
            <member><type>VkAccelerationStructureMemoryRequirementsTypeNV</type>                      <name>type</name></member>
            <member><type>VkAccelerationStructureNV</type>                                            <name>accelerationStructure</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceRayTracingPropertiesNV" returnedonly="true" structextends="VkPhysicalDeviceProperties2">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PROPERTIES_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member><type>void</type>*                            <name>pNext</name></member>
            <member><type>uint32_t</type>                         <name>shaderGroupHandleSize</name></member>
            <member><type>uint32_t</type>                         <name>maxRecursionDepth</name></member>
            <member><type>uint32_t</type>                         <name>maxShaderGroupStride</name></member>
            <member><type>uint32_t</type>                         <name>shaderGroupBaseAlignment</name></member>
            <member><type>uint64_t</type>                         <name>maxGeometryCount</name></member>
            <member><type>uint64_t</type>                         <name>maxInstanceCount</name></member>
            <member><type>uint64_t</type>                         <name>maxTriangleCount</name></member>
            <member><type>uint32_t</type>                         <name>maxDescriptorSetAccelerationStructures</name></member>
        </type>
        <type category="struct" name="VkDrmFormatModifierPropertiesListEXT" returnedonly="true" structextends="VkFormatProperties2">
            <member values="VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member><type>void</type>* <name>pNext</name></member>
            <member optional="true"><type>uint32_t</type> <name>drmFormatModifierCount</name></member>
            <member optional="true,false" len="drmFormatModifierCount"><type>VkDrmFormatModifierPropertiesEXT</type>* <name>pDrmFormatModifierProperties</name></member>
        </type>
        <type category="struct" name="VkDrmFormatModifierPropertiesEXT" returnedonly="true">
            <member><type>uint64_t</type> <name>drmFormatModifier</name></member>
            <member><type>uint32_t</type> <name>drmFormatModifierPlaneCount</name></member>
            <member><type>VkFormatFeatureFlags</type> <name>drmFormatModifierTilingFeatures</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceImageDrmFormatModifierInfoEXT" structextends="VkPhysicalDeviceImageFormatInfo2">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_DRM_FORMAT_MODIFIER_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>* <name>pNext</name></member>
            <member><type>uint64_t</type> <name>drmFormatModifier</name></member>
            <member><type>VkSharingMode</type> <name>sharingMode</name></member>
            <member optional="true"><type>uint32_t</type> <name>queueFamilyIndexCount</name></member>
            <member noautovalidity="true" len="queueFamilyIndexCount">const <type>uint32_t</type>* <name>pQueueFamilyIndices</name></member>
        </type>
        <type category="struct" name="VkImageDrmFormatModifierListCreateInfoEXT" structextends="VkImageCreateInfo">
            <member values="VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_LIST_CREATE_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>* <name>pNext</name></member>
            <member><type>uint32_t</type> <name>drmFormatModifierCount</name></member>
            <member len="drmFormatModifierCount">const <type>uint64_t</type>* <name>pDrmFormatModifiers</name></member>
        </type>
        <type category="struct" name="VkImageDrmFormatModifierExplicitCreateInfoEXT" structextends="VkImageCreateInfo">
            <member values="VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>* <name>pNext</name></member>
            <member><type>uint64_t</type> <name>drmFormatModifier</name></member>
            <member optional="false"><type>uint32_t</type> <name>drmFormatModifierPlaneCount</name></member>
            <member len="drmFormatModifierPlaneCount">const <type>VkSubresourceLayout</type>* <name>pPlaneLayouts</name></member>
        </type>
        <type category="struct" name="VkImageDrmFormatModifierPropertiesEXT" returnedonly="true">
            <member values="VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_PROPERTIES_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member><type>void</type>* <name>pNext</name></member>
            <member><type>uint64_t</type> <name>drmFormatModifier</name></member>
        </type>
        <type category="struct" name="VkImageStencilUsageCreateInfoEXT" structextends="VkImageCreateInfo,VkPhysicalDeviceImageFormatInfo2">
            <member values="VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>* <name>pNext</name></member>
            <member><type>VkImageUsageFlags</type> <name>stencilUsage</name></member>
        </type>
        <type category="struct" name="VkDeviceMemoryOverallocationCreateInfoAMD"  structextends="VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_DEVICE_MEMORY_OVERALLOCATION_CREATE_INFO_AMD"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*                      <name>pNext</name></member>
            <member><type>VkMemoryOverallocationBehaviorAMD</type> <name>overallocationBehavior</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceFragmentDensityMapFeaturesEXT" returnedonly="true" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member><type>void</type>*                            <name>pNext</name></member>
            <member><type>VkBool32</type>                         <name>fragmentDensityMap</name></member>
            <member><type>VkBool32</type>                         <name>fragmentDensityMapDynamic</name></member>
            <member><type>VkBool32</type>                         <name>fragmentDensityMapNonSubsampledImages</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceFragmentDensityMapPropertiesEXT" returnedonly="true" structextends="VkPhysicalDeviceProperties2">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_PROPERTIES_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member><type>void</type>*                            <name>pNext</name></member>
            <member><type>VkExtent2D</type>                       <name>minFragmentDensityTexelSize</name></member>
            <member><type>VkExtent2D</type>                       <name>maxFragmentDensityTexelSize</name></member>
            <member><type>VkBool32</type>                         <name>fragmentDensityInvocations</name></member>
        </type>
        <type category="struct" name="VkRenderPassFragmentDensityMapCreateInfoEXT" structextends="VkRenderPassCreateInfo">
            <member values="VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_CREATE_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*                      <name>pNext</name></member>
            <member><type>VkAttachmentReference</type>            <name>fragmentDensityMapAttachment</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceScalarBlockLayoutFeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member><type>void</type>*                               <name>pNext</name></member>
            <member><type>VkBool32</type>                            <name>scalarBlockLayout</name></member>
        </type>
        <type category="struct" name="VkSurfaceProtectedCapabilitiesKHR" structextends="VkSurfaceCapabilities2KHR">
            <member values="VK_STRUCTURE_TYPE_SURFACE_PROTECTED_CAPABILITIES_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>* <name>pNext</name></member>
            <member><type>VkBool32</type> <name>supportsProtected</name><comment>Represents if surface can be protected</comment></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceUniformBufferStandardLayoutFeaturesKHR" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member><type>void</type>*                               <name>pNext</name></member>
            <member><type>VkBool32</type>                            <name>uniformBufferStandardLayout</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceDepthClipEnableFeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member><type>void</type>*                  <name>pNext</name><comment>Pointer to next structure</comment></member>
            <member><type>VkBool32</type>               <name>depthClipEnable</name></member>
        </type>
        <type category="struct" name="VkPipelineRasterizationDepthClipStateCreateInfoEXT" structextends="VkPipelineRasterizationStateCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_DEPTH_CLIP_STATE_CREATE_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*                                                                 <name>pNext</name></member>                 <!-- Pointer to next structure -->
            <member optional="true"><type>VkPipelineRasterizationDepthClipStateCreateFlagsEXT</type>         <name>flags</name></member>                 <!-- Reserved -->
            <member><type>VkBool32</type>                                                                    <name>depthClipEnable</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceMemoryBudgetPropertiesEXT" structextends="VkPhysicalDeviceMemoryProperties2" returnedonly="true">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_BUDGET_PROPERTIES_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member noautovalidity="true"><type>void</type>*        <name>pNext</name></member>
            <member><type>VkDeviceSize</type>                       <name>heapBudget</name>[<enum>VK_MAX_MEMORY_HEAPS</enum>]</member>
            <member><type>VkDeviceSize</type>                       <name>heapUsage</name>[<enum>VK_MAX_MEMORY_HEAPS</enum>]</member>
        </type>
        <type category="struct" name="VkPhysicalDeviceMemoryPriorityFeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PRIORITY_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member noautovalidity="true"><type>void</type>*        <name>pNext</name></member>
            <member><type>VkBool32</type>                           <name>memoryPriority</name></member>
        </type>
        <type category="struct" name="VkMemoryPriorityAllocateInfoEXT" structextends="VkMemoryAllocateInfo">
            <member values="VK_STRUCTURE_TYPE_MEMORY_PRIORITY_ALLOCATE_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*                        <name>pNext</name></member>
            <member><type>float</type>                              <name>priority</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceBufferDeviceAddressFeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member noautovalidity="true"><type>void</type>*        <name>pNext</name></member>
            <member><type>VkBool32</type>                           <name>bufferDeviceAddress</name></member>
            <member><type>VkBool32</type>                           <name>bufferDeviceAddressCaptureReplay</name></member>
            <member><type>VkBool32</type>                           <name>bufferDeviceAddressMultiDevice</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceBufferAddressFeaturesEXT" alias="VkPhysicalDeviceBufferDeviceAddressFeaturesEXT"/>
        <type category="struct" name="VkBufferDeviceAddressInfoEXT">
            <member values="VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*                                            <name>pNext</name></member>
            <member><type>VkBuffer</type>                                               <name>buffer</name></member>
        </type>
        <type category="struct" name="VkBufferDeviceAddressCreateInfoEXT" structextends="VkBufferCreateInfo">
            <member values="VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_CREATE_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*                      <name>pNext</name></member>
            <member><type>VkDeviceAddress</type>                  <name>deviceAddress</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceImageViewImageFormatInfoEXT" structextends="VkPhysicalDeviceImageFormatInfo2">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_IMAGE_FORMAT_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member><type>void</type>*                            <name>pNext</name></member>
            <member><type>VkImageViewType</type>                  <name>imageViewType</name></member>
        </type>
        <type category="struct" name="VkFilterCubicImageViewImageFormatPropertiesEXT" returnedonly="true" structextends="VkImageFormatProperties2">
            <member values="VK_STRUCTURE_TYPE_FILTER_CUBIC_IMAGE_VIEW_IMAGE_FORMAT_PROPERTIES_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member><type>void</type>*                            <name>pNext</name></member>
            <member><type>VkBool32</type>                         <name>filterCubic</name></member> <!-- The combinations of format, image type (and image view type if provided) can be filtered with VK_FILTER_CUBIC_EXT -->
            <member><type>VkBool32</type>                         <name>filterCubicMinmax</name> </member> <!-- The combination of format, image type (and image view type if provided) can be filtered with VK_FILTER_CUBIC_EXT and ReductionMode of Min or Max -->
        </type>
        <type category="struct" name="VkPhysicalDeviceCooperativeMatrixFeaturesNV" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member><type>void</type>*                               <name>pNext</name></member>
            <member><type>VkBool32</type>                            <name>cooperativeMatrix</name></member>
            <member><type>VkBool32</type>                            <name>cooperativeMatrixRobustBufferAccess</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceCooperativeMatrixPropertiesNV" returnedonly="true" structextends="VkPhysicalDeviceProperties2">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member><type>void</type>*                               <name>pNext</name></member>
            <member><type>VkShaderStageFlags</type>                  <name>cooperativeMatrixSupportedStages</name></member>
        </type>
        <type category="struct" name="VkCooperativeMatrixPropertiesNV">
            <member values="VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_PROPERTIES_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member><type>void</type>*                               <name>pNext</name></member>
            <member><type>uint32_t</type>                            <name>MSize</name></member>
            <member><type>uint32_t</type>                            <name>NSize</name></member>
            <member><type>uint32_t</type>                            <name>KSize</name></member>
            <member><type>VkComponentTypeNV</type>                   <name>AType</name></member>
            <member><type>VkComponentTypeNV</type>                   <name>BType</name></member>
            <member><type>VkComponentTypeNV</type>                   <name>CType</name></member>
            <member><type>VkComponentTypeNV</type>                   <name>DType</name></member>
            <member><type>VkScopeNV</type>                           <name>scope</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceYcbcrImageArraysFeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_IMAGE_ARRAYS_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member noautovalidity="true"><type>void</type>*        <name>pNext</name></member>
            <member><type>VkBool32</type>                           <name>ycbcrImageArrays</name></member>
        </type>
        <type category="struct" name="VkImageViewHandleInfoNVX">
            <member values="VK_STRUCTURE_TYPE_IMAGE_VIEW_HANDLE_INFO_NVX"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*            <name>pNext</name></member>
            <member><type>VkImageView</type>                         <name>imageView</name></member>
            <member><type>VkDescriptorType</type>                    <name>descriptorType</name></member>
            <member optional="true"><type>VkSampler</type>           <name>sampler</name></member>
        </type>
        <type category="struct" name="VkPresentFrameTokenGGP" structextends="VkPresentInfoKHR">
            <member values="VK_STRUCTURE_TYPE_PRESENT_FRAME_TOKEN_GGP"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*                      <name>pNext</name></member>
            <member><type>GgpFrameToken</type>                    <name>frameToken</name></member>
        </type>
        <type category="struct" name="VkPipelineCreationFeedbackEXT" returnedonly="true">
            <member><type>VkPipelineCreationFeedbackFlagsEXT</type>  <name>flags</name></member>
            <member><type>uint64_t</type>                            <name>duration</name></member>
        </type>
        <type category="struct" name="VkPipelineCreationFeedbackCreateInfoEXT" structextends="VkGraphicsPipelineCreateInfo,VkComputePipelineCreateInfo,VkRayTracingPipelineCreateInfoNV">
            <member values="VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*                         <name>pNext</name></member>
            <member><type>VkPipelineCreationFeedbackEXT</type>*      <name>pPipelineCreationFeedback</name><comment>Output pipeline creation feedback.</comment></member>
            <member><type>uint32_t</type>                            <name>pipelineStageCreationFeedbackCount</name></member>
            <member len="pipelineStageCreationFeedbackCount"><type>VkPipelineCreationFeedbackEXT</type>* <name>pPipelineStageCreationFeedbacks</name><comment>One entry for each shader stage specified in the parent Vk*PipelineCreateInfo struct</comment></member>
        </type>
        <type category="struct" name="VkSurfaceFullScreenExclusiveInfoEXT" structextends="VkPhysicalDeviceSurfaceInfo2KHR,VkSwapchainCreateInfoKHR">
            <member values="VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member><type>void</type>*                            <name>pNext</name></member>
            <member><type>VkFullScreenExclusiveEXT</type>         <name>fullScreenExclusive</name></member>
        </type>
        <type category="struct" name="VkSurfaceFullScreenExclusiveWin32InfoEXT" structextends="VkPhysicalDeviceSurfaceInfo2KHR,VkSwapchainCreateInfoKHR">
            <member values="VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_WIN32_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*      <name>pNext</name></member>
            <member><type>HMONITOR</type>         <name>hmonitor</name></member>
        </type>
        <type category="struct" name="VkSurfaceCapabilitiesFullScreenExclusiveEXT" structextends="VkSurfaceCapabilities2KHR">
            <member values="VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_FULL_SCREEN_EXCLUSIVE_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member><type>void</type>*            <name>pNext</name></member>
            <member><type>VkBool32</type>         <name>fullScreenExclusiveSupported</name></member>
        </type>
        <type category="struct" name="VkHeadlessSurfaceCreateInfoEXT">
            <member values="VK_STRUCTURE_TYPE_HEADLESS_SURFACE_CREATE_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*            <name>pNext</name></member>
            <member optional="true"><type>VkHeadlessSurfaceCreateFlagsEXT</type>   <name>flags</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceCoverageReductionModeFeaturesNV" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COVERAGE_REDUCTION_MODE_FEATURES_NV"><type>VkStructureType</type><name>sType</name></member>
            <member noautovalidity="true"><type>void</type>*    <name>pNext</name></member>
            <member><type>VkBool32</type>                       <name>coverageReductionMode</name></member>
        </type>
        <type category="struct" name="VkPipelineCoverageReductionStateCreateInfoNV" structextends="VkPipelineMultisampleStateCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_REDUCTION_STATE_CREATE_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*                                                        <name>pNext</name></member>
            <member optional="true"><type>VkPipelineCoverageReductionStateCreateFlagsNV</type>      <name>flags</name></member>
            <member><type>VkCoverageReductionModeNV</type>                                          <name>coverageReductionMode</name></member>
        </type>
        <type category="struct" name="VkFramebufferMixedSamplesCombinationNV" returnedonly="true">
            <member values="VK_STRUCTURE_TYPE_FRAMEBUFFER_MIXED_SAMPLES_COMBINATION_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member><type>void</type>*                      <name>pNext</name></member>
            <member><type>VkCoverageReductionModeNV</type>  <name>coverageReductionMode</name></member>
            <member><type>VkSampleCountFlagBits</type>      <name>rasterizationSamples</name></member>
            <member><type>VkSampleCountFlags</type>         <name>depthStencilSamples</name></member>
            <member><type>VkSampleCountFlags</type>         <name>colorSamples</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceShaderIntegerFunctions2INTEL" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_FUNCTIONS2_FEATURES_INTEL"><type>VkStructureType</type> <name>sType</name></member>
            <member><type>void</type>*                            <name>pNext</name></member>
            <member><type>VkBool32</type>                         <name>shaderIntegerFunctions2</name></member>
        </type>
        <type category="union" name="VkPerformanceValueDataINTEL">
            <member><type>uint32_t</type>                           <name>value32</name></member>
            <member><type>uint64_t</type>                           <name>value64</name></member>
            <member><type>float</type>                              <name>valueFloat</name></member>
            <member><type>VkBool32</type>                           <name>valueBool</name></member>
            <member>const <type>char</type>*                        <name>valueString</name></member>
        </type>
        <type category="struct" name="VkPerformanceValueINTEL">
            <member><type>VkPerformanceValueTypeINTEL</type>        <name>type</name></member>
            <member><type>VkPerformanceValueDataINTEL</type>        <name>data</name></member>
        </type>
        <type category="struct" name="VkInitializePerformanceApiInfoINTEL" >
            <member values="VK_STRUCTURE_TYPE_INITIALIZE_PERFORMANCE_API_INFO_INTEL"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*                         <name>pNext</name></member>
            <member optional="false"><type>void</type>*             <name>pUserData</name></member>
        </type>
        <type category="struct" name="VkQueryPoolCreateInfoINTEL">
            <member values="VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO_INTEL"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*                         <name>pNext</name></member>
            <member><type>VkQueryPoolSamplingModeINTEL</type>        <name>performanceCountersSampling</name></member>
        </type>
        <type category="struct" name="VkPerformanceMarkerInfoINTEL">
            <member values="VK_STRUCTURE_TYPE_PERFORMANCE_MARKER_INFO_INTEL"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*                         <name>pNext</name></member>
            <member><type>uint64_t</type>                            <name>marker</name></member>
        </type>
        <type category="struct" name="VkPerformanceStreamMarkerInfoINTEL">
            <member values="VK_STRUCTURE_TYPE_PERFORMANCE_STREAM_MARKER_INFO_INTEL"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*                         <name>pNext</name></member>
            <member><type>uint32_t</type>                            <name>marker</name></member>
        </type>
        <type category="struct" name="VkPerformanceOverrideInfoINTEL">
            <member values="VK_STRUCTURE_TYPE_PERFORMANCE_OVERRIDE_INFO_INTEL"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*                         <name>pNext</name></member>
            <member><type>VkPerformanceOverrideTypeINTEL</type>      <name>type</name></member>
            <member><type>VkBool32</type>                            <name>enable</name></member>
            <member><type>uint64_t</type>                            <name>parameter</name></member>
        </type>
        <type category="struct" name="VkPerformanceConfigurationAcquireInfoINTEL">
            <member values="VK_STRUCTURE_TYPE_PERFORMANCE_CONFIGURATION_ACQUIRE_INFO_INTEL"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*                         <name>pNext</name></member>
            <member><type>VkPerformanceConfigurationTypeINTEL</type> <name>type</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceShaderSMBuiltinsPropertiesNV" returnedonly="true" structextends="VkPhysicalDeviceProperties2">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_PROPERTIES_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member><type>void</type>*                          <name>pNext</name></member>
            <member><type>uint32_t</type>                       <name>shaderSMCount</name></member>
            <member><type>uint32_t</type>                       <name>shaderWarpsPerSM</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceShaderSMBuiltinsFeaturesNV" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_FEATURES_NV"><type>VkStructureType</type><name>sType</name></member>
            <member noautovalidity="true"><type>void</type>*    <name>pNext</name></member>
            <member><type>VkBool32</type>                       <name>shaderSMBuiltins</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_INTERLOCK_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member><type>void</type>*                  <name>pNext</name><comment>Pointer to next structure</comment></member>
            <member><type>VkBool32</type>               <name>fragmentShaderSampleInterlock</name></member>
            <member><type>VkBool32</type>               <name>fragmentShaderPixelInterlock</name></member>
            <member><type>VkBool32</type>               <name>fragmentShaderShadingRateInterlock</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member noautovalidity="true"><type>void</type>*        <name>pNext</name></member>
            <member><type>VkBool32</type>                           <name>shaderDemoteToHelperInvocation</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member noautovalidity="true"><type>void</type>*        <name>pNext</name></member>
            <member><type>VkBool32</type>                           <name>texelBufferAlignment</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT" structextends="VkPhysicalDeviceMemoryProperties2" returnedonly="true">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member noautovalidity="true"><type>void</type>*        <name>pNext</name></member>
            <member><type>VkDeviceSize</type>                       <name>storageTexelBufferOffsetAlignmentBytes</name></member>
            <member><type>VkBool32</type>                           <name>storageTexelBufferOffsetSingleTexelAlignment</name></member>
            <member><type>VkDeviceSize</type>                       <name>uniformTexelBufferOffsetAlignmentBytes</name></member>
            <member><type>VkBool32</type>                           <name>uniformTexelBufferOffsetSingleTexelAlignment</name></member>
        </type>
    </types>

    <comment>Vulkan enumerant (token) definitions</comment>

    <enums name="API Constants" comment="Vulkan hardcoded constants - not an enumerated type, part of the header boilerplate">
        <enum value="256"   name="VK_MAX_PHYSICAL_DEVICE_NAME_SIZE"/>
        <enum value="16"    name="VK_UUID_SIZE"/>
        <enum value="8"     name="VK_LUID_SIZE"/>
        <enum               name="VK_LUID_SIZE_KHR" alias="VK_LUID_SIZE"/>
        <enum value="256"   name="VK_MAX_EXTENSION_NAME_SIZE"/>
        <enum value="256"   name="VK_MAX_DESCRIPTION_SIZE"/>
        <enum value="32"    name="VK_MAX_MEMORY_TYPES"/>
        <enum value="16"    name="VK_MAX_MEMORY_HEAPS" comment="The maximum number of unique memory heaps, each of which supporting 1 or more memory types"/>
        <enum value="1000.0f" name="VK_LOD_CLAMP_NONE"/>
        <enum value="(~0U)" name="VK_REMAINING_MIP_LEVELS"/>
        <enum value="(~0U)" name="VK_REMAINING_ARRAY_LAYERS"/>
        <enum value="(~0ULL)" name="VK_WHOLE_SIZE"/>
        <enum value="(~0U)" name="VK_ATTACHMENT_UNUSED"/>
        <enum value="1"     name="VK_TRUE"/>
        <enum value="0"     name="VK_FALSE"/>
        <enum value="(~0U)" name="VK_QUEUE_FAMILY_IGNORED"/>
        <enum value="(~0U-1)" name="VK_QUEUE_FAMILY_EXTERNAL"/>
        <enum               name="VK_QUEUE_FAMILY_EXTERNAL_KHR" alias="VK_QUEUE_FAMILY_EXTERNAL"/>
        <enum value="(~0U-2)" name="VK_QUEUE_FAMILY_FOREIGN_EXT"/>
        <enum value="(~0U)" name="VK_SUBPASS_EXTERNAL"/>
        <enum value="32"    name="VK_MAX_DEVICE_GROUP_SIZE"/>
        <enum               name="VK_MAX_DEVICE_GROUP_SIZE_KHR" alias="VK_MAX_DEVICE_GROUP_SIZE"/>
        <enum value="256"   name="VK_MAX_DRIVER_NAME_SIZE_KHR"/>
        <enum value="256"   name="VK_MAX_DRIVER_INFO_SIZE_KHR"/>
        <enum value="(~0U)" name="VK_SHADER_UNUSED_NV"/>
    </enums>

    <comment>
        Unlike OpenGL, most tokens in Vulkan are actual typed enumerants in
        their own numeric namespaces. The "name" attribute is the C enum
        type name, and is pulled in from a type tag definition above
        (slightly clunky, but retains the type / enum distinction). "type"
        attributes of "enum" or "bitmask" indicate that these values should
        be generated inside an appropriate definition.
    </comment>

    <enums name="VkImageLayout" type="enum">
        <enum value="0"     name="VK_IMAGE_LAYOUT_UNDEFINED"                         comment="Implicit layout an image is when its contents are undefined due to various reasons (e.g. right after creation)"/>
        <enum value="1"     name="VK_IMAGE_LAYOUT_GENERAL"                           comment="General layout when image can be used for any kind of access"/>
        <enum value="2"     name="VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL"          comment="Optimal layout when image is only used for color attachment read/write"/>
        <enum value="3"     name="VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL"  comment="Optimal layout when image is only used for depth/stencil attachment read/write"/>
        <enum value="4"     name="VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL"   comment="Optimal layout when image is used for read only depth/stencil attachment and shader access"/>
        <enum value="5"     name="VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL"          comment="Optimal layout when image is used for read only shader access"/>
        <enum value="6"     name="VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL"              comment="Optimal layout when image is used only as source of transfer operations"/>
        <enum value="7"     name="VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL"              comment="Optimal layout when image is used only as destination of transfer operations"/>
        <enum value="8"     name="VK_IMAGE_LAYOUT_PREINITIALIZED"                    comment="Initial layout used when the data is populated by the CPU"/>
    </enums>
    <enums name="VkAttachmentLoadOp" type="enum">
        <enum value="0"     name="VK_ATTACHMENT_LOAD_OP_LOAD"/>
        <enum value="1"     name="VK_ATTACHMENT_LOAD_OP_CLEAR"/>
        <enum value="2"     name="VK_ATTACHMENT_LOAD_OP_DONT_CARE"/>
    </enums>
    <enums name="VkAttachmentStoreOp" type="enum">
        <enum value="0"     name="VK_ATTACHMENT_STORE_OP_STORE"/>
        <enum value="1"     name="VK_ATTACHMENT_STORE_OP_DONT_CARE"/>
    </enums>
    <enums name="VkImageType" type="enum">
        <enum value="0"     name="VK_IMAGE_TYPE_1D"/>
        <enum value="1"     name="VK_IMAGE_TYPE_2D"/>
        <enum value="2"     name="VK_IMAGE_TYPE_3D"/>
    </enums>
    <enums name="VkImageTiling" type="enum">
        <enum value="0"     name="VK_IMAGE_TILING_OPTIMAL"/>
        <enum value="1"     name="VK_IMAGE_TILING_LINEAR"/>
    </enums>
    <enums name="VkImageViewType" type="enum">
        <enum value="0"     name="VK_IMAGE_VIEW_TYPE_1D"/>
        <enum value="1"     name="VK_IMAGE_VIEW_TYPE_2D"/>
        <enum value="2"     name="VK_IMAGE_VIEW_TYPE_3D"/>
        <enum value="3"     name="VK_IMAGE_VIEW_TYPE_CUBE"/>
        <enum value="4"     name="VK_IMAGE_VIEW_TYPE_1D_ARRAY"/>
        <enum value="5"     name="VK_IMAGE_VIEW_TYPE_2D_ARRAY"/>
        <enum value="6"     name="VK_IMAGE_VIEW_TYPE_CUBE_ARRAY"/>
    </enums>
    <enums name="VkCommandBufferLevel" type="enum">
        <enum value="0"     name="VK_COMMAND_BUFFER_LEVEL_PRIMARY"/>
        <enum value="1"     name="VK_COMMAND_BUFFER_LEVEL_SECONDARY"/>
    </enums>
    <enums name="VkComponentSwizzle" type="enum">
        <enum value="0"     name="VK_COMPONENT_SWIZZLE_IDENTITY"/>
        <enum value="1"     name="VK_COMPONENT_SWIZZLE_ZERO"/>
        <enum value="2"     name="VK_COMPONENT_SWIZZLE_ONE"/>
        <enum value="3"     name="VK_COMPONENT_SWIZZLE_R"/>
        <enum value="4"     name="VK_COMPONENT_SWIZZLE_G"/>
        <enum value="5"     name="VK_COMPONENT_SWIZZLE_B"/>
        <enum value="6"     name="VK_COMPONENT_SWIZZLE_A"/>
    </enums>
    <enums name="VkDescriptorType" type="enum">
        <enum value="0"     name="VK_DESCRIPTOR_TYPE_SAMPLER"/>
        <enum value="1"     name="VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER"/>
        <enum value="2"     name="VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE"/>
        <enum value="3"     name="VK_DESCRIPTOR_TYPE_STORAGE_IMAGE"/>
        <enum value="4"     name="VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER"/>
        <enum value="5"     name="VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER"/>
        <enum value="6"     name="VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER"/>
        <enum value="7"     name="VK_DESCRIPTOR_TYPE_STORAGE_BUFFER"/>
        <enum value="8"     name="VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC"/>
        <enum value="9"     name="VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC"/>
        <enum value="10"    name="VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT"/>
    </enums>
    <enums name="VkQueryType" type="enum">
        <enum value="0"     name="VK_QUERY_TYPE_OCCLUSION"/>
        <enum value="1"     name="VK_QUERY_TYPE_PIPELINE_STATISTICS"                 comment="Optional"/>
        <enum value="2"     name="VK_QUERY_TYPE_TIMESTAMP"/>
    </enums>
    <enums name="VkBorderColor" type="enum">
        <enum value="0"     name="VK_BORDER_COLOR_FLOAT_TRANSPARENT_BLACK"/>
        <enum value="1"     name="VK_BORDER_COLOR_INT_TRANSPARENT_BLACK"/>
        <enum value="2"     name="VK_BORDER_COLOR_FLOAT_OPAQUE_BLACK"/>
        <enum value="3"     name="VK_BORDER_COLOR_INT_OPAQUE_BLACK"/>
        <enum value="4"     name="VK_BORDER_COLOR_FLOAT_OPAQUE_WHITE"/>
        <enum value="5"     name="VK_BORDER_COLOR_INT_OPAQUE_WHITE"/>
    </enums>
    <enums name="VkPipelineBindPoint" type="enum">
        <enum value="0"     name="VK_PIPELINE_BIND_POINT_GRAPHICS"/>
        <enum value="1"     name="VK_PIPELINE_BIND_POINT_COMPUTE"/>
    </enums>
    <enums name="VkPipelineCacheHeaderVersion" type="enum">
        <enum value="1"     name="VK_PIPELINE_CACHE_HEADER_VERSION_ONE"/>
    </enums>
    <enums name="VkPrimitiveTopology" type="enum">
        <enum value="0"     name="VK_PRIMITIVE_TOPOLOGY_POINT_LIST"/>
        <enum value="1"     name="VK_PRIMITIVE_TOPOLOGY_LINE_LIST"/>
        <enum value="2"     name="VK_PRIMITIVE_TOPOLOGY_LINE_STRIP"/>
        <enum value="3"     name="VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST"/>
        <enum value="4"     name="VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP"/>
        <enum value="5"     name="VK_PRIMITIVE_TOPOLOGY_TRIANGLE_FAN"/>
        <enum value="6"     name="VK_PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY"/>
        <enum value="7"     name="VK_PRIMITIVE_TOPOLOGY_LINE_STRIP_WITH_ADJACENCY"/>
        <enum value="8"     name="VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY"/>
        <enum value="9"     name="VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP_WITH_ADJACENCY"/>
        <enum value="10"    name="VK_PRIMITIVE_TOPOLOGY_PATCH_LIST"/>
    </enums>
    <enums name="VkSharingMode" type="enum">
        <enum value="0"     name="VK_SHARING_MODE_EXCLUSIVE"/>
        <enum value="1"     name="VK_SHARING_MODE_CONCURRENT"/>
    </enums>
    <enums name="VkIndexType" type="enum">
        <enum value="0"     name="VK_INDEX_TYPE_UINT16"/>
        <enum value="1"     name="VK_INDEX_TYPE_UINT32"/>
    </enums>
    <enums name="VkFilter" type="enum">
        <enum value="0"     name="VK_FILTER_NEAREST"/>
        <enum value="1"     name="VK_FILTER_LINEAR"/>
    </enums>
    <enums name="VkSamplerMipmapMode" type="enum">
        <enum value="0"     name="VK_SAMPLER_MIPMAP_MODE_NEAREST"                        comment="Choose nearest mip level"/>
        <enum value="1"     name="VK_SAMPLER_MIPMAP_MODE_LINEAR"                         comment="Linear filter between mip levels"/>
    </enums>
    <enums name="VkSamplerAddressMode" type="enum">
        <enum value="0"     name="VK_SAMPLER_ADDRESS_MODE_REPEAT"/>
        <enum value="1"     name="VK_SAMPLER_ADDRESS_MODE_MIRRORED_REPEAT"/>
        <enum value="2"     name="VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE"/>
        <enum value="3"     name="VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER"/>
            <comment>
                value="4" reserved for VK_KHR_sampler_mirror_clamp_to_edge
                enum VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE; do not
                alias!
            </comment>
    </enums>
    <enums name="VkCompareOp" type="enum">
        <enum value="0"     name="VK_COMPARE_OP_NEVER"/>
        <enum value="1"     name="VK_COMPARE_OP_LESS"/>
        <enum value="2"     name="VK_COMPARE_OP_EQUAL"/>
        <enum value="3"     name="VK_COMPARE_OP_LESS_OR_EQUAL"/>
        <enum value="4"     name="VK_COMPARE_OP_GREATER"/>
        <enum value="5"     name="VK_COMPARE_OP_NOT_EQUAL"/>
        <enum value="6"     name="VK_COMPARE_OP_GREATER_OR_EQUAL"/>
        <enum value="7"     name="VK_COMPARE_OP_ALWAYS"/>
    </enums>
    <enums name="VkPolygonMode" type="enum">
        <enum value="0"     name="VK_POLYGON_MODE_FILL"/>
        <enum value="1"     name="VK_POLYGON_MODE_LINE"/>
        <enum value="2"     name="VK_POLYGON_MODE_POINT"/>
    </enums>
    <enums name="VkCullModeFlagBits" type="bitmask">
        <enum value="0"     name="VK_CULL_MODE_NONE"/>
        <enum bitpos="0"    name="VK_CULL_MODE_FRONT_BIT"/>
        <enum bitpos="1"    name="VK_CULL_MODE_BACK_BIT"/>
        <enum value="0x00000003" name="VK_CULL_MODE_FRONT_AND_BACK"/>
    </enums>
    <enums name="VkFrontFace" type="enum">
        <enum value="0"     name="VK_FRONT_FACE_COUNTER_CLOCKWISE"/>
        <enum value="1"     name="VK_FRONT_FACE_CLOCKWISE"/>
    </enums>
    <enums name="VkBlendFactor" type="enum">
        <enum value="0"     name="VK_BLEND_FACTOR_ZERO"/>
        <enum value="1"     name="VK_BLEND_FACTOR_ONE"/>
        <enum value="2"     name="VK_BLEND_FACTOR_SRC_COLOR"/>
        <enum value="3"     name="VK_BLEND_FACTOR_ONE_MINUS_SRC_COLOR"/>
        <enum value="4"     name="VK_BLEND_FACTOR_DST_COLOR"/>
        <enum value="5"     name="VK_BLEND_FACTOR_ONE_MINUS_DST_COLOR"/>
        <enum value="6"     name="VK_BLEND_FACTOR_SRC_ALPHA"/>
        <enum value="7"     name="VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA"/>
        <enum value="8"     name="VK_BLEND_FACTOR_DST_ALPHA"/>
        <enum value="9"     name="VK_BLEND_FACTOR_ONE_MINUS_DST_ALPHA"/>
        <enum value="10"    name="VK_BLEND_FACTOR_CONSTANT_COLOR"/>
        <enum value="11"    name="VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR"/>
        <enum value="12"    name="VK_BLEND_FACTOR_CONSTANT_ALPHA"/>
        <enum value="13"    name="VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA"/>
        <enum value="14"    name="VK_BLEND_FACTOR_SRC_ALPHA_SATURATE"/>
        <enum value="15"    name="VK_BLEND_FACTOR_SRC1_COLOR"/>
        <enum value="16"    name="VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR"/>
        <enum value="17"    name="VK_BLEND_FACTOR_SRC1_ALPHA"/>
        <enum value="18"    name="VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA"/>
    </enums>
    <enums name="VkBlendOp" type="enum">
        <enum value="0"     name="VK_BLEND_OP_ADD"/>
        <enum value="1"     name="VK_BLEND_OP_SUBTRACT"/>
        <enum value="2"     name="VK_BLEND_OP_REVERSE_SUBTRACT"/>
        <enum value="3"     name="VK_BLEND_OP_MIN"/>
        <enum value="4"     name="VK_BLEND_OP_MAX"/>
    </enums>
    <enums name="VkStencilOp" type="enum">
        <enum value="0"     name="VK_STENCIL_OP_KEEP"/>
        <enum value="1"     name="VK_STENCIL_OP_ZERO"/>
        <enum value="2"     name="VK_STENCIL_OP_REPLACE"/>
        <enum value="3"     name="VK_STENCIL_OP_INCREMENT_AND_CLAMP"/>
        <enum value="4"     name="VK_STENCIL_OP_DECREMENT_AND_CLAMP"/>
        <enum value="5"     name="VK_STENCIL_OP_INVERT"/>
        <enum value="6"     name="VK_STENCIL_OP_INCREMENT_AND_WRAP"/>
        <enum value="7"     name="VK_STENCIL_OP_DECREMENT_AND_WRAP"/>
    </enums>
    <enums name="VkLogicOp" type="enum">
        <enum value="0"     name="VK_LOGIC_OP_CLEAR"/>
        <enum value="1"     name="VK_LOGIC_OP_AND"/>
        <enum value="2"     name="VK_LOGIC_OP_AND_REVERSE"/>
        <enum value="3"     name="VK_LOGIC_OP_COPY"/>
        <enum value="4"     name="VK_LOGIC_OP_AND_INVERTED"/>
        <enum value="5"     name="VK_LOGIC_OP_NO_OP"/>
        <enum value="6"     name="VK_LOGIC_OP_XOR"/>
        <enum value="7"     name="VK_LOGIC_OP_OR"/>
        <enum value="8"     name="VK_LOGIC_OP_NOR"/>
        <enum value="9"     name="VK_LOGIC_OP_EQUIVALENT"/>
        <enum value="10"    name="VK_LOGIC_OP_INVERT"/>
        <enum value="11"    name="VK_LOGIC_OP_OR_REVERSE"/>
        <enum value="12"    name="VK_LOGIC_OP_COPY_INVERTED"/>
        <enum value="13"    name="VK_LOGIC_OP_OR_INVERTED"/>
        <enum value="14"    name="VK_LOGIC_OP_NAND"/>
        <enum value="15"    name="VK_LOGIC_OP_SET"/>
    </enums>
    <enums name="VkInternalAllocationType" type="enum">
        <enum value="0"     name="VK_INTERNAL_ALLOCATION_TYPE_EXECUTABLE"/>
    </enums>
    <enums name="VkSystemAllocationScope" type="enum">
        <enum value="0"     name="VK_SYSTEM_ALLOCATION_SCOPE_COMMAND"/>
        <enum value="1"     name="VK_SYSTEM_ALLOCATION_SCOPE_OBJECT"/>
        <enum value="2"     name="VK_SYSTEM_ALLOCATION_SCOPE_CACHE"/>
        <enum value="3"     name="VK_SYSTEM_ALLOCATION_SCOPE_DEVICE"/>
        <enum value="4"     name="VK_SYSTEM_ALLOCATION_SCOPE_INSTANCE"/>
    </enums>
    <enums name="VkPhysicalDeviceType" type="enum">
        <enum value="0"     name="VK_PHYSICAL_DEVICE_TYPE_OTHER"/>
        <enum value="1"     name="VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU"/>
        <enum value="2"     name="VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU"/>
        <enum value="3"     name="VK_PHYSICAL_DEVICE_TYPE_VIRTUAL_GPU"/>
        <enum value="4"     name="VK_PHYSICAL_DEVICE_TYPE_CPU"/>
    </enums>
    <enums name="VkVertexInputRate" type="enum">
        <enum value="0"     name="VK_VERTEX_INPUT_RATE_VERTEX"/>
        <enum value="1"     name="VK_VERTEX_INPUT_RATE_INSTANCE"/>
    </enums>
    <enums name="VkFormat" type="enum" comment="Vulkan format definitions">
        <enum value="0"     name="VK_FORMAT_UNDEFINED"/>
        <enum value="1"     name="VK_FORMAT_R4G4_UNORM_PACK8"/>
        <enum value="2"     name="VK_FORMAT_R4G4B4A4_UNORM_PACK16"/>
        <enum value="3"     name="VK_FORMAT_B4G4R4A4_UNORM_PACK16"/>
        <enum value="4"     name="VK_FORMAT_R5G6B5_UNORM_PACK16"/>
        <enum value="5"     name="VK_FORMAT_B5G6R5_UNORM_PACK16"/>
        <enum value="6"     name="VK_FORMAT_R5G5B5A1_UNORM_PACK16"/>
        <enum value="7"     name="VK_FORMAT_B5G5R5A1_UNORM_PACK16"/>
        <enum value="8"     name="VK_FORMAT_A1R5G5B5_UNORM_PACK16"/>
        <enum value="9"     name="VK_FORMAT_R8_UNORM"/>
        <enum value="10"    name="VK_FORMAT_R8_SNORM"/>
        <enum value="11"    name="VK_FORMAT_R8_USCALED"/>
        <enum value="12"    name="VK_FORMAT_R8_SSCALED"/>
        <enum value="13"    name="VK_FORMAT_R8_UINT"/>
        <enum value="14"    name="VK_FORMAT_R8_SINT"/>
        <enum value="15"    name="VK_FORMAT_R8_SRGB"/>
        <enum value="16"    name="VK_FORMAT_R8G8_UNORM"/>
        <enum value="17"    name="VK_FORMAT_R8G8_SNORM"/>
        <enum value="18"    name="VK_FORMAT_R8G8_USCALED"/>
        <enum value="19"    name="VK_FORMAT_R8G8_SSCALED"/>
        <enum value="20"    name="VK_FORMAT_R8G8_UINT"/>
        <enum value="21"    name="VK_FORMAT_R8G8_SINT"/>
        <enum value="22"    name="VK_FORMAT_R8G8_SRGB"/>
        <enum value="23"    name="VK_FORMAT_R8G8B8_UNORM"/>
        <enum value="24"    name="VK_FORMAT_R8G8B8_SNORM"/>
        <enum value="25"    name="VK_FORMAT_R8G8B8_USCALED"/>
        <enum value="26"    name="VK_FORMAT_R8G8B8_SSCALED"/>
        <enum value="27"    name="VK_FORMAT_R8G8B8_UINT"/>
        <enum value="28"    name="VK_FORMAT_R8G8B8_SINT"/>
        <enum value="29"    name="VK_FORMAT_R8G8B8_SRGB"/>
        <enum value="30"    name="VK_FORMAT_B8G8R8_UNORM"/>
        <enum value="31"    name="VK_FORMAT_B8G8R8_SNORM"/>
        <enum value="32"    name="VK_FORMAT_B8G8R8_USCALED"/>
        <enum value="33"    name="VK_FORMAT_B8G8R8_SSCALED"/>
        <enum value="34"    name="VK_FORMAT_B8G8R8_UINT"/>
        <enum value="35"    name="VK_FORMAT_B8G8R8_SINT"/>
        <enum value="36"    name="VK_FORMAT_B8G8R8_SRGB"/>
        <enum value="37"    name="VK_FORMAT_R8G8B8A8_UNORM"/>
        <enum value="38"    name="VK_FORMAT_R8G8B8A8_SNORM"/>
        <enum value="39"    name="VK_FORMAT_R8G8B8A8_USCALED"/>
        <enum value="40"    name="VK_FORMAT_R8G8B8A8_SSCALED"/>
        <enum value="41"    name="VK_FORMAT_R8G8B8A8_UINT"/>
        <enum value="42"    name="VK_FORMAT_R8G8B8A8_SINT"/>
        <enum value="43"    name="VK_FORMAT_R8G8B8A8_SRGB"/>
        <enum value="44"    name="VK_FORMAT_B8G8R8A8_UNORM"/>
        <enum value="45"    name="VK_FORMAT_B8G8R8A8_SNORM"/>
        <enum value="46"    name="VK_FORMAT_B8G8R8A8_USCALED"/>
        <enum value="47"    name="VK_FORMAT_B8G8R8A8_SSCALED"/>
        <enum value="48"    name="VK_FORMAT_B8G8R8A8_UINT"/>
        <enum value="49"    name="VK_FORMAT_B8G8R8A8_SINT"/>
        <enum value="50"    name="VK_FORMAT_B8G8R8A8_SRGB"/>
        <enum value="51"    name="VK_FORMAT_A8B8G8R8_UNORM_PACK32"/>
        <enum value="52"    name="VK_FORMAT_A8B8G8R8_SNORM_PACK32"/>
        <enum value="53"    name="VK_FORMAT_A8B8G8R8_USCALED_PACK32"/>
        <enum value="54"    name="VK_FORMAT_A8B8G8R8_SSCALED_PACK32"/>
        <enum value="55"    name="VK_FORMAT_A8B8G8R8_UINT_PACK32"/>
        <enum value="56"    name="VK_FORMAT_A8B8G8R8_SINT_PACK32"/>
        <enum value="57"    name="VK_FORMAT_A8B8G8R8_SRGB_PACK32"/>
        <enum value="58"    name="VK_FORMAT_A2R10G10B10_UNORM_PACK32"/>
        <enum value="59"    name="VK_FORMAT_A2R10G10B10_SNORM_PACK32"/>
        <enum value="60"    name="VK_FORMAT_A2R10G10B10_USCALED_PACK32"/>
        <enum value="61"    name="VK_FORMAT_A2R10G10B10_SSCALED_PACK32"/>
        <enum value="62"    name="VK_FORMAT_A2R10G10B10_UINT_PACK32"/>
        <enum value="63"    name="VK_FORMAT_A2R10G10B10_SINT_PACK32"/>
        <enum value="64"    name="VK_FORMAT_A2B10G10R10_UNORM_PACK32"/>
        <enum value="65"    name="VK_FORMAT_A2B10G10R10_SNORM_PACK32"/>
        <enum value="66"    name="VK_FORMAT_A2B10G10R10_USCALED_PACK32"/>
        <enum value="67"    name="VK_FORMAT_A2B10G10R10_SSCALED_PACK32"/>
        <enum value="68"    name="VK_FORMAT_A2B10G10R10_UINT_PACK32"/>
        <enum value="69"    name="VK_FORMAT_A2B10G10R10_SINT_PACK32"/>
        <enum value="70"    name="VK_FORMAT_R16_UNORM"/>
        <enum value="71"    name="VK_FORMAT_R16_SNORM"/>
        <enum value="72"    name="VK_FORMAT_R16_USCALED"/>
        <enum value="73"    name="VK_FORMAT_R16_SSCALED"/>
        <enum value="74"    name="VK_FORMAT_R16_UINT"/>
        <enum value="75"    name="VK_FORMAT_R16_SINT"/>
        <enum value="76"    name="VK_FORMAT_R16_SFLOAT"/>
        <enum value="77"    name="VK_FORMAT_R16G16_UNORM"/>
        <enum value="78"    name="VK_FORMAT_R16G16_SNORM"/>
        <enum value="79"    name="VK_FORMAT_R16G16_USCALED"/>
        <enum value="80"    name="VK_FORMAT_R16G16_SSCALED"/>
        <enum value="81"    name="VK_FORMAT_R16G16_UINT"/>
        <enum value="82"    name="VK_FORMAT_R16G16_SINT"/>
        <enum value="83"    name="VK_FORMAT_R16G16_SFLOAT"/>
        <enum value="84"    name="VK_FORMAT_R16G16B16_UNORM"/>
        <enum value="85"    name="VK_FORMAT_R16G16B16_SNORM"/>
        <enum value="86"    name="VK_FORMAT_R16G16B16_USCALED"/>
        <enum value="87"    name="VK_FORMAT_R16G16B16_SSCALED"/>
        <enum value="88"    name="VK_FORMAT_R16G16B16_UINT"/>
        <enum value="89"    name="VK_FORMAT_R16G16B16_SINT"/>
        <enum value="90"    name="VK_FORMAT_R16G16B16_SFLOAT"/>
        <enum value="91"    name="VK_FORMAT_R16G16B16A16_UNORM"/>
        <enum value="92"    name="VK_FORMAT_R16G16B16A16_SNORM"/>
        <enum value="93"    name="VK_FORMAT_R16G16B16A16_USCALED"/>
        <enum value="94"    name="VK_FORMAT_R16G16B16A16_SSCALED"/>
        <enum value="95"    name="VK_FORMAT_R16G16B16A16_UINT"/>
        <enum value="96"    name="VK_FORMAT_R16G16B16A16_SINT"/>
        <enum value="97"    name="VK_FORMAT_R16G16B16A16_SFLOAT"/>
        <enum value="98"    name="VK_FORMAT_R32_UINT"/>
        <enum value="99"    name="VK_FORMAT_R32_SINT"/>
        <enum value="100"   name="VK_FORMAT_R32_SFLOAT"/>
        <enum value="101"   name="VK_FORMAT_R32G32_UINT"/>
        <enum value="102"   name="VK_FORMAT_R32G32_SINT"/>
        <enum value="103"   name="VK_FORMAT_R32G32_SFLOAT"/>
        <enum value="104"   name="VK_FORMAT_R32G32B32_UINT"/>
        <enum value="105"   name="VK_FORMAT_R32G32B32_SINT"/>
        <enum value="106"   name="VK_FORMAT_R32G32B32_SFLOAT"/>
        <enum value="107"   name="VK_FORMAT_R32G32B32A32_UINT"/>
        <enum value="108"   name="VK_FORMAT_R32G32B32A32_SINT"/>
        <enum value="109"   name="VK_FORMAT_R32G32B32A32_SFLOAT"/>
        <enum value="110"   name="VK_FORMAT_R64_UINT"/>
        <enum value="111"   name="VK_FORMAT_R64_SINT"/>
        <enum value="112"   name="VK_FORMAT_R64_SFLOAT"/>
        <enum value="113"   name="VK_FORMAT_R64G64_UINT"/>
        <enum value="114"   name="VK_FORMAT_R64G64_SINT"/>
        <enum value="115"   name="VK_FORMAT_R64G64_SFLOAT"/>
        <enum value="116"   name="VK_FORMAT_R64G64B64_UINT"/>
        <enum value="117"   name="VK_FORMAT_R64G64B64_SINT"/>
        <enum value="118"   name="VK_FORMAT_R64G64B64_SFLOAT"/>
        <enum value="119"   name="VK_FORMAT_R64G64B64A64_UINT"/>
        <enum value="120"   name="VK_FORMAT_R64G64B64A64_SINT"/>
        <enum value="121"   name="VK_FORMAT_R64G64B64A64_SFLOAT"/>
        <enum value="122"   name="VK_FORMAT_B10G11R11_UFLOAT_PACK32"/>
        <enum value="123"   name="VK_FORMAT_E5B9G9R9_UFLOAT_PACK32"/>
        <enum value="124"   name="VK_FORMAT_D16_UNORM"/>
        <enum value="125"   name="VK_FORMAT_X8_D24_UNORM_PACK32"/>
        <enum value="126"   name="VK_FORMAT_D32_SFLOAT"/>
        <enum value="127"   name="VK_FORMAT_S8_UINT"/>
        <enum value="128"   name="VK_FORMAT_D16_UNORM_S8_UINT"/>
        <enum value="129"   name="VK_FORMAT_D24_UNORM_S8_UINT"/>
        <enum value="130"   name="VK_FORMAT_D32_SFLOAT_S8_UINT"/>
        <enum value="131"   name="VK_FORMAT_BC1_RGB_UNORM_BLOCK"/>
        <enum value="132"   name="VK_FORMAT_BC1_RGB_SRGB_BLOCK"/>
        <enum value="133"   name="VK_FORMAT_BC1_RGBA_UNORM_BLOCK"/>
        <enum value="134"   name="VK_FORMAT_BC1_RGBA_SRGB_BLOCK"/>
        <enum value="135"   name="VK_FORMAT_BC2_UNORM_BLOCK"/>
        <enum value="136"   name="VK_FORMAT_BC2_SRGB_BLOCK"/>
        <enum value="137"   name="VK_FORMAT_BC3_UNORM_BLOCK"/>
        <enum value="138"   name="VK_FORMAT_BC3_SRGB_BLOCK"/>
        <enum value="139"   name="VK_FORMAT_BC4_UNORM_BLOCK"/>
        <enum value="140"   name="VK_FORMAT_BC4_SNORM_BLOCK"/>
        <enum value="141"   name="VK_FORMAT_BC5_UNORM_BLOCK"/>
        <enum value="142"   name="VK_FORMAT_BC5_SNORM_BLOCK"/>
        <enum value="143"   name="VK_FORMAT_BC6H_UFLOAT_BLOCK"/>
        <enum value="144"   name="VK_FORMAT_BC6H_SFLOAT_BLOCK"/>
        <enum value="145"   name="VK_FORMAT_BC7_UNORM_BLOCK"/>
        <enum value="146"   name="VK_FORMAT_BC7_SRGB_BLOCK"/>
        <enum value="147"   name="VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK"/>
        <enum value="148"   name="VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK"/>
        <enum value="149"   name="VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK"/>
        <enum value="150"   name="VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK"/>
        <enum value="151"   name="VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK"/>
        <enum value="152"   name="VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK"/>
        <enum value="153"   name="VK_FORMAT_EAC_R11_UNORM_BLOCK"/>
        <enum value="154"   name="VK_FORMAT_EAC_R11_SNORM_BLOCK"/>
        <enum value="155"   name="VK_FORMAT_EAC_R11G11_UNORM_BLOCK"/>
        <enum value="156"   name="VK_FORMAT_EAC_R11G11_SNORM_BLOCK"/>
        <enum value="157"   name="VK_FORMAT_ASTC_4x4_UNORM_BLOCK"/>
        <enum value="158"   name="VK_FORMAT_ASTC_4x4_SRGB_BLOCK"/>
        <enum value="159"   name="VK_FORMAT_ASTC_5x4_UNORM_BLOCK"/>
        <enum value="160"   name="VK_FORMAT_ASTC_5x4_SRGB_BLOCK"/>
        <enum value="161"   name="VK_FORMAT_ASTC_5x5_UNORM_BLOCK"/>
        <enum value="162"   name="VK_FORMAT_ASTC_5x5_SRGB_BLOCK"/>
        <enum value="163"   name="VK_FORMAT_ASTC_6x5_UNORM_BLOCK"/>
        <enum value="164"   name="VK_FORMAT_ASTC_6x5_SRGB_BLOCK"/>
        <enum value="165"   name="VK_FORMAT_ASTC_6x6_UNORM_BLOCK"/>
        <enum value="166"   name="VK_FORMAT_ASTC_6x6_SRGB_BLOCK"/>
        <enum value="167"   name="VK_FORMAT_ASTC_8x5_UNORM_BLOCK"/>
        <enum value="168"   name="VK_FORMAT_ASTC_8x5_SRGB_BLOCK"/>
        <enum value="169"   name="VK_FORMAT_ASTC_8x6_UNORM_BLOCK"/>
        <enum value="170"   name="VK_FORMAT_ASTC_8x6_SRGB_BLOCK"/>
        <enum value="171"   name="VK_FORMAT_ASTC_8x8_UNORM_BLOCK"/>
        <enum value="172"   name="VK_FORMAT_ASTC_8x8_SRGB_BLOCK"/>
        <enum value="173"   name="VK_FORMAT_ASTC_10x5_UNORM_BLOCK"/>
        <enum value="174"   name="VK_FORMAT_ASTC_10x5_SRGB_BLOCK"/>
        <enum value="175"   name="VK_FORMAT_ASTC_10x6_UNORM_BLOCK"/>
        <enum value="176"   name="VK_FORMAT_ASTC_10x6_SRGB_BLOCK"/>
        <enum value="177"   name="VK_FORMAT_ASTC_10x8_UNORM_BLOCK"/>
        <enum value="178"   name="VK_FORMAT_ASTC_10x8_SRGB_BLOCK"/>
        <enum value="179"   name="VK_FORMAT_ASTC_10x10_UNORM_BLOCK"/>
        <enum value="180"   name="VK_FORMAT_ASTC_10x10_SRGB_BLOCK"/>
        <enum value="181"   name="VK_FORMAT_ASTC_12x10_UNORM_BLOCK"/>
        <enum value="182"   name="VK_FORMAT_ASTC_12x10_SRGB_BLOCK"/>
        <enum value="183"   name="VK_FORMAT_ASTC_12x12_UNORM_BLOCK"/>
        <enum value="184"   name="VK_FORMAT_ASTC_12x12_SRGB_BLOCK"/>
    </enums>
    <enums name="VkStructureType" type="enum" comment="Structure type enumerant">
        <enum value="0"     name="VK_STRUCTURE_TYPE_APPLICATION_INFO"/>
        <enum value="1"     name="VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO"/>
        <enum value="2"     name="VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO"/>
        <enum value="3"     name="VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO"/>
        <enum value="4"     name="VK_STRUCTURE_TYPE_SUBMIT_INFO"/>
        <enum value="5"     name="VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO"/>
        <enum value="6"     name="VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE"/>
        <enum value="7"     name="VK_STRUCTURE_TYPE_BIND_SPARSE_INFO"/>
        <enum value="8"     name="VK_STRUCTURE_TYPE_FENCE_CREATE_INFO"/>
        <enum value="9"     name="VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO"/>
        <enum value="10"    name="VK_STRUCTURE_TYPE_EVENT_CREATE_INFO"/>
        <enum value="11"    name="VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO"/>
        <enum value="12"    name="VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO"/>
        <enum value="13"    name="VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO"/>
        <enum value="14"    name="VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO"/>
        <enum value="15"    name="VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO"/>
        <enum value="16"    name="VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO"/>
        <enum value="17"    name="VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO"/>
        <enum value="18"    name="VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO"/>
        <enum value="19"    name="VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO"/>
        <enum value="20"    name="VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO"/>
        <enum value="21"    name="VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO"/>
        <enum value="22"    name="VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO"/>
        <enum value="23"    name="VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO"/>
        <enum value="24"    name="VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO"/>
        <enum value="25"    name="VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO"/>
        <enum value="26"    name="VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO"/>
        <enum value="27"    name="VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO"/>
        <enum value="28"    name="VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO"/>
        <enum value="29"    name="VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO"/>
        <enum value="30"    name="VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO"/>
        <enum value="31"    name="VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO"/>
        <enum value="32"    name="VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO"/>
        <enum value="33"    name="VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO"/>
        <enum value="34"    name="VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO"/>
        <enum value="35"    name="VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET"/>
        <enum value="36"    name="VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET"/>
        <enum value="37"    name="VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO"/>
        <enum value="38"    name="VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO"/>
        <enum value="39"    name="VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO"/>
        <enum value="40"    name="VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO"/>
        <enum value="41"    name="VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO"/>
        <enum value="42"    name="VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO"/>
        <enum value="43"    name="VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO"/>
        <enum value="44"    name="VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER"/>
        <enum value="45"    name="VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER"/>
        <enum value="46"    name="VK_STRUCTURE_TYPE_MEMORY_BARRIER"/>
        <enum value="47"    name="VK_STRUCTURE_TYPE_LOADER_INSTANCE_CREATE_INFO" comment="Reserved for internal use by the loader, layers, and ICDs"/>
        <enum value="48"    name="VK_STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO" comment="Reserved for internal use by the loader, layers, and ICDs"/>
    </enums>
    <enums name="VkSubpassContents" type="enum">
        <enum value="0"     name="VK_SUBPASS_CONTENTS_INLINE"/>
        <enum value="1"     name="VK_SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS"/>
    </enums>
    <enums name="VkResult" type="enum" comment="API result codes">
            <comment>Return codes (positive values)</comment>
        <enum value="0"     name="VK_SUCCESS" comment="Command completed successfully"/>
        <enum value="1"     name="VK_NOT_READY" comment="A fence or query has not yet completed"/>
        <enum value="2"     name="VK_TIMEOUT" comment="A wait operation has not completed in the specified time"/>
        <enum value="3"     name="VK_EVENT_SET" comment="An event is signaled"/>
        <enum value="4"     name="VK_EVENT_RESET" comment="An event is unsignaled"/>
        <enum value="5"     name="VK_INCOMPLETE" comment="A return array was too small for the result"/>
            <comment>Error codes (negative values)</comment>
        <enum value="-1"    name="VK_ERROR_OUT_OF_HOST_MEMORY" comment="A host memory allocation has failed"/>
        <enum value="-2"    name="VK_ERROR_OUT_OF_DEVICE_MEMORY" comment="A device memory allocation has failed"/>
        <enum value="-3"    name="VK_ERROR_INITIALIZATION_FAILED" comment="Initialization of a object has failed"/>
        <enum value="-4"    name="VK_ERROR_DEVICE_LOST" comment="The logical device has been lost. See &lt;&lt;devsandqueues-lost-device&gt;&gt;"/>
        <enum value="-5"    name="VK_ERROR_MEMORY_MAP_FAILED" comment="Mapping of a memory object has failed"/>
        <enum value="-6"    name="VK_ERROR_LAYER_NOT_PRESENT" comment="Layer specified does not exist"/>
        <enum value="-7"    name="VK_ERROR_EXTENSION_NOT_PRESENT" comment="Extension specified does not exist"/>
        <enum value="-8"    name="VK_ERROR_FEATURE_NOT_PRESENT" comment="Requested feature is not available on this device"/>
        <enum value="-9"    name="VK_ERROR_INCOMPATIBLE_DRIVER" comment="Unable to find a Vulkan driver"/>
        <enum value="-10"   name="VK_ERROR_TOO_MANY_OBJECTS" comment="Too many objects of the type have already been created"/>
        <enum value="-11"   name="VK_ERROR_FORMAT_NOT_SUPPORTED" comment="Requested format is not supported on this device"/>
        <enum value="-12"   name="VK_ERROR_FRAGMENTED_POOL" comment="A requested pool allocation has failed due to fragmentation of the pool's memory"/>
            <unused start="-13" comment="This is the next unused available error code (negative value)"/>
    </enums>
    <enums name="VkDynamicState" type="enum">
        <enum value="0"     name="VK_DYNAMIC_STATE_VIEWPORT"/>
        <enum value="1"     name="VK_DYNAMIC_STATE_SCISSOR"/>
        <enum value="2"     name="VK_DYNAMIC_STATE_LINE_WIDTH"/>
        <enum value="3"     name="VK_DYNAMIC_STATE_DEPTH_BIAS"/>
        <enum value="4"     name="VK_DYNAMIC_STATE_BLEND_CONSTANTS"/>
        <enum value="5"     name="VK_DYNAMIC_STATE_DEPTH_BOUNDS"/>
        <enum value="6"     name="VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK"/>
        <enum value="7"     name="VK_DYNAMIC_STATE_STENCIL_WRITE_MASK"/>
        <enum value="8"     name="VK_DYNAMIC_STATE_STENCIL_REFERENCE"/>
    </enums>
    <enums name="VkDescriptorUpdateTemplateType" type="enum">
        <enum value="0"     name="VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET"   comment="Create descriptor update template for descriptor set updates"/>
    </enums>
    <enums name="VkObjectType" type="enum" comment="Enums to track objects of various types">
        <enum value="0"     name="VK_OBJECT_TYPE_UNKNOWN"/>
        <enum value="1"     name="VK_OBJECT_TYPE_INSTANCE"                           comment="VkInstance"/>
        <enum value="2"     name="VK_OBJECT_TYPE_PHYSICAL_DEVICE"                    comment="VkPhysicalDevice"/>
        <enum value="3"     name="VK_OBJECT_TYPE_DEVICE"                             comment="VkDevice"/>
        <enum value="4"     name="VK_OBJECT_TYPE_QUEUE"                              comment="VkQueue"/>
        <enum value="5"     name="VK_OBJECT_TYPE_SEMAPHORE"                          comment="VkSemaphore"/>
        <enum value="6"     name="VK_OBJECT_TYPE_COMMAND_BUFFER"                     comment="VkCommandBuffer"/>
        <enum value="7"     name="VK_OBJECT_TYPE_FENCE"                              comment="VkFence"/>
        <enum value="8"     name="VK_OBJECT_TYPE_DEVICE_MEMORY"                      comment="VkDeviceMemory"/>
        <enum value="9"     name="VK_OBJECT_TYPE_BUFFER"                             comment="VkBuffer"/>
        <enum value="10"    name="VK_OBJECT_TYPE_IMAGE"                              comment="VkImage"/>
        <enum value="11"    name="VK_OBJECT_TYPE_EVENT"                              comment="VkEvent"/>
        <enum value="12"    name="VK_OBJECT_TYPE_QUERY_POOL"                         comment="VkQueryPool"/>
        <enum value="13"    name="VK_OBJECT_TYPE_BUFFER_VIEW"                        comment="VkBufferView"/>
        <enum value="14"    name="VK_OBJECT_TYPE_IMAGE_VIEW"                         comment="VkImageView"/>
        <enum value="15"    name="VK_OBJECT_TYPE_SHADER_MODULE"                      comment="VkShaderModule"/>
        <enum value="16"    name="VK_OBJECT_TYPE_PIPELINE_CACHE"                     comment="VkPipelineCache"/>
        <enum value="17"    name="VK_OBJECT_TYPE_PIPELINE_LAYOUT"                    comment="VkPipelineLayout"/>
        <enum value="18"    name="VK_OBJECT_TYPE_RENDER_PASS"                        comment="VkRenderPass"/>
        <enum value="19"    name="VK_OBJECT_TYPE_PIPELINE"                           comment="VkPipeline"/>
        <enum value="20"    name="VK_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT"              comment="VkDescriptorSetLayout"/>
        <enum value="21"    name="VK_OBJECT_TYPE_SAMPLER"                            comment="VkSampler"/>
        <enum value="22"    name="VK_OBJECT_TYPE_DESCRIPTOR_POOL"                    comment="VkDescriptorPool"/>
        <enum value="23"    name="VK_OBJECT_TYPE_DESCRIPTOR_SET"                     comment="VkDescriptorSet"/>
        <enum value="24"    name="VK_OBJECT_TYPE_FRAMEBUFFER"                        comment="VkFramebuffer"/>
        <enum value="25"    name="VK_OBJECT_TYPE_COMMAND_POOL"                       comment="VkCommandPool"/>
    </enums>

        <comment>Flags</comment>
    <enums name="VkQueueFlagBits" type="bitmask">
        <enum bitpos="0"    name="VK_QUEUE_GRAPHICS_BIT"                             comment="Queue supports graphics operations"/>
        <enum bitpos="1"    name="VK_QUEUE_COMPUTE_BIT"                              comment="Queue supports compute operations"/>
        <enum bitpos="2"    name="VK_QUEUE_TRANSFER_BIT"                             comment="Queue supports transfer operations"/>
        <enum bitpos="3"    name="VK_QUEUE_SPARSE_BINDING_BIT"                       comment="Queue supports sparse resource memory management operations"/>
    </enums>
    <enums name="VkRenderPassCreateFlagBits" type="bitmask"></enums>
    <enums name="VkDeviceQueueCreateFlagBits" type="bitmask"></enums>
    <enums name="VkMemoryPropertyFlagBits" type="bitmask">
        <enum bitpos="0"    name="VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT"               comment="If otherwise stated, then allocate memory on device"/>
        <enum bitpos="1"    name="VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT"               comment="Memory is mappable by host"/>
        <enum bitpos="2"    name="VK_MEMORY_PROPERTY_HOST_COHERENT_BIT"              comment="Memory will have i/o coherency. If not set, application may need to use vkFlushMappedMemoryRanges and vkInvalidateMappedMemoryRanges to flush/invalidate host cache"/>
        <enum bitpos="3"    name="VK_MEMORY_PROPERTY_HOST_CACHED_BIT"                comment="Memory will be cached by the host"/>
        <enum bitpos="4"    name="VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT"           comment="Memory may be allocated by the driver when it is required"/>
    </enums>
    <enums name="VkMemoryHeapFlagBits" type="bitmask">
        <enum bitpos="0"    name="VK_MEMORY_HEAP_DEVICE_LOCAL_BIT"                   comment="If set, heap represents device memory"/>
    </enums>
    <enums name="VkAccessFlagBits" type="bitmask">
        <enum bitpos="0"    name="VK_ACCESS_INDIRECT_COMMAND_READ_BIT"               comment="Controls coherency of indirect command reads"/>
        <enum bitpos="1"    name="VK_ACCESS_INDEX_READ_BIT"                          comment="Controls coherency of index reads"/>
        <enum bitpos="2"    name="VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT"               comment="Controls coherency of vertex attribute reads"/>
        <enum bitpos="3"    name="VK_ACCESS_UNIFORM_READ_BIT"                        comment="Controls coherency of uniform buffer reads"/>
        <enum bitpos="4"    name="VK_ACCESS_INPUT_ATTACHMENT_READ_BIT"               comment="Controls coherency of input attachment reads"/>
        <enum bitpos="5"    name="VK_ACCESS_SHADER_READ_BIT"                         comment="Controls coherency of shader reads"/>
        <enum bitpos="6"    name="VK_ACCESS_SHADER_WRITE_BIT"                        comment="Controls coherency of shader writes"/>
        <enum bitpos="7"    name="VK_ACCESS_COLOR_ATTACHMENT_READ_BIT"               comment="Controls coherency of color attachment reads"/>
        <enum bitpos="8"    name="VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT"              comment="Controls coherency of color attachment writes"/>
        <enum bitpos="9"    name="VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT"       comment="Controls coherency of depth/stencil attachment reads"/>
        <enum bitpos="10"   name="VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT"      comment="Controls coherency of depth/stencil attachment writes"/>
        <enum bitpos="11"   name="VK_ACCESS_TRANSFER_READ_BIT"                       comment="Controls coherency of transfer reads"/>
        <enum bitpos="12"   name="VK_ACCESS_TRANSFER_WRITE_BIT"                      comment="Controls coherency of transfer writes"/>
        <enum bitpos="13"   name="VK_ACCESS_HOST_READ_BIT"                           comment="Controls coherency of host reads"/>
        <enum bitpos="14"   name="VK_ACCESS_HOST_WRITE_BIT"                          comment="Controls coherency of host writes"/>
        <enum bitpos="15"   name="VK_ACCESS_MEMORY_READ_BIT"                         comment="Controls coherency of memory reads"/>
        <enum bitpos="16"   name="VK_ACCESS_MEMORY_WRITE_BIT"                        comment="Controls coherency of memory writes"/>
    </enums>
    <enums name="VkBufferUsageFlagBits" type="bitmask">
        <enum bitpos="0"    name="VK_BUFFER_USAGE_TRANSFER_SRC_BIT"                  comment="Can be used as a source of transfer operations"/>
        <enum bitpos="1"    name="VK_BUFFER_USAGE_TRANSFER_DST_BIT"                  comment="Can be used as a destination of transfer operations"/>
        <enum bitpos="2"    name="VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT"          comment="Can be used as TBO"/>
        <enum bitpos="3"    name="VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT"          comment="Can be used as IBO"/>
        <enum bitpos="4"    name="VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT"                comment="Can be used as UBO"/>
        <enum bitpos="5"    name="VK_BUFFER_USAGE_STORAGE_BUFFER_BIT"                comment="Can be used as SSBO"/>
        <enum bitpos="6"    name="VK_BUFFER_USAGE_INDEX_BUFFER_BIT"                  comment="Can be used as source of fixed-function index fetch (index buffer)"/>
        <enum bitpos="7"    name="VK_BUFFER_USAGE_VERTEX_BUFFER_BIT"                 comment="Can be used as source of fixed-function vertex fetch (VBO)"/>
        <enum bitpos="8"    name="VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT"               comment="Can be the source of indirect parameters (e.g. indirect buffer, parameter buffer)"/>
    </enums>
    <enums name="VkBufferCreateFlagBits" type="bitmask">
        <enum bitpos="0"    name="VK_BUFFER_CREATE_SPARSE_BINDING_BIT"               comment="Buffer should support sparse backing"/>
        <enum bitpos="1"    name="VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT"             comment="Buffer should support sparse backing with partial residency"/>
        <enum bitpos="2"    name="VK_BUFFER_CREATE_SPARSE_ALIASED_BIT"               comment="Buffer should support constent data access to physical memory ranges mapped into multiple locations of sparse buffers"/>
    </enums>
    <enums name="VkShaderStageFlagBits" type="bitmask">
        <enum bitpos="0"    name="VK_SHADER_STAGE_VERTEX_BIT"/>
        <enum bitpos="1"    name="VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT"/>
        <enum bitpos="2"    name="VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT"/>
        <enum bitpos="3"    name="VK_SHADER_STAGE_GEOMETRY_BIT"/>
        <enum bitpos="4"    name="VK_SHADER_STAGE_FRAGMENT_BIT"/>
        <enum bitpos="5"    name="VK_SHADER_STAGE_COMPUTE_BIT"/>
        <enum value="0x0000001F" name="VK_SHADER_STAGE_ALL_GRAPHICS"/>
        <enum value="0x7FFFFFFF" name="VK_SHADER_STAGE_ALL"/>
    </enums>
    <enums name="VkImageUsageFlagBits" type="bitmask">
        <enum bitpos="0"    name="VK_IMAGE_USAGE_TRANSFER_SRC_BIT"                   comment="Can be used as a source of transfer operations"/>
        <enum bitpos="1"    name="VK_IMAGE_USAGE_TRANSFER_DST_BIT"                   comment="Can be used as a destination of transfer operations"/>
        <enum bitpos="2"    name="VK_IMAGE_USAGE_SAMPLED_BIT"                        comment="Can be sampled from (SAMPLED_IMAGE and COMBINED_IMAGE_SAMPLER descriptor types)"/>
        <enum bitpos="3"    name="VK_IMAGE_USAGE_STORAGE_BIT"                        comment="Can be used as storage image (STORAGE_IMAGE descriptor type)"/>
        <enum bitpos="4"    name="VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT"               comment="Can be used as framebuffer color attachment"/>
        <enum bitpos="5"    name="VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT"       comment="Can be used as framebuffer depth/stencil attachment"/>
        <enum bitpos="6"    name="VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT"           comment="Image data not needed outside of rendering"/>
        <enum bitpos="7"    name="VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT"               comment="Can be used as framebuffer input attachment"/>
    </enums>
    <enums name="VkImageCreateFlagBits" type="bitmask">
        <enum bitpos="0"    name="VK_IMAGE_CREATE_SPARSE_BINDING_BIT"                comment="Image should support sparse backing"/>
        <enum bitpos="1"    name="VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT"              comment="Image should support sparse backing with partial residency"/>
        <enum bitpos="2"    name="VK_IMAGE_CREATE_SPARSE_ALIASED_BIT"                comment="Image should support constent data access to physical memory ranges mapped into multiple locations of sparse images"/>
        <enum bitpos="3"    name="VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT"                comment="Allows image views to have different format than the base image"/>
        <enum bitpos="4"    name="VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT"               comment="Allows creating image views with cube type from the created image"/>
    </enums>
    <enums name="VkImageViewCreateFlagBits" type="bitmask">
    </enums>
    <enums name="VkSamplerCreateFlagBits" type="bitmask">
    </enums>
    <enums name="VkPipelineCreateFlagBits" type="bitmask">
        <enum bitpos="0"    name="VK_PIPELINE_CREATE_DISABLE_OPTIMIZATION_BIT"/>
        <enum bitpos="1"    name="VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT"/>
        <enum bitpos="2"    name="VK_PIPELINE_CREATE_DERIVATIVE_BIT"/>
    </enums>
    <enums name="VkColorComponentFlagBits" type="bitmask">
        <enum bitpos="0"    name="VK_COLOR_COMPONENT_R_BIT"/>
        <enum bitpos="1"    name="VK_COLOR_COMPONENT_G_BIT"/>
        <enum bitpos="2"    name="VK_COLOR_COMPONENT_B_BIT"/>
        <enum bitpos="3"    name="VK_COLOR_COMPONENT_A_BIT"/>
    </enums>
    <enums name="VkFenceCreateFlagBits" type="bitmask">
        <enum bitpos="0"    name="VK_FENCE_CREATE_SIGNALED_BIT"/>
    </enums>
    <enums name="VkFormatFeatureFlagBits" type="bitmask">
        <enum bitpos="0"    name="VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT"               comment="Format can be used for sampled images (SAMPLED_IMAGE and COMBINED_IMAGE_SAMPLER descriptor types)"/>
        <enum bitpos="1"    name="VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT"               comment="Format can be used for storage images (STORAGE_IMAGE descriptor type)"/>
        <enum bitpos="2"    name="VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT"        comment="Format supports atomic operations in case it is used for storage images"/>
        <enum bitpos="3"    name="VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT"        comment="Format can be used for uniform texel buffers (TBOs)"/>
        <enum bitpos="4"    name="VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT"        comment="Format can be used for storage texel buffers (IBOs)"/>
        <enum bitpos="5"    name="VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT" comment="Format supports atomic operations in case it is used for storage texel buffers"/>
        <enum bitpos="6"    name="VK_FORMAT_FEATURE_VERTEX_BUFFER_BIT"               comment="Format can be used for vertex buffers (VBOs)"/>
        <enum bitpos="7"    name="VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT"            comment="Format can be used for color attachment images"/>
        <enum bitpos="8"    name="VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT"      comment="Format supports blending in case it is used for color attachment images"/>
        <enum bitpos="9"    name="VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT"    comment="Format can be used for depth/stencil attachment images"/>
        <enum bitpos="10"   name="VK_FORMAT_FEATURE_BLIT_SRC_BIT"                    comment="Format can be used as the source image of blits with vkCmdBlitImage"/>
        <enum bitpos="11"   name="VK_FORMAT_FEATURE_BLIT_DST_BIT"                    comment="Format can be used as the destination image of blits with vkCmdBlitImage"/>
        <enum bitpos="12"   name="VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT" comment="Format can be filtered with VK_FILTER_LINEAR when being sampled"/>
    </enums>
    <enums name="VkQueryControlFlagBits" type="bitmask">
        <enum bitpos="0"    name="VK_QUERY_CONTROL_PRECISE_BIT"                      comment="Require precise results to be collected by the query"/>
    </enums>
    <enums name="VkQueryResultFlagBits" type="bitmask">
        <enum bitpos="0"    name="VK_QUERY_RESULT_64_BIT"                            comment="Results of the queries are written to the destination buffer as 64-bit values"/>
        <enum bitpos="1"    name="VK_QUERY_RESULT_WAIT_BIT"                          comment="Results of the queries are waited on before proceeding with the result copy"/>
        <enum bitpos="2"    name="VK_QUERY_RESULT_WITH_AVAILABILITY_BIT"             comment="Besides the results of the query, the availability of the results is also written"/>
        <enum bitpos="3"    name="VK_QUERY_RESULT_PARTIAL_BIT"                       comment="Copy the partial results of the query even if the final results are not available"/>
    </enums>
    <enums name="VkCommandBufferUsageFlagBits" type="bitmask">
        <enum bitpos="0"    name="VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT"/>
        <enum bitpos="1"    name="VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT"/>
        <enum bitpos="2"    name="VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT"      comment="Command buffer may be submitted/executed more than once simultaneously"/>
    </enums>
    <enums name="VkQueryPipelineStatisticFlagBits" type="bitmask">
        <enum bitpos="0"    name="VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_VERTICES_BIT"                    comment="Optional"/>
        <enum bitpos="1"    name="VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_PRIMITIVES_BIT"                  comment="Optional"/>
        <enum bitpos="2"    name="VK_QUERY_PIPELINE_STATISTIC_VERTEX_SHADER_INVOCATIONS_BIT"                  comment="Optional"/>
        <enum bitpos="3"    name="VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_INVOCATIONS_BIT"                comment="Optional"/>
        <enum bitpos="4"    name="VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_PRIMITIVES_BIT"                 comment="Optional"/>
        <enum bitpos="5"    name="VK_QUERY_PIPELINE_STATISTIC_CLIPPING_INVOCATIONS_BIT"                       comment="Optional"/>
        <enum bitpos="6"    name="VK_QUERY_PIPELINE_STATISTIC_CLIPPING_PRIMITIVES_BIT"                        comment="Optional"/>
        <enum bitpos="7"    name="VK_QUERY_PIPELINE_STATISTIC_FRAGMENT_SHADER_INVOCATIONS_BIT"                comment="Optional"/>
        <enum bitpos="8"    name="VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_CONTROL_SHADER_PATCHES_BIT"        comment="Optional"/>
        <enum bitpos="9"    name="VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_EVALUATION_SHADER_INVOCATIONS_BIT" comment="Optional"/>
        <enum bitpos="10"   name="VK_QUERY_PIPELINE_STATISTIC_COMPUTE_SHADER_INVOCATIONS_BIT"                 comment="Optional"/>
    </enums>
    <enums name="VkImageAspectFlagBits" type="bitmask">
        <enum bitpos="0"    name="VK_IMAGE_ASPECT_COLOR_BIT"/>
        <enum bitpos="1"    name="VK_IMAGE_ASPECT_DEPTH_BIT"/>
        <enum bitpos="2"    name="VK_IMAGE_ASPECT_STENCIL_BIT"/>
        <enum bitpos="3"    name="VK_IMAGE_ASPECT_METADATA_BIT"/>
    </enums>
    <enums name="VkSparseImageFormatFlagBits" type="bitmask">
        <enum bitpos="0"    name="VK_SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT"         comment="Image uses a single mip tail region for all array layers"/>
        <enum bitpos="1"    name="VK_SPARSE_IMAGE_FORMAT_ALIGNED_MIP_SIZE_BIT"       comment="Image requires mip level dimensions to be an integer multiple of the sparse image block dimensions for non-tail mip levels."/>
        <enum bitpos="2"    name="VK_SPARSE_IMAGE_FORMAT_NONSTANDARD_BLOCK_SIZE_BIT" comment="Image uses a non-standard sparse image block dimensions"/>
    </enums>
    <enums name="VkSparseMemoryBindFlagBits" type="bitmask">
        <enum bitpos="0"    name="VK_SPARSE_MEMORY_BIND_METADATA_BIT"                comment="Operation binds resource metadata to memory"/>
    </enums>
    <enums name="VkPipelineStageFlagBits" type="bitmask">
        <enum bitpos="0"    name="VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT"                 comment="Before subsequent commands are processed"/>
        <enum bitpos="1"    name="VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT"               comment="Draw/DispatchIndirect command fetch"/>
        <enum bitpos="2"    name="VK_PIPELINE_STAGE_VERTEX_INPUT_BIT"                comment="Vertex/index fetch"/>
        <enum bitpos="3"    name="VK_PIPELINE_STAGE_VERTEX_SHADER_BIT"               comment="Vertex shading"/>
        <enum bitpos="4"    name="VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT" comment="Tessellation control shading"/>
        <enum bitpos="5"    name="VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT" comment="Tessellation evaluation shading"/>
        <enum bitpos="6"    name="VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT"             comment="Geometry shading"/>
        <enum bitpos="7"    name="VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT"             comment="Fragment shading"/>
        <enum bitpos="8"    name="VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT"        comment="Early fragment (depth and stencil) tests"/>
        <enum bitpos="9"    name="VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT"         comment="Late fragment (depth and stencil) tests"/>
        <enum bitpos="10"   name="VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT"     comment="Color attachment writes"/>
        <enum bitpos="11"   name="VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT"              comment="Compute shading"/>
        <enum bitpos="12"   name="VK_PIPELINE_STAGE_TRANSFER_BIT"                    comment="Transfer/copy operations"/>
        <enum bitpos="13"   name="VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT"              comment="After previous commands have completed"/>
        <enum bitpos="14"   name="VK_PIPELINE_STAGE_HOST_BIT"                        comment="Indicates host (CPU) is a source/sink of the dependency"/>
        <enum bitpos="15"   name="VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT"                comment="All stages of the graphics pipeline"/>
        <enum bitpos="16"   name="VK_PIPELINE_STAGE_ALL_COMMANDS_BIT"                comment="All stages supported on the queue"/>
    </enums>
    <enums name="VkCommandPoolCreateFlagBits" type="bitmask">
        <enum bitpos="0"    name="VK_COMMAND_POOL_CREATE_TRANSIENT_BIT"              comment="Command buffers have a short lifetime"/>
        <enum bitpos="1"    name="VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT"   comment="Command buffers may release their memory individually"/>
    </enums>
    <enums name="VkCommandPoolResetFlagBits" type="bitmask">
        <enum bitpos="0"    name="VK_COMMAND_POOL_RESET_RELEASE_RESOURCES_BIT"       comment="Release resources owned by the pool"/>
    </enums>
    <enums name="VkCommandBufferResetFlagBits" type="bitmask">
        <enum bitpos="0"    name="VK_COMMAND_BUFFER_RESET_RELEASE_RESOURCES_BIT"     comment="Release resources owned by the buffer"/>
    </enums>
    <enums name="VkSampleCountFlagBits" type="bitmask">
        <enum bitpos="0"    name="VK_SAMPLE_COUNT_1_BIT"                             comment="Sample count 1 supported"/>
        <enum bitpos="1"    name="VK_SAMPLE_COUNT_2_BIT"                             comment="Sample count 2 supported"/>
        <enum bitpos="2"    name="VK_SAMPLE_COUNT_4_BIT"                             comment="Sample count 4 supported"/>
        <enum bitpos="3"    name="VK_SAMPLE_COUNT_8_BIT"                             comment="Sample count 8 supported"/>
        <enum bitpos="4"    name="VK_SAMPLE_COUNT_16_BIT"                            comment="Sample count 16 supported"/>
        <enum bitpos="5"    name="VK_SAMPLE_COUNT_32_BIT"                            comment="Sample count 32 supported"/>
        <enum bitpos="6"    name="VK_SAMPLE_COUNT_64_BIT"                            comment="Sample count 64 supported"/>
    </enums>
    <enums name="VkAttachmentDescriptionFlagBits" type="bitmask">
        <enum bitpos="0"    name="VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT"           comment="The attachment may alias physical memory of another attachment in the same render pass"/>
    </enums>
    <enums name="VkStencilFaceFlagBits" type="bitmask">
        <enum bitpos="0"    name="VK_STENCIL_FACE_FRONT_BIT"                         comment="Front face"/>
        <enum bitpos="1"    name="VK_STENCIL_FACE_BACK_BIT"                          comment="Back face"/>
        <enum value="0x00000003" name="VK_STENCIL_FRONT_AND_BACK"                    comment="Front and back faces"/>
    </enums>
    <enums name="VkDescriptorPoolCreateFlagBits" type="bitmask">
        <enum bitpos="0"    name="VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT" comment="Descriptor sets may be freed individually"/>
    </enums>
    <enums name="VkDependencyFlagBits" type="bitmask">
        <enum bitpos="0"    name="VK_DEPENDENCY_BY_REGION_BIT"                       comment="Dependency is per pixel region "/>
    </enums>

        <comment>WSI Extensions</comment>
    <enums name="VkPresentModeKHR" type="enum">
        <enum value="0"     name="VK_PRESENT_MODE_IMMEDIATE_KHR"/>
        <enum value="1"     name="VK_PRESENT_MODE_MAILBOX_KHR"/>
        <enum value="2"     name="VK_PRESENT_MODE_FIFO_KHR"/>
        <enum value="3"     name="VK_PRESENT_MODE_FIFO_RELAXED_KHR"/>
    </enums>
    <enums name="VkColorSpaceKHR" type="enum">
        <enum value="0"     name="VK_COLOR_SPACE_SRGB_NONLINEAR_KHR"/>
        <enum               name="VK_COLORSPACE_SRGB_NONLINEAR_KHR" alias="VK_COLOR_SPACE_SRGB_NONLINEAR_KHR" comment="Backwards-compatible alias containing a typo"/>
    </enums>
    <enums name="VkDisplayPlaneAlphaFlagBitsKHR" type="bitmask">
        <enum bitpos="0"    name="VK_DISPLAY_PLANE_ALPHA_OPAQUE_BIT_KHR"/>
        <enum bitpos="1"    name="VK_DISPLAY_PLANE_ALPHA_GLOBAL_BIT_KHR"/>
        <enum bitpos="2"    name="VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_BIT_KHR"/>
        <enum bitpos="3"    name="VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_PREMULTIPLIED_BIT_KHR"/>
    </enums>
    <enums name="VkCompositeAlphaFlagBitsKHR" type="bitmask">
        <enum bitpos="0"    name="VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR"/>
        <enum bitpos="1"    name="VK_COMPOSITE_ALPHA_PRE_MULTIPLIED_BIT_KHR"/>
        <enum bitpos="2"    name="VK_COMPOSITE_ALPHA_POST_MULTIPLIED_BIT_KHR"/>
        <enum bitpos="3"    name="VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR"/>
    </enums>
    <enums name="VkSurfaceTransformFlagBitsKHR" type="bitmask">
        <enum bitpos="0"    name="VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR"/>
        <enum bitpos="1"    name="VK_SURFACE_TRANSFORM_ROTATE_90_BIT_KHR"/>
        <enum bitpos="2"    name="VK_SURFACE_TRANSFORM_ROTATE_180_BIT_KHR"/>
        <enum bitpos="3"    name="VK_SURFACE_TRANSFORM_ROTATE_270_BIT_KHR"/>
        <enum bitpos="4"    name="VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_BIT_KHR"/>
        <enum bitpos="5"    name="VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_90_BIT_KHR"/>
        <enum bitpos="6"    name="VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_180_BIT_KHR"/>
        <enum bitpos="7"    name="VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_270_BIT_KHR"/>
        <enum bitpos="8"    name="VK_SURFACE_TRANSFORM_INHERIT_BIT_KHR"/>
    </enums>
    <enums name="VkTimeDomainEXT" type="enum">
        <enum value="0"     name="VK_TIME_DOMAIN_DEVICE_EXT"/>
        <enum value="1"     name="VK_TIME_DOMAIN_CLOCK_MONOTONIC_EXT"/>
        <enum value="2"     name="VK_TIME_DOMAIN_CLOCK_MONOTONIC_RAW_EXT"/>
        <enum value="3"     name="VK_TIME_DOMAIN_QUERY_PERFORMANCE_COUNTER_EXT"/>
    </enums>
    <enums name="VkDebugReportFlagBitsEXT" type="bitmask">
        <enum bitpos="0"    name="VK_DEBUG_REPORT_INFORMATION_BIT_EXT"/>
        <enum bitpos="1"    name="VK_DEBUG_REPORT_WARNING_BIT_EXT"/>
        <enum bitpos="2"    name="VK_DEBUG_REPORT_PERFORMANCE_WARNING_BIT_EXT"/>
        <enum bitpos="3"    name="VK_DEBUG_REPORT_ERROR_BIT_EXT"/>
        <enum bitpos="4"    name="VK_DEBUG_REPORT_DEBUG_BIT_EXT"/>
    </enums>
    <enums name="VkDebugReportObjectTypeEXT" type="enum">
        <enum value="0"     name="VK_DEBUG_REPORT_OBJECT_TYPE_UNKNOWN_EXT"/>
        <enum value="1"     name="VK_DEBUG_REPORT_OBJECT_TYPE_INSTANCE_EXT"/>
        <enum value="2"     name="VK_DEBUG_REPORT_OBJECT_TYPE_PHYSICAL_DEVICE_EXT"/>
        <enum value="3"     name="VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_EXT"/>
        <enum value="4"     name="VK_DEBUG_REPORT_OBJECT_TYPE_QUEUE_EXT"/>
        <enum value="5"     name="VK_DEBUG_REPORT_OBJECT_TYPE_SEMAPHORE_EXT"/>
        <enum value="6"     name="VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_BUFFER_EXT"/>
        <enum value="7"     name="VK_DEBUG_REPORT_OBJECT_TYPE_FENCE_EXT"/>
        <enum value="8"     name="VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_MEMORY_EXT"/>
        <enum value="9"     name="VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_EXT"/>
        <enum value="10"    name="VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_EXT"/>
        <enum value="11"    name="VK_DEBUG_REPORT_OBJECT_TYPE_EVENT_EXT"/>
        <enum value="12"    name="VK_DEBUG_REPORT_OBJECT_TYPE_QUERY_POOL_EXT"/>
        <enum value="13"    name="VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_VIEW_EXT"/>
        <enum value="14"    name="VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_VIEW_EXT"/>
        <enum value="15"    name="VK_DEBUG_REPORT_OBJECT_TYPE_SHADER_MODULE_EXT"/>
        <enum value="16"    name="VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_CACHE_EXT"/>
        <enum value="17"    name="VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_LAYOUT_EXT"/>
        <enum value="18"    name="VK_DEBUG_REPORT_OBJECT_TYPE_RENDER_PASS_EXT"/>
        <enum value="19"    name="VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_EXT"/>
        <enum value="20"    name="VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT_EXT"/>
        <enum value="21"    name="VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_EXT"/>
        <enum value="22"    name="VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_POOL_EXT"/>
        <enum value="23"    name="VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_EXT"/>
        <enum value="24"    name="VK_DEBUG_REPORT_OBJECT_TYPE_FRAMEBUFFER_EXT"/>
        <enum value="25"    name="VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_POOL_EXT"/>
        <enum value="26"    name="VK_DEBUG_REPORT_OBJECT_TYPE_SURFACE_KHR_EXT"/>
        <enum value="27"    name="VK_DEBUG_REPORT_OBJECT_TYPE_SWAPCHAIN_KHR_EXT"/>
        <enum value="28"    name="VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT_EXT"/>
        <enum               name="VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_EXT" alias="VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT_EXT" comment="Backwards-compatible alias containing a typo"/>
        <enum value="29"    name="VK_DEBUG_REPORT_OBJECT_TYPE_DISPLAY_KHR_EXT"/>
        <enum value="30"    name="VK_DEBUG_REPORT_OBJECT_TYPE_DISPLAY_MODE_KHR_EXT"/>
        <enum value="31"    name="VK_DEBUG_REPORT_OBJECT_TYPE_OBJECT_TABLE_NVX_EXT"/>
        <enum value="32"    name="VK_DEBUG_REPORT_OBJECT_TYPE_INDIRECT_COMMANDS_LAYOUT_NVX_EXT"/>
        <enum value="33"    name="VK_DEBUG_REPORT_OBJECT_TYPE_VALIDATION_CACHE_EXT_EXT"/>
        <enum               name="VK_DEBUG_REPORT_OBJECT_TYPE_VALIDATION_CACHE_EXT" alias="VK_DEBUG_REPORT_OBJECT_TYPE_VALIDATION_CACHE_EXT_EXT" comment="Backwards-compatible alias containing a typo"/>
    </enums>
    <enums name="VkRasterizationOrderAMD" type="enum">
        <enum value="0"     name="VK_RASTERIZATION_ORDER_STRICT_AMD"/>
        <enum value="1"     name="VK_RASTERIZATION_ORDER_RELAXED_AMD"/>
    </enums>
    <enums name="VkExternalMemoryHandleTypeFlagBitsNV" type="bitmask">
        <enum bitpos="0"    name="VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_NV"/>
        <enum bitpos="1"    name="VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_NV"/>
        <enum bitpos="2"    name="VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_BIT_NV"/>
        <enum bitpos="3"    name="VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_KMT_BIT_NV"/>
    </enums>
    <enums name="VkExternalMemoryFeatureFlagBitsNV" type="bitmask">
        <enum bitpos="0"    name="VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_NV"/>
        <enum bitpos="1"    name="VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT_NV"/>
        <enum bitpos="2"    name="VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT_NV"/>
    </enums>
    <enums name="VkValidationCheckEXT" type="enum">
        <enum value="0"     name="VK_VALIDATION_CHECK_ALL_EXT"/>
        <enum value="1"     name="VK_VALIDATION_CHECK_SHADERS_EXT"/>
            <comment>Placeholder for validation enums to be defined for VK_EXT_Validation_flags extension</comment>
    </enums>
    <enums name="VkValidationFeatureEnableEXT" type="enum">
        <enum value="0"     name="VK_VALIDATION_FEATURE_ENABLE_GPU_ASSISTED_EXT"/>
        <enum value="1"     name="VK_VALIDATION_FEATURE_ENABLE_GPU_ASSISTED_RESERVE_BINDING_SLOT_EXT"/>
            <comment>Placeholder for validation feature enable enums to be defined for VK_EXT_validation_features extension</comment>
    </enums>
    <enums name="VkValidationFeatureDisableEXT" type="enum">
        <enum value="0"     name="VK_VALIDATION_FEATURE_DISABLE_ALL_EXT"/>
        <enum value="1"     name="VK_VALIDATION_FEATURE_DISABLE_SHADERS_EXT"/>
        <enum value="2"     name="VK_VALIDATION_FEATURE_DISABLE_THREAD_SAFETY_EXT"/>
        <enum value="3"     name="VK_VALIDATION_FEATURE_DISABLE_API_PARAMETERS_EXT"/>
        <enum value="4"     name="VK_VALIDATION_FEATURE_DISABLE_OBJECT_LIFETIMES_EXT"/>
        <enum value="5"     name="VK_VALIDATION_FEATURE_DISABLE_CORE_CHECKS_EXT"/>
        <enum value="6"     name="VK_VALIDATION_FEATURE_DISABLE_UNIQUE_HANDLES_EXT"/>
            <comment>Placeholder for validation feature disable enums to be defined for VK_EXT_validation_features extension</comment>
    </enums>
    <enums name="VkSubgroupFeatureFlagBits" type="bitmask">
        <enum bitpos="0"    name="VK_SUBGROUP_FEATURE_BASIC_BIT"              comment="Basic subgroup operations"/>
        <enum bitpos="1"    name="VK_SUBGROUP_FEATURE_VOTE_BIT"               comment="Vote subgroup operations"/>
        <enum bitpos="2"    name="VK_SUBGROUP_FEATURE_ARITHMETIC_BIT"         comment="Arithmetic subgroup operations"/>
        <enum bitpos="3"    name="VK_SUBGROUP_FEATURE_BALLOT_BIT"             comment="Ballot subgroup operations"/>
        <enum bitpos="4"    name="VK_SUBGROUP_FEATURE_SHUFFLE_BIT"            comment="Shuffle subgroup operations"/>
        <enum bitpos="5"    name="VK_SUBGROUP_FEATURE_SHUFFLE_RELATIVE_BIT"   comment="Shuffle relative subgroup operations"/>
        <enum bitpos="6"    name="VK_SUBGROUP_FEATURE_CLUSTERED_BIT"          comment="Clustered subgroup operations"/>
        <enum bitpos="7"    name="VK_SUBGROUP_FEATURE_QUAD_BIT"               comment="Quad subgroup operations"/>
    </enums>
    <enums name="VkIndirectCommandsLayoutUsageFlagBitsNVX" type="bitmask">
        <enum bitpos="0"    name="VK_INDIRECT_COMMANDS_LAYOUT_USAGE_UNORDERED_SEQUENCES_BIT_NVX"/>
        <enum bitpos="1"    name="VK_INDIRECT_COMMANDS_LAYOUT_USAGE_SPARSE_SEQUENCES_BIT_NVX"/>
        <enum bitpos="2"    name="VK_INDIRECT_COMMANDS_LAYOUT_USAGE_EMPTY_EXECUTIONS_BIT_NVX"/>
        <enum bitpos="3"    name="VK_INDIRECT_COMMANDS_LAYOUT_USAGE_INDEXED_SEQUENCES_BIT_NVX"/>
    </enums>
    <enums name="VkObjectEntryUsageFlagBitsNVX" type="bitmask">
        <enum bitpos="0"    name="VK_OBJECT_ENTRY_USAGE_GRAPHICS_BIT_NVX"/>
        <enum bitpos="1"    name="VK_OBJECT_ENTRY_USAGE_COMPUTE_BIT_NVX"/>
    </enums>
    <enums name="VkIndirectCommandsTokenTypeNVX" type="enum">
        <enum value="0"     name="VK_INDIRECT_COMMANDS_TOKEN_TYPE_PIPELINE_NVX"/>
        <enum value="1"     name="VK_INDIRECT_COMMANDS_TOKEN_TYPE_DESCRIPTOR_SET_NVX"/>
        <enum value="2"     name="VK_INDIRECT_COMMANDS_TOKEN_TYPE_INDEX_BUFFER_NVX"/>
        <enum value="3"     name="VK_INDIRECT_COMMANDS_TOKEN_TYPE_VERTEX_BUFFER_NVX"/>
        <enum value="4"     name="VK_INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_CONSTANT_NVX"/>
        <enum value="5"     name="VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_INDEXED_NVX"/>
        <enum value="6"     name="VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_NVX"/>
        <enum value="7"     name="VK_INDIRECT_COMMANDS_TOKEN_TYPE_DISPATCH_NVX"/>
    </enums>
    <enums name="VkObjectEntryTypeNVX" type="enum">
        <enum value="0"     name="VK_OBJECT_ENTRY_TYPE_DESCRIPTOR_SET_NVX"/>
        <enum value="1"     name="VK_OBJECT_ENTRY_TYPE_PIPELINE_NVX"/>
        <enum value="2"     name="VK_OBJECT_ENTRY_TYPE_INDEX_BUFFER_NVX"/>
        <enum value="3"     name="VK_OBJECT_ENTRY_TYPE_VERTEX_BUFFER_NVX"/>
        <enum value="4"     name="VK_OBJECT_ENTRY_TYPE_PUSH_CONSTANT_NVX"/>
    </enums>
    <enums name="VkDescriptorSetLayoutCreateFlagBits" type="bitmask">
    </enums>
    <enums name="VkExternalMemoryHandleTypeFlagBits" type="bitmask">
        <enum bitpos="0"    name="VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT"/>
        <enum bitpos="1"    name="VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT"/>
        <enum bitpos="2"    name="VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT"/>
        <enum bitpos="3"    name="VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT"/>
        <enum bitpos="4"    name="VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT"/>
        <enum bitpos="5"    name="VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT"/>
        <enum bitpos="6"    name="VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT"/>
    </enums>
    <enums name="VkExternalMemoryFeatureFlagBits" type="bitmask">
        <enum bitpos="0"    name="VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT"/>
        <enum bitpos="1"    name="VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT"/>
        <enum bitpos="2"    name="VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT"/>
    </enums>
    <enums name="VkExternalSemaphoreHandleTypeFlagBits" type="bitmask">
        <enum bitpos="0"    name="VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT"/>
        <enum bitpos="1"    name="VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT"/>
        <enum bitpos="2"    name="VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT"/>
        <enum bitpos="3"    name="VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT"/>
        <enum bitpos="4"    name="VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT"/>
    </enums>
    <enums name="VkExternalSemaphoreFeatureFlagBits" type="bitmask">
        <enum bitpos="0"    name="VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT"/>
        <enum bitpos="1"    name="VK_EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT"/>
    </enums>
    <enums name="VkSemaphoreImportFlagBits" type="bitmask">
        <enum bitpos="0"    name="VK_SEMAPHORE_IMPORT_TEMPORARY_BIT"/>
    </enums>
    <enums name="VkExternalFenceHandleTypeFlagBits" type="bitmask">
        <enum bitpos="0"    name="VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT"/>
        <enum bitpos="1"    name="VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT"/>
        <enum bitpos="2"    name="VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT"/>
        <enum bitpos="3"    name="VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT"/>
    </enums>
    <enums name="VkExternalFenceFeatureFlagBits" type="bitmask">
        <enum bitpos="0"    name="VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT"/>
        <enum bitpos="1"    name="VK_EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT"/>
    </enums>
    <enums name="VkFenceImportFlagBits" type="bitmask">
        <enum bitpos="0"    name="VK_FENCE_IMPORT_TEMPORARY_BIT"/>
    </enums>
    <enums name="VkSurfaceCounterFlagBitsEXT" type="bitmask">
        <enum bitpos="0"    name="VK_SURFACE_COUNTER_VBLANK_EXT"/>
    </enums>
    <enums name="VkDisplayPowerStateEXT" type="enum">
        <enum value="0"     name="VK_DISPLAY_POWER_STATE_OFF_EXT"/>
        <enum value="1"     name="VK_DISPLAY_POWER_STATE_SUSPEND_EXT"/>
        <enum value="2"     name="VK_DISPLAY_POWER_STATE_ON_EXT"/>
    </enums>
    <enums name="VkDeviceEventTypeEXT" type="enum">
        <enum value="0"     name="VK_DEVICE_EVENT_TYPE_DISPLAY_HOTPLUG_EXT"/>
    </enums>
    <enums name="VkDisplayEventTypeEXT" type="enum">
        <enum value="0"     name="VK_DISPLAY_EVENT_TYPE_FIRST_PIXEL_OUT_EXT"/>
    </enums>
    <enums name="VkPeerMemoryFeatureFlagBits" type="bitmask">
        <enum bitpos="0"    name="VK_PEER_MEMORY_FEATURE_COPY_SRC_BIT"           comment="Can read with vkCmdCopy commands"/>
        <enum bitpos="1"    name="VK_PEER_MEMORY_FEATURE_COPY_DST_BIT"           comment="Can write with vkCmdCopy commands"/>
        <enum bitpos="2"    name="VK_PEER_MEMORY_FEATURE_GENERIC_SRC_BIT"        comment="Can read with any access type/command"/>
        <enum bitpos="3"    name="VK_PEER_MEMORY_FEATURE_GENERIC_DST_BIT"        comment="Can write with and access type/command"/>
    </enums>
    <enums name="VkMemoryAllocateFlagBits" type="bitmask">
        <enum bitpos="0"    name="VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT"            comment="Force allocation on specific devices"/>
    </enums>
    <enums name="VkDeviceGroupPresentModeFlagBitsKHR" type="bitmask">
        <enum bitpos="0"    name="VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_BIT_KHR"        comment="Present from local memory"/>
        <enum bitpos="1"    name="VK_DEVICE_GROUP_PRESENT_MODE_REMOTE_BIT_KHR"       comment="Present from remote memory"/>
        <enum bitpos="2"    name="VK_DEVICE_GROUP_PRESENT_MODE_SUM_BIT_KHR"          comment="Present sum of local and/or remote memory"/>
        <enum bitpos="3"    name="VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_MULTI_DEVICE_BIT_KHR" comment="Each physical device presents from local memory"/>
    </enums>
    <enums name="VkSwapchainCreateFlagBitsKHR" type="bitmask">
    </enums>
    <enums name="VkViewportCoordinateSwizzleNV" type="enum">
        <enum value="0"     name="VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_X_NV"/>
        <enum value="1"     name="VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_X_NV"/>
        <enum value="2"     name="VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_Y_NV"/>
        <enum value="3"     name="VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_Y_NV"/>
        <enum value="4"     name="VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_Z_NV"/>
        <enum value="5"     name="VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_Z_NV"/>
        <enum value="6"     name="VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_W_NV"/>
        <enum value="7"     name="VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_W_NV"/>
    </enums>
    <enums name="VkDiscardRectangleModeEXT" type="enum">
        <enum value="0"     name="VK_DISCARD_RECTANGLE_MODE_INCLUSIVE_EXT"/>
        <enum value="1"     name="VK_DISCARD_RECTANGLE_MODE_EXCLUSIVE_EXT"/>
    </enums>
    <enums name="VkSubpassDescriptionFlagBits" type="bitmask">
    </enums>
    <enums name="VkPointClippingBehavior" type="enum">
        <enum value="0"     name="VK_POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES"/>
        <enum value="1"     name="VK_POINT_CLIPPING_BEHAVIOR_USER_CLIP_PLANES_ONLY"/>
    </enums>
    <enums name="VkSamplerReductionModeEXT" type="enum">
        <enum value="0"     name="VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE_EXT"/>
        <enum value="1"     name="VK_SAMPLER_REDUCTION_MODE_MIN_EXT"/>
        <enum value="2"     name="VK_SAMPLER_REDUCTION_MODE_MAX_EXT"/>
    </enums>
    <enums name="VkTessellationDomainOrigin" type="enum">
        <enum value="0"     name="VK_TESSELLATION_DOMAIN_ORIGIN_UPPER_LEFT"/>
        <enum value="1"     name="VK_TESSELLATION_DOMAIN_ORIGIN_LOWER_LEFT"/>
    </enums>
    <enums name="VkSamplerYcbcrModelConversion" type="enum">
        <enum value="0"     name="VK_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY"/>
        <enum value="1"     name="VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_IDENTITY" comment="just range expansion"/>
        <enum value="2"     name="VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_709"      comment="aka HD YUV"/>
        <enum value="3"     name="VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_601"      comment="aka SD YUV"/>
        <enum value="4"     name="VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_2020"     comment="aka UHD YUV"/>
    </enums>
    <enums name="VkSamplerYcbcrRange" type="enum">
        <enum value="0"     name="VK_SAMPLER_YCBCR_RANGE_ITU_FULL"    comment="Luma 0..1 maps to 0..255, chroma -0.5..0.5 to 1..255 (clamped)"/>
        <enum value="1"     name="VK_SAMPLER_YCBCR_RANGE_ITU_NARROW"  comment="Luma 0..1 maps to 16..235, chroma -0.5..0.5 to 16..240"/>
    </enums>
    <enums name="VkChromaLocation" type="enum">
        <enum value="0"     name="VK_CHROMA_LOCATION_COSITED_EVEN"/>
        <enum value="1"     name="VK_CHROMA_LOCATION_MIDPOINT"/>
    </enums>
    <enums name="VkBlendOverlapEXT" type="enum">
        <enum value="0"     name="VK_BLEND_OVERLAP_UNCORRELATED_EXT"/>
        <enum value="1"     name="VK_BLEND_OVERLAP_DISJOINT_EXT"/>
        <enum value="2"     name="VK_BLEND_OVERLAP_CONJOINT_EXT"/>
    </enums>
    <enums name="VkCoverageModulationModeNV" type="enum">
        <enum value="0"     name="VK_COVERAGE_MODULATION_MODE_NONE_NV"/>
        <enum value="1"     name="VK_COVERAGE_MODULATION_MODE_RGB_NV"/>
        <enum value="2"     name="VK_COVERAGE_MODULATION_MODE_ALPHA_NV"/>
        <enum value="3"     name="VK_COVERAGE_MODULATION_MODE_RGBA_NV"/>
    </enums>
    <enums name="VkCoverageReductionModeNV" type="enum">
        <enum value="0"     name="VK_COVERAGE_REDUCTION_MODE_MERGE_NV"/>
        <enum value="1"     name="VK_COVERAGE_REDUCTION_MODE_TRUNCATE_NV"/>
    </enums>
    <enums name="VkValidationCacheHeaderVersionEXT" type="enum">
        <enum value="1"     name="VK_VALIDATION_CACHE_HEADER_VERSION_ONE_EXT"/>
    </enums>
    <enums name="VkShaderInfoTypeAMD" type="enum">
        <enum value="0"     name="VK_SHADER_INFO_TYPE_STATISTICS_AMD"/>
        <enum value="1"     name="VK_SHADER_INFO_TYPE_BINARY_AMD"/>
        <enum value="2"     name="VK_SHADER_INFO_TYPE_DISASSEMBLY_AMD"/>
    </enums>
    <enums name="VkQueueGlobalPriorityEXT" type="enum">
        <enum value="128"   name="VK_QUEUE_GLOBAL_PRIORITY_LOW_EXT"/>
        <enum value="256"   name="VK_QUEUE_GLOBAL_PRIORITY_MEDIUM_EXT"/>
        <enum value="512"   name="VK_QUEUE_GLOBAL_PRIORITY_HIGH_EXT"/>
        <enum value="1024"  name="VK_QUEUE_GLOBAL_PRIORITY_REALTIME_EXT"/>
    </enums>
    <enums name="VkDebugUtilsMessageSeverityFlagBitsEXT" type="bitmask">
        <enum bitpos="0"    name="VK_DEBUG_UTILS_MESSAGE_SEVERITY_VERBOSE_BIT_EXT"/>
        <enum bitpos="4"    name="VK_DEBUG_UTILS_MESSAGE_SEVERITY_INFO_BIT_EXT"/>
        <enum bitpos="8"    name="VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT"/>
        <enum bitpos="12"   name="VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT"/>
    </enums>
    <enums name="VkDebugUtilsMessageTypeFlagBitsEXT" type="bitmask">
        <enum bitpos="0"    name="VK_DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT"/>
        <enum bitpos="1"    name="VK_DEBUG_UTILS_MESSAGE_TYPE_VALIDATION_BIT_EXT"/>
        <enum bitpos="2"    name="VK_DEBUG_UTILS_MESSAGE_TYPE_PERFORMANCE_BIT_EXT"/>
    </enums>
    <enums name="VkConservativeRasterizationModeEXT" type="enum">
        <enum value="0"     name="VK_CONSERVATIVE_RASTERIZATION_MODE_DISABLED_EXT"/>
        <enum value="1"     name="VK_CONSERVATIVE_RASTERIZATION_MODE_OVERESTIMATE_EXT"/>
        <enum value="2"     name="VK_CONSERVATIVE_RASTERIZATION_MODE_UNDERESTIMATE_EXT"/>
    </enums>
    <enums name="VkDescriptorBindingFlagBitsEXT" type="bitmask">
        <enum bitpos="0" name="VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT_EXT"/>
        <enum bitpos="1" name="VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT_EXT"/>
        <enum bitpos="2" name="VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT_EXT"/>
        <enum bitpos="3" name="VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT_EXT"/>
    </enums>
    <enums name="VkVendorId" type="enum">
        <comment>Vendor IDs are now represented as enums instead of the old
                 &lt;vendorids&gt; tag, allowing them to be included in the
                 API headers.</comment>
        <enum value="0x10001" name="VK_VENDOR_ID_VIV"   comment="Vivante vendor ID"/>
        <enum value="0x10002" name="VK_VENDOR_ID_VSI"   comment="VeriSilicon vendor ID"/>
        <enum value="0x10003" name="VK_VENDOR_ID_KAZAN" comment="Kazan Software Renderer"/>
            <unused start="0x10004" comment="This is the next unused available Khronos vendor ID"/>
    </enums>
    <enums name="VkDriverIdKHR" type="enum">
        <comment>Driver IDs are now represented as enums instead of the old
                 &lt;driverids&gt; tag, allowing them to be included in the
                 API headers.</comment>
        <enum value="1"       name="VK_DRIVER_ID_AMD_PROPRIETARY_KHR"           comment="Advanced Micro Devices, Inc."/>
        <enum value="2"       name="VK_DRIVER_ID_AMD_OPEN_SOURCE_KHR"           comment="Advanced Micro Devices, Inc."/>
        <enum value="3"       name="VK_DRIVER_ID_MESA_RADV_KHR"                 comment="Mesa open source project"/>
        <enum value="4"       name="VK_DRIVER_ID_NVIDIA_PROPRIETARY_KHR"        comment="NVIDIA Corporation"/>
        <enum value="5"       name="VK_DRIVER_ID_INTEL_PROPRIETARY_WINDOWS_KHR" comment="Intel Corporation"/>
        <enum value="6"       name="VK_DRIVER_ID_INTEL_OPEN_SOURCE_MESA_KHR"    comment="Intel Corporation"/>
        <enum value="7"       name="VK_DRIVER_ID_IMAGINATION_PROPRIETARY_KHR"   comment="Imagination Technologies"/>
        <enum value="8"       name="VK_DRIVER_ID_QUALCOMM_PROPRIETARY_KHR"      comment="Qualcomm Technologies, Inc."/>
        <enum value="9"       name="VK_DRIVER_ID_ARM_PROPRIETARY_KHR"           comment="Arm Limited"/>
        <enum value="10"      name="VK_DRIVER_ID_GOOGLE_SWIFTSHADER_KHR"        comment="Google LLC"/>
        <enum value="11"      name="VK_DRIVER_ID_GGP_PROPRIETARY_KHR"           comment="Google LLC"/>
        <enum value="12"      name="VK_DRIVER_ID_BROADCOM_PROPRIETARY_KHR"      comment="Broadcom Inc."/>
    </enums>
    <enums name="VkConditionalRenderingFlagBitsEXT" type="bitmask">
        <enum bitpos="0"    name="VK_CONDITIONAL_RENDERING_INVERTED_BIT_EXT"/>
    </enums>
    <enums name="VkResolveModeFlagBitsKHR" type="bitmask">
        <enum value="0" name="VK_RESOLVE_MODE_NONE_KHR"/>
        <enum bitpos="0" name="VK_RESOLVE_MODE_SAMPLE_ZERO_BIT_KHR"/>
        <enum bitpos="1" name="VK_RESOLVE_MODE_AVERAGE_BIT_KHR"/>
        <enum bitpos="2" name="VK_RESOLVE_MODE_MIN_BIT_KHR"/>
        <enum bitpos="3" name="VK_RESOLVE_MODE_MAX_BIT_KHR"/>
    </enums>
    <enums name="VkShadingRatePaletteEntryNV" type="enum">
        <enum value="0" name="VK_SHADING_RATE_PALETTE_ENTRY_NO_INVOCATIONS_NV"/>
        <enum value="1" name="VK_SHADING_RATE_PALETTE_ENTRY_16_INVOCATIONS_PER_PIXEL_NV"/>
        <enum value="2" name="VK_SHADING_RATE_PALETTE_ENTRY_8_INVOCATIONS_PER_PIXEL_NV"/>
        <enum value="3" name="VK_SHADING_RATE_PALETTE_ENTRY_4_INVOCATIONS_PER_PIXEL_NV"/>
        <enum value="4" name="VK_SHADING_RATE_PALETTE_ENTRY_2_INVOCATIONS_PER_PIXEL_NV"/>
        <enum value="5" name="VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_PIXEL_NV"/>
        <enum value="6" name="VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_2X1_PIXELS_NV"/>
        <enum value="7" name="VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_1X2_PIXELS_NV"/>
        <enum value="8" name="VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_2X2_PIXELS_NV"/>
        <enum value="9" name="VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_4X2_PIXELS_NV"/>
        <enum value="10" name="VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_2X4_PIXELS_NV"/>
        <enum value="11" name="VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_4X4_PIXELS_NV"/>
    </enums>
    <enums name="VkCoarseSampleOrderTypeNV" type="enum">
        <enum value="0" name="VK_COARSE_SAMPLE_ORDER_TYPE_DEFAULT_NV"/>
        <enum value="1" name="VK_COARSE_SAMPLE_ORDER_TYPE_CUSTOM_NV"/>
        <enum value="2" name="VK_COARSE_SAMPLE_ORDER_TYPE_PIXEL_MAJOR_NV"/>
        <enum value="3" name="VK_COARSE_SAMPLE_ORDER_TYPE_SAMPLE_MAJOR_NV"/>
    </enums>
    <enums name="VkGeometryInstanceFlagBitsNV" type="bitmask">
        <enum bitpos="0" name="VK_GEOMETRY_INSTANCE_TRIANGLE_CULL_DISABLE_BIT_NV"/>
        <enum bitpos="1" name="VK_GEOMETRY_INSTANCE_TRIANGLE_FRONT_COUNTERCLOCKWISE_BIT_NV"/>
        <enum bitpos="2" name="VK_GEOMETRY_INSTANCE_FORCE_OPAQUE_BIT_NV"/>
        <enum bitpos="3" name="VK_GEOMETRY_INSTANCE_FORCE_NO_OPAQUE_BIT_NV"/>
    </enums>
    <enums name="VkGeometryFlagBitsNV" type="bitmask">
        <enum bitpos="0" name="VK_GEOMETRY_OPAQUE_BIT_NV"/>
        <enum bitpos="1" name="VK_GEOMETRY_NO_DUPLICATE_ANY_HIT_INVOCATION_BIT_NV"/>
    </enums>
    <enums name="VkBuildAccelerationStructureFlagBitsNV" type="bitmask">
        <enum bitpos="0" name="VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_UPDATE_BIT_NV"/>
        <enum bitpos="1" name="VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_COMPACTION_BIT_NV"/>
        <enum bitpos="2" name="VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_TRACE_BIT_NV"/>
        <enum bitpos="3" name="VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_BUILD_BIT_NV"/>
        <enum bitpos="4" name="VK_BUILD_ACCELERATION_STRUCTURE_LOW_MEMORY_BIT_NV"/>
    </enums>
    <enums name="VkCopyAccelerationStructureModeNV" type="enum">
        <enum value="0" name="VK_COPY_ACCELERATION_STRUCTURE_MODE_CLONE_NV"/>
        <enum value="1" name="VK_COPY_ACCELERATION_STRUCTURE_MODE_COMPACT_NV"/>
    </enums>
    <enums name="VkAccelerationStructureTypeNV" type="enum">
        <enum value="0" name="VK_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_NV"/>
        <enum value="1" name="VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_NV"/>
    </enums>
    <enums name="VkGeometryTypeNV" type="enum">
        <enum value="0" name="VK_GEOMETRY_TYPE_TRIANGLES_NV"/>
        <enum value="1" name="VK_GEOMETRY_TYPE_AABBS_NV"/>
    </enums>
    <enums name="VkAccelerationStructureMemoryRequirementsTypeNV" type="enum">
        <enum value="0" name="VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_OBJECT_NV"/>
        <enum value="1" name="VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_BUILD_SCRATCH_NV"/>
        <enum value="2" name="VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_UPDATE_SCRATCH_NV"/>
    </enums>
    <enums name="VkRayTracingShaderGroupTypeNV" type="enum">
        <enum value="0" name="VK_RAY_TRACING_SHADER_GROUP_TYPE_GENERAL_NV"/>
        <enum value="1" name="VK_RAY_TRACING_SHADER_GROUP_TYPE_TRIANGLES_HIT_GROUP_NV"/>
        <enum value="2" name="VK_RAY_TRACING_SHADER_GROUP_TYPE_PROCEDURAL_HIT_GROUP_NV"/>
    </enums>
    <enums name="VkMemoryOverallocationBehaviorAMD" type="enum">
        <enum value="0"     name="VK_MEMORY_OVERALLOCATION_BEHAVIOR_DEFAULT_AMD"/>
        <enum value="1"     name="VK_MEMORY_OVERALLOCATION_BEHAVIOR_ALLOWED_AMD"/>
        <enum value="2"     name="VK_MEMORY_OVERALLOCATION_BEHAVIOR_DISALLOWED_AMD"/>
    </enums>
    <enums name="VkScopeNV" type="enum">
        <enum value="1"     name="VK_SCOPE_DEVICE_NV"/>
        <enum value="2"     name="VK_SCOPE_WORKGROUP_NV"/>
        <enum value="3"     name="VK_SCOPE_SUBGROUP_NV"/>
        <enum value="5"     name="VK_SCOPE_QUEUE_FAMILY_NV"/>
    </enums>
    <enums name="VkComponentTypeNV" type="enum">
        <enum value="0"     name="VK_COMPONENT_TYPE_FLOAT16_NV"/>
        <enum value="1"     name="VK_COMPONENT_TYPE_FLOAT32_NV"/>
        <enum value="2"     name="VK_COMPONENT_TYPE_FLOAT64_NV"/>
        <enum value="3"     name="VK_COMPONENT_TYPE_SINT8_NV"/>
        <enum value="4"     name="VK_COMPONENT_TYPE_SINT16_NV"/>
        <enum value="5"     name="VK_COMPONENT_TYPE_SINT32_NV"/>
        <enum value="6"     name="VK_COMPONENT_TYPE_SINT64_NV"/>
        <enum value="7"     name="VK_COMPONENT_TYPE_UINT8_NV"/>
        <enum value="8"     name="VK_COMPONENT_TYPE_UINT16_NV"/>
        <enum value="9"     name="VK_COMPONENT_TYPE_UINT32_NV"/>
        <enum value="10"    name="VK_COMPONENT_TYPE_UINT64_NV"/>
    </enums>
    <enums name="VkPipelineCreationFeedbackFlagBitsEXT" type="bitmask">
        <enum bitpos="0"    name="VK_PIPELINE_CREATION_FEEDBACK_VALID_BIT_EXT"/>
        <enum bitpos="1"    name="VK_PIPELINE_CREATION_FEEDBACK_APPLICATION_PIPELINE_CACHE_HIT_BIT_EXT"/>
        <enum bitpos="2"    name="VK_PIPELINE_CREATION_FEEDBACK_BASE_PIPELINE_ACCELERATION_BIT_EXT"/>
    </enums>
    <enums name="VkFullScreenExclusiveEXT" type="enum">
        <enum value="0"     name="VK_FULL_SCREEN_EXCLUSIVE_DEFAULT_EXT"/>
        <enum value="1"     name="VK_FULL_SCREEN_EXCLUSIVE_ALLOWED_EXT"/>
        <enum value="2"     name="VK_FULL_SCREEN_EXCLUSIVE_DISALLOWED_EXT"/>
        <enum value="3"     name="VK_FULL_SCREEN_EXCLUSIVE_APPLICATION_CONTROLLED_EXT"/>
    </enums>
    <enums name="VkPerformanceConfigurationTypeINTEL" type="enum">
        <enum value="0"     name="VK_PERFORMANCE_CONFIGURATION_TYPE_COMMAND_QUEUE_METRICS_DISCOVERY_ACTIVATED_INTEL"/>
    </enums>
    <enums name="VkQueryPoolSamplingModeINTEL" type="enum">
        <enum value="0"     name="VK_QUERY_POOL_SAMPLING_MODE_MANUAL_INTEL"/>
    </enums>
    <enums name="VkPerformanceOverrideTypeINTEL" type="enum">
        <enum value="0"     name="VK_PERFORMANCE_OVERRIDE_TYPE_NULL_HARDWARE_INTEL"/>
        <enum value="1"     name="VK_PERFORMANCE_OVERRIDE_TYPE_FLUSH_GPU_CACHES_INTEL"/>
    </enums>
    <enums name="VkPerformanceParameterTypeINTEL" type="enum">
        <enum value="0"     name="VK_PERFORMANCE_PARAMETER_TYPE_HW_COUNTERS_SUPPORTED_INTEL"/>
        <enum value="1"     name="VK_PERFORMANCE_PARAMETER_TYPE_STREAM_MARKER_VALID_BITS_INTEL"/>
    </enums>
    <enums name="VkPerformanceValueTypeINTEL" type="enum">
        <enum value="0"     name="VK_PERFORMANCE_VALUE_TYPE_UINT32_INTEL"/>
        <enum value="1"     name="VK_PERFORMANCE_VALUE_TYPE_UINT64_INTEL"/>
        <enum value="2"     name="VK_PERFORMANCE_VALUE_TYPE_FLOAT_INTEL"/>
        <enum value="3"     name="VK_PERFORMANCE_VALUE_TYPE_BOOL_INTEL"/>
        <enum value="4"     name="VK_PERFORMANCE_VALUE_TYPE_STRING_INTEL"/>
    </enums>

    <commands comment="Vulkan command definitions">
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_INITIALIZATION_FAILED,VK_ERROR_LAYER_NOT_PRESENT,VK_ERROR_EXTENSION_NOT_PRESENT,VK_ERROR_INCOMPATIBLE_DRIVER">
            <proto><type>VkResult</type> <name>vkCreateInstance</name></proto>
            <param>const <type>VkInstanceCreateInfo</type>* <name>pCreateInfo</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param><type>VkInstance</type>* <name>pInstance</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkDestroyInstance</name></proto>
            <param optional="true" externsync="true"><type>VkInstance</type> <name>instance</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
        </command>
        <command successcodes="VK_SUCCESS,VK_INCOMPLETE" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_INITIALIZATION_FAILED">
            <proto><type>VkResult</type> <name>vkEnumeratePhysicalDevices</name></proto>
            <param><type>VkInstance</type> <name>instance</name></param>
            <param optional="false,true"><type>uint32_t</type>* <name>pPhysicalDeviceCount</name></param>
            <param optional="true" len="pPhysicalDeviceCount"><type>VkPhysicalDevice</type>* <name>pPhysicalDevices</name></param>
        </command>
        <command>
            <proto><type>PFN_vkVoidFunction</type> <name>vkGetDeviceProcAddr</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param len="null-terminated">const <type>char</type>* <name>pName</name></param>
        </command>
        <command>
            <proto><type>PFN_vkVoidFunction</type> <name>vkGetInstanceProcAddr</name></proto>
            <param optional="true"><type>VkInstance</type> <name>instance</name></param>
            <param len="null-terminated">const <type>char</type>* <name>pName</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkGetPhysicalDeviceProperties</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param><type>VkPhysicalDeviceProperties</type>* <name>pProperties</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkGetPhysicalDeviceQueueFamilyProperties</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param optional="false,true"><type>uint32_t</type>* <name>pQueueFamilyPropertyCount</name></param>
            <param optional="true" len="pQueueFamilyPropertyCount"><type>VkQueueFamilyProperties</type>* <name>pQueueFamilyProperties</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkGetPhysicalDeviceMemoryProperties</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param><type>VkPhysicalDeviceMemoryProperties</type>* <name>pMemoryProperties</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkGetPhysicalDeviceFeatures</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param><type>VkPhysicalDeviceFeatures</type>* <name>pFeatures</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkGetPhysicalDeviceFormatProperties</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param><type>VkFormat</type> <name>format</name></param>
            <param><type>VkFormatProperties</type>* <name>pFormatProperties</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_FORMAT_NOT_SUPPORTED">
            <proto><type>VkResult</type> <name>vkGetPhysicalDeviceImageFormatProperties</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param><type>VkFormat</type> <name>format</name></param>
            <param><type>VkImageType</type> <name>type</name></param>
            <param><type>VkImageTiling</type> <name>tiling</name></param>
            <param><type>VkImageUsageFlags</type> <name>usage</name></param>
            <param optional="true"><type>VkImageCreateFlags</type> <name>flags</name></param>
            <param><type>VkImageFormatProperties</type>* <name>pImageFormatProperties</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_INITIALIZATION_FAILED,VK_ERROR_EXTENSION_NOT_PRESENT,VK_ERROR_FEATURE_NOT_PRESENT,VK_ERROR_TOO_MANY_OBJECTS,VK_ERROR_DEVICE_LOST">
            <proto><type>VkResult</type> <name>vkCreateDevice</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param>const <type>VkDeviceCreateInfo</type>* <name>pCreateInfo</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param><type>VkDevice</type>* <name>pDevice</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkDestroyDevice</name></proto>
            <param optional="true" externsync="true"><type>VkDevice</type> <name>device</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
        </command>
        <command successcodes="VK_SUCCESS">
            <proto><type>VkResult</type> <name>vkEnumerateInstanceVersion</name></proto>
            <param><type>uint32_t</type>* <name>pApiVersion</name></param>
        </command>
        <command successcodes="VK_SUCCESS,VK_INCOMPLETE" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
            <proto><type>VkResult</type> <name>vkEnumerateInstanceLayerProperties</name></proto>
            <param optional="false,true"><type>uint32_t</type>* <name>pPropertyCount</name></param>
            <param optional="true" len="pPropertyCount"><type>VkLayerProperties</type>* <name>pProperties</name></param>
        </command>
        <command successcodes="VK_SUCCESS,VK_INCOMPLETE" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_LAYER_NOT_PRESENT">
            <proto><type>VkResult</type> <name>vkEnumerateInstanceExtensionProperties</name></proto>
            <param optional="true" len="null-terminated">const <type>char</type>* <name>pLayerName</name></param>
            <param optional="false,true"><type>uint32_t</type>* <name>pPropertyCount</name></param>
            <param optional="true" len="pPropertyCount"><type>VkExtensionProperties</type>* <name>pProperties</name></param>
        </command>
        <command successcodes="VK_SUCCESS,VK_INCOMPLETE" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
            <proto><type>VkResult</type> <name>vkEnumerateDeviceLayerProperties</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param optional="false,true"><type>uint32_t</type>* <name>pPropertyCount</name></param>
            <param optional="true" len="pPropertyCount"><type>VkLayerProperties</type>* <name>pProperties</name></param>
        </command>
        <command successcodes="VK_SUCCESS,VK_INCOMPLETE" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_LAYER_NOT_PRESENT">
            <proto><type>VkResult</type> <name>vkEnumerateDeviceExtensionProperties</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param optional="true" len="null-terminated">const <type>char</type>* <name>pLayerName</name></param>
            <param optional="false,true"><type>uint32_t</type>* <name>pPropertyCount</name></param>
            <param optional="true" len="pPropertyCount"><type>VkExtensionProperties</type>* <name>pProperties</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkGetDeviceQueue</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>uint32_t</type> <name>queueFamilyIndex</name></param>
            <param><type>uint32_t</type> <name>queueIndex</name></param>
            <param><type>VkQueue</type>* <name>pQueue</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_DEVICE_LOST">
            <proto><type>VkResult</type> <name>vkQueueSubmit</name></proto>
            <param externsync="true"><type>VkQueue</type> <name>queue</name></param>
            <param optional="true"><type>uint32_t</type> <name>submitCount</name></param>
            <param len="submitCount">const <type>VkSubmitInfo</type>* <name>pSubmits</name></param>
            <param optional="true" externsync="true"><type>VkFence</type> <name>fence</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_DEVICE_LOST">
            <proto><type>VkResult</type> <name>vkQueueWaitIdle</name></proto>
            <param externsync="true"><type>VkQueue</type> <name>queue</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_DEVICE_LOST">
            <proto><type>VkResult</type> <name>vkDeviceWaitIdle</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <implicitexternsyncparams>
                <param>all sname:VkQueue objects created from pname:device</param>
            </implicitexternsyncparams>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_TOO_MANY_OBJECTS,VK_ERROR_INVALID_EXTERNAL_HANDLE">
            <proto><type>VkResult</type> <name>vkAllocateMemory</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkMemoryAllocateInfo</type>* <name>pAllocateInfo</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param><type>VkDeviceMemory</type>* <name>pMemory</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkFreeMemory</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param optional="true" externsync="true"><type>VkDeviceMemory</type> <name>memory</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_MEMORY_MAP_FAILED">
            <proto><type>VkResult</type> <name>vkMapMemory</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param externsync="true"><type>VkDeviceMemory</type> <name>memory</name></param>
            <param><type>VkDeviceSize</type> <name>offset</name></param>
            <param><type>VkDeviceSize</type> <name>size</name></param>
            <param optional="true"><type>VkMemoryMapFlags</type> <name>flags</name></param>
            <param optional="false,true"><type>void</type>** <name>ppData</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkUnmapMemory</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param externsync="true"><type>VkDeviceMemory</type> <name>memory</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
            <proto><type>VkResult</type> <name>vkFlushMappedMemoryRanges</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>uint32_t</type> <name>memoryRangeCount</name></param>
            <param len="memoryRangeCount">const <type>VkMappedMemoryRange</type>* <name>pMemoryRanges</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
            <proto><type>VkResult</type> <name>vkInvalidateMappedMemoryRanges</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>uint32_t</type> <name>memoryRangeCount</name></param>
            <param len="memoryRangeCount">const <type>VkMappedMemoryRange</type>* <name>pMemoryRanges</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkGetDeviceMemoryCommitment</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>VkDeviceMemory</type> <name>memory</name></param>
            <param><type>VkDeviceSize</type>* <name>pCommittedMemoryInBytes</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkGetBufferMemoryRequirements</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>VkBuffer</type> <name>buffer</name></param>
            <param><type>VkMemoryRequirements</type>* <name>pMemoryRequirements</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
            <proto><type>VkResult</type> <name>vkBindBufferMemory</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param externsync="true"><type>VkBuffer</type> <name>buffer</name></param>
            <param><type>VkDeviceMemory</type> <name>memory</name></param>
            <param><type>VkDeviceSize</type> <name>memoryOffset</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkGetImageMemoryRequirements</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>VkImage</type> <name>image</name></param>
            <param><type>VkMemoryRequirements</type>* <name>pMemoryRequirements</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
            <proto><type>VkResult</type> <name>vkBindImageMemory</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param externsync="true"><type>VkImage</type> <name>image</name></param>
            <param><type>VkDeviceMemory</type> <name>memory</name></param>
            <param><type>VkDeviceSize</type> <name>memoryOffset</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkGetImageSparseMemoryRequirements</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>VkImage</type> <name>image</name></param>
            <param optional="false,true"><type>uint32_t</type>* <name>pSparseMemoryRequirementCount</name></param>
            <param optional="true" len="pSparseMemoryRequirementCount"><type>VkSparseImageMemoryRequirements</type>* <name>pSparseMemoryRequirements</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkGetPhysicalDeviceSparseImageFormatProperties</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param><type>VkFormat</type> <name>format</name></param>
            <param><type>VkImageType</type> <name>type</name></param>
            <param><type>VkSampleCountFlagBits</type> <name>samples</name></param>
            <param><type>VkImageUsageFlags</type> <name>usage</name></param>
            <param><type>VkImageTiling</type> <name>tiling</name></param>
            <param optional="false,true"><type>uint32_t</type>* <name>pPropertyCount</name></param>
            <param optional="true" len="pPropertyCount"><type>VkSparseImageFormatProperties</type>* <name>pProperties</name></param>
        </command>
        <command queues="sparse_binding" successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_DEVICE_LOST">
            <proto><type>VkResult</type> <name>vkQueueBindSparse</name></proto>
            <param externsync="true"><type>VkQueue</type> <name>queue</name></param>
            <param optional="true"><type>uint32_t</type> <name>bindInfoCount</name></param>
            <param len="bindInfoCount" externsync="pBindInfo[].pBufferBinds[].buffer,pBindInfo[].pImageOpaqueBinds[].image,pBindInfo[].pImageBinds[].image">const <type>VkBindSparseInfo</type>* <name>pBindInfo</name></param>
            <param optional="true" externsync="true"><type>VkFence</type> <name>fence</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
            <proto><type>VkResult</type> <name>vkCreateFence</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkFenceCreateInfo</type>* <name>pCreateInfo</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param><type>VkFence</type>* <name>pFence</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkDestroyFence</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param optional="true" externsync="true"><type>VkFence</type> <name>fence</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
            <proto><type>VkResult</type> <name>vkResetFences</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>uint32_t</type> <name>fenceCount</name></param>
            <param len="fenceCount" externsync="true">const <type>VkFence</type>* <name>pFences</name></param>
        </command>
        <command successcodes="VK_SUCCESS,VK_NOT_READY" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_DEVICE_LOST">
            <proto><type>VkResult</type> <name>vkGetFenceStatus</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>VkFence</type> <name>fence</name></param>
        </command>
        <command successcodes="VK_SUCCESS,VK_TIMEOUT" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_DEVICE_LOST">
            <proto><type>VkResult</type> <name>vkWaitForFences</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>uint32_t</type> <name>fenceCount</name></param>
            <param len="fenceCount">const <type>VkFence</type>* <name>pFences</name></param>
            <param><type>VkBool32</type> <name>waitAll</name></param>
            <param><type>uint64_t</type> <name>timeout</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
            <proto><type>VkResult</type> <name>vkCreateSemaphore</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkSemaphoreCreateInfo</type>* <name>pCreateInfo</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param><type>VkSemaphore</type>* <name>pSemaphore</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkDestroySemaphore</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param optional="true" externsync="true"><type>VkSemaphore</type> <name>semaphore</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
            <proto><type>VkResult</type> <name>vkCreateEvent</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkEventCreateInfo</type>* <name>pCreateInfo</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param><type>VkEvent</type>* <name>pEvent</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkDestroyEvent</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param optional="true" externsync="true"><type>VkEvent</type> <name>event</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
        </command>
        <command successcodes="VK_EVENT_SET,VK_EVENT_RESET" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_DEVICE_LOST">
            <proto><type>VkResult</type> <name>vkGetEventStatus</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>VkEvent</type> <name>event</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
            <proto><type>VkResult</type> <name>vkSetEvent</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param externsync="true"><type>VkEvent</type> <name>event</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
            <proto><type>VkResult</type> <name>vkResetEvent</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param externsync="true"><type>VkEvent</type> <name>event</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
            <proto><type>VkResult</type> <name>vkCreateQueryPool</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkQueryPoolCreateInfo</type>* <name>pCreateInfo</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param><type>VkQueryPool</type>* <name>pQueryPool</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkDestroyQueryPool</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param optional="true" externsync="true"><type>VkQueryPool</type> <name>queryPool</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
        </command>
        <command successcodes="VK_SUCCESS,VK_NOT_READY" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_DEVICE_LOST">
            <proto><type>VkResult</type> <name>vkGetQueryPoolResults</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>VkQueryPool</type> <name>queryPool</name></param>
            <param><type>uint32_t</type> <name>firstQuery</name></param>
            <param><type>uint32_t</type> <name>queryCount</name></param>
            <param><type>size_t</type> <name>dataSize</name></param>
            <param len="dataSize"><type>void</type>* <name>pData</name></param>
            <param><type>VkDeviceSize</type> <name>stride</name></param>
            <param optional="true"><type>VkQueryResultFlags</type> <name>flags</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkResetQueryPoolEXT</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>VkQueryPool</type> <name>queryPool</name></param>
            <param><type>uint32_t</type> <name>firstQuery</name></param>
            <param><type>uint32_t</type> <name>queryCount</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_INVALID_DEVICE_ADDRESS_EXT">
            <proto><type>VkResult</type> <name>vkCreateBuffer</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkBufferCreateInfo</type>* <name>pCreateInfo</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param><type>VkBuffer</type>* <name>pBuffer</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkDestroyBuffer</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param optional="true" externsync="true"><type>VkBuffer</type> <name>buffer</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
            <proto><type>VkResult</type> <name>vkCreateBufferView</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkBufferViewCreateInfo</type>* <name>pCreateInfo</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param><type>VkBufferView</type>* <name>pView</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkDestroyBufferView</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param optional="true" externsync="true"><type>VkBufferView</type> <name>bufferView</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
            <proto><type>VkResult</type> <name>vkCreateImage</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkImageCreateInfo</type>* <name>pCreateInfo</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param><type>VkImage</type>* <name>pImage</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkDestroyImage</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param optional="true" externsync="true"><type>VkImage</type> <name>image</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkGetImageSubresourceLayout</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>VkImage</type> <name>image</name></param>
            <param>const <type>VkImageSubresource</type>* <name>pSubresource</name></param>
            <param><type>VkSubresourceLayout</type>* <name>pLayout</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
            <proto><type>VkResult</type> <name>vkCreateImageView</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkImageViewCreateInfo</type>* <name>pCreateInfo</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param><type>VkImageView</type>* <name>pView</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkDestroyImageView</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param optional="true" externsync="true"><type>VkImageView</type> <name>imageView</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_INVALID_SHADER_NV">
            <proto><type>VkResult</type> <name>vkCreateShaderModule</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkShaderModuleCreateInfo</type>* <name>pCreateInfo</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param><type>VkShaderModule</type>* <name>pShaderModule</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkDestroyShaderModule</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param optional="true" externsync="true"><type>VkShaderModule</type> <name>shaderModule</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
            <proto><type>VkResult</type> <name>vkCreatePipelineCache</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkPipelineCacheCreateInfo</type>* <name>pCreateInfo</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param><type>VkPipelineCache</type>* <name>pPipelineCache</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkDestroyPipelineCache</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param optional="true" externsync="true"><type>VkPipelineCache</type> <name>pipelineCache</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
        </command>
        <command successcodes="VK_SUCCESS,VK_INCOMPLETE" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
            <proto><type>VkResult</type> <name>vkGetPipelineCacheData</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>VkPipelineCache</type> <name>pipelineCache</name></param>
            <param optional="false,true"><type>size_t</type>* <name>pDataSize</name></param>
            <param optional="true" len="pDataSize"><type>void</type>* <name>pData</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
            <proto><type>VkResult</type> <name>vkMergePipelineCaches</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param externsync="true"><type>VkPipelineCache</type> <name>dstCache</name></param>
            <param><type>uint32_t</type> <name>srcCacheCount</name></param>
            <param len="srcCacheCount">const <type>VkPipelineCache</type>* <name>pSrcCaches</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_INVALID_SHADER_NV">
            <proto><type>VkResult</type> <name>vkCreateGraphicsPipelines</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param optional="true"><type>VkPipelineCache</type> <name>pipelineCache</name></param>
            <param><type>uint32_t</type> <name>createInfoCount</name></param>
            <param len="createInfoCount">const <type>VkGraphicsPipelineCreateInfo</type>* <name>pCreateInfos</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param len="createInfoCount"><type>VkPipeline</type>* <name>pPipelines</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_INVALID_SHADER_NV">
            <proto><type>VkResult</type> <name>vkCreateComputePipelines</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param optional="true"><type>VkPipelineCache</type> <name>pipelineCache</name></param>
            <param><type>uint32_t</type> <name>createInfoCount</name></param>
            <param len="createInfoCount">const <type>VkComputePipelineCreateInfo</type>* <name>pCreateInfos</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param len="createInfoCount"><type>VkPipeline</type>* <name>pPipelines</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkDestroyPipeline</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param optional="true" externsync="true"><type>VkPipeline</type> <name>pipeline</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
            <proto><type>VkResult</type> <name>vkCreatePipelineLayout</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkPipelineLayoutCreateInfo</type>* <name>pCreateInfo</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param><type>VkPipelineLayout</type>* <name>pPipelineLayout</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkDestroyPipelineLayout</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param optional="true" externsync="true"><type>VkPipelineLayout</type> <name>pipelineLayout</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_TOO_MANY_OBJECTS">
            <proto><type>VkResult</type> <name>vkCreateSampler</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkSamplerCreateInfo</type>* <name>pCreateInfo</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param><type>VkSampler</type>* <name>pSampler</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkDestroySampler</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param optional="true" externsync="true"><type>VkSampler</type> <name>sampler</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
            <proto><type>VkResult</type> <name>vkCreateDescriptorSetLayout</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkDescriptorSetLayoutCreateInfo</type>* <name>pCreateInfo</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param><type>VkDescriptorSetLayout</type>* <name>pSetLayout</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkDestroyDescriptorSetLayout</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param optional="true" externsync="true"><type>VkDescriptorSetLayout</type> <name>descriptorSetLayout</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_FRAGMENTATION_EXT">
            <proto><type>VkResult</type> <name>vkCreateDescriptorPool</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkDescriptorPoolCreateInfo</type>* <name>pCreateInfo</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param><type>VkDescriptorPool</type>* <name>pDescriptorPool</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkDestroyDescriptorPool</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param optional="true" externsync="true"><type>VkDescriptorPool</type> <name>descriptorPool</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
            <proto><type>VkResult</type> <name>vkResetDescriptorPool</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param externsync="true"><type>VkDescriptorPool</type> <name>descriptorPool</name></param>
            <param optional="true"><type>VkDescriptorPoolResetFlags</type> <name>flags</name></param>
            <implicitexternsyncparams>
                <param>any sname:VkDescriptorSet objects allocated from pname:descriptorPool</param>
            </implicitexternsyncparams>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_FRAGMENTED_POOL,VK_ERROR_OUT_OF_POOL_MEMORY">
            <proto><type>VkResult</type> <name>vkAllocateDescriptorSets</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param externsync="pAllocateInfo::descriptorPool">const <type>VkDescriptorSetAllocateInfo</type>* <name>pAllocateInfo</name></param>
            <param len="pAllocateInfo::descriptorSetCount"><type>VkDescriptorSet</type>* <name>pDescriptorSets</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
            <proto><type>VkResult</type> <name>vkFreeDescriptorSets</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param externsync="true"><type>VkDescriptorPool</type> <name>descriptorPool</name></param>
            <param><type>uint32_t</type> <name>descriptorSetCount</name></param>
            <param noautovalidity="true" externsync="true" len="descriptorSetCount">const <type>VkDescriptorSet</type>* <name>pDescriptorSets</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkUpdateDescriptorSets</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param optional="true"><type>uint32_t</type> <name>descriptorWriteCount</name></param>
            <param len="descriptorWriteCount" externsync="pDescriptorWrites[].dstSet">const <type>VkWriteDescriptorSet</type>* <name>pDescriptorWrites</name></param>
            <param optional="true"><type>uint32_t</type> <name>descriptorCopyCount</name></param>
            <param len="descriptorCopyCount" externsync="pDescriptorCopies[].dstSet">const <type>VkCopyDescriptorSet</type>* <name>pDescriptorCopies</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
            <proto><type>VkResult</type> <name>vkCreateFramebuffer</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkFramebufferCreateInfo</type>* <name>pCreateInfo</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param><type>VkFramebuffer</type>* <name>pFramebuffer</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkDestroyFramebuffer</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param optional="true" externsync="true"><type>VkFramebuffer</type> <name>framebuffer</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
            <proto><type>VkResult</type> <name>vkCreateRenderPass</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkRenderPassCreateInfo</type>* <name>pCreateInfo</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param><type>VkRenderPass</type>* <name>pRenderPass</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkDestroyRenderPass</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param optional="true" externsync="true"><type>VkRenderPass</type> <name>renderPass</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkGetRenderAreaGranularity</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>VkRenderPass</type> <name>renderPass</name></param>
            <param><type>VkExtent2D</type>* <name>pGranularity</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
            <proto><type>VkResult</type> <name>vkCreateCommandPool</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkCommandPoolCreateInfo</type>* <name>pCreateInfo</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param><type>VkCommandPool</type>* <name>pCommandPool</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkDestroyCommandPool</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param optional="true" externsync="true"><type>VkCommandPool</type> <name>commandPool</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
            <proto><type>VkResult</type> <name>vkResetCommandPool</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param externsync="true"><type>VkCommandPool</type> <name>commandPool</name></param>
            <param optional="true"><type>VkCommandPoolResetFlags</type> <name>flags</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
            <proto><type>VkResult</type> <name>vkAllocateCommandBuffers</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param externsync="pAllocateInfo::commandPool">const <type>VkCommandBufferAllocateInfo</type>* <name>pAllocateInfo</name></param>
            <param len="pAllocateInfo::commandBufferCount"><type>VkCommandBuffer</type>* <name>pCommandBuffers</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkFreeCommandBuffers</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param externsync="true"><type>VkCommandPool</type> <name>commandPool</name></param>
            <param><type>uint32_t</type> <name>commandBufferCount</name></param>
            <param noautovalidity="true" externsync="true" len="commandBufferCount">const <type>VkCommandBuffer</type>* <name>pCommandBuffers</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
            <proto><type>VkResult</type> <name>vkBeginCommandBuffer</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param>const <type>VkCommandBufferBeginInfo</type>* <name>pBeginInfo</name></param>
            <implicitexternsyncparams>
                <param>the sname:VkCommandPool that pname:commandBuffer was allocated from</param>
            </implicitexternsyncparams>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
            <proto><type>VkResult</type> <name>vkEndCommandBuffer</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <implicitexternsyncparams>
                <param>the sname:VkCommandPool that pname:commandBuffer was allocated from</param>
            </implicitexternsyncparams>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
            <proto><type>VkResult</type> <name>vkResetCommandBuffer</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param optional="true"><type>VkCommandBufferResetFlags</type> <name>flags</name></param>
        </command>
        <command queues="graphics,compute" renderpass="both" cmdbufferlevel="primary,secondary">
            <proto><type>void</type> <name>vkCmdBindPipeline</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkPipelineBindPoint</type> <name>pipelineBindPoint</name></param>
            <param><type>VkPipeline</type> <name>pipeline</name></param>
        </command>
        <command queues="graphics" renderpass="both" cmdbufferlevel="primary,secondary">
            <proto><type>void</type> <name>vkCmdSetViewport</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>uint32_t</type> <name>firstViewport</name></param>
            <param><type>uint32_t</type> <name>viewportCount</name></param>
            <param len="viewportCount">const <type>VkViewport</type>* <name>pViewports</name></param>
        </command>
        <command queues="graphics" renderpass="both" cmdbufferlevel="primary,secondary">
            <proto><type>void</type> <name>vkCmdSetScissor</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>uint32_t</type> <name>firstScissor</name></param>
            <param><type>uint32_t</type> <name>scissorCount</name></param>
            <param len="scissorCount">const <type>VkRect2D</type>* <name>pScissors</name></param>
        </command>
        <command queues="graphics" renderpass="both" cmdbufferlevel="primary,secondary">
            <proto><type>void</type> <name>vkCmdSetLineWidth</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>float</type> <name>lineWidth</name></param>
        </command>
        <command queues="graphics" renderpass="both" cmdbufferlevel="primary,secondary">
            <proto><type>void</type> <name>vkCmdSetDepthBias</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>float</type> <name>depthBiasConstantFactor</name></param>
            <param><type>float</type> <name>depthBiasClamp</name></param>
            <param><type>float</type> <name>depthBiasSlopeFactor</name></param>
        </command>
        <command queues="graphics" renderpass="both" cmdbufferlevel="primary,secondary">
            <proto><type>void</type> <name>vkCmdSetBlendConstants</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param>const <type>float</type> <name>blendConstants</name>[4]</param>
        </command>
        <command queues="graphics" renderpass="both" cmdbufferlevel="primary,secondary">
            <proto><type>void</type> <name>vkCmdSetDepthBounds</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>float</type> <name>minDepthBounds</name></param>
            <param><type>float</type> <name>maxDepthBounds</name></param>
        </command>
        <command queues="graphics" renderpass="both" cmdbufferlevel="primary,secondary">
            <proto><type>void</type> <name>vkCmdSetStencilCompareMask</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkStencilFaceFlags</type> <name>faceMask</name></param>
            <param><type>uint32_t</type> <name>compareMask</name></param>
        </command>
        <command queues="graphics" renderpass="both" cmdbufferlevel="primary,secondary">
            <proto><type>void</type> <name>vkCmdSetStencilWriteMask</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkStencilFaceFlags</type> <name>faceMask</name></param>
            <param><type>uint32_t</type> <name>writeMask</name></param>
        </command>
        <command queues="graphics" renderpass="both" cmdbufferlevel="primary,secondary">
            <proto><type>void</type> <name>vkCmdSetStencilReference</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkStencilFaceFlags</type> <name>faceMask</name></param>
            <param><type>uint32_t</type> <name>reference</name></param>
        </command>
        <command queues="graphics,compute" renderpass="both" cmdbufferlevel="primary,secondary">
            <proto><type>void</type> <name>vkCmdBindDescriptorSets</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkPipelineBindPoint</type> <name>pipelineBindPoint</name></param>
            <param><type>VkPipelineLayout</type> <name>layout</name></param>
            <param><type>uint32_t</type> <name>firstSet</name></param>
            <param><type>uint32_t</type> <name>descriptorSetCount</name></param>
            <param len="descriptorSetCount">const <type>VkDescriptorSet</type>* <name>pDescriptorSets</name></param>
            <param optional="true"><type>uint32_t</type> <name>dynamicOffsetCount</name></param>
            <param len="dynamicOffsetCount">const <type>uint32_t</type>* <name>pDynamicOffsets</name></param>
        </command>
        <command queues="graphics" renderpass="both" cmdbufferlevel="primary,secondary">
            <proto><type>void</type> <name>vkCmdBindIndexBuffer</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkBuffer</type> <name>buffer</name></param>
            <param><type>VkDeviceSize</type> <name>offset</name></param>
            <param><type>VkIndexType</type> <name>indexType</name></param>
        </command>
        <command queues="graphics" renderpass="both" cmdbufferlevel="primary,secondary">
            <proto><type>void</type> <name>vkCmdBindVertexBuffers</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>uint32_t</type> <name>firstBinding</name></param>
            <param><type>uint32_t</type> <name>bindingCount</name></param>
            <param len="bindingCount">const <type>VkBuffer</type>* <name>pBuffers</name></param>
            <param len="bindingCount">const <type>VkDeviceSize</type>* <name>pOffsets</name></param>
        </command>
        <command queues="graphics" renderpass="inside" cmdbufferlevel="primary,secondary" pipeline="graphics">
            <proto><type>void</type> <name>vkCmdDraw</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>uint32_t</type> <name>vertexCount</name></param>
            <param><type>uint32_t</type> <name>instanceCount</name></param>
            <param><type>uint32_t</type> <name>firstVertex</name></param>
            <param><type>uint32_t</type> <name>firstInstance</name></param>
        </command>
        <command queues="graphics" renderpass="inside" cmdbufferlevel="primary,secondary" pipeline="graphics">
            <proto><type>void</type> <name>vkCmdDrawIndexed</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>uint32_t</type> <name>indexCount</name></param>
            <param><type>uint32_t</type> <name>instanceCount</name></param>
            <param><type>uint32_t</type> <name>firstIndex</name></param>
            <param><type>int32_t</type> <name>vertexOffset</name></param>
            <param><type>uint32_t</type> <name>firstInstance</name></param>
        </command>
        <command queues="graphics" renderpass="inside" cmdbufferlevel="primary,secondary" pipeline="graphics">
            <proto><type>void</type> <name>vkCmdDrawIndirect</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkBuffer</type> <name>buffer</name></param>
            <param><type>VkDeviceSize</type> <name>offset</name></param>
            <param><type>uint32_t</type> <name>drawCount</name></param>
            <param><type>uint32_t</type> <name>stride</name></param>
        </command>
        <command queues="graphics" renderpass="inside" cmdbufferlevel="primary,secondary" pipeline="graphics">
            <proto><type>void</type> <name>vkCmdDrawIndexedIndirect</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkBuffer</type> <name>buffer</name></param>
            <param><type>VkDeviceSize</type> <name>offset</name></param>
            <param><type>uint32_t</type> <name>drawCount</name></param>
            <param><type>uint32_t</type> <name>stride</name></param>
        </command>
        <command queues="compute" renderpass="outside" cmdbufferlevel="primary,secondary" pipeline="compute">
            <proto><type>void</type> <name>vkCmdDispatch</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>uint32_t</type> <name>groupCountX</name></param>
            <param><type>uint32_t</type> <name>groupCountY</name></param>
            <param><type>uint32_t</type> <name>groupCountZ</name></param>
        </command>
        <command queues="compute" renderpass="outside" cmdbufferlevel="primary,secondary" pipeline="compute">
            <proto><type>void</type> <name>vkCmdDispatchIndirect</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkBuffer</type> <name>buffer</name></param>
            <param><type>VkDeviceSize</type> <name>offset</name></param>
        </command>
        <command queues="transfer,graphics,compute" renderpass="outside" cmdbufferlevel="primary,secondary" pipeline="transfer">
            <proto><type>void</type> <name>vkCmdCopyBuffer</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkBuffer</type> <name>srcBuffer</name></param>
            <param><type>VkBuffer</type> <name>dstBuffer</name></param>
            <param><type>uint32_t</type> <name>regionCount</name></param>
            <param len="regionCount">const <type>VkBufferCopy</type>* <name>pRegions</name></param>
        </command>
        <command queues="transfer,graphics,compute" renderpass="outside" cmdbufferlevel="primary,secondary" pipeline="transfer">
            <proto><type>void</type> <name>vkCmdCopyImage</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkImage</type> <name>srcImage</name></param>
            <param><type>VkImageLayout</type> <name>srcImageLayout</name></param>
            <param><type>VkImage</type> <name>dstImage</name></param>
            <param><type>VkImageLayout</type> <name>dstImageLayout</name></param>
            <param><type>uint32_t</type> <name>regionCount</name></param>
            <param len="regionCount">const <type>VkImageCopy</type>* <name>pRegions</name></param>
        </command>
        <command queues="graphics" renderpass="outside" cmdbufferlevel="primary,secondary" pipeline="transfer">
            <proto><type>void</type> <name>vkCmdBlitImage</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkImage</type> <name>srcImage</name></param>
            <param><type>VkImageLayout</type> <name>srcImageLayout</name></param>
            <param><type>VkImage</type> <name>dstImage</name></param>
            <param><type>VkImageLayout</type> <name>dstImageLayout</name></param>
            <param><type>uint32_t</type> <name>regionCount</name></param>
            <param len="regionCount">const <type>VkImageBlit</type>* <name>pRegions</name></param>
            <param><type>VkFilter</type> <name>filter</name></param>
        </command>
        <command queues="transfer,graphics,compute" renderpass="outside" cmdbufferlevel="primary,secondary" pipeline="transfer">
            <proto><type>void</type> <name>vkCmdCopyBufferToImage</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkBuffer</type> <name>srcBuffer</name></param>
            <param><type>VkImage</type> <name>dstImage</name></param>
            <param><type>VkImageLayout</type> <name>dstImageLayout</name></param>
            <param><type>uint32_t</type> <name>regionCount</name></param>
            <param len="regionCount">const <type>VkBufferImageCopy</type>* <name>pRegions</name></param>
        </command>
        <command queues="transfer,graphics,compute" renderpass="outside" cmdbufferlevel="primary,secondary" pipeline="transfer">
            <proto><type>void</type> <name>vkCmdCopyImageToBuffer</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkImage</type> <name>srcImage</name></param>
            <param><type>VkImageLayout</type> <name>srcImageLayout</name></param>
            <param><type>VkBuffer</type> <name>dstBuffer</name></param>
            <param><type>uint32_t</type> <name>regionCount</name></param>
            <param len="regionCount">const <type>VkBufferImageCopy</type>* <name>pRegions</name></param>
        </command>
        <command queues="transfer,graphics,compute" renderpass="outside" cmdbufferlevel="primary,secondary" pipeline="transfer">
            <proto><type>void</type> <name>vkCmdUpdateBuffer</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkBuffer</type> <name>dstBuffer</name></param>
            <param><type>VkDeviceSize</type> <name>dstOffset</name></param>
            <param><type>VkDeviceSize</type> <name>dataSize</name></param>
            <param len="dataSize">const <type>void</type>* <name>pData</name></param>
        </command>
        <command queues="transfer,graphics,compute" renderpass="outside" cmdbufferlevel="primary,secondary" pipeline="transfer" comment="transfer support is only available when VK_KHR_maintenance1 is enabled, as documented in valid usage language in the specification">
            <proto><type>void</type> <name>vkCmdFillBuffer</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkBuffer</type> <name>dstBuffer</name></param>
            <param><type>VkDeviceSize</type> <name>dstOffset</name></param>
            <param><type>VkDeviceSize</type> <name>size</name></param>
            <param><type>uint32_t</type> <name>data</name></param>
        </command>
        <command queues="graphics,compute" renderpass="outside" cmdbufferlevel="primary,secondary" pipeline="transfer">
            <proto><type>void</type> <name>vkCmdClearColorImage</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkImage</type> <name>image</name></param>
            <param><type>VkImageLayout</type> <name>imageLayout</name></param>
            <param>const <type>VkClearColorValue</type>* <name>pColor</name></param>
            <param><type>uint32_t</type> <name>rangeCount</name></param>
            <param len="rangeCount">const <type>VkImageSubresourceRange</type>* <name>pRanges</name></param>
        </command>
        <command queues="graphics" renderpass="outside" cmdbufferlevel="primary,secondary" pipeline="transfer">
            <proto><type>void</type> <name>vkCmdClearDepthStencilImage</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkImage</type> <name>image</name></param>
            <param><type>VkImageLayout</type> <name>imageLayout</name></param>
            <param>const <type>VkClearDepthStencilValue</type>* <name>pDepthStencil</name></param>
            <param><type>uint32_t</type> <name>rangeCount</name></param>
            <param len="rangeCount">const <type>VkImageSubresourceRange</type>* <name>pRanges</name></param>
        </command>
        <command queues="graphics" renderpass="inside" cmdbufferlevel="primary,secondary" pipeline="graphics">
            <proto><type>void</type> <name>vkCmdClearAttachments</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>uint32_t</type> <name>attachmentCount</name></param>
            <param len="attachmentCount">const <type>VkClearAttachment</type>* <name>pAttachments</name></param>
            <param><type>uint32_t</type> <name>rectCount</name></param>
            <param len="rectCount">const <type>VkClearRect</type>* <name>pRects</name></param>
        </command>
        <command queues="graphics" renderpass="outside" cmdbufferlevel="primary,secondary" pipeline="transfer">
            <proto><type>void</type> <name>vkCmdResolveImage</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkImage</type> <name>srcImage</name></param>
            <param><type>VkImageLayout</type> <name>srcImageLayout</name></param>
            <param><type>VkImage</type> <name>dstImage</name></param>
            <param><type>VkImageLayout</type> <name>dstImageLayout</name></param>
            <param><type>uint32_t</type> <name>regionCount</name></param>
            <param len="regionCount">const <type>VkImageResolve</type>* <name>pRegions</name></param>
        </command>
        <command queues="graphics,compute" renderpass="outside" cmdbufferlevel="primary,secondary">
            <proto><type>void</type> <name>vkCmdSetEvent</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkEvent</type> <name>event</name></param>
            <param><type>VkPipelineStageFlags</type> <name>stageMask</name></param>
        </command>
        <command queues="graphics,compute" renderpass="outside" cmdbufferlevel="primary,secondary">
            <proto><type>void</type> <name>vkCmdResetEvent</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkEvent</type> <name>event</name></param>
            <param><type>VkPipelineStageFlags</type> <name>stageMask</name></param>
        </command>
        <command queues="graphics,compute" renderpass="both" cmdbufferlevel="primary,secondary">
            <proto><type>void</type> <name>vkCmdWaitEvents</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>uint32_t</type> <name>eventCount</name></param>
            <param len="eventCount">const <type>VkEvent</type>* <name>pEvents</name></param>
            <param><type>VkPipelineStageFlags</type> <name>srcStageMask</name></param>
            <param><type>VkPipelineStageFlags</type> <name>dstStageMask</name></param>
            <param optional="true"><type>uint32_t</type> <name>memoryBarrierCount</name></param>
            <param len="memoryBarrierCount">const <type>VkMemoryBarrier</type>* <name>pMemoryBarriers</name></param>
            <param optional="true"><type>uint32_t</type> <name>bufferMemoryBarrierCount</name></param>
            <param len="bufferMemoryBarrierCount">const <type>VkBufferMemoryBarrier</type>* <name>pBufferMemoryBarriers</name></param>
            <param optional="true"><type>uint32_t</type> <name>imageMemoryBarrierCount</name></param>
            <param len="imageMemoryBarrierCount">const <type>VkImageMemoryBarrier</type>* <name>pImageMemoryBarriers</name></param>
        </command>
        <command queues="transfer,graphics,compute" renderpass="both" cmdbufferlevel="primary,secondary">
            <proto><type>void</type> <name>vkCmdPipelineBarrier</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkPipelineStageFlags</type> <name>srcStageMask</name></param>
            <param><type>VkPipelineStageFlags</type> <name>dstStageMask</name></param>
            <param optional="true"><type>VkDependencyFlags</type> <name>dependencyFlags</name></param>
            <param optional="true"><type>uint32_t</type> <name>memoryBarrierCount</name></param>
            <param len="memoryBarrierCount">const <type>VkMemoryBarrier</type>* <name>pMemoryBarriers</name></param>
            <param optional="true"><type>uint32_t</type> <name>bufferMemoryBarrierCount</name></param>
            <param len="bufferMemoryBarrierCount">const <type>VkBufferMemoryBarrier</type>* <name>pBufferMemoryBarriers</name></param>
            <param optional="true"><type>uint32_t</type> <name>imageMemoryBarrierCount</name></param>
            <param len="imageMemoryBarrierCount">const <type>VkImageMemoryBarrier</type>* <name>pImageMemoryBarriers</name></param>
        </command>
        <command queues="graphics,compute" renderpass="both" cmdbufferlevel="primary,secondary">
            <proto><type>void</type> <name>vkCmdBeginQuery</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkQueryPool</type> <name>queryPool</name></param>
            <param><type>uint32_t</type> <name>query</name></param>
            <param optional="true"><type>VkQueryControlFlags</type> <name>flags</name></param>
        </command>
        <command queues="graphics,compute" renderpass="both" cmdbufferlevel="primary,secondary">
            <proto><type>void</type> <name>vkCmdEndQuery</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkQueryPool</type> <name>queryPool</name></param>
            <param><type>uint32_t</type> <name>query</name></param>
        </command>
        <command queues="graphics,compute" renderpass="both" cmdbufferlevel="primary,secondary">
            <proto><type>void</type> <name>vkCmdBeginConditionalRenderingEXT</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param>const <type>VkConditionalRenderingBeginInfoEXT</type>* <name>pConditionalRenderingBegin</name></param>
        </command>
        <command queues="graphics,compute" renderpass="both" cmdbufferlevel="primary,secondary">
            <proto><type>void</type> <name>vkCmdEndConditionalRenderingEXT</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
        </command>
        <command queues="graphics,compute" renderpass="outside" cmdbufferlevel="primary,secondary">
            <proto><type>void</type> <name>vkCmdResetQueryPool</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkQueryPool</type> <name>queryPool</name></param>
            <param><type>uint32_t</type> <name>firstQuery</name></param>
            <param><type>uint32_t</type> <name>queryCount</name></param>
        </command>
        <command queues="transfer,graphics,compute" renderpass="both" cmdbufferlevel="primary,secondary" pipeline="transfer">
            <proto><type>void</type> <name>vkCmdWriteTimestamp</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkPipelineStageFlagBits</type> <name>pipelineStage</name></param>
            <param><type>VkQueryPool</type> <name>queryPool</name></param>
            <param><type>uint32_t</type> <name>query</name></param>
        </command>
        <command queues="graphics,compute" renderpass="outside" cmdbufferlevel="primary,secondary" pipeline="transfer">
            <proto><type>void</type> <name>vkCmdCopyQueryPoolResults</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkQueryPool</type> <name>queryPool</name></param>
            <param><type>uint32_t</type> <name>firstQuery</name></param>
            <param><type>uint32_t</type> <name>queryCount</name></param>
            <param><type>VkBuffer</type> <name>dstBuffer</name></param>
            <param><type>VkDeviceSize</type> <name>dstOffset</name></param>
            <param><type>VkDeviceSize</type> <name>stride</name></param>
            <param optional="true"><type>VkQueryResultFlags</type> <name>flags</name></param>
        </command>
        <command queues="graphics,compute" renderpass="both" cmdbufferlevel="primary,secondary">
            <proto><type>void</type> <name>vkCmdPushConstants</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkPipelineLayout</type> <name>layout</name></param>
            <param><type>VkShaderStageFlags</type> <name>stageFlags</name></param>
            <param><type>uint32_t</type> <name>offset</name></param>
            <param><type>uint32_t</type> <name>size</name></param>
            <param len="size">const <type>void</type>* <name>pValues</name></param>
        </command>
        <command queues="graphics" renderpass="outside" cmdbufferlevel="primary" pipeline="graphics">
            <proto><type>void</type> <name>vkCmdBeginRenderPass</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param>const <type>VkRenderPassBeginInfo</type>* <name>pRenderPassBegin</name></param>
            <param><type>VkSubpassContents</type> <name>contents</name></param>
        </command>
        <command queues="graphics" renderpass="inside" cmdbufferlevel="primary" pipeline="graphics">
            <proto><type>void</type> <name>vkCmdNextSubpass</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkSubpassContents</type> <name>contents</name></param>
        </command>
        <command queues="graphics" renderpass="inside" cmdbufferlevel="primary" pipeline="graphics">
            <proto><type>void</type> <name>vkCmdEndRenderPass</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
        </command>
        <command queues="transfer,graphics,compute" renderpass="both" cmdbufferlevel="primary">
            <proto><type>void</type> <name>vkCmdExecuteCommands</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>uint32_t</type> <name>commandBufferCount</name></param>
            <param len="commandBufferCount">const <type>VkCommandBuffer</type>* <name>pCommandBuffers</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_NATIVE_WINDOW_IN_USE_KHR">
            <proto><type>VkResult</type> <name>vkCreateAndroidSurfaceKHR</name></proto>
            <param><type>VkInstance</type> <name>instance</name></param>
            <param>const <type>VkAndroidSurfaceCreateInfoKHR</type>* <name>pCreateInfo</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param><type>VkSurfaceKHR</type>* <name>pSurface</name></param>
        </command>
        <command successcodes="VK_SUCCESS,VK_INCOMPLETE" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
            <proto><type>VkResult</type> <name>vkGetPhysicalDeviceDisplayPropertiesKHR</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param optional="false,true"><type>uint32_t</type>* <name>pPropertyCount</name></param>
            <param optional="true" len="pPropertyCount"><type>VkDisplayPropertiesKHR</type>* <name>pProperties</name></param>
        </command>
        <command successcodes="VK_SUCCESS,VK_INCOMPLETE" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
            <proto><type>VkResult</type> <name>vkGetPhysicalDeviceDisplayPlanePropertiesKHR</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param optional="false,true"><type>uint32_t</type>* <name>pPropertyCount</name></param>
            <param optional="true" len="pPropertyCount"><type>VkDisplayPlanePropertiesKHR</type>* <name>pProperties</name></param>
        </command>
        <command successcodes="VK_SUCCESS,VK_INCOMPLETE" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
            <proto><type>VkResult</type> <name>vkGetDisplayPlaneSupportedDisplaysKHR</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param><type>uint32_t</type> <name>planeIndex</name></param>
            <param optional="false,true"><type>uint32_t</type>* <name>pDisplayCount</name></param>
            <param optional="true" len="pDisplayCount"><type>VkDisplayKHR</type>* <name>pDisplays</name></param>
        </command>
        <command successcodes="VK_SUCCESS,VK_INCOMPLETE" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
            <proto><type>VkResult</type> <name>vkGetDisplayModePropertiesKHR</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param><type>VkDisplayKHR</type> <name>display</name></param>
            <param optional="false,true"><type>uint32_t</type>* <name>pPropertyCount</name></param>
            <param optional="true" len="pPropertyCount"><type>VkDisplayModePropertiesKHR</type>* <name>pProperties</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_INITIALIZATION_FAILED">
            <proto><type>VkResult</type> <name>vkCreateDisplayModeKHR</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param externsync="true"><type>VkDisplayKHR</type> <name>display</name></param>
            <param>const <type>VkDisplayModeCreateInfoKHR</type>* <name>pCreateInfo</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param><type>VkDisplayModeKHR</type>* <name>pMode</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
            <proto><type>VkResult</type> <name>vkGetDisplayPlaneCapabilitiesKHR</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param externsync="true"><type>VkDisplayModeKHR</type> <name>mode</name></param>
            <param><type>uint32_t</type> <name>planeIndex</name></param>
            <param><type>VkDisplayPlaneCapabilitiesKHR</type>* <name>pCapabilities</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
            <proto><type>VkResult</type> <name>vkCreateDisplayPlaneSurfaceKHR</name></proto>
            <param><type>VkInstance</type> <name>instance</name></param>
            <param>const <type>VkDisplaySurfaceCreateInfoKHR</type>* <name>pCreateInfo</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param><type>VkSurfaceKHR</type>* <name>pSurface</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_INCOMPATIBLE_DISPLAY_KHR,VK_ERROR_DEVICE_LOST,VK_ERROR_SURFACE_LOST_KHR">
            <proto><type>VkResult</type> <name>vkCreateSharedSwapchainsKHR</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>uint32_t</type> <name>swapchainCount</name></param>
            <param len="swapchainCount" externsync="pCreateInfos[].surface,pCreateInfos[].oldSwapchain">const <type>VkSwapchainCreateInfoKHR</type>* <name>pCreateInfos</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param len="swapchainCount"><type>VkSwapchainKHR</type>* <name>pSwapchains</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkDestroySurfaceKHR</name></proto>
            <param><type>VkInstance</type> <name>instance</name></param>
            <param optional="true" externsync="true"><type>VkSurfaceKHR</type> <name>surface</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_SURFACE_LOST_KHR">
            <proto><type>VkResult</type> <name>vkGetPhysicalDeviceSurfaceSupportKHR</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param><type>uint32_t</type> <name>queueFamilyIndex</name></param>
            <param><type>VkSurfaceKHR</type> <name>surface</name></param>
            <param><type>VkBool32</type>* <name>pSupported</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_SURFACE_LOST_KHR">
            <proto><type>VkResult</type> <name>vkGetPhysicalDeviceSurfaceCapabilitiesKHR</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param><type>VkSurfaceKHR</type> <name>surface</name></param>
            <param><type>VkSurfaceCapabilitiesKHR</type>* <name>pSurfaceCapabilities</name></param>
        </command>
        <command successcodes="VK_SUCCESS,VK_INCOMPLETE" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_SURFACE_LOST_KHR">
            <proto><type>VkResult</type> <name>vkGetPhysicalDeviceSurfaceFormatsKHR</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param><type>VkSurfaceKHR</type> <name>surface</name></param>
            <param optional="false,true"><type>uint32_t</type>* <name>pSurfaceFormatCount</name></param>
            <param optional="true" len="pSurfaceFormatCount"><type>VkSurfaceFormatKHR</type>* <name>pSurfaceFormats</name></param>
        </command>
        <command successcodes="VK_SUCCESS,VK_INCOMPLETE" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_SURFACE_LOST_KHR">
            <proto><type>VkResult</type> <name>vkGetPhysicalDeviceSurfacePresentModesKHR</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param><type>VkSurfaceKHR</type> <name>surface</name></param>
            <param optional="false,true"><type>uint32_t</type>* <name>pPresentModeCount</name></param>
            <param optional="true" len="pPresentModeCount"><type>VkPresentModeKHR</type>* <name>pPresentModes</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_DEVICE_LOST,VK_ERROR_SURFACE_LOST_KHR,VK_ERROR_NATIVE_WINDOW_IN_USE_KHR,VK_ERROR_INITIALIZATION_FAILED">
            <proto><type>VkResult</type> <name>vkCreateSwapchainKHR</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param externsync="pCreateInfo.surface,pCreateInfo.oldSwapchain">const <type>VkSwapchainCreateInfoKHR</type>* <name>pCreateInfo</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param><type>VkSwapchainKHR</type>* <name>pSwapchain</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkDestroySwapchainKHR</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param optional="true" externsync="true"><type>VkSwapchainKHR</type> <name>swapchain</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
        </command>
        <command successcodes="VK_SUCCESS,VK_INCOMPLETE" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
            <proto><type>VkResult</type> <name>vkGetSwapchainImagesKHR</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>VkSwapchainKHR</type> <name>swapchain</name></param>
            <param optional="false,true"><type>uint32_t</type>* <name>pSwapchainImageCount</name></param>
            <param optional="true" len="pSwapchainImageCount"><type>VkImage</type>* <name>pSwapchainImages</name></param>
        </command>
        <command successcodes="VK_SUCCESS,VK_TIMEOUT,VK_NOT_READY,VK_SUBOPTIMAL_KHR" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_DEVICE_LOST,VK_ERROR_OUT_OF_DATE_KHR,VK_ERROR_SURFACE_LOST_KHR,VK_ERROR_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT">
            <proto><type>VkResult</type> <name>vkAcquireNextImageKHR</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param externsync="true"><type>VkSwapchainKHR</type> <name>swapchain</name></param>
            <param><type>uint64_t</type> <name>timeout</name></param>
            <param optional="true" externsync="true"><type>VkSemaphore</type> <name>semaphore</name></param>
            <param optional="true" externsync="true"><type>VkFence</type> <name>fence</name></param>
            <param><type>uint32_t</type>* <name>pImageIndex</name></param>
        </command>
        <command successcodes="VK_SUCCESS,VK_SUBOPTIMAL_KHR" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_DEVICE_LOST,VK_ERROR_OUT_OF_DATE_KHR,VK_ERROR_SURFACE_LOST_KHR,VK_ERROR_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT">
            <proto><type>VkResult</type> <name>vkQueuePresentKHR</name></proto>
            <param externsync="true"><type>VkQueue</type> <name>queue</name></param>
            <param externsync="pPresentInfo.pWaitSemaphores[],pPresentInfo.pSwapchains[]">const <type>VkPresentInfoKHR</type>* <name>pPresentInfo</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_NATIVE_WINDOW_IN_USE_KHR">
            <proto><type>VkResult</type> <name>vkCreateViSurfaceNN</name></proto>
            <param><type>VkInstance</type> <name>instance</name></param>
            <param>const <type>VkViSurfaceCreateInfoNN</type>* <name>pCreateInfo</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param><type>VkSurfaceKHR</type>* <name>pSurface</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
            <proto><type>VkResult</type> <name>vkCreateWaylandSurfaceKHR</name></proto>
            <param><type>VkInstance</type> <name>instance</name></param>
            <param>const <type>VkWaylandSurfaceCreateInfoKHR</type>* <name>pCreateInfo</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param><type>VkSurfaceKHR</type>* <name>pSurface</name></param>
        </command>
        <command>
            <proto><type>VkBool32</type> <name>vkGetPhysicalDeviceWaylandPresentationSupportKHR</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param><type>uint32_t</type> <name>queueFamilyIndex</name></param>
            <param>struct <type>wl_display</type>* <name>display</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
            <proto><type>VkResult</type> <name>vkCreateWin32SurfaceKHR</name></proto>
            <param><type>VkInstance</type> <name>instance</name></param>
            <param>const <type>VkWin32SurfaceCreateInfoKHR</type>* <name>pCreateInfo</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param><type>VkSurfaceKHR</type>* <name>pSurface</name></param>
        </command>
        <command>
            <proto><type>VkBool32</type> <name>vkGetPhysicalDeviceWin32PresentationSupportKHR</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param><type>uint32_t</type> <name>queueFamilyIndex</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
            <proto><type>VkResult</type> <name>vkCreateXlibSurfaceKHR</name></proto>
            <param><type>VkInstance</type> <name>instance</name></param>
            <param>const <type>VkXlibSurfaceCreateInfoKHR</type>* <name>pCreateInfo</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param><type>VkSurfaceKHR</type>* <name>pSurface</name></param>
        </command>
        <command>
            <proto><type>VkBool32</type> <name>vkGetPhysicalDeviceXlibPresentationSupportKHR</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param><type>uint32_t</type> <name>queueFamilyIndex</name></param>
            <param><type>Display</type>* <name>dpy</name></param>
            <param><type>VisualID</type> <name>visualID</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
            <proto><type>VkResult</type> <name>vkCreateXcbSurfaceKHR</name></proto>
            <param><type>VkInstance</type> <name>instance</name></param>
            <param>const <type>VkXcbSurfaceCreateInfoKHR</type>* <name>pCreateInfo</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param><type>VkSurfaceKHR</type>* <name>pSurface</name></param>
        </command>
        <command>
            <proto><type>VkBool32</type> <name>vkGetPhysicalDeviceXcbPresentationSupportKHR</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param><type>uint32_t</type> <name>queueFamilyIndex</name></param>
            <param><type>xcb_connection_t</type>* <name>connection</name></param>
            <param><type>xcb_visualid_t</type> <name>visual_id</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
            <proto><type>VkResult</type> <name>vkCreateImagePipeSurfaceFUCHSIA</name></proto>
            <param><type>VkInstance</type> <name>instance</name></param>
            <param>const <type>VkImagePipeSurfaceCreateInfoFUCHSIA</type>* <name>pCreateInfo</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param><type>VkSurfaceKHR</type>* <name>pSurface</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_NATIVE_WINDOW_IN_USE_KHR">
            <proto><type>VkResult</type> <name>vkCreateStreamDescriptorSurfaceGGP</name></proto>
            <param><type>VkInstance</type> <name>instance</name></param>
            <param>const <type>VkStreamDescriptorSurfaceCreateInfoGGP</type>* <name>pCreateInfo</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param><type>VkSurfaceKHR</type>* <name>pSurface</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY">
            <proto><type>VkResult</type> <name>vkCreateDebugReportCallbackEXT</name></proto>
            <param><type>VkInstance</type> <name>instance</name></param>
            <param>const <type>VkDebugReportCallbackCreateInfoEXT</type>* <name>pCreateInfo</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param><type>VkDebugReportCallbackEXT</type>* <name>pCallback</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkDestroyDebugReportCallbackEXT</name></proto>
            <param><type>VkInstance</type> <name>instance</name></param>
            <param externsync="true"><type>VkDebugReportCallbackEXT</type> <name>callback</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkDebugReportMessageEXT</name></proto>
            <param><type>VkInstance</type> <name>instance</name></param>
            <param><type>VkDebugReportFlagsEXT</type> <name>flags</name></param>
            <param><type>VkDebugReportObjectTypeEXT</type> <name>objectType</name></param>
            <param><type>uint64_t</type> <name>object</name></param>
            <param><type>size_t</type> <name>location</name></param>
            <param><type>int32_t</type> <name>messageCode</name></param>
            <param len="null-terminated">const <type>char</type>* <name>pLayerPrefix</name></param>
            <param len="null-terminated">const <type>char</type>* <name>pMessage</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
            <proto><type>VkResult</type> <name>vkDebugMarkerSetObjectNameEXT</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param externsync="pNameInfo.object">const <type>VkDebugMarkerObjectNameInfoEXT</type>* <name>pNameInfo</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
            <proto><type>VkResult</type> <name>vkDebugMarkerSetObjectTagEXT</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param externsync="pTagInfo.object">const <type>VkDebugMarkerObjectTagInfoEXT</type>* <name>pTagInfo</name></param>
        </command>
        <command queues="graphics,compute" renderpass="both" cmdbufferlevel="primary,secondary">
            <proto><type>void</type> <name>vkCmdDebugMarkerBeginEXT</name></proto>
            <param><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param>const <type>VkDebugMarkerMarkerInfoEXT</type>* <name>pMarkerInfo</name></param>
        </command>
        <command queues="graphics,compute" renderpass="both" cmdbufferlevel="primary,secondary">
            <proto><type>void</type> <name>vkCmdDebugMarkerEndEXT</name></proto>
            <param><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
        </command>
        <command queues="graphics,compute" renderpass="both" cmdbufferlevel="primary,secondary">
            <proto><type>void</type> <name>vkCmdDebugMarkerInsertEXT</name></proto>
            <param><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param>const <type>VkDebugMarkerMarkerInfoEXT</type>* <name>pMarkerInfo</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_FORMAT_NOT_SUPPORTED">
            <proto><type>VkResult</type> <name>vkGetPhysicalDeviceExternalImageFormatPropertiesNV</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param><type>VkFormat</type> <name>format</name></param>
            <param><type>VkImageType</type> <name>type</name></param>
            <param><type>VkImageTiling</type> <name>tiling</name></param>
            <param><type>VkImageUsageFlags</type> <name>usage</name></param>
            <param optional="true"><type>VkImageCreateFlags</type> <name>flags</name></param>
            <param optional="true"><type>VkExternalMemoryHandleTypeFlagsNV</type> <name>externalHandleType</name></param>
            <param><type>VkExternalImageFormatPropertiesNV</type>* <name>pExternalImageFormatProperties</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_TOO_MANY_OBJECTS,VK_ERROR_OUT_OF_HOST_MEMORY">
            <proto><type>VkResult</type> <name>vkGetMemoryWin32HandleNV</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>VkDeviceMemory</type> <name>memory</name></param>
            <param><type>VkExternalMemoryHandleTypeFlagsNV</type> <name>handleType</name></param>
            <param><type>HANDLE</type>* <name>pHandle</name></param>
        </command>
        <command queues="graphics,compute" renderpass="inside" cmdbufferlevel="primary,secondary">
            <proto><type>void</type> <name>vkCmdProcessCommandsNVX</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param>const <type>VkCmdProcessCommandsInfoNVX</type>* <name>pProcessCommandsInfo</name></param>
        </command>
        <command queues="graphics,compute" renderpass="inside" cmdbufferlevel="secondary">
            <proto><type>void</type> <name>vkCmdReserveSpaceForCommandsNVX</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param>const <type>VkCmdReserveSpaceForCommandsInfoNVX</type>* <name>pReserveSpaceInfo</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
            <proto><type>VkResult</type> <name>vkCreateIndirectCommandsLayoutNVX</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkIndirectCommandsLayoutCreateInfoNVX</type>* <name>pCreateInfo</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param><type>VkIndirectCommandsLayoutNVX</type>* <name>pIndirectCommandsLayout</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkDestroyIndirectCommandsLayoutNVX</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>VkIndirectCommandsLayoutNVX</type> <name>indirectCommandsLayout</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
            <proto><type>VkResult</type> <name>vkCreateObjectTableNVX</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkObjectTableCreateInfoNVX</type>* <name>pCreateInfo</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param><type>VkObjectTableNVX</type>* <name>pObjectTable</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkDestroyObjectTableNVX</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param externsync="true"><type>VkObjectTableNVX</type> <name>objectTable</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
            <proto><type>VkResult</type> <name>vkRegisterObjectsNVX</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param externsync="true"><type>VkObjectTableNVX</type> <name>objectTable</name></param>
            <param><type>uint32_t</type> <name>objectCount</name></param>
            <param len="objectCount">const <type>VkObjectTableEntryNVX</type>* const*    <name>ppObjectTableEntries</name></param>
            <param len="objectCount">const <type>uint32_t</type>* <name>pObjectIndices</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
            <proto><type>VkResult</type> <name>vkUnregisterObjectsNVX</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param externsync="true"><type>VkObjectTableNVX</type> <name>objectTable</name></param>
            <param><type>uint32_t</type> <name>objectCount</name></param>
            <param len="objectCount">const <type>VkObjectEntryTypeNVX</type>* <name>pObjectEntryTypes</name></param>
            <param len="objectCount">const <type>uint32_t</type>* <name>pObjectIndices</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param><type>VkDeviceGeneratedCommandsFeaturesNVX</type>* <name>pFeatures</name></param>
            <param><type>VkDeviceGeneratedCommandsLimitsNVX</type>* <name>pLimits</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkGetPhysicalDeviceFeatures2</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param><type>VkPhysicalDeviceFeatures2</type>* <name>pFeatures</name></param>
        </command>
        <command name="vkGetPhysicalDeviceFeatures2KHR"                        alias="vkGetPhysicalDeviceFeatures2"/>
        <command>
            <proto><type>void</type> <name>vkGetPhysicalDeviceProperties2</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param><type>VkPhysicalDeviceProperties2</type>* <name>pProperties</name></param>
        </command>
        <command name="vkGetPhysicalDeviceProperties2KHR"                      alias="vkGetPhysicalDeviceProperties2"/>
        <command>
            <proto><type>void</type> <name>vkGetPhysicalDeviceFormatProperties2</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param><type>VkFormat</type> <name>format</name></param>
            <param><type>VkFormatProperties2</type>* <name>pFormatProperties</name></param>
        </command>
        <command name="vkGetPhysicalDeviceFormatProperties2KHR"                alias="vkGetPhysicalDeviceFormatProperties2"/>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_FORMAT_NOT_SUPPORTED">
            <proto><type>VkResult</type> <name>vkGetPhysicalDeviceImageFormatProperties2</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param>const <type>VkPhysicalDeviceImageFormatInfo2</type>* <name>pImageFormatInfo</name></param>
            <param><type>VkImageFormatProperties2</type>* <name>pImageFormatProperties</name></param>
        </command>
        <command name="vkGetPhysicalDeviceImageFormatProperties2KHR"           alias="vkGetPhysicalDeviceImageFormatProperties2"/>
        <command>
            <proto><type>void</type> <name>vkGetPhysicalDeviceQueueFamilyProperties2</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param optional="false,true"><type>uint32_t</type>* <name>pQueueFamilyPropertyCount</name></param>
            <param optional="true" len="pQueueFamilyPropertyCount"><type>VkQueueFamilyProperties2</type>* <name>pQueueFamilyProperties</name></param>
        </command>
        <command name="vkGetPhysicalDeviceQueueFamilyProperties2KHR"           alias="vkGetPhysicalDeviceQueueFamilyProperties2"/>
        <command>
            <proto><type>void</type> <name>vkGetPhysicalDeviceMemoryProperties2</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param><type>VkPhysicalDeviceMemoryProperties2</type>* <name>pMemoryProperties</name></param>
        </command>
        <command name="vkGetPhysicalDeviceMemoryProperties2KHR"                alias="vkGetPhysicalDeviceMemoryProperties2"/>
        <command>
            <proto><type>void</type> <name>vkGetPhysicalDeviceSparseImageFormatProperties2</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param>const <type>VkPhysicalDeviceSparseImageFormatInfo2</type>* <name>pFormatInfo</name></param>
            <param optional="false,true"><type>uint32_t</type>* <name>pPropertyCount</name></param>
            <param optional="true" len="pPropertyCount"><type>VkSparseImageFormatProperties2</type>* <name>pProperties</name></param>
        </command>
        <command name="vkGetPhysicalDeviceSparseImageFormatProperties2KHR"     alias="vkGetPhysicalDeviceSparseImageFormatProperties2"/>
        <command queues="graphics,compute" renderpass="both" cmdbufferlevel="primary,secondary">
            <proto><type>void</type> <name>vkCmdPushDescriptorSetKHR</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkPipelineBindPoint</type> <name>pipelineBindPoint</name></param>
            <param><type>VkPipelineLayout</type> <name>layout</name></param>
            <param><type>uint32_t</type> <name>set</name></param>
            <param><type>uint32_t</type> <name>descriptorWriteCount</name></param>
            <param len="descriptorWriteCount">const <type>VkWriteDescriptorSet</type>* <name>pDescriptorWrites</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkTrimCommandPool</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param externsync="true"><type>VkCommandPool</type> <name>commandPool</name></param>
            <param optional="true"><type>VkCommandPoolTrimFlags</type> <name>flags</name></param>
        </command>
        <command name="vkTrimCommandPoolKHR"                                   alias="vkTrimCommandPool"/>
        <command>
            <proto><type>void</type> <name>vkGetPhysicalDeviceExternalBufferProperties</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param>const <type>VkPhysicalDeviceExternalBufferInfo</type>* <name>pExternalBufferInfo</name></param>
            <param><type>VkExternalBufferProperties</type>* <name>pExternalBufferProperties</name></param>
        </command>
        <command name="vkGetPhysicalDeviceExternalBufferPropertiesKHR"         alias="vkGetPhysicalDeviceExternalBufferProperties"/>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_TOO_MANY_OBJECTS,VK_ERROR_OUT_OF_HOST_MEMORY">
            <proto><type>VkResult</type> <name>vkGetMemoryWin32HandleKHR</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkMemoryGetWin32HandleInfoKHR</type>* <name>pGetWin32HandleInfo</name></param>
            <param><type>HANDLE</type>* <name>pHandle</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_INVALID_EXTERNAL_HANDLE">
            <proto><type>VkResult</type> <name>vkGetMemoryWin32HandlePropertiesKHR</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>VkExternalMemoryHandleTypeFlagBits</type> <name>handleType</name></param>
            <param><type>HANDLE</type> <name>handle</name></param>
            <param><type>VkMemoryWin32HandlePropertiesKHR</type>* <name>pMemoryWin32HandleProperties</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_TOO_MANY_OBJECTS,VK_ERROR_OUT_OF_HOST_MEMORY">
            <proto><type>VkResult</type> <name>vkGetMemoryFdKHR</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkMemoryGetFdInfoKHR</type>* <name>pGetFdInfo</name></param>
            <param><type>int</type>* <name>pFd</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_INVALID_EXTERNAL_HANDLE">
            <proto><type>VkResult</type> <name>vkGetMemoryFdPropertiesKHR</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>VkExternalMemoryHandleTypeFlagBits</type> <name>handleType</name></param>
            <param><type>int</type> <name>fd</name></param>
            <param><type>VkMemoryFdPropertiesKHR</type>* <name>pMemoryFdProperties</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkGetPhysicalDeviceExternalSemaphoreProperties</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param>const <type>VkPhysicalDeviceExternalSemaphoreInfo</type>* <name>pExternalSemaphoreInfo</name></param>
            <param><type>VkExternalSemaphoreProperties</type>* <name>pExternalSemaphoreProperties</name></param>
        </command>
        <command name="vkGetPhysicalDeviceExternalSemaphorePropertiesKHR"           alias="vkGetPhysicalDeviceExternalSemaphoreProperties"/>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_TOO_MANY_OBJECTS,VK_ERROR_OUT_OF_HOST_MEMORY">
            <proto><type>VkResult</type> <name>vkGetSemaphoreWin32HandleKHR</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkSemaphoreGetWin32HandleInfoKHR</type>* <name>pGetWin32HandleInfo</name></param>
            <param><type>HANDLE</type>* <name>pHandle</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_INVALID_EXTERNAL_HANDLE">
            <proto><type>VkResult</type> <name>vkImportSemaphoreWin32HandleKHR</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkImportSemaphoreWin32HandleInfoKHR</type>* <name>pImportSemaphoreWin32HandleInfo</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_TOO_MANY_OBJECTS,VK_ERROR_OUT_OF_HOST_MEMORY">
            <proto><type>VkResult</type> <name>vkGetSemaphoreFdKHR</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkSemaphoreGetFdInfoKHR</type>* <name>pGetFdInfo</name></param>
            <param><type>int</type>* <name>pFd</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_INVALID_EXTERNAL_HANDLE">
            <proto><type>VkResult</type> <name>vkImportSemaphoreFdKHR</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkImportSemaphoreFdInfoKHR</type>* <name>pImportSemaphoreFdInfo</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkGetPhysicalDeviceExternalFenceProperties</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param>const <type>VkPhysicalDeviceExternalFenceInfo</type>* <name>pExternalFenceInfo</name></param>
            <param><type>VkExternalFenceProperties</type>* <name>pExternalFenceProperties</name></param>
        </command>
        <command name="vkGetPhysicalDeviceExternalFencePropertiesKHR"           alias="vkGetPhysicalDeviceExternalFenceProperties"/>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_TOO_MANY_OBJECTS,VK_ERROR_OUT_OF_HOST_MEMORY">
            <proto><type>VkResult</type> <name>vkGetFenceWin32HandleKHR</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkFenceGetWin32HandleInfoKHR</type>* <name>pGetWin32HandleInfo</name></param>
            <param><type>HANDLE</type>* <name>pHandle</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_INVALID_EXTERNAL_HANDLE">
            <proto><type>VkResult</type> <name>vkImportFenceWin32HandleKHR</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkImportFenceWin32HandleInfoKHR</type>* <name>pImportFenceWin32HandleInfo</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_TOO_MANY_OBJECTS,VK_ERROR_OUT_OF_HOST_MEMORY">
            <proto><type>VkResult</type> <name>vkGetFenceFdKHR</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkFenceGetFdInfoKHR</type>* <name>pGetFdInfo</name></param>
            <param><type>int</type>* <name>pFd</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_INVALID_EXTERNAL_HANDLE">
            <proto><type>VkResult</type> <name>vkImportFenceFdKHR</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkImportFenceFdInfoKHR</type>* <name>pImportFenceFdInfo</name></param>
        </command>
        <command successcodes="VK_SUCCESS">
            <proto><type>VkResult</type> <name>vkReleaseDisplayEXT</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param><type>VkDisplayKHR</type> <name>display</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_INITIALIZATION_FAILED">
            <proto><type>VkResult</type> <name>vkAcquireXlibDisplayEXT</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param><type>Display</type>* <name>dpy</name></param>
            <param><type>VkDisplayKHR</type> <name>display</name></param>
        </command>
        <command successcodes="VK_SUCCESS">
            <proto><type>VkResult</type> <name>vkGetRandROutputDisplayEXT</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param><type>Display</type>* <name>dpy</name></param>
            <param><type>RROutput</type> <name>rrOutput</name></param>
            <param><type>VkDisplayKHR</type>* <name>pDisplay</name></param>
        </command>
        <command successcodes="VK_SUCCESS">
            <proto><type>VkResult</type> <name>vkDisplayPowerControlEXT</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>VkDisplayKHR</type> <name>display</name></param>
            <param>const <type>VkDisplayPowerInfoEXT</type>* <name>pDisplayPowerInfo</name></param>
        </command>
        <command successcodes="VK_SUCCESS">
            <proto><type>VkResult</type> <name>vkRegisterDeviceEventEXT</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkDeviceEventInfoEXT</type>* <name>pDeviceEventInfo</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param><type>VkFence</type>* <name>pFence</name></param>
        </command>
        <command successcodes="VK_SUCCESS">
            <proto><type>VkResult</type> <name>vkRegisterDisplayEventEXT</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>VkDisplayKHR</type> <name>display</name></param>
            <param>const <type>VkDisplayEventInfoEXT</type>* <name>pDisplayEventInfo</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param><type>VkFence</type>* <name>pFence</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_DEVICE_LOST,VK_ERROR_OUT_OF_DATE_KHR">
            <proto><type>VkResult</type> <name>vkGetSwapchainCounterEXT</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>VkSwapchainKHR</type> <name>swapchain</name></param>
            <param><type>VkSurfaceCounterFlagBitsEXT</type> <name>counter</name></param>
            <param><type>uint64_t</type>* <name>pCounterValue</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_SURFACE_LOST_KHR">
            <proto><type>VkResult</type> <name>vkGetPhysicalDeviceSurfaceCapabilities2EXT</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param><type>VkSurfaceKHR</type> <name>surface</name></param>
            <param><type>VkSurfaceCapabilities2EXT</type>* <name>pSurfaceCapabilities</name></param>
        </command>
        <command successcodes="VK_SUCCESS,VK_INCOMPLETE" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_INITIALIZATION_FAILED">
            <proto><type>VkResult</type> <name>vkEnumeratePhysicalDeviceGroups</name></proto>
            <param><type>VkInstance</type> <name>instance</name></param>
            <param optional="false,true"><type>uint32_t</type>* <name>pPhysicalDeviceGroupCount</name></param>
            <param optional="true" len="pPhysicalDeviceGroupCount"><type>VkPhysicalDeviceGroupProperties</type>* <name>pPhysicalDeviceGroupProperties</name></param>
        </command>
        <command name="vkEnumeratePhysicalDeviceGroupsKHR"                     alias="vkEnumeratePhysicalDeviceGroups"/>
        <command>
            <proto><type>void</type> <name>vkGetDeviceGroupPeerMemoryFeatures</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>uint32_t</type> <name>heapIndex</name></param>
            <param><type>uint32_t</type> <name>localDeviceIndex</name></param>
            <param><type>uint32_t</type> <name>remoteDeviceIndex</name></param>
            <param><type>VkPeerMemoryFeatureFlags</type>* <name>pPeerMemoryFeatures</name></param>
        </command>
        <command name="vkGetDeviceGroupPeerMemoryFeaturesKHR"                  alias="vkGetDeviceGroupPeerMemoryFeatures"/>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
            <proto><type>VkResult</type> <name>vkBindBufferMemory2</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>uint32_t</type> <name>bindInfoCount</name></param>
            <param len="bindInfoCount">const <type>VkBindBufferMemoryInfo</type>* <name>pBindInfos</name></param>
        </command>
        <command name="vkBindBufferMemory2KHR"                                 alias="vkBindBufferMemory2"/>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
            <proto><type>VkResult</type> <name>vkBindImageMemory2</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>uint32_t</type> <name>bindInfoCount</name></param>
            <param len="bindInfoCount">const <type>VkBindImageMemoryInfo</type>* <name>pBindInfos</name></param>
        </command>
        <command name="vkBindImageMemory2KHR"                                  alias="vkBindImageMemory2"/>
        <command queues="graphics,compute,transfer" renderpass="both" cmdbufferlevel="primary,secondary">
            <proto><type>void</type> <name>vkCmdSetDeviceMask</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>uint32_t</type> <name>deviceMask</name></param>
        </command>
        <command name="vkCmdSetDeviceMaskKHR"                                  alias="vkCmdSetDeviceMask"/>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
            <proto><type>VkResult</type> <name>vkGetDeviceGroupPresentCapabilitiesKHR</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>VkDeviceGroupPresentCapabilitiesKHR</type>* <name>pDeviceGroupPresentCapabilities</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_SURFACE_LOST_KHR">
            <proto><type>VkResult</type> <name>vkGetDeviceGroupSurfacePresentModesKHR</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param externsync="true"><type>VkSurfaceKHR</type> <name>surface</name></param>
            <param optional="false,true"><type>VkDeviceGroupPresentModeFlagsKHR</type>* <name>pModes</name></param>
        </command>
        <command successcodes="VK_SUCCESS,VK_TIMEOUT,VK_NOT_READY,VK_SUBOPTIMAL_KHR" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_DEVICE_LOST,VK_ERROR_OUT_OF_DATE_KHR,VK_ERROR_SURFACE_LOST_KHR,VK_ERROR_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT">
            <proto><type>VkResult</type> <name>vkAcquireNextImage2KHR</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkAcquireNextImageInfoKHR</type>* <name>pAcquireInfo</name></param>
            <param><type>uint32_t</type>* <name>pImageIndex</name></param>
        </command>
        <command queues="compute" renderpass="outside" cmdbufferlevel="primary,secondary">
            <proto><type>void</type> <name>vkCmdDispatchBase</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>uint32_t</type> <name>baseGroupX</name></param>
            <param><type>uint32_t</type> <name>baseGroupY</name></param>
            <param><type>uint32_t</type> <name>baseGroupZ</name></param>
            <param><type>uint32_t</type> <name>groupCountX</name></param>
            <param><type>uint32_t</type> <name>groupCountY</name></param>
            <param><type>uint32_t</type> <name>groupCountZ</name></param>
        </command>
        <command name="vkCmdDispatchBaseKHR"                                   alias="vkCmdDispatchBase"/>
        <command successcodes="VK_SUCCESS,VK_INCOMPLETE" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
            <proto><type>VkResult</type> <name>vkGetPhysicalDevicePresentRectanglesKHR</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param externsync="true"><type>VkSurfaceKHR</type> <name>surface</name></param>
            <param optional="false,true"><type>uint32_t</type>* <name>pRectCount</name></param>
            <param optional="true" len="pRectCount"><type>VkRect2D</type>* <name>pRects</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
            <proto><type>VkResult</type> <name>vkCreateDescriptorUpdateTemplate</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkDescriptorUpdateTemplateCreateInfo</type>* <name>pCreateInfo</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param><type>VkDescriptorUpdateTemplate</type>* <name>pDescriptorUpdateTemplate</name></param>
        </command>
        <command name="vkCreateDescriptorUpdateTemplateKHR"                    alias="vkCreateDescriptorUpdateTemplate"/>
        <command>
            <proto><type>void</type> <name>vkDestroyDescriptorUpdateTemplate</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param optional="true" externsync="true"><type>VkDescriptorUpdateTemplate</type> <name>descriptorUpdateTemplate</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
        </command>
        <command name="vkDestroyDescriptorUpdateTemplateKHR"                   alias="vkDestroyDescriptorUpdateTemplate"/>
        <command>
            <proto><type>void</type> <name>vkUpdateDescriptorSetWithTemplate</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param externsync="true"><type>VkDescriptorSet</type> <name>descriptorSet</name></param>
            <param><type>VkDescriptorUpdateTemplate</type> <name>descriptorUpdateTemplate</name></param>
            <param noautovalidity="true">const <type>void</type>* <name>pData</name></param>
        </command>
        <command name="vkUpdateDescriptorSetWithTemplateKHR"                   alias="vkUpdateDescriptorSetWithTemplate"/>
        <command queues="graphics,compute" renderpass="both" cmdbufferlevel="primary,secondary">
            <proto><type>void</type> <name>vkCmdPushDescriptorSetWithTemplateKHR</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkDescriptorUpdateTemplate</type> <name>descriptorUpdateTemplate</name></param>
            <param><type>VkPipelineLayout</type> <name>layout</name></param>
            <param><type>uint32_t</type> <name>set</name></param>
            <param noautovalidity="true">const <type>void</type>* <name>pData</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkSetHdrMetadataEXT</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>uint32_t</type> <name>swapchainCount</name></param>
            <param len="swapchainCount">const <type>VkSwapchainKHR</type>* <name>pSwapchains</name></param>
            <param len="swapchainCount">const <type>VkHdrMetadataEXT</type>* <name>pMetadata</name></param>
        </command>
        <command successcodes="VK_SUCCESS,VK_SUBOPTIMAL_KHR" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_DEVICE_LOST,VK_ERROR_OUT_OF_DATE_KHR,VK_ERROR_SURFACE_LOST_KHR,VK_ERROR_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT">
            <proto><type>VkResult</type> <name>vkGetSwapchainStatusKHR</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param externsync="true"><type>VkSwapchainKHR</type> <name>swapchain</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_DEVICE_LOST,VK_ERROR_SURFACE_LOST_KHR">
            <proto><type>VkResult</type> <name>vkGetRefreshCycleDurationGOOGLE</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param externsync="true"><type>VkSwapchainKHR</type> <name>swapchain</name></param>
            <param><type>VkRefreshCycleDurationGOOGLE</type>* <name>pDisplayTimingProperties</name></param>
        </command>
        <command successcodes="VK_SUCCESS,VK_INCOMPLETE" errorcodes="VK_ERROR_DEVICE_LOST,VK_ERROR_OUT_OF_DATE_KHR,VK_ERROR_SURFACE_LOST_KHR">
            <proto><type>VkResult</type> <name>vkGetPastPresentationTimingGOOGLE</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param externsync="true"><type>VkSwapchainKHR</type> <name>swapchain</name></param>
            <param optional="false,true"><type>uint32_t</type>* <name>pPresentationTimingCount</name></param>
            <param optional="true" len="pPresentationTimingCount"><type>VkPastPresentationTimingGOOGLE</type>* <name>pPresentationTimings</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_NATIVE_WINDOW_IN_USE_KHR">
            <proto><type>VkResult</type> <name>vkCreateIOSSurfaceMVK</name></proto>
            <param><type>VkInstance</type> <name>instance</name></param>
            <param>const <type>VkIOSSurfaceCreateInfoMVK</type>* <name>pCreateInfo</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param><type>VkSurfaceKHR</type>* <name>pSurface</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_NATIVE_WINDOW_IN_USE_KHR">
            <proto><type>VkResult</type> <name>vkCreateMacOSSurfaceMVK</name></proto>
            <param><type>VkInstance</type> <name>instance</name></param>
            <param>const <type>VkMacOSSurfaceCreateInfoMVK</type>* <name>pCreateInfo</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param><type>VkSurfaceKHR</type>* <name>pSurface</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_NATIVE_WINDOW_IN_USE_KHR">
            <proto><type>VkResult</type> <name>vkCreateMetalSurfaceEXT</name></proto>
            <param><type>VkInstance</type> <name>instance</name></param>
            <param>const <type>VkMetalSurfaceCreateInfoEXT</type>* <name>pCreateInfo</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param><type>VkSurfaceKHR</type>* <name>pSurface</name></param>
        </command>
        <command queues="graphics" renderpass="both" cmdbufferlevel="primary,secondary">
            <proto><type>void</type> <name>vkCmdSetViewportWScalingNV</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>uint32_t</type> <name>firstViewport</name></param>
            <param><type>uint32_t</type> <name>viewportCount</name></param>
            <param len="viewportCount">const <type>VkViewportWScalingNV</type>* <name>pViewportWScalings</name></param>
        </command>
        <command queues="graphics" renderpass="both" cmdbufferlevel="primary,secondary">
            <proto><type>void</type> <name>vkCmdSetDiscardRectangleEXT</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>uint32_t</type> <name>firstDiscardRectangle</name></param>
            <param><type>uint32_t</type> <name>discardRectangleCount</name></param>
            <param len="discardRectangleCount">const <type>VkRect2D</type>* <name>pDiscardRectangles</name></param>
        </command>
        <command queues="graphics" renderpass="both" cmdbufferlevel="primary,secondary">
            <proto><type>void</type> <name>vkCmdSetSampleLocationsEXT</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param>const <type>VkSampleLocationsInfoEXT</type>* <name>pSampleLocationsInfo</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkGetPhysicalDeviceMultisamplePropertiesEXT</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param><type>VkSampleCountFlagBits</type> <name>samples</name></param>
            <param><type>VkMultisamplePropertiesEXT</type>* <name>pMultisampleProperties</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_SURFACE_LOST_KHR">
            <proto><type>VkResult</type> <name>vkGetPhysicalDeviceSurfaceCapabilities2KHR</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param>const <type>VkPhysicalDeviceSurfaceInfo2KHR</type>* <name>pSurfaceInfo</name></param>
            <param><type>VkSurfaceCapabilities2KHR</type>* <name>pSurfaceCapabilities</name></param>
        </command>
        <command successcodes="VK_SUCCESS,VK_INCOMPLETE" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_SURFACE_LOST_KHR">
            <proto><type>VkResult</type> <name>vkGetPhysicalDeviceSurfaceFormats2KHR</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param>const <type>VkPhysicalDeviceSurfaceInfo2KHR</type>* <name>pSurfaceInfo</name></param>
            <param optional="false,true"><type>uint32_t</type>* <name>pSurfaceFormatCount</name></param>
            <param optional="true" len="pSurfaceFormatCount"><type>VkSurfaceFormat2KHR</type>* <name>pSurfaceFormats</name></param>
        </command>
        <command successcodes="VK_SUCCESS,VK_INCOMPLETE" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
            <proto><type>VkResult</type> <name>vkGetPhysicalDeviceDisplayProperties2KHR</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param optional="false,true"><type>uint32_t</type>* <name>pPropertyCount</name></param>
            <param optional="true" len="pPropertyCount"><type>VkDisplayProperties2KHR</type>* <name>pProperties</name></param>
        </command>
        <command successcodes="VK_SUCCESS,VK_INCOMPLETE" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
            <proto><type>VkResult</type> <name>vkGetPhysicalDeviceDisplayPlaneProperties2KHR</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param optional="false,true"><type>uint32_t</type>* <name>pPropertyCount</name></param>
            <param optional="true" len="pPropertyCount"><type>VkDisplayPlaneProperties2KHR</type>* <name>pProperties</name></param>
        </command>
        <command successcodes="VK_SUCCESS,VK_INCOMPLETE" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
            <proto><type>VkResult</type> <name>vkGetDisplayModeProperties2KHR</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param><type>VkDisplayKHR</type> <name>display</name></param>
            <param optional="false,true"><type>uint32_t</type>* <name>pPropertyCount</name></param>
            <param optional="true" len="pPropertyCount"><type>VkDisplayModeProperties2KHR</type>* <name>pProperties</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
            <proto><type>VkResult</type> <name>vkGetDisplayPlaneCapabilities2KHR</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param>const <type>VkDisplayPlaneInfo2KHR</type>* <name>pDisplayPlaneInfo</name></param>
            <param><type>VkDisplayPlaneCapabilities2KHR</type>* <name>pCapabilities</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkGetBufferMemoryRequirements2</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkBufferMemoryRequirementsInfo2</type>* <name>pInfo</name></param>
            <param><type>VkMemoryRequirements2</type>* <name>pMemoryRequirements</name></param>
        </command>
        <command name="vkGetBufferMemoryRequirements2KHR"                      alias="vkGetBufferMemoryRequirements2"/>
        <command>
            <proto><type>void</type> <name>vkGetImageMemoryRequirements2</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkImageMemoryRequirementsInfo2</type>* <name>pInfo</name></param>
            <param><type>VkMemoryRequirements2</type>* <name>pMemoryRequirements</name></param>
        </command>
        <command name="vkGetImageMemoryRequirements2KHR"                       alias="vkGetImageMemoryRequirements2"/>
        <command>
            <proto><type>void</type> <name>vkGetImageSparseMemoryRequirements2</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkImageSparseMemoryRequirementsInfo2</type>* <name>pInfo</name></param>
            <param optional="false,true"><type>uint32_t</type>* <name>pSparseMemoryRequirementCount</name></param>
            <param optional="true" len="pSparseMemoryRequirementCount"><type>VkSparseImageMemoryRequirements2</type>* <name>pSparseMemoryRequirements</name></param>
        </command>
        <command name="vkGetImageSparseMemoryRequirements2KHR"                 alias="vkGetImageSparseMemoryRequirements2"/>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
            <proto><type>VkResult</type> <name>vkCreateSamplerYcbcrConversion</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkSamplerYcbcrConversionCreateInfo</type>* <name>pCreateInfo</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param><type>VkSamplerYcbcrConversion</type>* <name>pYcbcrConversion</name></param>
        </command>
        <command name="vkCreateSamplerYcbcrConversionKHR"                      alias="vkCreateSamplerYcbcrConversion"/>
        <command>
            <proto><type>void</type> <name>vkDestroySamplerYcbcrConversion</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param optional="true" externsync="true"><type>VkSamplerYcbcrConversion</type> <name>ycbcrConversion</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
        </command>
        <command name="vkDestroySamplerYcbcrConversionKHR"                     alias="vkDestroySamplerYcbcrConversion"/>
        <command>
            <proto><type>void</type> <name>vkGetDeviceQueue2</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkDeviceQueueInfo2</type>* <name>pQueueInfo</name></param>
            <param><type>VkQueue</type>* <name>pQueue</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY">
            <proto><type>VkResult</type> <name>vkCreateValidationCacheEXT</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkValidationCacheCreateInfoEXT</type>* <name>pCreateInfo</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param><type>VkValidationCacheEXT</type>* <name>pValidationCache</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkDestroyValidationCacheEXT</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param optional="true" externsync="true"><type>VkValidationCacheEXT</type> <name>validationCache</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
        </command>
        <command successcodes="VK_SUCCESS,VK_INCOMPLETE" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
            <proto><type>VkResult</type> <name>vkGetValidationCacheDataEXT</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>VkValidationCacheEXT</type> <name>validationCache</name></param>
            <param optional="false,true"><type>size_t</type>* <name>pDataSize</name></param>
            <param optional="true" len="pDataSize"><type>void</type>* <name>pData</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
            <proto><type>VkResult</type> <name>vkMergeValidationCachesEXT</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param externsync="true"><type>VkValidationCacheEXT</type> <name>dstCache</name></param>
            <param><type>uint32_t</type> <name>srcCacheCount</name></param>
            <param len="srcCacheCount">const <type>VkValidationCacheEXT</type>* <name>pSrcCaches</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkGetDescriptorSetLayoutSupport</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkDescriptorSetLayoutCreateInfo</type>* <name>pCreateInfo</name></param>
            <param><type>VkDescriptorSetLayoutSupport</type>* <name>pSupport</name></param>
        </command>
        <command name="vkGetDescriptorSetLayoutSupportKHR"                     alias="vkGetDescriptorSetLayoutSupport"/>
        <command>
            <proto><type>VkResult</type> <name>vkGetSwapchainGrallocUsageANDROID</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>VkFormat</type> <name>format</name></param>
            <param><type>VkImageUsageFlags</type> <name>imageUsage</name></param>
            <param><type>int</type>* <name>grallocUsage</name></param>
        </command>
        <command>
            <proto><type>VkResult</type> <name>vkAcquireImageANDROID</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>VkImage</type> <name>image</name></param>
            <param><type>int</type> <name>nativeFenceFd</name></param>
            <param><type>VkSemaphore</type> <name>semaphore</name></param>
            <param><type>VkFence</type> <name>fence</name></param>
        </command>
        <command>
            <proto><type>VkResult</type> <name>vkQueueSignalReleaseImageANDROID</name></proto>
            <param><type>VkQueue</type> <name>queue</name></param>
            <param><type>uint32_t</type> <name>waitSemaphoreCount</name></param>
            <param>const <type>VkSemaphore</type>* <name>pWaitSemaphores</name></param>
            <param><type>VkImage</type> <name>image</name></param>
            <param><type>int</type>* <name>pNativeFenceFd</name></param>
        </command>
        <command successcodes="VK_SUCCESS,VK_INCOMPLETE" errorcodes="VK_ERROR_FEATURE_NOT_PRESENT,VK_ERROR_OUT_OF_HOST_MEMORY">
            <proto><type>VkResult</type> <name>vkGetShaderInfoAMD</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>VkPipeline</type> <name>pipeline</name></param>
            <param><type>VkShaderStageFlagBits</type> <name>shaderStage</name></param>
            <param><type>VkShaderInfoTypeAMD</type> <name>infoType</name></param>
            <param optional="false,true"><type>size_t</type>* <name>pInfoSize</name></param>
            <param optional="true" len="pInfoSize"><type>void</type>* <name>pInfo</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkSetLocalDimmingAMD</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>VkSwapchainKHR</type> <name>swapChain</name></param>
            <param><type>VkBool32</type> <name>localDimmingEnable</name></param>
        </command>
        <command successcodes="VK_SUCCESS,VK_INCOMPLETE" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
            <proto><type>VkResult</type> <name>vkGetPhysicalDeviceCalibrateableTimeDomainsEXT</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param optional="false,true"><type>uint32_t</type>* <name>pTimeDomainCount</name></param>
            <param optional="true" len="pTimeDomainCount"><type>VkTimeDomainEXT</type>* <name>pTimeDomains</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
            <proto><type>VkResult</type> <name>vkGetCalibratedTimestampsEXT</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>uint32_t</type> <name>timestampCount</name></param>
            <param len="timestampCount">const <type>VkCalibratedTimestampInfoEXT</type>* <name>pTimestampInfos</name></param>
            <param len="timestampCount"><type>uint64_t</type>* <name>pTimestamps</name></param>
            <param><type>uint64_t</type>* <name>pMaxDeviation</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
            <proto><type>VkResult</type> <name>vkSetDebugUtilsObjectNameEXT</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param externsync="pNameInfo.objectHandle">const <type>VkDebugUtilsObjectNameInfoEXT</type>* <name>pNameInfo</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
            <proto><type>VkResult</type> <name>vkSetDebugUtilsObjectTagEXT</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param externsync="pTagInfo.objectHandle">const <type>VkDebugUtilsObjectTagInfoEXT</type>* <name>pTagInfo</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkQueueBeginDebugUtilsLabelEXT</name></proto>
            <param><type>VkQueue</type> <name>queue</name></param>
            <param>const <type>VkDebugUtilsLabelEXT</type>* <name>pLabelInfo</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkQueueEndDebugUtilsLabelEXT</name></proto>
            <param><type>VkQueue</type> <name>queue</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkQueueInsertDebugUtilsLabelEXT</name></proto>
            <param><type>VkQueue</type> <name>queue</name></param>
            <param>const <type>VkDebugUtilsLabelEXT</type>* <name>pLabelInfo</name></param>
        </command>
        <command queues="graphics,compute" renderpass="both" cmdbufferlevel="primary,secondary">
            <proto><type>void</type> <name>vkCmdBeginDebugUtilsLabelEXT</name></proto>
            <param><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param>const <type>VkDebugUtilsLabelEXT</type>* <name>pLabelInfo</name></param>
        </command>
        <command queues="graphics,compute" renderpass="both" cmdbufferlevel="primary,secondary">
            <proto><type>void</type> <name>vkCmdEndDebugUtilsLabelEXT</name></proto>
            <param><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
        </command>
        <command queues="graphics,compute" renderpass="both" cmdbufferlevel="primary,secondary">
            <proto><type>void</type> <name>vkCmdInsertDebugUtilsLabelEXT</name></proto>
            <param><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param>const <type>VkDebugUtilsLabelEXT</type>* <name>pLabelInfo</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY">
            <proto><type>VkResult</type> <name>vkCreateDebugUtilsMessengerEXT</name></proto>
            <param><type>VkInstance</type> <name>instance</name></param>
            <param>const <type>VkDebugUtilsMessengerCreateInfoEXT</type>* <name>pCreateInfo</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param><type>VkDebugUtilsMessengerEXT</type>* <name>pMessenger</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkDestroyDebugUtilsMessengerEXT</name></proto>
            <param><type>VkInstance</type> <name>instance</name></param>
            <param externsync="true"><type>VkDebugUtilsMessengerEXT</type> <name>messenger</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkSubmitDebugUtilsMessageEXT</name></proto>
            <param><type>VkInstance</type> <name>instance</name></param>
            <param><type>VkDebugUtilsMessageSeverityFlagBitsEXT</type> <name>messageSeverity</name></param>
            <param><type>VkDebugUtilsMessageTypeFlagsEXT</type> <name>messageTypes</name></param>
            <param>const <type>VkDebugUtilsMessengerCallbackDataEXT</type>* <name>pCallbackData</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_INVALID_EXTERNAL_HANDLE">
            <proto><type>VkResult</type> <name>vkGetMemoryHostPointerPropertiesEXT</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>VkExternalMemoryHandleTypeFlagBits</type> <name>handleType</name></param>
            <param optional="false">const <type>void</type>* <name>pHostPointer</name></param>
            <param><type>VkMemoryHostPointerPropertiesEXT</type>* <name>pMemoryHostPointerProperties</name></param>
        </command>
        <command queues="transfer,graphics,compute" renderpass="both" cmdbufferlevel="primary,secondary" pipeline="transfer">
            <proto><type>void</type> <name>vkCmdWriteBufferMarkerAMD</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkPipelineStageFlagBits</type> <name>pipelineStage</name></param>
            <param><type>VkBuffer</type> <name>dstBuffer</name></param>
            <param><type>VkDeviceSize</type> <name>dstOffset</name></param>
            <param><type>uint32_t</type> <name>marker</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
            <proto><type>VkResult</type> <name>vkCreateRenderPass2KHR</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkRenderPassCreateInfo2KHR</type>* <name>pCreateInfo</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param><type>VkRenderPass</type>* <name>pRenderPass</name></param>
        </command>
        <command queues="graphics" renderpass="outside" cmdbufferlevel="primary" pipeline="graphics">
            <proto><type>void</type> <name>vkCmdBeginRenderPass2KHR</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param>const <type>VkRenderPassBeginInfo</type>*      <name>pRenderPassBegin</name></param>
            <param>const <type>VkSubpassBeginInfoKHR</type>*      <name>pSubpassBeginInfo</name></param>
        </command>
        <command queues="graphics" renderpass="inside" cmdbufferlevel="primary" pipeline="graphics">
            <proto><type>void</type> <name>vkCmdNextSubpass2KHR</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param>const <type>VkSubpassBeginInfoKHR</type>*      <name>pSubpassBeginInfo</name></param>
            <param>const <type>VkSubpassEndInfoKHR</type>*        <name>pSubpassEndInfo</name></param>
        </command>
        <command queues="graphics" renderpass="inside" cmdbufferlevel="primary" pipeline="graphics">
            <proto><type>void</type> <name>vkCmdEndRenderPass2KHR</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param>const <type>VkSubpassEndInfoKHR</type>*        <name>pSubpassEndInfo</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_INVALID_EXTERNAL_HANDLE_KHR">
            <proto><type>VkResult</type> <name>vkGetAndroidHardwareBufferPropertiesANDROID</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const struct <type>AHardwareBuffer</type>* <name>buffer</name></param>
            <param><type>VkAndroidHardwareBufferPropertiesANDROID</type>* <name>pProperties</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_TOO_MANY_OBJECTS,VK_ERROR_OUT_OF_HOST_MEMORY">
            <proto><type>VkResult</type> <name>vkGetMemoryAndroidHardwareBufferANDROID</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkMemoryGetAndroidHardwareBufferInfoANDROID</type>* <name>pInfo</name></param>
            <param>struct <type>AHardwareBuffer</type>** <name>pBuffer</name></param>
        </command>
        <command queues="graphics" renderpass="inside" cmdbufferlevel="primary,secondary" pipeline="graphics">
            <proto><type>void</type> <name>vkCmdDrawIndirectCountKHR</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkBuffer</type> <name>buffer</name></param>
            <param><type>VkDeviceSize</type> <name>offset</name></param>
            <param><type>VkBuffer</type> <name>countBuffer</name></param>
            <param><type>VkDeviceSize</type> <name>countBufferOffset</name></param>
            <param><type>uint32_t</type> <name>maxDrawCount</name></param>
            <param><type>uint32_t</type> <name>stride</name></param>
        </command>
        <command name="vkCmdDrawIndirectCountAMD"                                  alias="vkCmdDrawIndirectCountKHR"/>
        <command queues="graphics" renderpass="inside" cmdbufferlevel="primary,secondary" pipeline="graphics">
            <proto><type>void</type> <name>vkCmdDrawIndexedIndirectCountKHR</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkBuffer</type> <name>buffer</name></param>
            <param><type>VkDeviceSize</type> <name>offset</name></param>
            <param><type>VkBuffer</type> <name>countBuffer</name></param>
            <param><type>VkDeviceSize</type> <name>countBufferOffset</name></param>
            <param><type>uint32_t</type> <name>maxDrawCount</name></param>
            <param><type>uint32_t</type> <name>stride</name></param>
        </command>
        <command name="vkCmdDrawIndexedIndirectCountAMD"                           alias="vkCmdDrawIndexedIndirectCountKHR"/>
        <command queues="graphics,compute,transfer" renderpass="both" cmdbufferlevel="primary,secondary">
            <proto><type>void</type> <name>vkCmdSetCheckpointNV</name></proto>
            <param><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param noautovalidity="true">const <type>void</type>* <name>pCheckpointMarker</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkGetQueueCheckpointDataNV</name></proto>
            <param><type>VkQueue</type> <name>queue</name></param>
            <param optional="false,true"><type>uint32_t</type>* <name>pCheckpointDataCount</name></param>
            <param optional="true" len="pCheckpointDataCount"><type>VkCheckpointDataNV</type>* <name>pCheckpointData</name></param>
        </command>
        <command queues="graphics" renderpass="both" cmdbufferlevel="primary,secondary">
            <proto><type>void</type> <name>vkCmdBindTransformFeedbackBuffersEXT</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>uint32_t</type> <name>firstBinding</name></param>
            <param><type>uint32_t</type> <name>bindingCount</name></param>
            <param len="bindingCount">const <type>VkBuffer</type>* <name>pBuffers</name></param>
            <param len="bindingCount">const <type>VkDeviceSize</type>* <name>pOffsets</name></param>
            <param optional="true" len="bindingCount">const <type>VkDeviceSize</type>* <name>pSizes</name></param>
        </command>
        <command queues="graphics" renderpass="inside" cmdbufferlevel="primary,secondary">
            <proto><type>void</type> <name>vkCmdBeginTransformFeedbackEXT</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>uint32_t</type> <name>firstCounterBuffer</name></param>
            <param optional="true"><type>uint32_t</type> <name>counterBufferCount</name></param>
            <param noautovalidity="true" len="counterBufferCount">const <type>VkBuffer</type>* <name>pCounterBuffers</name></param>
            <param optional="true" len="counterBufferCount">const <type>VkDeviceSize</type>* <name>pCounterBufferOffsets</name></param>
        </command>
        <command queues="graphics" renderpass="inside" cmdbufferlevel="primary,secondary">
            <proto><type>void</type> <name>vkCmdEndTransformFeedbackEXT</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>uint32_t</type> <name>firstCounterBuffer</name></param>
            <param optional="true"><type>uint32_t</type> <name>counterBufferCount</name></param>
            <param noautovalidity="true" len="counterBufferCount">const <type>VkBuffer</type>* <name>pCounterBuffers</name></param>
            <param optional="true" len="counterBufferCount">const <type>VkDeviceSize</type>* <name>pCounterBufferOffsets</name></param>
        </command>
        <command queues="graphics,compute" renderpass="both" cmdbufferlevel="primary,secondary">
            <proto><type>void</type> <name>vkCmdBeginQueryIndexedEXT</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkQueryPool</type> <name>queryPool</name></param>
            <param><type>uint32_t</type> <name>query</name></param>
            <param optional="true"><type>VkQueryControlFlags</type> <name>flags</name></param>
            <param><type>uint32_t</type> <name>index</name></param>
        </command>
        <command queues="graphics,compute" renderpass="both" cmdbufferlevel="primary,secondary">
            <proto><type>void</type> <name>vkCmdEndQueryIndexedEXT</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkQueryPool</type> <name>queryPool</name></param>
            <param><type>uint32_t</type> <name>query</name></param>
            <param><type>uint32_t</type> <name>index</name></param>
        </command>
        <command queues="graphics" renderpass="inside" cmdbufferlevel="primary,secondary" pipeline="graphics">
            <proto><type>void</type> <name>vkCmdDrawIndirectByteCountEXT</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>uint32_t</type> <name>instanceCount</name></param>
            <param><type>uint32_t</type> <name>firstInstance</name></param>
            <param><type>VkBuffer</type> <name>counterBuffer</name></param>
            <param><type>VkDeviceSize</type> <name>counterBufferOffset</name></param>
            <param><type>uint32_t</type> <name>counterOffset</name></param>
            <param><type>uint32_t</type> <name>vertexStride</name></param>
        </command>
        <command queues="graphics" renderpass="both" cmdbufferlevel="primary,secondary">
            <proto><type>void</type> <name>vkCmdSetExclusiveScissorNV</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>uint32_t</type> <name>firstExclusiveScissor</name></param>
            <param><type>uint32_t</type> <name>exclusiveScissorCount</name></param>
            <param len="exclusiveScissorCount">const <type>VkRect2D</type>* <name>pExclusiveScissors</name></param>
        </command>
        <command queues="graphics" renderpass="both" cmdbufferlevel="primary,secondary">
            <proto><type>void</type> <name>vkCmdBindShadingRateImageNV</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param optional="true"><type>VkImageView</type> <name>imageView</name></param>
            <param><type>VkImageLayout</type> <name>imageLayout</name></param>
        </command>
        <command queues="graphics" renderpass="both" cmdbufferlevel="primary,secondary">
            <proto><type>void</type> <name>vkCmdSetViewportShadingRatePaletteNV</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>uint32_t</type> <name>firstViewport</name></param>
            <param><type>uint32_t</type> <name>viewportCount</name></param>
            <param len="viewportCount">const <type>VkShadingRatePaletteNV</type>* <name>pShadingRatePalettes</name></param>
        </command>
        <command queues="graphics" renderpass="both" cmdbufferlevel="primary,secondary">
            <proto><type>void</type> <name>vkCmdSetCoarseSampleOrderNV</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkCoarseSampleOrderTypeNV</type> <name>sampleOrderType</name></param>
            <param optional="true"><type>uint32_t</type> <name>customSampleOrderCount</name></param>
            <param len="customSampleOrderCount">const <type>VkCoarseSampleOrderCustomNV</type>* <name>pCustomSampleOrders</name></param>
        </command>
        <command queues="graphics" renderpass="inside" cmdbufferlevel="primary,secondary" pipeline="graphics">
            <proto><type>void</type> <name>vkCmdDrawMeshTasksNV</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>uint32_t</type> <name>taskCount</name></param>
            <param><type>uint32_t</type> <name>firstTask</name></param>
        </command>
        <command queues="graphics" renderpass="inside" cmdbufferlevel="primary,secondary" pipeline="graphics">
            <proto><type>void</type> <name>vkCmdDrawMeshTasksIndirectNV</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkBuffer</type> <name>buffer</name></param>
            <param><type>VkDeviceSize</type> <name>offset</name></param>
            <param><type>uint32_t</type> <name>drawCount</name></param>
            <param><type>uint32_t</type> <name>stride</name></param>
        </command>
        <command queues="graphics" renderpass="inside" cmdbufferlevel="primary,secondary" pipeline="graphics">
            <proto><type>void</type> <name>vkCmdDrawMeshTasksIndirectCountNV</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkBuffer</type> <name>buffer</name></param>
            <param><type>VkDeviceSize</type> <name>offset</name></param>
            <param><type>VkBuffer</type> <name>countBuffer</name></param>
            <param><type>VkDeviceSize</type> <name>countBufferOffset</name></param>
            <param><type>uint32_t</type> <name>maxDrawCount</name></param>
            <param><type>uint32_t</type> <name>stride</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
            <proto><type>VkResult</type> <name>vkCompileDeferredNV</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>VkPipeline</type> <name>pipeline</name></param>
            <param><type>uint32_t</type> <name>shader</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY">
            <proto><type>VkResult</type> <name>vkCreateAccelerationStructureNV</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkAccelerationStructureCreateInfoNV</type>* <name>pCreateInfo</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param><type>VkAccelerationStructureNV</type>* <name>pAccelerationStructure</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkDestroyAccelerationStructureNV</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>VkAccelerationStructureNV</type> <name>accelerationStructure</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkGetAccelerationStructureMemoryRequirementsNV</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkAccelerationStructureMemoryRequirementsInfoNV</type>* <name>pInfo</name></param>
            <param><type>VkMemoryRequirements2KHR</type>* <name>pMemoryRequirements</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
            <proto><type>VkResult</type> <name>vkBindAccelerationStructureMemoryNV</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>uint32_t</type> <name>bindInfoCount</name></param>
            <param len="bindInfoCount">const <type>VkBindAccelerationStructureMemoryInfoNV</type>* <name>pBindInfos</name></param>
        </command>
        <command queues="compute" renderpass="both" cmdbufferlevel="primary,secondary">
            <proto><type>void</type> <name>vkCmdCopyAccelerationStructureNV</name></proto>
            <param><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkAccelerationStructureNV</type> <name>dst</name></param>
            <param><type>VkAccelerationStructureNV</type> <name>src</name></param>
            <param><type>VkCopyAccelerationStructureModeNV</type> <name>mode</name></param>
        </command>
        <command queues="compute" renderpass="both" cmdbufferlevel="primary,secondary">
            <proto><type>void</type> <name>vkCmdWriteAccelerationStructuresPropertiesNV</name></proto>
            <param><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>uint32_t</type> <name>accelerationStructureCount</name></param>
            <param len="accelerationStructureCount">const <type>VkAccelerationStructureNV</type>* <name>pAccelerationStructures</name></param>
            <param><type>VkQueryType</type> <name>queryType</name></param>
            <param><type>VkQueryPool</type> <name>queryPool</name></param>
            <param><type>uint32_t</type> <name>firstQuery</name></param>
        </command>
        <command queues="compute" renderpass="both" cmdbufferlevel="primary,secondary">
            <proto><type>void</type> <name>vkCmdBuildAccelerationStructureNV</name></proto>
            <param><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param>const <type>VkAccelerationStructureInfoNV</type>* <name>pInfo</name></param>
            <param optional="true"><type>VkBuffer</type> <name>instanceData</name></param>
            <param><type>VkDeviceSize</type> <name>instanceOffset</name></param>
            <param><type>VkBool32</type> <name>update</name></param>
            <param><type>VkAccelerationStructureNV</type> <name>dst</name></param>
            <param optional="true"><type>VkAccelerationStructureNV</type> <name>src</name></param>
            <param><type>VkBuffer</type> <name>scratch</name></param>
            <param><type>VkDeviceSize</type> <name>scratchOffset</name></param>
        </command>
        <command queues="compute" renderpass="both" cmdbufferlevel="primary,secondary">
            <proto><type>void</type> <name>vkCmdTraceRaysNV</name></proto>
            <param><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkBuffer</type> <name>raygenShaderBindingTableBuffer</name></param>
            <param><type>VkDeviceSize</type> <name>raygenShaderBindingOffset</name></param>
            <param optional="true"><type>VkBuffer</type> <name>missShaderBindingTableBuffer</name></param>
            <param><type>VkDeviceSize</type> <name>missShaderBindingOffset</name></param>
            <param><type>VkDeviceSize</type> <name>missShaderBindingStride</name></param>
            <param optional="true"><type>VkBuffer</type> <name>hitShaderBindingTableBuffer</name></param>
            <param><type>VkDeviceSize</type> <name>hitShaderBindingOffset</name></param>
            <param><type>VkDeviceSize</type> <name>hitShaderBindingStride</name></param>
            <param optional="true"><type>VkBuffer</type> <name>callableShaderBindingTableBuffer</name></param>
            <param><type>VkDeviceSize</type> <name>callableShaderBindingOffset</name></param>
            <param><type>VkDeviceSize</type> <name>callableShaderBindingStride</name></param>
            <param><type>uint32_t</type> <name>width</name></param>
            <param><type>uint32_t</type> <name>height</name></param>
            <param><type>uint32_t</type> <name>depth</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
            <proto><type>VkResult</type> <name>vkGetRayTracingShaderGroupHandlesNV</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>VkPipeline</type> <name>pipeline</name></param>
            <param><type>uint32_t</type> <name>firstGroup</name></param>
            <param><type>uint32_t</type> <name>groupCount</name></param>
            <param><type>size_t</type> <name>dataSize</name></param>
            <param len="dataSize"><type>void</type>* <name>pData</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
            <proto><type>VkResult</type> <name>vkGetAccelerationStructureHandleNV</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>VkAccelerationStructureNV</type> <name>accelerationStructure</name></param>
            <param><type>size_t</type> <name>dataSize</name></param>
            <param len="dataSize"><type>void</type>* <name>pData</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_INVALID_SHADER_NV">
            <proto><type>VkResult</type> <name>vkCreateRayTracingPipelinesNV</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param optional="true"><type>VkPipelineCache</type> <name>pipelineCache</name></param>
            <param><type>uint32_t</type> <name>createInfoCount</name></param>
            <param len="createInfoCount">const <type>VkRayTracingPipelineCreateInfoNV</type>* <name>pCreateInfos</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param len="createInfoCount"><type>VkPipeline</type>* <name>pPipelines</name></param>
        </command>
        <command successcodes="VK_SUCCESS">
            <proto><type>VkResult</type> <name>vkGetImageDrmFormatModifierPropertiesEXT</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>VkImage</type> <name>image</name></param>
            <param><type>VkImageDrmFormatModifierPropertiesEXT</type>* <name>pProperties</name></param>
        </command>
        <command>
            <proto><type>VkDeviceAddress</type> <name>vkGetBufferDeviceAddressEXT</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkBufferDeviceAddressInfoEXT</type>* <name>pInfo</name></param>
        </command>
        <command successcodes="VK_SUCCESS,VK_INCOMPLETE" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
            <proto><type>VkResult</type> <name>vkGetPhysicalDeviceCooperativeMatrixPropertiesNV</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param optional="false,true"><type>uint32_t</type>* <name>pPropertyCount</name></param>
            <param optional="true" len="pPropertyCount"><type>VkCooperativeMatrixPropertiesNV</type>* <name>pProperties</name></param>
        </command>
        <command>
            <proto><type>uint32_t</type> <name>vkGetImageViewHandleNVX</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkImageViewHandleInfoNVX</type>* <name>pInfo</name></param>
        </command>
        <command successcodes="VK_SUCCESS,VK_INCOMPLETE" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_SURFACE_LOST_KHR">
            <proto><type>VkResult</type> <name>vkGetPhysicalDeviceSurfacePresentModes2EXT</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param>const <type>VkPhysicalDeviceSurfaceInfo2KHR</type>* <name>pSurfaceInfo</name></param>
            <param optional="false,true"><type>uint32_t</type>* <name>pPresentModeCount</name></param>
            <param optional="true" len="pPresentModeCount"><type>VkPresentModeKHR</type>* <name>pPresentModes</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_SURFACE_LOST_KHR">
            <proto><type>VkResult</type> <name>vkGetDeviceGroupSurfacePresentModes2EXT</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkPhysicalDeviceSurfaceInfo2KHR</type>* <name>pSurfaceInfo</name></param>
            <param optional="false,true"><type>VkDeviceGroupPresentModeFlagsKHR</type>* <name>pModes</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_INITIALIZATION_FAILED,VK_ERROR_SURFACE_LOST_KHR">
            <proto><type>VkResult</type> <name>vkAcquireFullScreenExclusiveModeEXT</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>VkSwapchainKHR</type> <name>swapchain</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_SURFACE_LOST_KHR">
            <proto><type>VkResult</type> <name>vkReleaseFullScreenExclusiveModeEXT</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>VkSwapchainKHR</type> <name>swapchain</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
            <proto><type>VkResult</type> <name>vkCreateHeadlessSurfaceEXT</name></proto>
            <param><type>VkInstance</type> <name>instance</name></param>
            <param>const <type>VkHeadlessSurfaceCreateInfoEXT</type>* <name>pCreateInfo</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param><type>VkSurfaceKHR</type>* <name>pSurface</name></param>
        </command>
        <command successcodes="VK_SUCCESS,VK_INCOMPLETE" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
            <proto><type>VkResult</type> <name>vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param optional="false,true"><type>uint32_t</type>* <name>pCombinationCount</name></param>
            <param optional="true" len="pCombinationCount"><type>VkFramebufferMixedSamplesCombinationNV</type>* <name>pCombinations</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_TOO_MANY_OBJECTS,VK_ERROR_OUT_OF_HOST_MEMORY">
            <proto><type>VkResult</type> <name>vkInitializePerformanceApiINTEL</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkInitializePerformanceApiInfoINTEL</type>* <name>pInitializeInfo</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkUninitializePerformanceApiINTEL</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
        </command>
        <command queues="graphics,compute,transfer" renderpass="both" cmdbufferlevel="primary,secondary" successcodes="VK_SUCCESS" errorcodes="VK_ERROR_TOO_MANY_OBJECTS,VK_ERROR_OUT_OF_HOST_MEMORY">
            <proto><type>VkResult</type> <name>vkCmdSetPerformanceMarkerINTEL</name></proto>
            <param><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param>const <type>VkPerformanceMarkerInfoINTEL</type>* <name>pMarkerInfo</name></param>
        </command>
        <command queues="graphics,compute,transfer" renderpass="both" cmdbufferlevel="primary,secondary" successcodes="VK_SUCCESS" errorcodes="VK_ERROR_TOO_MANY_OBJECTS,VK_ERROR_OUT_OF_HOST_MEMORY">
            <proto><type>VkResult</type> <name>vkCmdSetPerformanceStreamMarkerINTEL</name></proto>
            <param><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param>const <type>VkPerformanceStreamMarkerInfoINTEL</type>* <name>pMarkerInfo</name></param>
        </command>
        <command queues="graphics,compute,transfer" renderpass="both" cmdbufferlevel="primary,secondary" successcodes="VK_SUCCESS" errorcodes="VK_ERROR_TOO_MANY_OBJECTS,VK_ERROR_OUT_OF_HOST_MEMORY">
            <proto><type>VkResult</type> <name>vkCmdSetPerformanceOverrideINTEL</name></proto>
            <param><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param>const <type>VkPerformanceOverrideInfoINTEL</type>* <name>pOverrideInfo</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_TOO_MANY_OBJECTS,VK_ERROR_OUT_OF_HOST_MEMORY">
            <proto><type>VkResult</type> <name>vkAcquirePerformanceConfigurationINTEL</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkPerformanceConfigurationAcquireInfoINTEL</type>* <name>pAcquireInfo</name></param>
            <param><type>VkPerformanceConfigurationINTEL</type>* <name>pConfiguration</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_TOO_MANY_OBJECTS,VK_ERROR_OUT_OF_HOST_MEMORY">
            <proto><type>VkResult</type> <name>vkReleasePerformanceConfigurationINTEL</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>VkPerformanceConfigurationINTEL</type> <name>configuration</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_TOO_MANY_OBJECTS,VK_ERROR_OUT_OF_HOST_MEMORY">
            <proto><type>VkResult</type> <name>vkQueueSetPerformanceConfigurationINTEL</name></proto>
            <param><type>VkQueue</type> <name>queue</name></param>
            <param><type>VkPerformanceConfigurationINTEL</type> <name>configuration</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_TOO_MANY_OBJECTS,VK_ERROR_OUT_OF_HOST_MEMORY">
            <proto><type>VkResult</type> <name>vkGetPerformanceParameterINTEL</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>VkPerformanceParameterTypeINTEL</type> <name>parameter</name></param>
            <param><type>VkPerformanceValueINTEL</type>* <name>pValue</name></param>
        </command>
    </commands>

    <feature api="vulkan" name="VK_VERSION_1_0" number="1.0" comment="Vulkan core API interface definitions">
        <require comment="Header boilerplate">
            <type name="vk_platform"/>
        </require>
        <require comment="API version">
            <type name="VK_API_VERSION"/>
            <type name="VK_API_VERSION_1_0"/>
            <type name="VK_VERSION_MAJOR"/>
            <type name="VK_VERSION_MINOR"/>
            <type name="VK_VERSION_PATCH"/>
            <type name="VK_HEADER_VERSION"/>
        </require>
        <require comment="API constants">
            <enum name="VK_LOD_CLAMP_NONE"/>
            <enum name="VK_REMAINING_MIP_LEVELS"/>
            <enum name="VK_REMAINING_ARRAY_LAYERS"/>
            <enum name="VK_WHOLE_SIZE"/>
            <enum name="VK_ATTACHMENT_UNUSED"/>
            <enum name="VK_TRUE"/>
            <enum name="VK_FALSE"/>
            <type name="VK_NULL_HANDLE"/>
            <enum name="VK_QUEUE_FAMILY_IGNORED"/>
            <enum name="VK_SUBPASS_EXTERNAL"/>
            <type name="VkPipelineCacheHeaderVersion"/>
        </require>
        <require comment="Device initialization">
            <command name="vkCreateInstance"/>
            <command name="vkDestroyInstance"/>
            <command name="vkEnumeratePhysicalDevices"/>
            <command name="vkGetPhysicalDeviceFeatures"/>
            <command name="vkGetPhysicalDeviceFormatProperties"/>
            <command name="vkGetPhysicalDeviceImageFormatProperties"/>
            <command name="vkGetPhysicalDeviceProperties"/>
            <command name="vkGetPhysicalDeviceQueueFamilyProperties"/>
            <command name="vkGetPhysicalDeviceMemoryProperties"/>
            <command name="vkGetInstanceProcAddr"/>
            <command name="vkGetDeviceProcAddr"/>
        </require>
        <require comment="Device commands">
            <command name="vkCreateDevice"/>
            <command name="vkDestroyDevice"/>
        </require>
        <require comment="Extension discovery commands">
            <command name="vkEnumerateInstanceExtensionProperties"/>
            <command name="vkEnumerateDeviceExtensionProperties"/>
        </require>
        <require comment="Layer discovery commands">
            <command name="vkEnumerateInstanceLayerProperties"/>
            <command name="vkEnumerateDeviceLayerProperties"/>
        </require>
        <require comment="queue commands">
            <command name="vkGetDeviceQueue"/>
            <command name="vkQueueSubmit"/>
            <command name="vkQueueWaitIdle"/>
            <command name="vkDeviceWaitIdle"/>
        </require>
        <require comment="Memory commands">
            <command name="vkAllocateMemory"/>
            <command name="vkFreeMemory"/>
            <command name="vkMapMemory"/>
            <command name="vkUnmapMemory"/>
            <command name="vkFlushMappedMemoryRanges"/>
            <command name="vkInvalidateMappedMemoryRanges"/>
            <command name="vkGetDeviceMemoryCommitment"/>
        </require>
        <require comment="Memory management API commands">
            <command name="vkBindBufferMemory"/>
            <command name="vkBindImageMemory"/>
            <command name="vkGetBufferMemoryRequirements"/>
            <command name="vkGetImageMemoryRequirements"/>
        </require>
        <require comment="Sparse resource memory management API commands">
            <command name="vkGetImageSparseMemoryRequirements"/>
            <command name="vkGetPhysicalDeviceSparseImageFormatProperties"/>
            <command name="vkQueueBindSparse"/>
        </require>
        <require comment="Fence commands">
            <command name="vkCreateFence"/>
            <command name="vkDestroyFence"/>
            <command name="vkResetFences"/>
            <command name="vkGetFenceStatus"/>
            <command name="vkWaitForFences"/>
        </require>
        <require comment="Queue semaphore commands">
            <command name="vkCreateSemaphore"/>
            <command name="vkDestroySemaphore"/>
        </require>
        <require comment="Event commands">
            <command name="vkCreateEvent"/>
            <command name="vkDestroyEvent"/>
            <command name="vkGetEventStatus"/>
            <command name="vkSetEvent"/>
            <command name="vkResetEvent"/>
        </require>
        <require comment="Query commands">
            <command name="vkCreateQueryPool"/>
            <command name="vkDestroyQueryPool"/>
            <command name="vkGetQueryPoolResults"/>
        </require>
        <require comment="Buffer commands">
            <command name="vkCreateBuffer"/>
            <command name="vkDestroyBuffer"/>
        </require>
        <require comment="Buffer view commands">
            <command name="vkCreateBufferView"/>
            <command name="vkDestroyBufferView"/>
        </require>
        <require comment="Image commands">
            <command name="vkCreateImage"/>
            <command name="vkDestroyImage"/>
            <command name="vkGetImageSubresourceLayout"/>
        </require>
        <require comment="Image view commands">
            <command name="vkCreateImageView"/>
            <command name="vkDestroyImageView"/>
        </require>
        <require comment="Shader commands">
            <command name="vkCreateShaderModule"/>
            <command name="vkDestroyShaderModule"/>
        </require>
        <require comment="Pipeline Cache commands">
            <command name="vkCreatePipelineCache"/>
            <command name="vkDestroyPipelineCache"/>
            <command name="vkGetPipelineCacheData"/>
            <command name="vkMergePipelineCaches"/>
        </require>
        <require comment="Pipeline commands">
            <command name="vkCreateGraphicsPipelines"/>
            <command name="vkCreateComputePipelines"/>
            <command name="vkDestroyPipeline"/>
        </require>
        <require comment="Pipeline layout commands">
            <command name="vkCreatePipelineLayout"/>
            <command name="vkDestroyPipelineLayout"/>
        </require>
        <require comment="Sampler commands">
            <command name="vkCreateSampler"/>
            <command name="vkDestroySampler"/>
        </require>
        <require comment="Descriptor set commands">
            <command name="vkCreateDescriptorSetLayout"/>
            <command name="vkDestroyDescriptorSetLayout"/>
            <command name="vkCreateDescriptorPool"/>
            <command name="vkDestroyDescriptorPool"/>
            <command name="vkResetDescriptorPool"/>
            <command name="vkAllocateDescriptorSets"/>
            <command name="vkFreeDescriptorSets"/>
            <command name="vkUpdateDescriptorSets"/>
        </require>
        <require comment="Pass commands">
            <command name="vkCreateFramebuffer"/>
            <command name="vkDestroyFramebuffer"/>
            <command name="vkCreateRenderPass"/>
            <command name="vkDestroyRenderPass"/>
            <command name="vkGetRenderAreaGranularity"/>
        </require>
        <require comment="Command pool commands">
            <command name="vkCreateCommandPool"/>
            <command name="vkDestroyCommandPool"/>
            <command name="vkResetCommandPool"/>
        </require>
        <require comment="Command buffer commands">
            <command name="vkAllocateCommandBuffers"/>
            <command name="vkFreeCommandBuffers"/>
            <command name="vkBeginCommandBuffer"/>
            <command name="vkEndCommandBuffer"/>
            <command name="vkResetCommandBuffer"/>
        </require>
        <require comment="Command buffer building commands">
            <command name="vkCmdBindPipeline"/>
            <command name="vkCmdSetViewport"/>
            <command name="vkCmdSetScissor"/>
            <command name="vkCmdSetLineWidth"/>
            <command name="vkCmdSetDepthBias"/>
            <command name="vkCmdSetBlendConstants"/>
            <command name="vkCmdSetDepthBounds"/>
            <command name="vkCmdSetStencilCompareMask"/>
            <command name="vkCmdSetStencilWriteMask"/>
            <command name="vkCmdSetStencilReference"/>
            <command name="vkCmdBindDescriptorSets"/>
            <command name="vkCmdBindIndexBuffer"/>
            <command name="vkCmdBindVertexBuffers"/>
            <command name="vkCmdDraw"/>
            <command name="vkCmdDrawIndexed"/>
            <command name="vkCmdDrawIndirect"/>
            <command name="vkCmdDrawIndexedIndirect"/>
            <command name="vkCmdDispatch"/>
            <command name="vkCmdDispatchIndirect"/>
            <command name="vkCmdCopyBuffer"/>
            <command name="vkCmdCopyImage"/>
            <command name="vkCmdBlitImage"/>
            <command name="vkCmdCopyBufferToImage"/>
            <command name="vkCmdCopyImageToBuffer"/>
            <command name="vkCmdUpdateBuffer"/>
            <command name="vkCmdFillBuffer"/>
            <command name="vkCmdClearColorImage"/>
            <command name="vkCmdClearDepthStencilImage"/>
            <command name="vkCmdClearAttachments"/>
            <command name="vkCmdResolveImage"/>
            <command name="vkCmdSetEvent"/>
            <command name="vkCmdResetEvent"/>
            <command name="vkCmdWaitEvents"/>
            <command name="vkCmdPipelineBarrier"/>
            <command name="vkCmdBeginQuery"/>
            <command name="vkCmdEndQuery"/>
            <command name="vkCmdResetQueryPool"/>
            <command name="vkCmdWriteTimestamp"/>
            <command name="vkCmdCopyQueryPoolResults"/>
            <command name="vkCmdPushConstants"/>
            <command name="vkCmdBeginRenderPass"/>
            <command name="vkCmdNextSubpass"/>
            <command name="vkCmdEndRenderPass"/>
            <command name="vkCmdExecuteCommands"/>
        </require>
        <require comment="Types not directly used by the API. Include e.g. structs that are not parameter types of commands, but still defined by the API.">
            <type name="VkBufferMemoryBarrier"/>
            <type name="VkDispatchIndirectCommand"/>
            <type name="VkDrawIndexedIndirectCommand"/>
            <type name="VkDrawIndirectCommand"/>
            <type name="VkImageMemoryBarrier"/>
            <type name="VkMemoryBarrier"/>
            <type name="VkObjectType"/>
            <type name="VkBaseOutStructure"/>
            <type name="VkBaseInStructure"/>
            <type name="VkVendorId"/>
        </require>
    </feature>
    <feature api="vulkan" name="VK_VERSION_1_1" number="1.1" comment="Vulkan 1.1 core API interface definitions.">
        <require>
            <type name="VK_API_VERSION_1_1"/>
        </require>
        <require comment="Device Initialization">
            <command name="vkEnumerateInstanceVersion"/>
        </require>
        <require comment="Promoted from VK_KHR_relaxed_block_layout, which has no API"/>
        <require comment="Promoted from VK_KHR_storage_buffer_storage_class, which has no API"/>
        <require comment="Originally based on VK_KHR_subgroup (extension 94), but the actual enum block used was, incorrectly, that of extension 95">
            <enum extends="VkStructureType" extnumber="95"  offset="0"          name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES"/>
            <type                                       name="VkPhysicalDeviceSubgroupProperties"/>
            <type                                       name="VkSubgroupFeatureFlags"/>
            <type                                       name="VkSubgroupFeatureFlagBits"/>
        </require>
        <require comment="Promoted from VK_KHR_bind_memory2">
            <command name="vkBindBufferMemory2"/>
            <command name="vkBindImageMemory2"/>
            <enum extends="VkStructureType" extnumber="158" offset="0"          name="VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO"/>
            <enum extends="VkStructureType" extnumber="158" offset="1"          name="VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO"/>
            <enum bitpos="10" extends="VkImageCreateFlagBits"                   name="VK_IMAGE_CREATE_ALIAS_BIT"/>
            <type name="VkBindBufferMemoryInfo"/>
            <type name="VkBindImageMemoryInfo"/>
        </require>
        <require comment="Promoted from VK_KHR_16bit_storage">
            <enum extends="VkStructureType" extnumber="84"  offset="0"          name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES"/>
            <type name="VkPhysicalDevice16BitStorageFeatures"/>
        </require>
        <require comment="Promoted from VK_KHR_dedicated_allocation">
            <enum extends="VkStructureType" extnumber="128" offset="0"          name="VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS"/>
            <enum extends="VkStructureType" extnumber="128" offset="1"          name="VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO"/>
            <type name="VkMemoryDedicatedRequirements"/>
            <type name="VkMemoryDedicatedAllocateInfo"/>
        </require>
        <require comment="Promoted from VK_KHR_device_group">
            <enum extends="VkStructureType" extnumber="61"  offset="0"          name="VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO"/>
            <comment>offset 1 reserved for the old VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO_KHX enum</comment>
            <comment>offset 2 reserved for the old VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO_KHX enum</comment>
            <enum extends="VkStructureType" extnumber="61"  offset="3"          name="VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO"/>
            <enum extends="VkStructureType" extnumber="61"  offset="4"          name="VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO"/>
            <enum extends="VkStructureType" extnumber="61"  offset="5"          name="VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO"/>
            <enum extends="VkStructureType" extnumber="61"  offset="6"          name="VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO"/>
            <type name="VkPeerMemoryFeatureFlags"/>
            <type name="VkPeerMemoryFeatureFlagBits"/>
            <type name="VkMemoryAllocateFlags"/>
            <type name="VkMemoryAllocateFlagBits"/>
            <type name="VkMemoryAllocateFlagsInfo"/>
            <type name="VkDeviceGroupRenderPassBeginInfo"/>
            <type name="VkDeviceGroupCommandBufferBeginInfo"/>
            <type name="VkDeviceGroupSubmitInfo"/>
            <type name="VkDeviceGroupBindSparseInfo"/>
            <command name="vkGetDeviceGroupPeerMemoryFeatures"/>
            <command name="vkCmdSetDeviceMask"/>
            <command name="vkCmdDispatchBase"/>
            <enum bitpos="3"  extends="VkPipelineCreateFlagBits"                name="VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT"/>
            <enum bitpos="4"  extends="VkPipelineCreateFlagBits"                name="VK_PIPELINE_CREATE_DISPATCH_BASE"/>
            <enum bitpos="2"  extends="VkDependencyFlagBits"                    name="VK_DEPENDENCY_DEVICE_GROUP_BIT" comment="Dependency is across devices"/>
        </require>
        <require comment="Promoted from VK_KHR_device_group + VK_KHR_bind_memory2">
            <enum extends="VkStructureType" extnumber="61"  offset="13"         name="VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO"/>
            <enum extends="VkStructureType" extnumber="61"  offset="14"         name="VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO"/>
            <type name="VkBindBufferMemoryDeviceGroupInfo"/>
            <type name="VkBindImageMemoryDeviceGroupInfo"/>
            <enum bitpos="6"  extends="VkImageCreateFlagBits"                   name="VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT" comment="Allows using VkBindImageMemoryDeviceGroupInfo::pSplitInstanceBindRegions when binding memory to the image"/>
        </require>
        <require comment="Promoted from VK_KHR_device_group_creation">
            <enum extends="VkStructureType" extnumber="71"  offset="0"          name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES"/>
            <enum extends="VkStructureType" extnumber="71"  offset="1"          name="VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO"/>
            <enum name="VK_MAX_DEVICE_GROUP_SIZE"/>
            <type name="VkPhysicalDeviceGroupProperties"/>
            <type name="VkDeviceGroupDeviceCreateInfo"/>
            <command name="vkEnumeratePhysicalDeviceGroups"/>
            <enum bitpos="1"  extends="VkMemoryHeapFlagBits"                    name="VK_MEMORY_HEAP_MULTI_INSTANCE_BIT" comment="If set, heap allocations allocate multiple instances by default"/>
        </require>
        <require comment="Promoted from VK_KHR_get_memory_requirements2">
            <enum extends="VkStructureType" extnumber="147" offset="0"          name="VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2"/>
            <enum extends="VkStructureType" extnumber="147" offset="1"          name="VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2"/>
            <enum extends="VkStructureType" extnumber="147" offset="2"          name="VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2"/>
            <enum extends="VkStructureType" extnumber="147" offset="3"          name="VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2"/>
            <enum extends="VkStructureType" extnumber="147" offset="4"          name="VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2"/>
            <type name="VkBufferMemoryRequirementsInfo2"/>
            <type name="VkImageMemoryRequirementsInfo2"/>
            <type name="VkImageSparseMemoryRequirementsInfo2"/>
            <type name="VkMemoryRequirements2KHR"/>
            <type name="VkMemoryRequirements2"/>
            <type name="VkSparseImageMemoryRequirements2"/>
            <command name="vkGetImageMemoryRequirements2"/>
            <command name="vkGetBufferMemoryRequirements2"/>
            <command name="vkGetImageSparseMemoryRequirements2"/>
        </require>
        <require comment="Promoted from VK_KHR_get_physical_device_properties2">
            <enum extends="VkStructureType" extnumber="60"  offset="0"          name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2"/>
            <enum extends="VkStructureType" extnumber="60"  offset="1"          name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2"/>
            <enum extends="VkStructureType" extnumber="60"  offset="2"          name="VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2"/>
            <enum extends="VkStructureType" extnumber="60"  offset="3"          name="VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2"/>
            <enum extends="VkStructureType" extnumber="60"  offset="4"          name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2"/>
            <enum extends="VkStructureType" extnumber="60"  offset="5"          name="VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2"/>
            <enum extends="VkStructureType" extnumber="60"  offset="6"          name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2"/>
            <enum extends="VkStructureType" extnumber="60"  offset="7"          name="VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2"/>
            <enum extends="VkStructureType" extnumber="60"  offset="8"          name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2"/>
            <type name="VkPhysicalDeviceFeatures2"/>
            <type name="VkPhysicalDeviceProperties2"/>
            <type name="VkFormatProperties2"/>
            <type name="VkImageFormatProperties2"/>
            <type name="VkPhysicalDeviceImageFormatInfo2"/>
            <type name="VkQueueFamilyProperties2"/>
            <type name="VkPhysicalDeviceMemoryProperties2"/>
            <type name="VkSparseImageFormatProperties2"/>
            <type name="VkPhysicalDeviceSparseImageFormatInfo2"/>
            <command name="vkGetPhysicalDeviceFeatures2"/>
            <command name="vkGetPhysicalDeviceProperties2"/>
            <command name="vkGetPhysicalDeviceFormatProperties2"/>
            <command name="vkGetPhysicalDeviceImageFormatProperties2"/>
            <command name="vkGetPhysicalDeviceQueueFamilyProperties2"/>
            <command name="vkGetPhysicalDeviceMemoryProperties2"/>
            <command name="vkGetPhysicalDeviceSparseImageFormatProperties2"/>
        </require>
        <require comment="Promoted from VK_KHR_maintenance1">
            <enum extends="VkResult"        extnumber="70"  offset="0"  dir="-" name="VK_ERROR_OUT_OF_POOL_MEMORY"/>
            <enum bitpos="14" extends="VkFormatFeatureFlagBits"                 name="VK_FORMAT_FEATURE_TRANSFER_SRC_BIT" comment="Format can be used as the source image of image transfer commands"/>
            <enum bitpos="15" extends="VkFormatFeatureFlagBits"                 name="VK_FORMAT_FEATURE_TRANSFER_DST_BIT" comment="Format can be used as the destination image of image transfer commands"/>
            <enum bitpos="5"  extends="VkImageCreateFlagBits"                   name="VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT" comment="The 3D image can be viewed as a 2D or 2D array image"/>
            <command name="vkTrimCommandPool"/>
            <comment>Additional dependent types / tokens extending enumerants, not explicitly mentioned</comment>
            <type name="VkCommandPoolTrimFlags"/>
        </require>
        <require comment="Promoted from VK_KHR_maintenance2">
            <enum bitpos="7"  extends="VkImageCreateFlagBits"                   name="VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT"/>
            <enum bitpos="8"  extends="VkImageCreateFlagBits"                   name="VK_IMAGE_CREATE_EXTENDED_USAGE_BIT"/>
            <enum extends="VkStructureType" extnumber="118" offset="0"          name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES"/>
            <enum extends="VkStructureType" extnumber="118" offset="1"          name="VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO"/>
            <enum extends="VkStructureType" extnumber="118" offset="2"          name="VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO"/>
            <enum extends="VkStructureType" extnumber="118" offset="3"          name="VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO"/>
            <enum extends="VkImageLayout"   extnumber="118" offset="0"          name="VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL"/>
            <enum extends="VkImageLayout"   extnumber="118" offset="1"          name="VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL"/>
            <type name="VkPhysicalDevicePointClippingProperties"/>
            <type name="VkPointClippingBehavior"/>
            <type name="VkRenderPassInputAttachmentAspectCreateInfo"/>
            <type name="VkInputAttachmentAspectReference"/>
            <type name="VkImageViewUsageCreateInfo"/>
            <type name="VkTessellationDomainOrigin"/>
            <type name="VkPipelineTessellationDomainOriginStateCreateInfo"/>
        </require>
        <require comment="Promoted from VK_KHR_multiview">
            <enum extends="VkStructureType" extnumber="54"  offset="0"          name="VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO"/>
            <enum extends="VkStructureType" extnumber="54"  offset="1"          name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES"/>
            <enum extends="VkStructureType" extnumber="54"  offset="2"          name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES"/>
            <enum bitpos="1"  extends="VkDependencyFlagBits"                    name="VK_DEPENDENCY_VIEW_LOCAL_BIT"/>
            <type name="VkRenderPassMultiviewCreateInfo"/>
            <type name="VkPhysicalDeviceMultiviewFeatures"/>
            <type name="VkPhysicalDeviceMultiviewProperties"/>
        </require>
        <require comment="Promoted from VK_KHR_variable_pointers">
            <enum extends="VkStructureType" extnumber="121" offset="0"          name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES"/>
            <enum extends="VkStructureType"                                     name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES"/>
            <type name="VkPhysicalDeviceVariablePointerFeatures"/>
            <type name="VkPhysicalDeviceVariablePointersFeatures"/>
        </require>
        <require comment="Originally based on VK_KHR_protected_memory (extension 146), which was never published; thus the mystifying large value= numbers below. These are not aliased since they weren't actually promoted from an extension.">
            <enum extends="VkStructureType" extnumber="146" offset="0"          name="VK_STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO"/>
            <enum extends="VkStructureType" extnumber="146" offset="1"          name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES"/>
            <enum extends="VkStructureType" extnumber="146" offset="2"          name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES"/>
            <enum extends="VkStructureType" extnumber="146" offset="3"          name="VK_STRUCTURE_TYPE_DEVICE_QUEUE_INFO_2"/>
            <enum bitpos="4"  extends="VkQueueFlagBits"                         name="VK_QUEUE_PROTECTED_BIT" comment="Queues may support protected operations"/>
            <enum bitpos="0"  extends="VkDeviceQueueCreateFlagBits"             name="VK_DEVICE_QUEUE_CREATE_PROTECTED_BIT" comment="Queue is a protected-capable device queue"/>
            <enum bitpos="5"  extends="VkMemoryPropertyFlagBits"                name="VK_MEMORY_PROPERTY_PROTECTED_BIT" comment="Memory is protected"/>
            <enum bitpos="3"  extends="VkBufferCreateFlagBits"                  name="VK_BUFFER_CREATE_PROTECTED_BIT" comment="Buffer requires protected memory"/>
            <enum bitpos="11" extends="VkImageCreateFlagBits"                   name="VK_IMAGE_CREATE_PROTECTED_BIT" comment="Image requires protected memory"/>
            <enum bitpos="2"  extends="VkCommandPoolCreateFlagBits"             name="VK_COMMAND_POOL_CREATE_PROTECTED_BIT" comment="Command buffers allocated from pool are protected command buffers"/>
            <type name="VkPhysicalDeviceProtectedMemoryFeatures"/>
            <type name="VkPhysicalDeviceProtectedMemoryProperties"/>
            <type name="VkDeviceQueueInfo2"/>
            <type name="VkProtectedSubmitInfo"/>
            <command name="vkGetDeviceQueue2"/>
        </require>
        <require comment="Promoted from VK_KHR_sampler_ycbcr_conversion">
            <enum extends="VkStructureType" extnumber="157" offset="0"          name="VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO"/>
            <enum extends="VkStructureType" extnumber="157" offset="1"          name="VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO"/>
            <enum extends="VkStructureType" extnumber="157" offset="2"          name="VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO"/>
            <enum extends="VkStructureType" extnumber="157" offset="3"          name="VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO"/>
            <enum extends="VkStructureType" extnumber="157" offset="4"          name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES"/>
            <enum extends="VkStructureType" extnumber="157" offset="5"          name="VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES"/>
            <enum extends="VkObjectType"    extnumber="157" offset="0"          name="VK_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION"/>
            <enum extends="VkFormat"        extnumber="157" offset="0"          name="VK_FORMAT_G8B8G8R8_422_UNORM"/>
            <enum extends="VkFormat"        extnumber="157" offset="1"          name="VK_FORMAT_B8G8R8G8_422_UNORM"/>
            <enum extends="VkFormat"        extnumber="157" offset="2"          name="VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM"/>
            <enum extends="VkFormat"        extnumber="157" offset="3"          name="VK_FORMAT_G8_B8R8_2PLANE_420_UNORM"/>
            <enum extends="VkFormat"        extnumber="157" offset="4"          name="VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM"/>
            <enum extends="VkFormat"        extnumber="157" offset="5"          name="VK_FORMAT_G8_B8R8_2PLANE_422_UNORM"/>
            <enum extends="VkFormat"        extnumber="157" offset="6"          name="VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM"/>
            <enum extends="VkFormat"        extnumber="157" offset="7"          name="VK_FORMAT_R10X6_UNORM_PACK16"/>
            <enum extends="VkFormat"        extnumber="157" offset="8"          name="VK_FORMAT_R10X6G10X6_UNORM_2PACK16"/>
            <enum extends="VkFormat"        extnumber="157" offset="9"          name="VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16"/>
            <enum extends="VkFormat"        extnumber="157" offset="10"         name="VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16"/>
            <enum extends="VkFormat"        extnumber="157" offset="11"         name="VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16"/>
            <enum extends="VkFormat"        extnumber="157" offset="12"         name="VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16"/>
            <enum extends="VkFormat"        extnumber="157" offset="13"         name="VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16"/>
            <enum extends="VkFormat"        extnumber="157" offset="14"         name="VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16"/>
            <enum extends="VkFormat"        extnumber="157" offset="15"         name="VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16"/>
            <enum extends="VkFormat"        extnumber="157" offset="16"         name="VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16"/>
            <enum extends="VkFormat"        extnumber="157" offset="17"         name="VK_FORMAT_R12X4_UNORM_PACK16"/>
            <enum extends="VkFormat"        extnumber="157" offset="18"         name="VK_FORMAT_R12X4G12X4_UNORM_2PACK16"/>
            <enum extends="VkFormat"        extnumber="157" offset="19"         name="VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16"/>
            <enum extends="VkFormat"        extnumber="157" offset="20"         name="VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16"/>
            <enum extends="VkFormat"        extnumber="157" offset="21"         name="VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16"/>
            <enum extends="VkFormat"        extnumber="157" offset="22"         name="VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16"/>
            <enum extends="VkFormat"        extnumber="157" offset="23"         name="VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16"/>
            <enum extends="VkFormat"        extnumber="157" offset="24"         name="VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16"/>
            <enum extends="VkFormat"        extnumber="157" offset="25"         name="VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16"/>
            <enum extends="VkFormat"        extnumber="157" offset="26"         name="VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16"/>
            <enum extends="VkFormat"        extnumber="157" offset="27"         name="VK_FORMAT_G16B16G16R16_422_UNORM"/>
            <enum extends="VkFormat"        extnumber="157" offset="28"         name="VK_FORMAT_B16G16R16G16_422_UNORM"/>
            <enum extends="VkFormat"        extnumber="157" offset="29"         name="VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM"/>
            <enum extends="VkFormat"        extnumber="157" offset="30"         name="VK_FORMAT_G16_B16R16_2PLANE_420_UNORM"/>
            <enum extends="VkFormat"        extnumber="157" offset="31"         name="VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM"/>
            <enum extends="VkFormat"        extnumber="157" offset="32"         name="VK_FORMAT_G16_B16R16_2PLANE_422_UNORM"/>
            <enum extends="VkFormat"        extnumber="157" offset="33"         name="VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM"/>
            <enum bitpos="4"  extends="VkImageAspectFlagBits"                   name="VK_IMAGE_ASPECT_PLANE_0_BIT"/>
            <enum bitpos="5"  extends="VkImageAspectFlagBits"                   name="VK_IMAGE_ASPECT_PLANE_1_BIT"/>
            <enum bitpos="6"  extends="VkImageAspectFlagBits"                   name="VK_IMAGE_ASPECT_PLANE_2_BIT"/>
            <enum bitpos="9"  extends="VkImageCreateFlagBits"                   name="VK_IMAGE_CREATE_DISJOINT_BIT"/>
            <enum bitpos="17" extends="VkFormatFeatureFlagBits"                 name="VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT" comment="Format can have midpoint rather than cosited chroma samples"/>
            <enum bitpos="18" extends="VkFormatFeatureFlagBits"                 name="VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT" comment="Format can be used with linear filtering whilst color conversion is enabled"/>
            <enum bitpos="19" extends="VkFormatFeatureFlagBits"                 name="VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT" comment="Format can have different chroma, min and mag filters"/>
            <enum bitpos="20" extends="VkFormatFeatureFlagBits"                 name="VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT"/>
            <enum bitpos="21" extends="VkFormatFeatureFlagBits"                 name="VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT"/>
            <enum bitpos="22" extends="VkFormatFeatureFlagBits"                 name="VK_FORMAT_FEATURE_DISJOINT_BIT" comment="Format supports disjoint planes"/>
            <enum bitpos="23" extends="VkFormatFeatureFlagBits"                 name="VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT" comment="Format can have cosited rather than midpoint chroma samples"/>
            <type name="VkSamplerYcbcrConversionCreateInfo"/>
            <type name="VkSamplerYcbcrConversionInfo"/>
            <type name="VkBindImagePlaneMemoryInfo"/>
            <type name="VkImagePlaneMemoryRequirementsInfo"/>
            <type name="VkPhysicalDeviceSamplerYcbcrConversionFeatures"/>
            <type name="VkSamplerYcbcrConversionImageFormatProperties"/>
            <command name="vkCreateSamplerYcbcrConversion"/>
            <command name="vkDestroySamplerYcbcrConversion"/>
            <comment>Additional dependent types / tokens extending enumerants, not explicitly mentioned</comment>
            <type name="VkSamplerYcbcrConversion"/>
            <type name="VkSamplerYcbcrModelConversion"/>
            <type name="VkSamplerYcbcrRange"/>
            <type name="VkChromaLocation"/>
        </require>
        <require comment="Promoted from VK_KHR_descriptor_update_template">
            <enum extends="VkStructureType" extnumber="86"  offset="0"          name="VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO"/>
            <enum extends="VkObjectType"    extnumber="86"  offset="0"          name="VK_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE"/>
            <command name="vkCreateDescriptorUpdateTemplate"/>
            <command name="vkDestroyDescriptorUpdateTemplate"/>
            <command name="vkUpdateDescriptorSetWithTemplate"/>
            <type name="VkDescriptorUpdateTemplate"/>
            <type name="VkDescriptorUpdateTemplateCreateFlags"/>
            <type name="VkDescriptorUpdateTemplateType"/>
            <type name="VkDescriptorUpdateTemplateEntry"/>
            <type name="VkDescriptorUpdateTemplateCreateInfo"/>
        </require>
        <require comment="Promoted from VK_KHR_external_memory_capabilities">
            <enum extends="VkStructureType" extnumber="72"  offset="0"          name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO"/>
            <enum extends="VkStructureType" extnumber="72"  offset="1"          name="VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES"/>
            <enum extends="VkStructureType" extnumber="72"  offset="2"          name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO"/>
            <enum extends="VkStructureType" extnumber="72"  offset="3"          name="VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES"/>
            <enum extends="VkStructureType" extnumber="72"  offset="4"          name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES"/>
            <enum name="VK_LUID_SIZE"/>
            <type name="VkExternalMemoryHandleTypeFlags"/>
            <type name="VkExternalMemoryHandleTypeFlagBits"/>
            <type name="VkExternalMemoryFeatureFlags"/>
            <type name="VkExternalMemoryFeatureFlagBits"/>
            <type name="VkExternalMemoryProperties"/>
            <type name="VkPhysicalDeviceExternalImageFormatInfo"/>
            <type name="VkExternalImageFormatProperties"/>
            <type name="VkPhysicalDeviceExternalBufferInfo"/>
            <type name="VkExternalBufferProperties"/>
            <type name="VkPhysicalDeviceIDProperties"/>
            <command name="vkGetPhysicalDeviceExternalBufferProperties"/>
        </require>
        <require comment="Promoted from VK_KHR_external_memory">
            <enum extends="VkStructureType" extnumber="73"  offset="0"          name="VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO"/>
            <enum extends="VkStructureType" extnumber="73"  offset="1"          name="VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO"/>
            <enum extends="VkStructureType" extnumber="73"  offset="2"          name="VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO"/>
            <enum extends="VkResult"        extnumber="73"  offset="3"  dir="-" name="VK_ERROR_INVALID_EXTERNAL_HANDLE"/>
            <enum name="VK_QUEUE_FAMILY_EXTERNAL"/>
            <type name="VkExternalMemoryImageCreateInfo"/>
            <type name="VkExternalMemoryBufferCreateInfo"/>
            <type name="VkExportMemoryAllocateInfo"/>
        </require>
        <require comment="Promoted from VK_KHR_external_fence_capabilities">
            <enum extends="VkStructureType" extnumber="113" offset="0"          name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO"/>
            <enum extends="VkStructureType" extnumber="113" offset="1"          name="VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES"/>
            <type name="VkExternalFenceHandleTypeFlags"/>
            <type name="VkExternalFenceHandleTypeFlagBits"/>
            <type name="VkExternalFenceFeatureFlags"/>
            <type name="VkExternalFenceFeatureFlagBits"/>
            <type name="VkPhysicalDeviceExternalFenceInfo"/>
            <type name="VkExternalFenceProperties"/>
            <command name="vkGetPhysicalDeviceExternalFenceProperties"/>
        </require>
        <require comment="Promoted from VK_KHR_external_fence">
            <enum extends="VkStructureType" extnumber="114" offset="0"          name="VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO"/>
            <type name="VkFenceImportFlags"/>
            <type name="VkFenceImportFlagBits"/>
            <type name="VkExportFenceCreateInfo"/>
        </require>
        <require comment="Promoted from VK_KHR_external_semaphore">
            <enum extends="VkStructureType" extnumber="78"  offset="0"          name="VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO"/>
            <type name="VkSemaphoreImportFlags"/>
            <type name="VkSemaphoreImportFlagBits"/>
            <type name="VkExportSemaphoreCreateInfo"/>
        </require>
        <require comment="Promoted from VK_KHR_external_semaphore_capabilities">
            <enum extends="VkStructureType" extnumber="77"  offset="0"          name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO"/>
            <enum extends="VkStructureType" extnumber="77"  offset="1"          name="VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES"/>
            <type name="VkExternalSemaphoreHandleTypeFlags"/>
            <type name="VkExternalSemaphoreHandleTypeFlagBits"/>
            <type name="VkExternalSemaphoreFeatureFlags"/>
            <type name="VkExternalSemaphoreFeatureFlagBits"/>
            <type name="VkPhysicalDeviceExternalSemaphoreInfo"/>
            <type name="VkExternalSemaphoreProperties"/>
            <command name="vkGetPhysicalDeviceExternalSemaphoreProperties"/>
        </require>
        <require comment="Promoted from VK_KHR_maintenance3">
            <enum extends="VkStructureType" extnumber="169" offset="0"          name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES"/>
            <enum extends="VkStructureType" extnumber="169" offset="1"          name="VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT"/>
            <type name="VkPhysicalDeviceMaintenance3Properties"/>
            <type name="VkDescriptorSetLayoutSupport"/>
            <command name="vkGetDescriptorSetLayoutSupport"/>
        </require>
        <require comment="Promoted from VK_KHR_shader_draw_parameters, with a feature support query added">
            <enum extends="VkStructureType" extnumber="64"  offset="0"          name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES"/>
            <enum extends="VkStructureType"                                     name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETER_FEATURES" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES"/>
            <type name="VkPhysicalDeviceShaderDrawParameterFeatures"/>
            <type name="VkPhysicalDeviceShaderDrawParametersFeatures"/>
        </require>
    </feature>


    <extensions comment="Vulkan extension interface definitions">
        <extension name="VK_KHR_surface" number="1" type="instance" author="KHR" contact="James Jones @cubanismo,Ian Elliott @ianelliottus" supported="vulkan">
            <require>
                <enum value="25"                                                name="VK_KHR_SURFACE_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_surface&quot;"                        name="VK_KHR_SURFACE_EXTENSION_NAME"/>
                <enum offset="0" extends="VkResult" dir="-"                     name="VK_ERROR_SURFACE_LOST_KHR"/>
                <enum offset="1" extends="VkResult" dir="-"                     name="VK_ERROR_NATIVE_WINDOW_IN_USE_KHR"/>
                <enum offset="0" extends="VkObjectType"                         name="VK_OBJECT_TYPE_SURFACE_KHR"                  comment="VkSurfaceKHR"/>
                <command name="vkDestroySurfaceKHR"/>
                <command name="vkGetPhysicalDeviceSurfaceSupportKHR"/>
                <command name="vkGetPhysicalDeviceSurfaceCapabilitiesKHR"/>
                <command name="vkGetPhysicalDeviceSurfaceFormatsKHR"/>
                <command name="vkGetPhysicalDeviceSurfacePresentModesKHR"/>
            </require>
        </extension>
        <extension name="VK_KHR_swapchain" number="2" type="device" requires="VK_KHR_surface" author="KHR" contact="James Jones @cubanismo,Ian Elliott @ianelliottus" supported="vulkan">
            <require>
                <enum value="70"                                                name="VK_KHR_SWAPCHAIN_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_swapchain&quot;"                      name="VK_KHR_SWAPCHAIN_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR"/>
                <enum offset="1" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_PRESENT_INFO_KHR"/>
                <enum offset="2" extends="VkImageLayout"                        name="VK_IMAGE_LAYOUT_PRESENT_SRC_KHR"/>
                <enum offset="3" extends="VkResult"                             name="VK_SUBOPTIMAL_KHR"/>
                <enum offset="4" extends="VkResult" dir="-"                     name="VK_ERROR_OUT_OF_DATE_KHR"/>
                <enum offset="0" extends="VkObjectType"                         name="VK_OBJECT_TYPE_SWAPCHAIN_KHR"              comment="VkSwapchainKHR"/>
                <command name="vkCreateSwapchainKHR"/>
                <command name="vkDestroySwapchainKHR"/>
                <command name="vkGetSwapchainImagesKHR"/>
                <command name="vkAcquireNextImageKHR"/>
                <command name="vkQueuePresentKHR"/>
            </require>
            <require feature="VK_VERSION_1_1">
                <comment>This duplicates definitions in VK_KHR_device_group below</comment>
                <enum extends="VkStructureType" extnumber="61"  offset="7"      name="VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_CAPABILITIES_KHR"/>
                <enum extends="VkStructureType" extnumber="61"  offset="8"      name="VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR"/>
                <enum extends="VkStructureType" extnumber="61"  offset="9"      name="VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR"/>
                <enum extends="VkStructureType" extnumber="61"  offset="10"     name="VK_STRUCTURE_TYPE_ACQUIRE_NEXT_IMAGE_INFO_KHR"/>
                <enum extends="VkStructureType" extnumber="61"  offset="11"     name="VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR"/>
                <enum extends="VkStructureType" extnumber="61"  offset="12"     name="VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR"/>
                <enum bitpos="0" extends="VkSwapchainCreateFlagBitsKHR"         name="VK_SWAPCHAIN_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR" comment="Allow images with VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT"/>
                <type name="VkImageSwapchainCreateInfoKHR"/>
                <type name="VkBindImageMemorySwapchainInfoKHR"/>
                <type name="VkAcquireNextImageInfoKHR"/>
                <type name="VkDeviceGroupPresentModeFlagBitsKHR"/>
                <type name="VkDeviceGroupPresentModeFlagsKHR"/>
                <type name="VkDeviceGroupPresentCapabilitiesKHR"/>
                <type name="VkDeviceGroupPresentInfoKHR"/>
                <type name="VkDeviceGroupSwapchainCreateInfoKHR"/>
                <command name="vkGetDeviceGroupPresentCapabilitiesKHR"/>
                <command name="vkGetDeviceGroupSurfacePresentModesKHR"/>
                <command name="vkGetPhysicalDevicePresentRectanglesKHR"/>
                <command name="vkAcquireNextImage2KHR"/>
                <enum bitpos="1" extends="VkSwapchainCreateFlagBitsKHR"         name="VK_SWAPCHAIN_CREATE_PROTECTED_BIT_KHR"     comment="Swapchain is protected"/>
            </require>
        </extension>
        <extension name="VK_KHR_display" number="3" type="instance" requires="VK_KHR_surface" author="KHR" contact="James Jones @cubanismo,Norbert Nopper @FslNopper" supported="vulkan">
            <require>
                <enum value="21"                                                name="VK_KHR_DISPLAY_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_display&quot;"                        name="VK_KHR_DISPLAY_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR"/>
                <enum offset="1" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR"/>
                <enum offset="0" extends="VkObjectType"                         name="VK_OBJECT_TYPE_DISPLAY_KHR"               comment="VkDisplayKHR"/>
                <enum offset="1" extends="VkObjectType"                         name="VK_OBJECT_TYPE_DISPLAY_MODE_KHR"          comment="VkDisplayModeKHR"/>
                <type name="VkDisplayPlaneAlphaFlagsKHR"/>
                <type name="VkDisplayPlaneAlphaFlagBitsKHR"/>
                <type name="VkDisplayPropertiesKHR"/>
                <type name="VkDisplayModeParametersKHR"/>
                <type name="VkDisplayModePropertiesKHR"/>
                <type name="VkDisplayModeCreateInfoKHR"/>
                <type name="VkDisplayPlaneCapabilitiesKHR"/>
                <type name="VkDisplayPlanePropertiesKHR"/>
                <type name="VkDisplaySurfaceCreateInfoKHR"/>
                <command name="vkGetPhysicalDeviceDisplayPropertiesKHR"/>
                <command name="vkGetPhysicalDeviceDisplayPlanePropertiesKHR"/>
                <command name="vkGetDisplayPlaneSupportedDisplaysKHR"/>
                <command name="vkGetDisplayModePropertiesKHR"/>
                <command name="vkCreateDisplayModeKHR"/>
                <command name="vkGetDisplayPlaneCapabilitiesKHR"/>
                <command name="vkCreateDisplayPlaneSurfaceKHR"/>
            </require>
        </extension>
        <extension name="VK_KHR_display_swapchain" number="4" type="device" requires="VK_KHR_swapchain,VK_KHR_display" author="KHR" contact="James Jones @cubanismo" supported="vulkan">
            <require>
                <enum value="9"                                                 name="VK_KHR_DISPLAY_SWAPCHAIN_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_display_swapchain&quot;"              name="VK_KHR_DISPLAY_SWAPCHAIN_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR"/>
                <enum offset="1" extends="VkResult" dir="-"                     name="VK_ERROR_INCOMPATIBLE_DISPLAY_KHR"/>
                <type name="VkDisplayPresentInfoKHR"/>
                <command name="vkCreateSharedSwapchainsKHR"/>
            </require>
        </extension>
        <extension name="VK_KHR_xlib_surface" number="5" type="instance" requires="VK_KHR_surface" platform="xlib" author="KHR" contact="Jesse Hall @critsec,Ian Elliott @ianelliottus" supported="vulkan">
            <require>
                <enum value="6"                                                 name="VK_KHR_XLIB_SURFACE_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_xlib_surface&quot;"                   name="VK_KHR_XLIB_SURFACE_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR"/>
                <type name="VkXlibSurfaceCreateFlagsKHR"/>
                <type name="VkXlibSurfaceCreateInfoKHR"/>
                <command name="vkCreateXlibSurfaceKHR"/>
                <command name="vkGetPhysicalDeviceXlibPresentationSupportKHR"/>
            </require>
        </extension>
        <extension name="VK_KHR_xcb_surface" number="6" type="instance" requires="VK_KHR_surface" platform="xcb" author="KHR" contact="Jesse Hall @critsec,Ian Elliott @ianelliottus" supported="vulkan">
            <require>
                <enum value="6"                                                 name="VK_KHR_XCB_SURFACE_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_xcb_surface&quot;"                    name="VK_KHR_XCB_SURFACE_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_XCB_SURFACE_CREATE_INFO_KHR"/>
                <type name="VkXcbSurfaceCreateFlagsKHR"/>
                <type name="VkXcbSurfaceCreateInfoKHR"/>
                <command name="vkCreateXcbSurfaceKHR"/>
                <command name="vkGetPhysicalDeviceXcbPresentationSupportKHR"/>
            </require>
        </extension>
        <extension name="VK_KHR_wayland_surface" number="7" type="instance" requires="VK_KHR_surface" platform="wayland" author="KHR" contact="Jesse Hall @critsec,Ian Elliott @ianelliottus" supported="vulkan">
            <require>
                <enum value="6"                                                 name="VK_KHR_WAYLAND_SURFACE_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_wayland_surface&quot;"                name="VK_KHR_WAYLAND_SURFACE_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_WAYLAND_SURFACE_CREATE_INFO_KHR"/>
                <type name="VkWaylandSurfaceCreateFlagsKHR"/>
                <type name="VkWaylandSurfaceCreateInfoKHR"/>
                <command name="vkCreateWaylandSurfaceKHR"/>
                <command name="vkGetPhysicalDeviceWaylandPresentationSupportKHR"/>
            </require>
        </extension>
        <!-- Extension permanently disabled.  Extension number should not be re-used -->
        <extension name="VK_KHR_mir_surface" number="8" type="instance" requires="VK_KHR_surface" author="KHR" supported="disabled">
            <require>
                <enum value="4"                                                 name="VK_KHR_MIR_SURFACE_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_mir_surface&quot;"                    name="VK_KHR_MIR_SURFACE_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_KHR_android_surface" number="9" type="instance" requires="VK_KHR_surface" platform="android" author="KHR" contact="Jesse Hall @critsec" supported="vulkan">
            <require>
                <enum value="6"                                                 name="VK_KHR_ANDROID_SURFACE_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_android_surface&quot;"                name="VK_KHR_ANDROID_SURFACE_EXTENSION_NAME"/>
                <type name="ANativeWindow"/>
                <enum offset="0" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_ANDROID_SURFACE_CREATE_INFO_KHR"/>
                <type name="VkAndroidSurfaceCreateFlagsKHR"/>
                <type name="VkAndroidSurfaceCreateInfoKHR"/>
                <command name="vkCreateAndroidSurfaceKHR"/>
            </require>
        </extension>
        <extension name="VK_KHR_win32_surface" number="10" type="instance" requires="VK_KHR_surface" platform="win32" author="KHR" contact="Jesse Hall @critsec,Ian Elliott @ianelliottus" supported="vulkan">
            <require>
                <enum value="6"                                                 name="VK_KHR_WIN32_SURFACE_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_win32_surface&quot;"                  name="VK_KHR_WIN32_SURFACE_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR"/>
                <type name="VkWin32SurfaceCreateFlagsKHR"/>
                <type name="VkWin32SurfaceCreateInfoKHR"/>
                <command name="vkCreateWin32SurfaceKHR"/>
                <command name="vkGetPhysicalDeviceWin32PresentationSupportKHR"/>
            </require>
        </extension>
        <extension name="VK_ANDROID_native_buffer" number="11" type="device" author="ANDROID" platform="android" contact="Jesse Hall @critsec" supported="disabled">
            <require>
                <comment>VK_ANDROID_native_buffer is used between the Android Vulkan loader and drivers to implement the WSI extensions. It isn't exposed to applications and uses types that aren't part of Android's stable public API, so it is left disabled to keep it out of the standard Vulkan headers.</comment>
                <enum value="5"                                                 name="VK_ANDROID_NATIVE_BUFFER_SPEC_VERSION"/>
                <enum value="11"                                                name="VK_ANDROID_NATIVE_BUFFER_NUMBER"/>
                <enum value="&quot;VK_ANDROID_native_buffer&quot;"              name="VK_ANDROID_NATIVE_BUFFER_NAME"/>
                <enum offset="0" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_NATIVE_BUFFER_ANDROID"/>
                <type name="VkNativeBufferANDROID"/>
                <command name="vkGetSwapchainGrallocUsageANDROID"/>
                <command name="vkAcquireImageANDROID"/>
                <command name="vkQueueSignalReleaseImageANDROID"/>
            </require>
        </extension>
        <extension name="VK_EXT_debug_report" number="12" type="instance" author="GOOGLE" contact="Courtney Goeltzenleuchter @courtney-g" supported="vulkan" deprecatedby="VK_EXT_debug_utils">
            <require>
                <enum value="9"                                                 name="VK_EXT_DEBUG_REPORT_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_debug_report&quot;"                   name="VK_EXT_DEBUG_REPORT_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT"/>
                <enum alias="VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT" extends="VkStructureType" name="VK_STRUCTURE_TYPE_DEBUG_REPORT_CREATE_INFO_EXT" comment="Backwards-compatible alias containing a typo"/>
                <enum offset="1" extends="VkResult" dir="-"                     name="VK_ERROR_VALIDATION_FAILED_EXT"/>
                <enum offset="0" extends="VkObjectType"                         name="VK_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT"          comment="VkDebugReportCallbackEXT"/>
                <type name="VkDebugReportObjectTypeEXT"/>
                <type name="VkDebugReportCallbackCreateInfoEXT"/>
                <command name="vkCreateDebugReportCallbackEXT"/>
                <command name="vkDestroyDebugReportCallbackEXT"/>
                <command name="vkDebugReportMessageEXT"/>
            </require>
            <require feature="VK_VERSION_1_1">
                <comment>This duplicates definitions in other extensions, below</comment>
                <enum extends="VkDebugReportObjectTypeEXT" extnumber="157" offset="0"  name="VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_EXT"/>
                <enum extends="VkDebugReportObjectTypeEXT" extnumber="86"  offset="0"  name="VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_EXT"/>
            </require>
        </extension>
        <extension name="VK_NV_glsl_shader" number="13" type="device" author="NV" contact="Piers Daniell @pdaniell-nv" supported="vulkan" deprecatedby="">
            <require>
                <enum value="1"                                                 name="VK_NV_GLSL_SHADER_SPEC_VERSION"/>
                <enum value="&quot;VK_NV_glsl_shader&quot;"                     name="VK_NV_GLSL_SHADER_EXTENSION_NAME"/>
                <enum offset="0" extends="VkResult" dir="-"                     name="VK_ERROR_INVALID_SHADER_NV"/>
            </require>
        </extension>
        <extension name="VK_EXT_depth_range_unrestricted" type="device" number="14" author="NV" contact="Piers Daniell @pdaniell-nv" supported="vulkan">
            <require>
                <enum value="1"                                                 name="VK_EXT_DEPTH_RANGE_UNRESTRICTED_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_depth_range_unrestricted&quot;"       name="VK_EXT_DEPTH_RANGE_UNRESTRICTED_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_KHR_sampler_mirror_clamp_to_edge" type="device" number="15" author="KHR" contact="Tobias Hector @tobski" supported="vulkan">
            <require>
                <enum value="1"                                                 name="VK_KHR_SAMPLER_MIRROR_CLAMP_TO_EDGE_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_sampler_mirror_clamp_to_edge&quot;"   name="VK_KHR_SAMPLER_MIRROR_CLAMP_TO_EDGE_EXTENSION_NAME"/>
                <enum value="4" extends="VkSamplerAddressMode"                  name="VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE" comment="Note that this defines what was previously a core enum, and so uses the 'value' attribute rather than 'offset', and does not have a suffix. This is a special case, and should not be repeated"/>
            </require>
        </extension>
        <extension name="VK_IMG_filter_cubic" number="16" type="device" author="IMG" contact="Tobias Hector @tobski" supported="vulkan">
            <require>
                <enum value="1"                                                 name="VK_IMG_FILTER_CUBIC_SPEC_VERSION"/>
                <enum value="&quot;VK_IMG_filter_cubic&quot;"                   name="VK_IMG_FILTER_CUBIC_EXTENSION_NAME"/>
                <enum offset="0" extends="VkFilter"                             name="VK_FILTER_CUBIC_IMG"/>
                <enum bitpos="13" extends="VkFormatFeatureFlagBits"             name="VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_IMG" comment="Format can be filtered with VK_FILTER_CUBIC_IMG when being sampled"/>
            </require>
        </extension>
        <extension name="VK_AMD_extension_17" number="17" author="AMD" contact="Daniel Rakos @drakos-amd" supported="disabled">
            <require>
                <enum value="0"                                                 name="VK_AMD_EXTENSION_17_SPEC_VERSION"/>
                <enum value="&quot;VK_AMD_extension_17&quot;"                   name="VK_AMD_EXTENSION_17_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_AMD_extension_18" number="18" author="AMD" contact="Daniel Rakos @drakos-amd" supported="disabled">
            <require>
                <enum value="0"                                                 name="VK_AMD_EXTENSION_18_SPEC_VERSION"/>
                <enum value="&quot;VK_AMD_extension_18&quot;"                   name="VK_AMD_EXTENSION_18_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_AMD_rasterization_order" number="19" type="device" author="AMD" contact="Daniel Rakos @drakos-amd" supported="vulkan">
            <require>
                <enum value="1"                                                 name="VK_AMD_RASTERIZATION_ORDER_SPEC_VERSION"/>
                <enum value="&quot;VK_AMD_rasterization_order&quot;"            name="VK_AMD_RASTERIZATION_ORDER_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD"/>
                <type name="VkRasterizationOrderAMD"/>
                <type name="VkPipelineRasterizationStateRasterizationOrderAMD"/>
            </require>
        </extension>
        <extension name="VK_AMD_extension_20" number="20" author="AMD" contact="Daniel Rakos @drakos-amd" supported="disabled">
            <require>
                <enum value="0"                                                 name="VK_AMD_EXTENSION_20_SPEC_VERSION"/>
                <enum value="&quot;VK_AMD_extension_20&quot;"                   name="VK_AMD_EXTENSION_20_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_AMD_shader_trinary_minmax" number="21" type="device" author="AMD" contact="Qun Lin @linqun" supported="vulkan">
            <require>
                <enum value="1"                                                 name="VK_AMD_SHADER_TRINARY_MINMAX_SPEC_VERSION"/>
                <enum value="&quot;VK_AMD_shader_trinary_minmax&quot;"          name="VK_AMD_SHADER_TRINARY_MINMAX_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_AMD_shader_explicit_vertex_parameter" number="22" type="device" author="AMD" contact="Qun Lin @linqun" supported="vulkan">
            <require>
                <enum value="1"                                                 name="VK_AMD_SHADER_EXPLICIT_VERTEX_PARAMETER_SPEC_VERSION"/>
                <enum value="&quot;VK_AMD_shader_explicit_vertex_parameter&quot;" name="VK_AMD_SHADER_EXPLICIT_VERTEX_PARAMETER_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_EXT_debug_marker" number="23" type="device" requires="VK_EXT_debug_report" author="Baldur Karlsson" contact="Baldur Karlsson @baldurk" supported="vulkan" promotedto="VK_EXT_debug_utils">
            <require>
                <enum value="4"                                                 name="VK_EXT_DEBUG_MARKER_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_debug_marker&quot;"                   name="VK_EXT_DEBUG_MARKER_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_NAME_INFO_EXT"/>
                <enum offset="1" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_TAG_INFO_EXT"/>
                <enum offset="2" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_DEBUG_MARKER_MARKER_INFO_EXT"/>
                <type name="VkDebugReportObjectTypeEXT"/>
                <type name="VkDebugMarkerObjectNameInfoEXT"/>
                <type name="VkDebugMarkerObjectTagInfoEXT"/>
                <type name="VkDebugMarkerMarkerInfoEXT"/>
                <command name="vkDebugMarkerSetObjectTagEXT"/>
                <command name="vkDebugMarkerSetObjectNameEXT"/>
                <command name="vkCmdDebugMarkerBeginEXT"/>
                <command name="vkCmdDebugMarkerEndEXT"/>
                <command name="vkCmdDebugMarkerInsertEXT"/>
            </require>
        </extension>
        <extension name="VK_AMD_extension_24" number="24" author="AMD" contact="Daniel Rakos @drakos-amd" supported="disabled">
            <require>
                <enum value="0"                                         name="VK_AMD_EXTENSION_24_SPEC_VERSION"/>
                <enum value="&quot;VK_AMD_extension_24&quot;"           name="VK_AMD_EXTENSION_24_EXTENSION_NAME"/>
                <enum bitpos="6" extends="VkQueueFlagBits"              name="VK_QUEUE_RESERVED_6_BIT_KHR"/>
                <enum bitpos="27" extends="VkPipelineStageFlagBits"     name="VK_PIPELINE_STAGE_RESERVED_27_BIT_KHR"/>
                <enum bitpos="30" extends="VkAccessFlagBits"            name="VK_ACCESS_RESERVED_30_BIT_KHR"/>
                <enum bitpos="31" extends="VkAccessFlagBits"            name="VK_ACCESS_RESERVED_31_BIT_KHR"/>
                <enum bitpos="15" extends="VkBufferUsageFlagBits"       name="VK_BUFFER_USAGE_RESERVED_15_BIT_KHR"/>
                <enum bitpos="16" extends="VkBufferUsageFlagBits"       name="VK_BUFFER_USAGE_RESERVED_16_BIT_KHR"/>
                <enum bitpos="13" extends="VkImageUsageFlagBits"        name="VK_IMAGE_USAGE_RESERVED_13_BIT_KHR"/>
                <enum bitpos="14" extends="VkImageUsageFlagBits"        name="VK_IMAGE_USAGE_RESERVED_14_BIT_KHR"/>
                <enum bitpos="15" extends="VkImageUsageFlagBits"        name="VK_IMAGE_USAGE_RESERVED_15_BIT_KHR"/>
                <enum bitpos="27" extends="VkFormatFeatureFlagBits"     name="VK_FORMAT_FEATURE_RESERVED_27_BIT_KHR"/>
                <enum bitpos="28" extends="VkFormatFeatureFlagBits"     name="VK_FORMAT_FEATURE_RESERVED_28_BIT_KHR"/>
                <enum offset="8" extends="VkQueryType"                  name="VK_QUERY_TYPE_RESERVED_8"/>
            </require>
        </extension>
        <extension name="VK_AMD_extension_25" number="25" author="AMD" contact="Daniel Rakos @drakos-amd" supported="disabled">
            <require>
                <enum value="0"                                         name="VK_AMD_EXTENSION_25_SPEC_VERSION"/>
                <enum value="&quot;VK_AMD_extension_25&quot;"           name="VK_AMD_EXTENSION_25_EXTENSION_NAME"/>
                <enum bitpos="5" extends="VkQueueFlagBits"              name="VK_QUEUE_RESERVED_5_BIT_KHR"/>
                <enum bitpos="26" extends="VkPipelineStageFlagBits"     name="VK_PIPELINE_STAGE_RESERVED_26_BIT_KHR"/>
                <enum bitpos="28" extends="VkAccessFlagBits"            name="VK_ACCESS_RESERVED_28_BIT_KHR"/>
                <enum bitpos="29" extends="VkAccessFlagBits"            name="VK_ACCESS_RESERVED_29_BIT_KHR"/>
                <enum bitpos="13" extends="VkBufferUsageFlagBits"       name="VK_BUFFER_USAGE_RESERVED_13_BIT_KHR"/>
                <enum bitpos="14" extends="VkBufferUsageFlagBits"       name="VK_BUFFER_USAGE_RESERVED_14_BIT_KHR"/>
                <enum bitpos="10" extends="VkImageUsageFlagBits"        name="VK_IMAGE_USAGE_RESERVED_10_BIT_KHR"/>
                <enum bitpos="11" extends="VkImageUsageFlagBits"        name="VK_IMAGE_USAGE_RESERVED_11_BIT_KHR"/>
                <enum bitpos="12" extends="VkImageUsageFlagBits"        name="VK_IMAGE_USAGE_RESERVED_12_BIT_KHR"/>
                <enum bitpos="25" extends="VkFormatFeatureFlagBits"     name="VK_FORMAT_FEATURE_RESERVED_25_BIT_KHR"/>
                <enum bitpos="26" extends="VkFormatFeatureFlagBits"     name="VK_FORMAT_FEATURE_RESERVED_26_BIT_KHR"/>
                <enum offset="4"  extends="VkQueryType"                 name="VK_QUERY_TYPE_RESERVED_4"/>
            </require>
        </extension>
        <extension name="VK_AMD_gcn_shader" number="26" type="device" author="AMD" contact="Dominik Witczak @dominikwitczakamd" supported="vulkan">
            <require>
                <enum value="1"                                                 name="VK_AMD_GCN_SHADER_SPEC_VERSION"/>
                <enum value="&quot;VK_AMD_gcn_shader&quot;"                     name="VK_AMD_GCN_SHADER_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_NV_dedicated_allocation" number="27" type="device" author="NV" contact="Jeff Bolz @jeffbolznv" supported="vulkan" deprecatedby="VK_KHR_dedicated_allocation">
            <require>
                <enum value="1"                                                 name="VK_NV_DEDICATED_ALLOCATION_SPEC_VERSION"/>
                <enum value="&quot;VK_NV_dedicated_allocation&quot;"            name="VK_NV_DEDICATED_ALLOCATION_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV"/>
                <enum offset="1" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV"/>
                <enum offset="2" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV"/>
                <type name="VkDedicatedAllocationImageCreateInfoNV"/>
                <type name="VkDedicatedAllocationBufferCreateInfoNV"/>
                <type name="VkDedicatedAllocationMemoryAllocateInfoNV"/>
            </require>
        </extension>
        <extension name="VK_EXT_extension_28" number="28" author="NV" contact="Piers Daniell @pdaniell-nv" supported="disabled">
            <require>
                <enum value="0"                                                 name="VK_EXT_EXTENSION_28_SPEC_VERSION"/>
                <enum value="&quot;VK_NV_extension_28&quot;"                    name="VK_EXT_EXTENSION_28_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_EXT_transform_feedback" number="29" type="device" author="NV" contact="Piers Daniell @pdaniell-nv" supported="vulkan" requires="VK_KHR_get_physical_device_properties2">
            <require>
                <enum value="1"                                                 name="VK_EXT_TRANSFORM_FEEDBACK_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_transform_feedback&quot;"             name="VK_EXT_TRANSFORM_FEEDBACK_EXTENSION_NAME"/>
                <command name="vkCmdBindTransformFeedbackBuffersEXT"/>
                <command name="vkCmdBeginTransformFeedbackEXT"/>
                <command name="vkCmdEndTransformFeedbackEXT"/>
                <command name="vkCmdBeginQueryIndexedEXT"/>
                <command name="vkCmdEndQueryIndexedEXT"/>
                <command name="vkCmdDrawIndirectByteCountEXT"/>

                <enum offset="0" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT"/>
                <enum offset="1" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_PROPERTIES_EXT"/>
                <enum offset="2" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_STREAM_CREATE_INFO_EXT"/>

                <enum offset="4" extends="VkQueryType"                          name="VK_QUERY_TYPE_TRANSFORM_FEEDBACK_STREAM_EXT"/>

                <enum bitpos="11" extends="VkBufferUsageFlagBits"                name="VK_BUFFER_USAGE_TRANSFORM_FEEDBACK_BUFFER_BIT_EXT"/>
                <enum bitpos="12" extends="VkBufferUsageFlagBits"                name="VK_BUFFER_USAGE_TRANSFORM_FEEDBACK_COUNTER_BUFFER_BIT_EXT"/>

                <enum bitpos="25" extends="VkAccessFlagBits"                    name="VK_ACCESS_TRANSFORM_FEEDBACK_WRITE_BIT_EXT"/>
                <enum bitpos="26" extends="VkAccessFlagBits"                    name="VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_READ_BIT_EXT"/>
                <enum bitpos="27" extends="VkAccessFlagBits"                    name="VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_WRITE_BIT_EXT"/>

                <enum bitpos="24" extends="VkPipelineStageFlagBits"             name="VK_PIPELINE_STAGE_TRANSFORM_FEEDBACK_BIT_EXT"/>

                <type name="VkPhysicalDeviceTransformFeedbackFeaturesEXT"/>
                <type name="VkPhysicalDeviceTransformFeedbackPropertiesEXT"/>
                <type name="VkPipelineRasterizationStateStreamCreateInfoEXT"/>

                <type name="VkPipelineRasterizationStateStreamCreateFlagsEXT"/>
            </require>
        </extension>
        <extension name="VK_NVX_extension_30" number="30" author="NVX" contact="Jeff Juliano @jjulianoatnv" supported="disabled">
            <require>
                <enum value="0"                                                 name="VK_NVX_EXTENSION_30_SPEC_VERSION"/>
                <enum value="&quot;VK_NVX_extension_30&quot;"                   name="VK_NVX_EXTENSION_30_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_NVX_image_view_handle" number="31" type="device" author="NVX" contact="Eric Werness @ewerness" supported="vulkan">
            <require>
                <enum value="1"                                                 name="VK_NVX_IMAGE_VIEW_HANDLE_SPEC_VERSION"/>
                <enum value="&quot;VK_NVX_image_view_handle&quot;"              name="VK_NVX_IMAGE_VIEW_HANDLE_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_IMAGE_VIEW_HANDLE_INFO_NVX"/>
                <type name="VkImageViewHandleInfoNVX"/>
                <command name="vkGetImageViewHandleNVX"/>
            </require>
        </extension>
        <extension name="VK_AMD_extension_32" number="32" author="AMD" contact="Daniel Rakos @drakos-amd" supported="disabled">
            <require>
                <enum value="0"                                                 name="VK_AMD_EXTENSION_32_SPEC_VERSION"/>
                <enum value="&quot;VK_AMD_extension_32&quot;"                   name="VK_AMD_EXTENSION_32_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_AMD_extension_33" number="33" author="AMD" contact="Daniel Rakos @drakos-amd" supported="disabled">
            <require>
                <enum value="0"                                                 name="VK_AMD_EXTENSION_33_SPEC_VERSION"/>
                <enum value="&quot;VK_AMD_extension_33&quot;"                   name="VK_AMD_EXTENSION_33_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_AMD_draw_indirect_count" number="34" type="device" author="AMD" contact="Daniel Rakos @drakos-amd" supported="vulkan" promotedto="VK_KHR_draw_indirect_count">
            <require>
                <enum value="1"                                                 name="VK_AMD_DRAW_INDIRECT_COUNT_SPEC_VERSION"/>
                <enum value="&quot;VK_AMD_draw_indirect_count&quot;"            name="VK_AMD_DRAW_INDIRECT_COUNT_EXTENSION_NAME"/>
                <command name="vkCmdDrawIndirectCountAMD"/>
                <command name="vkCmdDrawIndexedIndirectCountAMD"/>
            </require>
        </extension>
        <extension name="VK_AMD_extension_35" number="35" author="AMD" contact="Daniel Rakos @drakos-amd" supported="disabled">
            <require>
                <enum value="0"                                                 name="VK_AMD_EXTENSION_35_SPEC_VERSION"/>
                <enum value="&quot;VK_AMD_extension_35&quot;"                   name="VK_AMD_EXTENSION_35_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_AMD_negative_viewport_height" number="36" type="device" author="AMD" contact="Matthaeus G. Chajdas @anteru" supported="vulkan" obsoletedby="VK_KHR_maintenance1">
            <require>
                <enum value="1"                                                 name="VK_AMD_NEGATIVE_VIEWPORT_HEIGHT_SPEC_VERSION"/>
                <enum value="&quot;VK_AMD_negative_viewport_height&quot;"       name="VK_AMD_NEGATIVE_VIEWPORT_HEIGHT_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_AMD_gpu_shader_half_float" number="37" type="device" author="AMD" contact="Dominik Witczak @dominikwitczakamd" supported="vulkan" deprecatedby="VK_KHR_shader_float16_int8">
            <require>
                <enum value="2"                                                 name="VK_AMD_GPU_SHADER_HALF_FLOAT_SPEC_VERSION"/>
                <enum value="&quot;VK_AMD_gpu_shader_half_float&quot;"          name="VK_AMD_GPU_SHADER_HALF_FLOAT_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_AMD_shader_ballot" number="38" type="device" author="AMD" contact="Dominik Witczak @dominikwitczakamd" supported="vulkan">
            <require>
                <enum value="1"                                                 name="VK_AMD_SHADER_BALLOT_SPEC_VERSION"/>
                <enum value="&quot;VK_AMD_shader_ballot&quot;"                  name="VK_AMD_SHADER_BALLOT_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_AMD_extension_39" number="39" author="AMD" contact="Daniel Rakos @drakos-amd" supported="disabled">
            <require>
                <enum value="0"                                                 name="VK_AMD_EXTENSION_39_SPEC_VERSION"/>
                <enum value="&quot;VK_AMD_extension_39&quot;"                   name="VK_AMD_EXTENSION_39_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_AMD_extension_40" number="40" author="AMD" contact="Daniel Rakos @drakos-amd" supported="disabled">
            <require>
                <enum value="0"                                                 name="VK_AMD_EXTENSION_40_SPEC_VERSION"/>
                <enum value="&quot;VK_AMD_extension_40&quot;"                   name="VK_AMD_EXTENSION_40_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_AMD_extension_41" number="41" author="AMD" contact="Daniel Rakos @drakos-amd" supported="disabled">
            <require>
                <enum value="0"                                                 name="VK_AMD_EXTENSION_41_SPEC_VERSION"/>
                <enum value="&quot;VK_AMD_extension_41&quot;"                   name="VK_AMD_EXTENSION_41_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_AMD_texture_gather_bias_lod" number="42" author="AMD" contact="Rex Xu @amdrexu" supported="vulkan" type="device" requires="VK_KHR_get_physical_device_properties2">
            <require>
                <enum value="1"                                                 name="VK_AMD_TEXTURE_GATHER_BIAS_LOD_SPEC_VERSION"/>
                <enum value="&quot;VK_AMD_texture_gather_bias_lod&quot;"        name="VK_AMD_TEXTURE_GATHER_BIAS_LOD_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD"/>
                <type name="VkTextureLODGatherFormatPropertiesAMD"/>
            </require>
        </extension>
        <extension name="VK_AMD_shader_info" number="43" author="AMD" contact="Jaakko Konttinen @jaakkoamd" supported="vulkan" type="device">
            <require>
                <enum value="1"                                                 name="VK_AMD_SHADER_INFO_SPEC_VERSION"/>
                <enum value="&quot;VK_AMD_shader_info&quot;"                    name="VK_AMD_SHADER_INFO_EXTENSION_NAME"/>
                <type name="VkShaderInfoTypeAMD"/>
                <type name="VkShaderResourceUsageAMD"/>
                <type name="VkShaderStatisticsInfoAMD"/>
                <command name="vkGetShaderInfoAMD"/>
            </require>
        </extension>
        <extension name="VK_AMD_extension_44" number="44" author="AMD" contact="Daniel Rakos @drakos-amd" supported="disabled">
            <require>
                <enum value="0"                                                 name="VK_AMD_EXTENSION_44_SPEC_VERSION"/>
                <enum value="&quot;VK_AMD_extension_44&quot;"                   name="VK_AMD_EXTENSION_44_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_AMD_extension_45" number="45" author="AMD" contact="Daniel Rakos @drakos-amd" supported="disabled">
            <require>
                <enum value="0"                                                 name="VK_AMD_EXTENSION_45_SPEC_VERSION"/>
                <enum value="&quot;VK_AMD_extension_45&quot;"                   name="VK_AMD_EXTENSION_45_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_AMD_extension_46" number="46" author="AMD" contact="Daniel Rakos @drakos-amd" supported="disabled">
            <require>
                <enum value="0"                                                 name="VK_AMD_EXTENSION_46_SPEC_VERSION"/>
                <enum value="&quot;VK_AMD_extension_46&quot;"                   name="VK_AMD_EXTENSION_46_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_AMD_shader_image_load_store_lod" number="47" author="AMD" contact="Dominik Witczak @dominikwitczakamd" supported="vulkan" type="device">
            <require>
                <enum value="1"                                                 name="VK_AMD_SHADER_IMAGE_LOAD_STORE_LOD_SPEC_VERSION"/>
                <enum value="&quot;VK_AMD_shader_image_load_store_lod&quot;"    name="VK_AMD_SHADER_IMAGE_LOAD_STORE_LOD_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_NVX_extension_48" number="48" author="NVX" contact="James Jones @cubanismo" supported="disabled">
            <require>
                <enum value="0"                                                 name="VK_NVX_EXTENSION_48_SPEC_VERSION"/>
                <enum value="&quot;VK_NVX_extension_48&quot;"                   name="VK_NVX_EXTENSION_48_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_GOOGLE_extension_49" number="49" author="GOOGLE" contact="Jean-Francois Roy @jfroy" supported="disabled">
            <require>
                <enum value="0"                                                 name="VK_GOOGLE_EXTENSION_49_SPEC_VERSION"/>
                <enum value="&quot;VK_GOOGLE_extension_49&quot;"                name="VK_GOOGLE_EXTENSION_49_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_GGP_stream_descriptor_surface" number="50" type="instance" requires="VK_KHR_surface" platform="ggp" author="GGP" contact="Jean-Francois Roy @jfroy" supported="vulkan">
            <require>
                <enum value="1"                                                 name="VK_GGP_STREAM_DESCRIPTOR_SURFACE_SPEC_VERSION"/>
                <enum value="&quot;VK_GGP_stream_descriptor_surface&quot;"      name="VK_GGP_STREAM_DESCRIPTOR_SURFACE_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_STREAM_DESCRIPTOR_SURFACE_CREATE_INFO_GGP"/>
                <type name="VkStreamDescriptorSurfaceCreateFlagsGGP"/>
                <type name="VkStreamDescriptorSurfaceCreateInfoGGP"/>
                <command name="vkCreateStreamDescriptorSurfaceGGP"/>
            </require>
        </extension>
        <extension name="VK_NV_corner_sampled_image" number="51" author="NV" type="device" requires="VK_KHR_get_physical_device_properties2" contact="Daniel Koch @dgkoch" supported="vulkan">
            <require>
                <enum value="2"                                                 name="VK_NV_CORNER_SAMPLED_IMAGE_SPEC_VERSION"/>
                <enum value="&quot;VK_NV_corner_sampled_image&quot;"            name="VK_NV_CORNER_SAMPLED_IMAGE_EXTENSION_NAME"/>
                <enum bitpos="13" extends="VkImageCreateFlagBits"               name="VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV"/>
                <enum offset="0" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CORNER_SAMPLED_IMAGE_FEATURES_NV"/>
                <type name="VkPhysicalDeviceCornerSampledImageFeaturesNV"/>
            </require>
        </extension>
        <extension name="VK_NVX_extension_52" number="52" author="NVX" contact="James Jones @cubanismo" supported="disabled">
            <require>
                <enum value="0"                                                 name="VK_NVX_EXTENSION_52_SPEC_VERSION"/>
                <enum value="&quot;VK_NVX_extension_52&quot;"                   name="VK_NVX_EXTENSION_52_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_NV_extension_53" number="53" author="NV" contact="Jeff Bolz @jeffbolznv" supported="disabled">
            <require>
                <enum value="0"                                                 name="VK_NV_EXTENSION_53_SPEC_VERSION"/>
                <enum value="&quot;VK_NV_extension_53&quot;"                    name="VK_NV_EXTENSION_53_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_KHR_multiview" number="54" type="device" author="KHR" requires="VK_KHR_get_physical_device_properties2" contact="Jeff Bolz @jeffbolznv" supported="vulkan" promotedto="VK_VERSION_1_1">
            <require>
                <enum value="1"                                                 name="VK_KHR_MULTIVIEW_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_multiview&quot;"                      name="VK_KHR_MULTIVIEW_EXTENSION_NAME"/>
                <enum extends="VkStructureType"                                 name="VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO_KHR" alias="VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO"/>
                <enum extends="VkStructureType"                                 name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES_KHR" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES"/>
                <enum extends="VkStructureType"                                 name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES_KHR" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES"/>
                <enum extends="VkDependencyFlagBits"                            name="VK_DEPENDENCY_VIEW_LOCAL_BIT_KHR" alias="VK_DEPENDENCY_VIEW_LOCAL_BIT"/>
                <type name="VkRenderPassMultiviewCreateInfoKHR"/>
                <type name="VkPhysicalDeviceMultiviewFeaturesKHR"/>
                <type name="VkPhysicalDeviceMultiviewPropertiesKHR"/>
            </require>
        </extension>
        <extension name="VK_IMG_format_pvrtc" number="55" type="device" author="IMG" contact="Tobias Hector @tobski" supported="vulkan">
            <require>
                <enum value="1"                                                 name="VK_IMG_FORMAT_PVRTC_SPEC_VERSION"/>
                <enum value="&quot;VK_IMG_format_pvrtc&quot;"                   name="VK_IMG_FORMAT_PVRTC_EXTENSION_NAME"/>
                <enum offset="0" extends="VkFormat"                             name="VK_FORMAT_PVRTC1_2BPP_UNORM_BLOCK_IMG"/>
                <enum offset="1" extends="VkFormat"                             name="VK_FORMAT_PVRTC1_4BPP_UNORM_BLOCK_IMG"/>
                <enum offset="2" extends="VkFormat"                             name="VK_FORMAT_PVRTC2_2BPP_UNORM_BLOCK_IMG"/>
                <enum offset="3" extends="VkFormat"                             name="VK_FORMAT_PVRTC2_4BPP_UNORM_BLOCK_IMG"/>
                <enum offset="4" extends="VkFormat"                             name="VK_FORMAT_PVRTC1_2BPP_SRGB_BLOCK_IMG"/>
                <enum offset="5" extends="VkFormat"                             name="VK_FORMAT_PVRTC1_4BPP_SRGB_BLOCK_IMG"/>
                <enum offset="6" extends="VkFormat"                             name="VK_FORMAT_PVRTC2_2BPP_SRGB_BLOCK_IMG"/>
                <enum offset="7" extends="VkFormat"                             name="VK_FORMAT_PVRTC2_4BPP_SRGB_BLOCK_IMG"/>
            </require>
        </extension>
        <extension name="VK_NV_external_memory_capabilities" number="56" type="instance" author="NV" contact="James Jones @cubanismo" supported="vulkan" deprecatedby="VK_KHR_external_memory_capabilities">
            <require>
                <enum value="1"                                                 name="VK_NV_EXTERNAL_MEMORY_CAPABILITIES_SPEC_VERSION"/>
                <enum value="&quot;VK_NV_external_memory_capabilities&quot;"    name="VK_NV_EXTERNAL_MEMORY_CAPABILITIES_EXTENSION_NAME"/>
                <type name="VkExternalMemoryHandleTypeFlagsNV"/>
                <type name="VkExternalMemoryHandleTypeFlagBitsNV"/>
                <type name="VkExternalMemoryFeatureFlagsNV"/>
                <type name="VkExternalMemoryFeatureFlagBitsNV"/>
                <type name="VkExternalImageFormatPropertiesNV"/>
                <command name="vkGetPhysicalDeviceExternalImageFormatPropertiesNV"/>
            </require>
        </extension>
        <extension name="VK_NV_external_memory" number="57" type="device" requires="VK_NV_external_memory_capabilities" author="NV" contact="James Jones @cubanismo" supported="vulkan" deprecatedby="VK_KHR_external_memory">
            <require>
                <enum value="1"                                                 name="VK_NV_EXTERNAL_MEMORY_SPEC_VERSION"/>
                <enum value="&quot;VK_NV_external_memory&quot;"                 name="VK_NV_EXTERNAL_MEMORY_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV"/>
                <enum offset="1" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_NV"/>
                <type name="VkExternalMemoryImageCreateInfoNV"/>
                <type name="VkExportMemoryAllocateInfoNV"/>
            </require>
        </extension>
        <extension name="VK_NV_external_memory_win32" number="58" type="device" requires="VK_NV_external_memory" author="NV" contact="James Jones @cubanismo" platform="win32" supported="vulkan" deprecatedby="VK_KHR_external_memory_win32">
            <require>
                <enum value="1"                                                 name="VK_NV_EXTERNAL_MEMORY_WIN32_SPEC_VERSION"/>
                <enum value="&quot;VK_NV_external_memory_win32&quot;"           name="VK_NV_EXTERNAL_MEMORY_WIN32_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_NV"/>
                <enum offset="1" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_NV"/>
                <type name="VkImportMemoryWin32HandleInfoNV"/>
                <type name="VkExportMemoryWin32HandleInfoNV"/>
                <command name="vkGetMemoryWin32HandleNV"/>
            </require>
        </extension>
        <extension name="VK_NV_win32_keyed_mutex" number="59" type="device" requires="VK_NV_external_memory_win32" author="NV" contact="Carsten Rohde @crohde" platform="win32" supported="vulkan" promotedto="VK_KHR_win32_keyed_mutex">
            <require>
                <enum value="1"                                                 name="VK_NV_WIN32_KEYED_MUTEX_SPEC_VERSION"/>
                <enum value="&quot;VK_NV_win32_keyed_mutex&quot;"               name="VK_NV_WIN32_KEYED_MUTEX_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV"/>
                <type name="VkWin32KeyedMutexAcquireReleaseInfoNV"/>
            </require>
        </extension>
        <extension name="VK_KHR_get_physical_device_properties2" number="60" type="instance" author="KHR" contact="Jeff Bolz @jeffbolznv" supported="vulkan" promotedto="VK_VERSION_1_1">
            <require>
                <enum value="1"                                                 name="VK_KHR_GET_PHYSICAL_DEVICE_PROPERTIES_2_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_get_physical_device_properties2&quot;" name="VK_KHR_GET_PHYSICAL_DEVICE_PROPERTIES_2_EXTENSION_NAME"/>
                <enum extends="VkStructureType"                                 name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2_KHR" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2"/>
                <enum extends="VkStructureType"                                 name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2_KHR" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2"/>
                <enum extends="VkStructureType"                                 name="VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2_KHR" alias="VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2"/>
                <enum extends="VkStructureType"                                 name="VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2_KHR" alias="VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2"/>
                <enum extends="VkStructureType"                                 name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2_KHR" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2"/>
                <enum extends="VkStructureType"                                 name="VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2_KHR" alias="VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2"/>
                <enum extends="VkStructureType"                                 name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2_KHR" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2"/>
                <enum extends="VkStructureType"                                 name="VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2_KHR" alias="VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2"/>
                <enum extends="VkStructureType"                                 name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2_KHR" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2"/>
                <type name="VkPhysicalDeviceFeatures2KHR"/>
                <type name="VkPhysicalDeviceProperties2KHR"/>
                <type name="VkFormatProperties2KHR"/>
                <type name="VkImageFormatProperties2KHR"/>
                <type name="VkPhysicalDeviceImageFormatInfo2KHR"/>
                <type name="VkQueueFamilyProperties2KHR"/>
                <type name="VkPhysicalDeviceMemoryProperties2KHR"/>
                <type name="VkSparseImageFormatProperties2KHR"/>
                <type name="VkPhysicalDeviceSparseImageFormatInfo2KHR"/>
                <command name="vkGetPhysicalDeviceFeatures2KHR"/>
                <command name="vkGetPhysicalDeviceProperties2KHR"/>
                <command name="vkGetPhysicalDeviceFormatProperties2KHR"/>
                <command name="vkGetPhysicalDeviceImageFormatProperties2KHR"/>
                <command name="vkGetPhysicalDeviceQueueFamilyProperties2KHR"/>
                <command name="vkGetPhysicalDeviceMemoryProperties2KHR"/>
                <command name="vkGetPhysicalDeviceSparseImageFormatProperties2KHR"/>
            </require>
        </extension>
        <extension name="VK_KHR_device_group" number="61" type="device" author="KHR" requires="VK_KHR_device_group_creation" contact="Jeff Bolz @jeffbolznv" supported="vulkan" promotedto="VK_VERSION_1_1">
            <require>
                <enum value="3"                                                 name="VK_KHR_DEVICE_GROUP_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_device_group&quot;"                   name="VK_KHR_DEVICE_GROUP_EXTENSION_NAME"/>
                <enum extends="VkStructureType"                                 name="VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO_KHR" alias="VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO"/>
                <enum extends="VkStructureType"                                 name="VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO_KHR" alias="VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO"/>
                <enum extends="VkStructureType"                                 name="VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO_KHR" alias="VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO"/>
                <enum extends="VkStructureType"                                 name="VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO_KHR" alias="VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO"/>
                <enum extends="VkStructureType"                                 name="VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO_KHR" alias="VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO"/>
                <type name="VkPeerMemoryFeatureFlagsKHR"/>
                <type name="VkPeerMemoryFeatureFlagBitsKHR"/>
                <enum extends="VkPeerMemoryFeatureFlagBits"                     name="VK_PEER_MEMORY_FEATURE_COPY_SRC_BIT_KHR" alias="VK_PEER_MEMORY_FEATURE_COPY_SRC_BIT"/>
                <enum extends="VkPeerMemoryFeatureFlagBits"                     name="VK_PEER_MEMORY_FEATURE_COPY_DST_BIT_KHR" alias="VK_PEER_MEMORY_FEATURE_COPY_DST_BIT"/>
                <enum extends="VkPeerMemoryFeatureFlagBits"                     name="VK_PEER_MEMORY_FEATURE_GENERIC_SRC_BIT_KHR" alias="VK_PEER_MEMORY_FEATURE_GENERIC_SRC_BIT"/>
                <enum extends="VkPeerMemoryFeatureFlagBits"                     name="VK_PEER_MEMORY_FEATURE_GENERIC_DST_BIT_KHR" alias="VK_PEER_MEMORY_FEATURE_GENERIC_DST_BIT"/>
                <type name="VkMemoryAllocateFlagsKHR"/>
                <type name="VkMemoryAllocateFlagBitsKHR"/>
                <enum extends="VkMemoryAllocateFlagBits"                        name="VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT_KHR" alias="VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT"/>
                <type name="VkMemoryAllocateFlagsInfoKHR"/>
                <type name="VkDeviceGroupRenderPassBeginInfoKHR"/>
                <type name="VkDeviceGroupCommandBufferBeginInfoKHR"/>
                <type name="VkDeviceGroupSubmitInfoKHR"/>
                <type name="VkDeviceGroupBindSparseInfoKHR"/>
                <command name="vkGetDeviceGroupPeerMemoryFeaturesKHR"/>
                <command name="vkCmdSetDeviceMaskKHR"/>
                <command name="vkCmdDispatchBaseKHR"/>
                <enum extends="VkPipelineCreateFlagBits"                        name="VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT_KHR" alias="VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT"/>
                <enum extends="VkPipelineCreateFlagBits"                        name="VK_PIPELINE_CREATE_DISPATCH_BASE_KHR" alias="VK_PIPELINE_CREATE_DISPATCH_BASE"/>
                <enum extends="VkDependencyFlagBits"                            name="VK_DEPENDENCY_DEVICE_GROUP_BIT_KHR" alias="VK_DEPENDENCY_DEVICE_GROUP_BIT"/>
            </require>
            <require extension="VK_KHR_bind_memory2">
                <enum extends="VkStructureType"                                 name="VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO_KHR" alias="VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO"/>
                <enum extends="VkStructureType"                                 name="VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO_KHR" alias="VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO"/>
                <type name="VkBindBufferMemoryDeviceGroupInfoKHR"/>
                <type name="VkBindImageMemoryDeviceGroupInfoKHR"/>
                <enum extends="VkImageCreateFlagBits"                           name="VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR" alias="VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT"/>
            </require>
            <require extension="VK_KHR_surface">
                <enum offset="7" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_CAPABILITIES_KHR"/>
                <type name="VkDeviceGroupPresentModeFlagBitsKHR"/>
                <type name="VkDeviceGroupPresentModeFlagsKHR"/>
                <type name="VkDeviceGroupPresentCapabilitiesKHR"/>
                <command name="vkGetDeviceGroupPresentCapabilitiesKHR"/>
                <command name="vkGetDeviceGroupSurfacePresentModesKHR"/>
                <command name="vkGetPhysicalDevicePresentRectanglesKHR"/>
            </require>
            <require extension="VK_KHR_swapchain">
                <enum offset="8" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR"/>
                <enum offset="9" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR"/>
                <enum offset="10" extends="VkStructureType"                     name="VK_STRUCTURE_TYPE_ACQUIRE_NEXT_IMAGE_INFO_KHR"/>
                <enum offset="11" extends="VkStructureType"                     name="VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR"/>
                <enum offset="12" extends="VkStructureType"                     name="VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR"/>
                <enum bitpos="0" extends="VkSwapchainCreateFlagBitsKHR"         name="VK_SWAPCHAIN_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR" comment="Allow images with VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT"/>
                <type name="VkImageSwapchainCreateInfoKHR"/>
                <type name="VkBindImageMemorySwapchainInfoKHR"/>
                <type name="VkAcquireNextImageInfoKHR"/>
                <type name="VkDeviceGroupPresentInfoKHR"/>
                <type name="VkDeviceGroupSwapchainCreateInfoKHR"/>
                <command name="vkAcquireNextImage2KHR"/>
            </require>
        </extension>
        <extension name="VK_EXT_validation_flags" number="62" type="instance" author="GOOGLE" contact="Tobin Ehlis @tobine" supported="vulkan">
            <require>
                <enum value="1"                                                 name="VK_EXT_VALIDATION_FLAGS_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_validation_flags&quot;"               name="VK_EXT_VALIDATION_FLAGS_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_VALIDATION_FLAGS_EXT"/>
                <type name="VkValidationFlagsEXT"/>
            </require>
        </extension>
        <extension name="VK_NN_vi_surface" number="63" type="instance" author="NN" contact="Mathias Heyer gitlab:@mheyer" requires="VK_KHR_surface" platform="vi" supported="vulkan">
            <require>
                <enum value="1"                                                 name="VK_NN_VI_SURFACE_SPEC_VERSION"/>
                <enum value="&quot;VK_NN_vi_surface&quot;"                      name="VK_NN_VI_SURFACE_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_VI_SURFACE_CREATE_INFO_NN"/>
                <type name="VkViSurfaceCreateFlagsNN"/>
                <type name="VkViSurfaceCreateInfoNN"/>
                <command name="vkCreateViSurfaceNN"/>
            </require>
        </extension>
        <extension name="VK_KHR_shader_draw_parameters" number="64" type="device" author="KHR" contact="Daniel Koch @dgkoch" supported="vulkan" promotedto="VK_VERSION_1_1">
            <require>
                <enum value="1"                                                 name="VK_KHR_SHADER_DRAW_PARAMETERS_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_shader_draw_parameters&quot;"         name="VK_KHR_SHADER_DRAW_PARAMETERS_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_EXT_shader_subgroup_ballot" number="65" type="device" author="NV" contact="Daniel Koch @dgkoch" supported="vulkan">
            <require>
                <enum value="1"                                                 name="VK_EXT_SHADER_SUBGROUP_BALLOT_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_shader_subgroup_ballot&quot;"         name="VK_EXT_SHADER_SUBGROUP_BALLOT_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_EXT_shader_subgroup_vote" number="66" type="device" author="NV" contact="Daniel Koch @dgkoch" supported="vulkan">
            <require>
                <enum value="1"                                                 name="VK_EXT_SHADER_SUBGROUP_VOTE_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_shader_subgroup_vote&quot;"           name="VK_EXT_SHADER_SUBGROUP_VOTE_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_ARM_extension_01" number="67" type="device" author="ARM" contact="Jan-Harald Fredriksen @janharaldfredriksen-arm" supported="disabled">
            <require>
                <enum value="0"                                                 name="VK_ARM_EXTENSION_01_SPEC_VERSION"/>
                <enum value="&quot;VK_ARM_extension_01&quot;"                   name="VK_ARM_EXTENSION_01_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_EXT_astc_decode_mode" number="68" type="device" author="ARM" contact="Jan-Harald Fredriksen @janharaldfredriksen-arm" requires="VK_KHR_get_physical_device_properties2" supported="vulkan">
            <require>
                <enum value="1"                                         name="VK_EXT_ASTC_DECODE_MODE_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_astc_decode_mode&quot;"       name="VK_EXT_ASTC_DECODE_MODE_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_IMAGE_VIEW_ASTC_DECODE_MODE_EXT"/>
                <enum offset="1" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT"/>
                <type name="VkImageViewASTCDecodeModeEXT"/>
                <type name="VkPhysicalDeviceASTCDecodeFeaturesEXT"/>
            </require>
        </extension>
        <extension name="VK_IMG_extension_69" number="69" type="device" author="IMG" contact="Tobias Hector @tobski" supported="disabled">
            <require>
                <enum value="0"                                                 name="VK_IMG_EXTENSION_69_SPEC_VERSION"/>
                <enum value="&quot;VK_IMG_extension_69&quot;"                   name="VK_IMG_EXTENSION_69_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_KHR_maintenance1" number="70" type="device" author="KHR" contact="Piers Daniell @pdaniell-nv" supported="vulkan" promotedto="VK_VERSION_1_1">
            <require>
                <enum value="2"                                                 name="VK_KHR_MAINTENANCE1_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_maintenance1&quot;"                   name="VK_KHR_MAINTENANCE1_EXTENSION_NAME"/>
                <enum extends="VkResult"                                        name="VK_ERROR_OUT_OF_POOL_MEMORY_KHR" alias="VK_ERROR_OUT_OF_POOL_MEMORY"/>
                <enum extends="VkFormatFeatureFlagBits"                         name="VK_FORMAT_FEATURE_TRANSFER_SRC_BIT_KHR" alias="VK_FORMAT_FEATURE_TRANSFER_SRC_BIT"/>
                <enum extends="VkFormatFeatureFlagBits"                         name="VK_FORMAT_FEATURE_TRANSFER_DST_BIT_KHR" alias="VK_FORMAT_FEATURE_TRANSFER_DST_BIT"/>
                <enum extends="VkImageCreateFlagBits"                           name="VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT_KHR" alias="VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT"/>
                <type name="VkCommandPoolTrimFlagsKHR"/>
                <command name="vkTrimCommandPoolKHR"/>
            </require>
        </extension>
        <extension name="VK_KHR_device_group_creation" number="71" type="instance" author="KHR" contact="Jeff Bolz @jeffbolznv" supported="vulkan" promotedto="VK_VERSION_1_1">
            <require>
                <enum value="1"                                                 name="VK_KHR_DEVICE_GROUP_CREATION_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_device_group_creation&quot;"          name="VK_KHR_DEVICE_GROUP_CREATION_EXTENSION_NAME"/>
                <enum extends="VkStructureType"                                 name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES_KHR" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES"/>
                <enum extends="VkStructureType"                                 name="VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO_KHR" alias="VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO"/>
                <enum name="VK_MAX_DEVICE_GROUP_SIZE_KHR"/>
                <type name="VkPhysicalDeviceGroupPropertiesKHR"/>
                <type name="VkDeviceGroupDeviceCreateInfoKHR"/>
                <command name="vkEnumeratePhysicalDeviceGroupsKHR"/>
                <enum extends="VkMemoryHeapFlagBits"                            name="VK_MEMORY_HEAP_MULTI_INSTANCE_BIT_KHR" alias="VK_MEMORY_HEAP_MULTI_INSTANCE_BIT"/>
            </require>
        </extension>
        <extension name="VK_KHR_external_memory_capabilities" number="72" type="instance" author="KHR" requires="VK_KHR_get_physical_device_properties2" contact="James Jones @cubanismo" supported="vulkan" promotedto="VK_VERSION_1_1">
            <require>
                <enum value="1"                                                 name="VK_KHR_EXTERNAL_MEMORY_CAPABILITIES_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_external_memory_capabilities&quot;"   name="VK_KHR_EXTERNAL_MEMORY_CAPABILITIES_EXTENSION_NAME"/>
                <enum extends="VkStructureType"                                 name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO_KHR" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO"/>
                <enum extends="VkStructureType"                                 name="VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES_KHR" alias="VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES"/>
                <enum extends="VkStructureType"                                 name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO_KHR" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO"/>
                <enum extends="VkStructureType"                                 name="VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES_KHR" alias="VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES"/>
                <enum extends="VkStructureType"                                 name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES_KHR" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES"/>
                <enum name="VK_LUID_SIZE_KHR"/>
                <type name="VkExternalMemoryHandleTypeFlagsKHR"/>
                <type name="VkExternalMemoryHandleTypeFlagBitsKHR"/>
                <enum extends="VkExternalMemoryHandleTypeFlagBits"              name="VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT_KHR" alias="VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT"/>
                <enum extends="VkExternalMemoryHandleTypeFlagBits"              name="VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR" alias="VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT"/>
                <enum extends="VkExternalMemoryHandleTypeFlagBits"              name="VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR" alias="VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT"/>
                <enum extends="VkExternalMemoryHandleTypeFlagBits"              name="VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT_KHR" alias="VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT"/>
                <enum extends="VkExternalMemoryHandleTypeFlagBits"              name="VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT_KHR" alias="VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT"/>
                <enum extends="VkExternalMemoryHandleTypeFlagBits"              name="VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT_KHR" alias="VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT"/>
                <enum extends="VkExternalMemoryHandleTypeFlagBits"              name="VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT_KHR" alias="VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT"/>
                <type name="VkExternalMemoryFeatureFlagsKHR"/>
                <type name="VkExternalMemoryFeatureFlagBitsKHR"/>
                <enum extends="VkExternalMemoryFeatureFlagBits"                 name="VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_KHR" alias="VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT"/>
                <enum extends="VkExternalMemoryFeatureFlagBits"                 name="VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT_KHR" alias="VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT"/>
                <enum extends="VkExternalMemoryFeatureFlagBits"                 name="VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT_KHR" alias="VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT"/>
                <type name="VkExternalMemoryPropertiesKHR"/>
                <type name="VkPhysicalDeviceExternalImageFormatInfoKHR"/>
                <type name="VkExternalImageFormatPropertiesKHR"/>
                <type name="VkPhysicalDeviceExternalBufferInfoKHR"/>
                <type name="VkExternalBufferPropertiesKHR"/>
                <type name="VkPhysicalDeviceIDPropertiesKHR"/>
                <command name="vkGetPhysicalDeviceExternalBufferPropertiesKHR"/>
            </require>
        </extension>
        <extension name="VK_KHR_external_memory" number="73" type="device" requires="VK_KHR_external_memory_capabilities" author="KHR" contact="James Jones @cubanismo" supported="vulkan" promotedto="VK_VERSION_1_1">
            <require>
                <enum value="1"                                                 name="VK_KHR_EXTERNAL_MEMORY_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_external_memory&quot;"                name="VK_KHR_EXTERNAL_MEMORY_EXTENSION_NAME"/>
                <enum extends="VkStructureType"                                 name="VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO_KHR" alias="VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO"/>
                <enum extends="VkStructureType"                                 name="VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_KHR" alias="VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO"/>
                <enum extends="VkStructureType"                                 name="VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_KHR" alias="VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO"/>
                <enum extends="VkResult"                                        name="VK_ERROR_INVALID_EXTERNAL_HANDLE_KHR" alias="VK_ERROR_INVALID_EXTERNAL_HANDLE"/>
                <enum name="VK_QUEUE_FAMILY_EXTERNAL_KHR"/>
                <type name="VkExternalMemoryImageCreateInfoKHR"/>
                <type name="VkExternalMemoryBufferCreateInfoKHR"/>
                <type name="VkExportMemoryAllocateInfoKHR"/>
            </require>
        </extension>
        <extension name="VK_KHR_external_memory_win32" number="74" type="device" requires="VK_KHR_external_memory" author="KHR" contact="James Jones @cubanismo" platform="win32" supported="vulkan">
            <require>
                <enum value="1"                                                 name="VK_KHR_EXTERNAL_MEMORY_WIN32_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_external_memory_win32&quot;"          name="VK_KHR_EXTERNAL_MEMORY_WIN32_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR"/>
                <enum offset="1" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR"/>
                <enum offset="2" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_MEMORY_WIN32_HANDLE_PROPERTIES_KHR"/>
                <enum offset="3" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_MEMORY_GET_WIN32_HANDLE_INFO_KHR"/>
                <type name="VkImportMemoryWin32HandleInfoKHR"/>
                <type name="VkExportMemoryWin32HandleInfoKHR"/>
                <type name="VkMemoryWin32HandlePropertiesKHR"/>
                <type name="VkMemoryGetWin32HandleInfoKHR"/>
                <command name="vkGetMemoryWin32HandleKHR"/>
                <command name="vkGetMemoryWin32HandlePropertiesKHR"/>
            </require>
        </extension>
        <extension name="VK_KHR_external_memory_fd" number="75" type="device" requires="VK_KHR_external_memory" author="KHR" contact="James Jones @cubanismo" supported="vulkan">
            <require>
                <enum value="1"                                                 name="VK_KHR_EXTERNAL_MEMORY_FD_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_external_memory_fd&quot;"             name="VK_KHR_EXTERNAL_MEMORY_FD_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR"/>
                <enum offset="1" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_MEMORY_FD_PROPERTIES_KHR"/>
                <enum offset="2" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_MEMORY_GET_FD_INFO_KHR"/>
                <type name="VkImportMemoryFdInfoKHR"/>
                <type name="VkMemoryFdPropertiesKHR"/>
                <type name="VkMemoryGetFdInfoKHR"/>
                <command name="vkGetMemoryFdKHR"/>
                <command name="vkGetMemoryFdPropertiesKHR"/>
            </require>
        </extension>
        <extension name="VK_KHR_win32_keyed_mutex" number="76" type="device" requires="VK_KHR_external_memory_win32" author="KHR" contact="Carsten Rohde @crohde" platform="win32" supported="vulkan">
            <require>
                <enum value="1"                                                 name="VK_KHR_WIN32_KEYED_MUTEX_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_win32_keyed_mutex&quot;"              name="VK_KHR_WIN32_KEYED_MUTEX_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR"/>
                <type name="VkWin32KeyedMutexAcquireReleaseInfoKHR"/>
            </require>
        </extension>
        <extension name="VK_KHR_external_semaphore_capabilities" number="77" type="instance" author="KHR" requires="VK_KHR_get_physical_device_properties2" contact="James Jones @cubanismo" supported="vulkan" promotedto="VK_VERSION_1_1">
            <require>
                <enum value="1"                                                 name="VK_KHR_EXTERNAL_SEMAPHORE_CAPABILITIES_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_external_semaphore_capabilities&quot;" name="VK_KHR_EXTERNAL_SEMAPHORE_CAPABILITIES_EXTENSION_NAME"/>
                <enum extends="VkStructureType"                                 name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO_KHR" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO"/>
                <enum extends="VkStructureType"                                 name="VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES_KHR" alias="VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES"/>
                <enum name="VK_LUID_SIZE_KHR"/>
                <type name="VkExternalSemaphoreHandleTypeFlagsKHR"/>
                <type name="VkExternalSemaphoreHandleTypeFlagBitsKHR"/>
                <enum extends="VkExternalSemaphoreHandleTypeFlagBits"       name="VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT_KHR" alias="VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT"/>
                <enum extends="VkExternalSemaphoreHandleTypeFlagBits"       name="VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR" alias="VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT"/>
                <enum extends="VkExternalSemaphoreHandleTypeFlagBits"       name="VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR" alias="VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT"/>
                <enum extends="VkExternalSemaphoreHandleTypeFlagBits"       name="VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT_KHR" alias="VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT"/>
                <enum extends="VkExternalSemaphoreHandleTypeFlagBits"       name="VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT_KHR" alias="VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT"/>
                <type name="VkExternalSemaphoreFeatureFlagsKHR"/>
                <type name="VkExternalSemaphoreFeatureFlagBitsKHR"/>
                <enum extends="VkExternalSemaphoreFeatureFlagBits"          name="VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT_KHR" alias="VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT"/>
                <enum extends="VkExternalSemaphoreFeatureFlagBits"          name="VK_EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT_KHR" alias="VK_EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT"/>
                <type name="VkPhysicalDeviceExternalSemaphoreInfoKHR"/>
                <type name="VkExternalSemaphorePropertiesKHR"/>
                <type name="VkPhysicalDeviceIDPropertiesKHR"/>
                <command name="vkGetPhysicalDeviceExternalSemaphorePropertiesKHR"/>
            </require>
        </extension>
        <extension name="VK_KHR_external_semaphore" number="78" type="device" requires="VK_KHR_external_semaphore_capabilities" author="KHR" contact="James Jones @cubanismo" supported="vulkan" promotedto="VK_VERSION_1_1">
            <require>
                <enum value="1"                                             name="VK_KHR_EXTERNAL_SEMAPHORE_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_external_semaphore&quot;"         name="VK_KHR_EXTERNAL_SEMAPHORE_EXTENSION_NAME"/>
                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO_KHR" alias="VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO"/>
                <type name="VkSemaphoreImportFlagsKHR"/>
                <type name="VkSemaphoreImportFlagBitsKHR"/>
                <enum extends="VkSemaphoreImportFlagBits"                   name="VK_SEMAPHORE_IMPORT_TEMPORARY_BIT_KHR" alias="VK_SEMAPHORE_IMPORT_TEMPORARY_BIT"/>
                <type name="VkExportSemaphoreCreateInfoKHR"/>
            </require>
        </extension>
        <extension name="VK_KHR_external_semaphore_win32" number="79" type="device" requires="VK_KHR_external_semaphore" author="KHR" contact="James Jones @cubanismo" platform="win32" supported="vulkan">
            <require>
                <enum value="1"                                             name="VK_KHR_EXTERNAL_SEMAPHORE_WIN32_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_external_semaphore_win32&quot;"   name="VK_KHR_EXTERNAL_SEMAPHORE_WIN32_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR"/>
                <enum offset="1" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR"/>
                <enum offset="2" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_D3D12_FENCE_SUBMIT_INFO_KHR"/>
                <enum offset="3" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_SEMAPHORE_GET_WIN32_HANDLE_INFO_KHR"/>
                <type name="VkImportSemaphoreWin32HandleInfoKHR"/>
                <type name="VkExportSemaphoreWin32HandleInfoKHR"/>
                <type name="VkD3D12FenceSubmitInfoKHR"/>
                <type name="VkSemaphoreGetWin32HandleInfoKHR"/>
                <command name="vkImportSemaphoreWin32HandleKHR"/>
                <command name="vkGetSemaphoreWin32HandleKHR"/>
            </require>
        </extension>
        <extension name="VK_KHR_external_semaphore_fd" number="80" type="device" requires="VK_KHR_external_semaphore" author="KHR" contact="James Jones @cubanismo" supported="vulkan">
            <require>
                <enum value="1"                                             name="VK_KHR_EXTERNAL_SEMAPHORE_FD_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_external_semaphore_fd&quot;"      name="VK_KHR_EXTERNAL_SEMAPHORE_FD_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_FD_INFO_KHR"/>
                <enum offset="1" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_SEMAPHORE_GET_FD_INFO_KHR"/>
                <type name="VkImportSemaphoreFdInfoKHR"/>
                <type name="VkSemaphoreGetFdInfoKHR"/>
                <command name="vkImportSemaphoreFdKHR"/>
                <command name="vkGetSemaphoreFdKHR"/>
            </require>
        </extension>
        <extension name="VK_KHR_push_descriptor" number="81" type="device" author="KHR" requires="VK_KHR_get_physical_device_properties2" contact="Jeff Bolz @jeffbolznv" supported="vulkan">
            <require>
                <enum value="2"                                             name="VK_KHR_PUSH_DESCRIPTOR_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_push_descriptor&quot;"            name="VK_KHR_PUSH_DESCRIPTOR_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES_KHR"/>
                <enum bitpos="0" extends="VkDescriptorSetLayoutCreateFlagBits"   name="VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR"  comment="Descriptors are pushed via flink:vkCmdPushDescriptorSetKHR"/>
                <command name="vkCmdPushDescriptorSetKHR"/>
                <type name="VkPhysicalDevicePushDescriptorPropertiesKHR"/>
            </require>
            <require feature="VK_VERSION_1_1">
                <command name="vkCmdPushDescriptorSetWithTemplateKHR"/>
                <enum value="1" extends="VkDescriptorUpdateTemplateType"    name="VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS_KHR" comment="Create descriptor update template for pushed descriptor updates"/>
            </require>
        </extension>
        <extension name="VK_EXT_conditional_rendering" number="82" type="device" author="NV" contact="Vikram Kushwaha @vkushwaha" supported="vulkan">
            <require>
                <enum value="1"                                             name="VK_EXT_CONDITIONAL_RENDERING_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_conditional_rendering&quot;"      name="VK_EXT_CONDITIONAL_RENDERING_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_CONDITIONAL_RENDERING_INFO_EXT"/>
                <enum offset="1" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT"/>
                <enum offset="2" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_CONDITIONAL_RENDERING_BEGIN_INFO_EXT"/>
                <type name="VkConditionalRenderingFlagsEXT"/>
                <type name="VkConditionalRenderingFlagBitsEXT"/>
                <enum bitpos="20" extends="VkAccessFlagBits"                name="VK_ACCESS_CONDITIONAL_RENDERING_READ_BIT_EXT"    comment="read access flag for reading conditional rendering predicate"/>
                <enum bitpos="9"  extends="VkBufferUsageFlagBits"           name="VK_BUFFER_USAGE_CONDITIONAL_RENDERING_BIT_EXT"   comment="Specifies the buffer can be used as predicate in conditional rendering"/>
                <enum bitpos="18" extends="VkPipelineStageFlagBits"         name="VK_PIPELINE_STAGE_CONDITIONAL_RENDERING_BIT_EXT" comment="A pipeline stage for conditional rendering predicate fetch"/>
                <command name="vkCmdBeginConditionalRenderingEXT"/>
                <command name="vkCmdEndConditionalRenderingEXT"/>
                <type name="VkConditionalRenderingBeginInfoEXT"/>
                <type name="VkPhysicalDeviceConditionalRenderingFeaturesEXT"/>
                <type name="VkCommandBufferInheritanceConditionalRenderingInfoEXT"/>
            </require>
        </extension>
        <extension name="VK_KHR_shader_float16_int8" number="83" type="device" requires="VK_KHR_get_physical_device_properties2" author="KHR" contact="Alexander Galazin @alegal-arm" supported="vulkan">
            <require>
                <enum value="1"                                           name="VK_KHR_SHADER_FLOAT16_INT8_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_shader_float16_int8&quot;"      name="VK_KHR_SHADER_FLOAT16_INT8_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT16_INT8_FEATURES_KHR"/>
                <type name="VkPhysicalDeviceFloat16Int8FeaturesKHR"/>
            </require>
        </extension>
        <extension name="VK_KHR_16bit_storage" number="84" type="device" requires="VK_KHR_get_physical_device_properties2,VK_KHR_storage_buffer_storage_class" author="KHR" contact="Jan-Harald Fredriksen @janharaldfredriksen-arm" supported="vulkan" promotedto="VK_VERSION_1_1">
            <require>
                <enum value="1"                                             name="VK_KHR_16BIT_STORAGE_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_16bit_storage&quot;"              name="VK_KHR_16BIT_STORAGE_EXTENSION_NAME"/>
                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES_KHR" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES"/>
                <type name="VkPhysicalDevice16BitStorageFeaturesKHR"/>
            </require>
        </extension>
        <extension name="VK_KHR_incremental_present" number="85" type="device" author="KHR" requires="VK_KHR_swapchain" contact="Ian Elliott @ianelliottus" supported="vulkan">
            <require>
                <enum value="1"                                             name="VK_KHR_INCREMENTAL_PRESENT_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_incremental_present&quot;"        name="VK_KHR_INCREMENTAL_PRESENT_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PRESENT_REGIONS_KHR"/>
                <type name="VkPresentRegionsKHR"/>
                <type name="VkPresentRegionKHR"/>
                <type name="VkRectLayerKHR"/>
            </require>
        </extension>
        <extension name="VK_KHR_descriptor_update_template" number="86" type="device" author="KHR" contact="Markus Tavenrath @mtavenrath" supported="vulkan" promotedto="VK_VERSION_1_1">
            <require>
                <enum value="1"                                             name="VK_KHR_DESCRIPTOR_UPDATE_TEMPLATE_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_descriptor_update_template&quot;" name="VK_KHR_DESCRIPTOR_UPDATE_TEMPLATE_EXTENSION_NAME"/>
                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO_KHR" alias="VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO"/>
                <enum extends="VkObjectType"                                name="VK_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_KHR" alias="VK_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE"/>
                <command name="vkCreateDescriptorUpdateTemplateKHR"/>
                <command name="vkDestroyDescriptorUpdateTemplateKHR"/>
                <command name="vkUpdateDescriptorSetWithTemplateKHR"/>
                <type name="VkDescriptorUpdateTemplateKHR"/>
                <type name="VkDescriptorUpdateTemplateCreateFlagsKHR"/>
                <type name="VkDescriptorUpdateTemplateTypeKHR"/>
                <type name="VkDescriptorUpdateTemplateEntryKHR"/>
                <type name="VkDescriptorUpdateTemplateCreateInfoKHR"/>
                <enum extends="VkDescriptorUpdateTemplateType"              name="VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET_KHR" alias="VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET"/>
            </require>
            <require extension="VK_KHR_push_descriptor">
                <command name="vkCmdPushDescriptorSetWithTemplateKHR"/>
                <enum value="1" extends="VkDescriptorUpdateTemplateType"    name="VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS_KHR" comment="Create descriptor update template for pushed descriptor updates"/>
            </require>
            <require extension="VK_EXT_debug_report">
                <enum extends="VkDebugReportObjectTypeEXT"                  name="VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_KHR_EXT" alias="VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_EXT"/>
            </require>
        </extension>
        <extension name="VK_NVX_device_generated_commands" number="87" type="device" author="NVX" contact="Christoph Kubisch @pixeljetstream" supported="vulkan">
            <require>
                <enum value="3"                                             name="VK_NVX_DEVICE_GENERATED_COMMANDS_SPEC_VERSION"/>
                <enum value="&quot;VK_NVX_device_generated_commands&quot;"  name="VK_NVX_DEVICE_GENERATED_COMMANDS_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_OBJECT_TABLE_CREATE_INFO_NVX"/>
                <enum offset="1" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_NVX"/>
                <enum offset="2" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_CMD_PROCESS_COMMANDS_INFO_NVX"/>
                <enum offset="3" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_CMD_RESERVE_SPACE_FOR_COMMANDS_INFO_NVX"/>
                <enum offset="4" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_DEVICE_GENERATED_COMMANDS_LIMITS_NVX"/>
                <enum offset="5" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_DEVICE_GENERATED_COMMANDS_FEATURES_NVX"/>
                <enum bitpos="17" extends="VkPipelineStageFlagBits"         name="VK_PIPELINE_STAGE_COMMAND_PROCESS_BIT_NVX"/>
                <enum bitpos="17" extends="VkAccessFlagBits"                name="VK_ACCESS_COMMAND_PROCESS_READ_BIT_NVX"/>
                <enum bitpos="18" extends="VkAccessFlagBits"                name="VK_ACCESS_COMMAND_PROCESS_WRITE_BIT_NVX"/>
                <enum offset="0" extends="VkObjectType"                     name="VK_OBJECT_TYPE_OBJECT_TABLE_NVX"                     comment="VkobjectTableNVX"/>
                <enum offset="1" extends="VkObjectType"                     name="VK_OBJECT_TYPE_INDIRECT_COMMANDS_LAYOUT_NVX"         comment="VkIndirectCommandsLayoutNVX"/>
                <type name="VkObjectTableNVX"/>
                <type name="VkIndirectCommandsLayoutNVX"/>
                <type name="VkIndirectCommandsLayoutUsageFlagsNVX"/>
                <type name="VkObjectEntryUsageFlagsNVX"/>
                <type name="VkIndirectCommandsLayoutUsageFlagBitsNVX"/>
                <type name="VkIndirectCommandsTokenTypeNVX"/>
                <type name="VkObjectEntryUsageFlagBitsNVX"/>
                <type name="VkObjectEntryTypeNVX"/>
                <type name="VkDeviceGeneratedCommandsFeaturesNVX"/>
                <type name="VkDeviceGeneratedCommandsLimitsNVX"/>
                <type name="VkIndirectCommandsTokenNVX"/>
                <type name="VkIndirectCommandsLayoutTokenNVX"/>
                <type name="VkIndirectCommandsLayoutCreateInfoNVX"/>
                <type name="VkCmdProcessCommandsInfoNVX"/>
                <type name="VkCmdReserveSpaceForCommandsInfoNVX"/>
                <type name="VkObjectTableCreateInfoNVX"/>
                <type name="VkObjectTableEntryNVX"/>
                <type name="VkObjectTablePipelineEntryNVX"/>
                <type name="VkObjectTableDescriptorSetEntryNVX"/>
                <type name="VkObjectTableVertexBufferEntryNVX"/>
                <type name="VkObjectTableIndexBufferEntryNVX"/>
                <type name="VkObjectTablePushConstantEntryNVX"/>
                <command name="vkCmdProcessCommandsNVX"/>
                <command name="vkCmdReserveSpaceForCommandsNVX"/>
                <command name="vkCreateIndirectCommandsLayoutNVX"/>
                <command name="vkDestroyIndirectCommandsLayoutNVX"/>
                <command name="vkCreateObjectTableNVX"/>
                <command name="vkDestroyObjectTableNVX"/>
                <command name="vkRegisterObjectsNVX"/>
                <command name="vkUnregisterObjectsNVX"/>
                <command name="vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX"/>
            </require>
        </extension>
        <extension name="VK_NV_clip_space_w_scaling" number="88" type="device" author="NV" contact="Eric Werness @ewerness-nv" supported="vulkan">
            <require>
                <enum value="1"                                             name="VK_NV_CLIP_SPACE_W_SCALING_SPEC_VERSION"/>
                <enum value="&quot;VK_NV_clip_space_w_scaling&quot;"        name="VK_NV_CLIP_SPACE_W_SCALING_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_NV"/>
                <enum offset="0" extends="VkDynamicState"                   name="VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_NV"/>
                <type name="VkViewportWScalingNV"/>
                <type name="VkPipelineViewportWScalingStateCreateInfoNV"/>
                <command name="vkCmdSetViewportWScalingNV"/>
            </require>
        </extension>
        <extension name="VK_EXT_direct_mode_display" number="89" type="instance" requires="VK_KHR_display" author="NV" contact="James Jones @cubanismo" supported="vulkan">
            <require>
                <enum value="1"                                             name="VK_EXT_DIRECT_MODE_DISPLAY_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_direct_mode_display&quot;"        name="VK_EXT_DIRECT_MODE_DISPLAY_EXTENSION_NAME"/>
                <command name="vkReleaseDisplayEXT"/>
            </require>
        </extension>
        <extension name="VK_EXT_acquire_xlib_display" number="90" type="instance" requires="VK_EXT_direct_mode_display" author="NV" contact="James Jones @cubanismo" platform="xlib_xrandr" supported="vulkan">
            <require>
                <enum value="1"                                             name="VK_EXT_ACQUIRE_XLIB_DISPLAY_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_acquire_xlib_display&quot;"       name="VK_EXT_ACQUIRE_XLIB_DISPLAY_EXTENSION_NAME"/>
                <command name="vkAcquireXlibDisplayEXT"/>
                <command name="vkGetRandROutputDisplayEXT"/>
            </require>
        </extension>
        <extension name="VK_EXT_display_surface_counter" number="91" type="instance" requires="VK_KHR_display" author="NV" contact="James Jones @cubanismo" supported="vulkan">
            <require>
                <enum value="1"                                             name="VK_EXT_DISPLAY_SURFACE_COUNTER_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_display_surface_counter&quot;"    name="VK_EXT_DISPLAY_SURFACE_COUNTER_EXTENSION_NAME"/>
                <enum offset="0"                                           extends="VkStructureType" name="VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_EXT"/>
                <enum alias="VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_EXT" extends="VkStructureType" name="VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES2_EXT" comment="Backwards-compatible alias containing a typo"/>
                <type name="VkSurfaceCounterFlagsEXT"/>
                <type name="VkSurfaceCounterFlagBitsEXT"/>
                <type name="VkSurfaceCapabilities2EXT"/>
                <command name="vkGetPhysicalDeviceSurfaceCapabilities2EXT"/>
            </require>
        </extension>
        <extension name="VK_EXT_display_control" number="92" type="device" requires="VK_EXT_display_surface_counter,VK_KHR_swapchain" author="NV" contact="James Jones @cubanismo" supported="vulkan">
            <require>
                <enum value="1"                                             name="VK_EXT_DISPLAY_CONTROL_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_display_control&quot;"            name="VK_EXT_DISPLAY_CONTROL_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_DISPLAY_POWER_INFO_EXT"/>
                <enum offset="1" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_DEVICE_EVENT_INFO_EXT"/>
                <enum offset="2" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_DISPLAY_EVENT_INFO_EXT"/>
                <enum offset="3" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_SWAPCHAIN_COUNTER_CREATE_INFO_EXT"/>
                <type name="VkDisplayPowerStateEXT"/>
                <type name="VkDeviceEventTypeEXT"/>
                <type name="VkDisplayEventTypeEXT"/>
                <type name="VkDisplayPowerInfoEXT"/>
                <type name="VkDeviceEventInfoEXT"/>
                <type name="VkDisplayEventInfoEXT"/>
                <type name="VkSwapchainCounterCreateInfoEXT"/>
                <command name="vkDisplayPowerControlEXT"/>
                <command name="vkRegisterDeviceEventEXT"/>
                <command name="vkRegisterDisplayEventEXT"/>
                <command name="vkGetSwapchainCounterEXT"/>
            </require>
        </extension>
        <extension name="VK_GOOGLE_display_timing" number="93" type="device" author="GOOGLE" requires="VK_KHR_swapchain" contact="Ian Elliott @ianelliottus" supported="vulkan">
            <require>
                <enum value="1"                                             name="VK_GOOGLE_DISPLAY_TIMING_SPEC_VERSION"/>
                <enum value="&quot;VK_GOOGLE_display_timing&quot;"          name="VK_GOOGLE_DISPLAY_TIMING_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PRESENT_TIMES_INFO_GOOGLE"/>
                <type name="VkRefreshCycleDurationGOOGLE"/>
                <type name="VkPastPresentationTimingGOOGLE"/>
                <type name="VkPresentTimesInfoGOOGLE"/>
                <type name="VkPresentTimeGOOGLE"/>
                <command name="vkGetRefreshCycleDurationGOOGLE"/>
                <command name="vkGetPastPresentationTimingGOOGLE"/>
            </require>
        </extension>
        <extension name="RESERVED_DO_NOT_USE_94" number="94" supported="disabled" comment="Used for functionality subsumed into Vulkan 1.1 and not published as an extension">
        </extension>
        <extension name="VK_NV_sample_mask_override_coverage" number="95" type="device" author="NV" contact="Piers Daniell @pdaniell-nv" supported="vulkan">
            <require>
                <enum value="1"                                             name="VK_NV_SAMPLE_MASK_OVERRIDE_COVERAGE_SPEC_VERSION"/>
                <enum value="&quot;VK_NV_sample_mask_override_coverage&quot;" name="VK_NV_SAMPLE_MASK_OVERRIDE_COVERAGE_EXTENSION_NAME"/>
                <comment>
                    enum offset=0 was mistakenly used for the 1.1 core enum
                    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES
                    (value=1000094000). Fortunately, no conflict resulted.
                </comment>
            </require>
        </extension>
        <extension name="VK_NV_geometry_shader_passthrough" number="96" type="device" author="NV" contact="Daniel Koch @dgkoch" supported="vulkan">
            <require>
                <enum value="1"                                             name="VK_NV_GEOMETRY_SHADER_PASSTHROUGH_SPEC_VERSION"/>
                <enum value="&quot;VK_NV_geometry_shader_passthrough&quot;" name="VK_NV_GEOMETRY_SHADER_PASSTHROUGH_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_NV_viewport_array2" number="97" type="device" author="NV" contact="Daniel Koch @dgkoch" supported="vulkan">
            <require>
                <enum value="1"                                             name="VK_NV_VIEWPORT_ARRAY2_SPEC_VERSION"/>
                <enum value="&quot;VK_NV_viewport_array2&quot;"             name="VK_NV_VIEWPORT_ARRAY2_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_NVX_multiview_per_view_attributes" number="98" type="device" requires="VK_KHR_multiview" author="NVX" contact="Jeff Bolz @jeffbolznv" supported="vulkan">
            <require>
                <enum value="1"                                             name="VK_NVX_MULTIVIEW_PER_VIEW_ATTRIBUTES_SPEC_VERSION"/>
                <enum value="&quot;VK_NVX_multiview_per_view_attributes&quot;" name="VK_NVX_MULTIVIEW_PER_VIEW_ATTRIBUTES_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_ATTRIBUTES_PROPERTIES_NVX"/>
                <enum bitpos="0" extends="VkSubpassDescriptionFlagBits"     name="VK_SUBPASS_DESCRIPTION_PER_VIEW_ATTRIBUTES_BIT_NVX"/>
                <enum bitpos="1" extends="VkSubpassDescriptionFlagBits"     name="VK_SUBPASS_DESCRIPTION_PER_VIEW_POSITION_X_ONLY_BIT_NVX"/>
                <type name="VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX"/>
            </require>
        </extension>
        <extension name="VK_NV_viewport_swizzle" number="99" type="device" author="NV" contact="Piers Daniell @pdaniell-nv" supported="vulkan">
            <require>
                <enum value="1"                                             name="VK_NV_VIEWPORT_SWIZZLE_SPEC_VERSION"/>
                <enum value="&quot;VK_NV_viewport_swizzle&quot;"            name="VK_NV_VIEWPORT_SWIZZLE_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV"/>
                <type name="VkViewportSwizzleNV"/>
                <type name="VkViewportCoordinateSwizzleNV"/>
                <type name="VkPipelineViewportSwizzleStateCreateInfoNV"/>
                <type name="VkPipelineViewportSwizzleStateCreateFlagsNV"/>
            </require>
        </extension>
        <extension name="VK_EXT_discard_rectangles" number="100" type="device" requires="VK_KHR_get_physical_device_properties2" author="NV" contact="Piers Daniell @pdaniell-nv" supported="vulkan">
            <require>
                <enum value="1"                                             name="VK_EXT_DISCARD_RECTANGLES_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_discard_rectangles&quot;"         name="VK_EXT_DISCARD_RECTANGLES_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT"/>
                <enum offset="1" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT"/>
                <enum offset="0" extends="VkDynamicState"                   name="VK_DYNAMIC_STATE_DISCARD_RECTANGLE_EXT"/>
                <type name="VkPhysicalDeviceDiscardRectanglePropertiesEXT"/>
                <type name="VkPipelineDiscardRectangleStateCreateInfoEXT"/>
                <type name="VkPipelineDiscardRectangleStateCreateFlagsEXT"/>
                <type name="VkDiscardRectangleModeEXT"/>
                <command name="vkCmdSetDiscardRectangleEXT"/>
            </require>
        </extension>
        <extension name="VK_NV_extension_101" number="101" author="NV" contact="Daniel Koch @dgkoch" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_NV_EXTENSION_101_SPEC_VERSION"/>
                <enum value="&quot;VK_NV_extension_101&quot;"               name="VK_NV_EXTENSION_101_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_EXT_conservative_rasterization" number="102" type="device" requires="VK_KHR_get_physical_device_properties2" author="NV" contact="Piers Daniell @pdaniell-nv" supported="vulkan">
            <require>
                <enum value="1"                                         name="VK_EXT_CONSERVATIVE_RASTERIZATION_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_conservative_rasterization&quot;"    name="VK_EXT_CONSERVATIVE_RASTERIZATION_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT"/>
                <enum offset="1" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT"/>
                <type name="VkPhysicalDeviceConservativeRasterizationPropertiesEXT"/>
                <type name="VkPipelineRasterizationConservativeStateCreateInfoEXT"/>
                <type name="VkPipelineRasterizationConservativeStateCreateFlagsEXT"/>
                <type name="VkConservativeRasterizationModeEXT"/>
            </require>
        </extension>
        <extension name="VK_EXT_depth_clip_enable" number="103" type="device" author="EXT" contact="Piers Daniell @pdaniell-nv" supported="vulkan">
            <require>
                <enum value="1"                                             name="VK_EXT_DEPTH_CLIP_ENABLE_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_depth_clip_enable&quot;"          name="VK_EXT_DEPTH_CLIP_ENABLE_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT"/>
                <enum offset="1" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_DEPTH_CLIP_STATE_CREATE_INFO_EXT"/>
                <type name="VkPhysicalDeviceDepthClipEnableFeaturesEXT"/>
                <type name="VkPipelineRasterizationDepthClipStateCreateInfoEXT"/>
                <type name="VkPipelineRasterizationDepthClipStateCreateFlagsEXT"/>
            </require>
        </extension>
        <extension name="VK_NV_extension_104" number="104" author="NV" contact="Mathias Schott gitlab:@mschott" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_NV_EXTENSION_104_SPEC_VERSION"/>
                <enum value="&quot;VK_NV_extension_104&quot;"               name="VK_NV_EXTENSION_104_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_EXT_swapchain_colorspace" number="105" type="instance" author="GOOGLE" contact="Courtney Goeltzenleuchter @courtney-g" requires="VK_KHR_surface" supported="vulkan">
            <require>
                <enum value="4"                                             name="VK_EXT_SWAPCHAIN_COLOR_SPACE_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_swapchain_colorspace&quot;"       name="VK_EXT_SWAPCHAIN_COLOR_SPACE_EXTENSION_NAME"/>
                <enum offset="1" extends="VkColorSpaceKHR"                  name="VK_COLOR_SPACE_DISPLAY_P3_NONLINEAR_EXT"/>
                <enum offset="2" extends="VkColorSpaceKHR"                  name="VK_COLOR_SPACE_EXTENDED_SRGB_LINEAR_EXT"/>
                <enum offset="3" extends="VkColorSpaceKHR"                  name="VK_COLOR_SPACE_DISPLAY_P3_LINEAR_EXT"/>
                <enum offset="4" extends="VkColorSpaceKHR"                  name="VK_COLOR_SPACE_DCI_P3_NONLINEAR_EXT"/>
                <enum offset="5" extends="VkColorSpaceKHR"                  name="VK_COLOR_SPACE_BT709_LINEAR_EXT"/>
                <enum offset="6" extends="VkColorSpaceKHR"                  name="VK_COLOR_SPACE_BT709_NONLINEAR_EXT"/>
                <enum offset="7" extends="VkColorSpaceKHR"                  name="VK_COLOR_SPACE_BT2020_LINEAR_EXT"/>
                <enum offset="8" extends="VkColorSpaceKHR"                  name="VK_COLOR_SPACE_HDR10_ST2084_EXT"/>
                <enum offset="9" extends="VkColorSpaceKHR"                  name="VK_COLOR_SPACE_DOLBYVISION_EXT"/>
                <enum offset="10" extends="VkColorSpaceKHR"                 name="VK_COLOR_SPACE_HDR10_HLG_EXT"/>
                <enum offset="11" extends="VkColorSpaceKHR"                 name="VK_COLOR_SPACE_ADOBERGB_LINEAR_EXT"/>
                <enum offset="12" extends="VkColorSpaceKHR"                 name="VK_COLOR_SPACE_ADOBERGB_NONLINEAR_EXT"/>
                <enum offset="13" extends="VkColorSpaceKHR"                 name="VK_COLOR_SPACE_PASS_THROUGH_EXT"/>
                <enum offset="14" extends="VkColorSpaceKHR"                 name="VK_COLOR_SPACE_EXTENDED_SRGB_NONLINEAR_EXT"/>
                <enum extends="VkColorSpaceKHR" name="VK_COLOR_SPACE_DCI_P3_LINEAR_EXT" alias="VK_COLOR_SPACE_DISPLAY_P3_LINEAR_EXT" comment="Deprecated name for backwards compatibility"/>
            </require>
        </extension>
        <extension name="VK_EXT_hdr_metadata" number="106" type="device" requires="VK_KHR_swapchain" author="GOOGLE" contact="Courtney Goeltzenleuchter @courtney-g" supported="vulkan">
            <require>
                <enum value="1"                                             name="VK_EXT_HDR_METADATA_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_hdr_metadata&quot;"               name="VK_EXT_HDR_METADATA_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_HDR_METADATA_EXT"/>
                <type name="VkHdrMetadataEXT"/>
                <type name="VkXYColorEXT"/>
                <command name="vkSetHdrMetadataEXT"/>
            </require>
        </extension>
        <extension name="VK_IMG_extension_107" number="107" author="IMG" contact="Michael Worcester @michaelworcester" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_IMG_EXTENSION_107_SPEC_VERSION"/>
                <enum value="&quot;VK_IMG_extension_107&quot;"              name="VK_IMG_EXTENSION_107_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_IMG_extension_108" number="108" author="IMG" contact="Michael Worcester @michaelworcester" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_IMG_EXTENSION_108_SPEC_VERSION"/>
                <enum value="&quot;VK_IMG_extension_108&quot;"              name="VK_IMG_EXTENSION_108_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_IMG_extension_109" number="109" author="IMG" contact="Michael Worcester @michaelworcester" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_IMG_EXTENSION_109_SPEC_VERSION"/>
                <enum value="&quot;VK_IMG_extension_109&quot;"              name="VK_IMG_EXTENSION_109_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_KHR_create_renderpass2" requires="VK_KHR_multiview,VK_KHR_maintenance2" number="110" contact="Tobias Hector @tobias" type="device" supported="vulkan">
            <require>
                <enum value="1"                                         name="VK_KHR_CREATE_RENDERPASS_2_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_create_renderpass2&quot;"     name="VK_KHR_CREATE_RENDERPASS_2_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2_KHR"/>
                <enum offset="1" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2_KHR"/>
                <enum offset="2" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2_KHR"/>
                <enum offset="3" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2_KHR"/>
                <enum offset="4" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2_KHR"/>
                <enum offset="5" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_SUBPASS_BEGIN_INFO_KHR"/>
                <enum offset="6" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_SUBPASS_END_INFO_KHR"/>
                <command name="vkCreateRenderPass2KHR"/>
                <command name="vkCmdBeginRenderPass2KHR"/>
                <command name="vkCmdNextSubpass2KHR"/>
                <command name="vkCmdEndRenderPass2KHR"/>
            </require>
        </extension>
        <extension name="VK_IMG_extension_111" number="111" author="IMG" contact="Michael Worcester @michaelworcester" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_IMG_EXTENSION_111_SPEC_VERSION"/>
                <enum value="&quot;VK_IMG_extension_111&quot;"              name="VK_IMG_EXTENSION_111_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_KHR_shared_presentable_image" number="112" type="device" requires="VK_KHR_swapchain,VK_KHR_get_physical_device_properties2,VK_KHR_get_surface_capabilities2" author="KHR" contact="Alon Or-bach @alonorbach" supported="vulkan">
            <require>
                <enum value="1"                                             name="VK_KHR_SHARED_PRESENTABLE_IMAGE_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_shared_presentable_image&quot;"   name="VK_KHR_SHARED_PRESENTABLE_IMAGE_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_SHARED_PRESENT_SURFACE_CAPABILITIES_KHR"/>
                <enum offset="0" extends="VkPresentModeKHR"                 name="VK_PRESENT_MODE_SHARED_DEMAND_REFRESH_KHR"/>
                <enum offset="1" extends="VkPresentModeKHR"                 name="VK_PRESENT_MODE_SHARED_CONTINUOUS_REFRESH_KHR"/>
                <enum offset="0" extends="VkImageLayout"                    name="VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR"/>
                <type name="VkSharedPresentSurfaceCapabilitiesKHR"/>
                <command name="vkGetSwapchainStatusKHR"/>
            </require>
        </extension>
        <extension name="VK_KHR_external_fence_capabilities" number="113" type="instance" author="KHR" requires="VK_KHR_get_physical_device_properties2" contact="Jesse Hall @critsec" supported="vulkan" promotedto="VK_VERSION_1_1">
            <require>
                <enum value="1"                                             name="VK_KHR_EXTERNAL_FENCE_CAPABILITIES_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_external_fence_capabilities&quot;" name="VK_KHR_EXTERNAL_FENCE_CAPABILITIES_EXTENSION_NAME"/>
                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO_KHR" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO"/>
                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES_KHR" alias="VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES"/>
                <enum name="VK_LUID_SIZE_KHR"/>
                <type name="VkExternalFenceHandleTypeFlagsKHR"/>
                <type name="VkExternalFenceHandleTypeFlagBitsKHR"/>
                <enum extends="VkExternalFenceHandleTypeFlagBits"           name="VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT_KHR" alias="VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT"/>
                <enum extends="VkExternalFenceHandleTypeFlagBits"           name="VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR" alias="VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT"/>
                <enum extends="VkExternalFenceHandleTypeFlagBits"           name="VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR" alias="VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT"/>
                <enum extends="VkExternalFenceHandleTypeFlagBits"           name="VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT_KHR" alias="VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT"/>
                <type name="VkExternalFenceFeatureFlagsKHR"/>
                <type name="VkExternalFenceFeatureFlagBitsKHR"/>
                <enum extends="VkExternalFenceFeatureFlagBits"              name="VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT_KHR" alias="VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT"/>
                <enum extends="VkExternalFenceFeatureFlagBits"              name="VK_EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT_KHR" alias="VK_EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT"/>
                <type name="VkPhysicalDeviceExternalFenceInfoKHR"/>
                <type name="VkExternalFencePropertiesKHR"/>
                <type name="VkPhysicalDeviceIDPropertiesKHR"/>
                <command name="vkGetPhysicalDeviceExternalFencePropertiesKHR"/>
            </require>
        </extension>
        <extension name="VK_KHR_external_fence" number="114" type="device" requires="VK_KHR_external_fence_capabilities" author="KHR" contact="Jesse Hall @critsec" supported="vulkan" promotedto="VK_VERSION_1_1">
            <require>
                <enum value="1"                                             name="VK_KHR_EXTERNAL_FENCE_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_external_fence&quot;"             name="VK_KHR_EXTERNAL_FENCE_EXTENSION_NAME"/>
                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO_KHR" alias="VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO"/>
                <type name="VkFenceImportFlagsKHR"/>
                <type name="VkFenceImportFlagBitsKHR"/>
                <enum extends="VkFenceImportFlagBits"                       name="VK_FENCE_IMPORT_TEMPORARY_BIT_KHR" alias="VK_FENCE_IMPORT_TEMPORARY_BIT"/>
                <type name="VkExportFenceCreateInfoKHR"/>
            </require>
        </extension>
        <extension name="VK_KHR_external_fence_win32" number="115" type="device" requires="VK_KHR_external_fence" author="KHR" contact="Jesse Hall @critsec" platform="win32" supported="vulkan">
            <require>
                <enum value="1"                                             name="VK_KHR_EXTERNAL_FENCE_WIN32_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_external_fence_win32&quot;"       name="VK_KHR_EXTERNAL_FENCE_WIN32_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_IMPORT_FENCE_WIN32_HANDLE_INFO_KHR"/>
                <enum offset="1" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_EXPORT_FENCE_WIN32_HANDLE_INFO_KHR"/>
                <enum offset="2" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_FENCE_GET_WIN32_HANDLE_INFO_KHR"/>
                <type name="VkImportFenceWin32HandleInfoKHR"/>
                <type name="VkExportFenceWin32HandleInfoKHR"/>
                <type name="VkFenceGetWin32HandleInfoKHR"/>
                <command name="vkImportFenceWin32HandleKHR"/>
                <command name="vkGetFenceWin32HandleKHR"/>
            </require>
        </extension>
        <extension name="VK_KHR_external_fence_fd" number="116" type="device" requires="VK_KHR_external_fence" author="KHR" contact="Jesse Hall @critsec" supported="vulkan">
            <require>
                <enum value="1"                                             name="VK_KHR_EXTERNAL_FENCE_FD_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_external_fence_fd&quot;"          name="VK_KHR_EXTERNAL_FENCE_FD_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_IMPORT_FENCE_FD_INFO_KHR"/>
                <enum offset="1" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_FENCE_GET_FD_INFO_KHR"/>
                <type name="VkImportFenceFdInfoKHR"/>
                <type name="VkFenceGetFdInfoKHR"/>
                <command name="vkImportFenceFdKHR"/>
                <command name="vkGetFenceFdKHR"/>
            </require>
        </extension>
        <extension name="VK_KHR_extension_117" number="117" author="KHR" contact="Kenneth Benzie @kbenzie" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_KHR_EXTENSION_117_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_extension_117&quot;"              name="VK_KHR_EXTENSION_117_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_KHR_maintenance2" number="118" type="device" author="KHR" contact="Michael Worcester @michaelworcester" supported="vulkan" promotedto="VK_VERSION_1_1">
            <require>
                <enum value="1"                                             name="VK_KHR_MAINTENANCE2_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_maintenance2&quot;"               name="VK_KHR_MAINTENANCE2_EXTENSION_NAME"/>
                <enum extends="VkImageCreateFlagBits"                       name="VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT_KHR" alias="VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT"/>
                <enum extends="VkImageCreateFlagBits"                       name="VK_IMAGE_CREATE_EXTENDED_USAGE_BIT_KHR" alias="VK_IMAGE_CREATE_EXTENDED_USAGE_BIT"/>
                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES_KHR" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES"/>
                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO_KHR" alias="VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO"/>
                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO_KHR" alias="VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO"/>
                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO_KHR" alias="VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO"/>
                <enum extends="VkImageLayout"                               name="VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL_KHR" alias="VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL"/>
                <enum extends="VkImageLayout"                               name="VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL_KHR" alias="VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL"/>
                <type name="VkPhysicalDevicePointClippingPropertiesKHR"/>
                <type name="VkPointClippingBehaviorKHR"/>
                <enum extends="VkPointClippingBehavior"                     name="VK_POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES_KHR" alias="VK_POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES"/>
                <enum extends="VkPointClippingBehavior"                     name="VK_POINT_CLIPPING_BEHAVIOR_USER_CLIP_PLANES_ONLY_KHR" alias="VK_POINT_CLIPPING_BEHAVIOR_USER_CLIP_PLANES_ONLY"/>
                <type name="VkRenderPassInputAttachmentAspectCreateInfoKHR"/>
                <type name="VkInputAttachmentAspectReferenceKHR"/>
                <type name="VkImageViewUsageCreateInfoKHR"/>
                <type name="VkTessellationDomainOriginKHR"/>
                <enum extends="VkTessellationDomainOrigin"                  name="VK_TESSELLATION_DOMAIN_ORIGIN_UPPER_LEFT_KHR" alias="VK_TESSELLATION_DOMAIN_ORIGIN_UPPER_LEFT"/>
                <enum extends="VkTessellationDomainOrigin"                  name="VK_TESSELLATION_DOMAIN_ORIGIN_LOWER_LEFT_KHR" alias="VK_TESSELLATION_DOMAIN_ORIGIN_LOWER_LEFT"/>
                <type name="VkPipelineTessellationDomainOriginStateCreateInfoKHR"/>
            </require>
        </extension>
        <extension name="VK_KHR_extension_119" number="119" author="KHR" contact="Michael Worcester @michaelworcester" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_KHR_EXTENSION_119_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_extension_119&quot;"              name="VK_KHR_EXTENSION_119_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_KHR_get_surface_capabilities2" number="120" type="instance" requires="VK_KHR_surface" author="KHR" contact="James Jones @cubanismo" supported="vulkan">
            <require>
                <enum value="1"                                             name="VK_KHR_GET_SURFACE_CAPABILITIES_2_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_get_surface_capabilities2&quot;"  name="VK_KHR_GET_SURFACE_CAPABILITIES_2_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SURFACE_INFO_2_KHR"/>
                <enum offset="1" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_KHR"/>
                <enum offset="2" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_SURFACE_FORMAT_2_KHR"/>
                <type name="VkPhysicalDeviceSurfaceInfo2KHR"/>
                <type name="VkSurfaceCapabilities2KHR"/>
                <type name="VkSurfaceFormat2KHR"/>
                <command name="vkGetPhysicalDeviceSurfaceCapabilities2KHR"/>
                <command name="vkGetPhysicalDeviceSurfaceFormats2KHR"/>
            </require>
        </extension>
        <extension name="VK_KHR_variable_pointers" number="121" type="device" author="KHR" contact="Jesse Hall @critsec" requires="VK_KHR_get_physical_device_properties2,VK_KHR_storage_buffer_storage_class" supported="vulkan" promotedto="VK_VERSION_1_1">
            <require>
                <enum value="1"                                             name="VK_KHR_VARIABLE_POINTERS_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_variable_pointers&quot;"          name="VK_KHR_VARIABLE_POINTERS_EXTENSION_NAME"/>
                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES_KHR" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES"/>
                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES_KHR" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES"/>
                <type name="VkPhysicalDeviceVariablePointerFeaturesKHR"/>
                <type name="VkPhysicalDeviceVariablePointersFeaturesKHR"/>
            </require>
        </extension>
        <extension name="VK_KHR_get_display_properties2" number="122" type="instance" requires="VK_KHR_display" author="KHR" contact="James Jones @cubanismo" supported="vulkan">
            <require>
                <enum value="1"                                         name="VK_KHR_GET_DISPLAY_PROPERTIES_2_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_get_display_properties2&quot;" name="VK_KHR_GET_DISPLAY_PROPERTIES_2_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_DISPLAY_PROPERTIES_2_KHR"/>
                <enum offset="1" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_DISPLAY_PLANE_PROPERTIES_2_KHR"/>
                <enum offset="2" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_DISPLAY_MODE_PROPERTIES_2_KHR"/>
                <enum offset="3" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_DISPLAY_PLANE_INFO_2_KHR"/>
                <enum offset="4" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_DISPLAY_PLANE_CAPABILITIES_2_KHR"/>
                <type name="VkDisplayProperties2KHR"/>
                <type name="VkDisplayPlaneProperties2KHR"/>
                <type name="VkDisplayModeProperties2KHR"/>
                <type name="VkDisplayPlaneInfo2KHR"/>
                <type name="VkDisplayPlaneCapabilities2KHR"/>
                <command name="vkGetPhysicalDeviceDisplayProperties2KHR"/>
                <command name="vkGetPhysicalDeviceDisplayPlaneProperties2KHR"/>
                <command name="vkGetDisplayModeProperties2KHR"/>
                <command name="vkGetDisplayPlaneCapabilities2KHR"/>
            </require>
        </extension>
        <extension name="VK_MVK_ios_surface" number="123" type="instance" requires="VK_KHR_surface" platform="ios" supported="vulkan" author="MVK" contact="Bill Hollings @billhollings">
            <require>
                <enum value="2"                                             name="VK_MVK_IOS_SURFACE_SPEC_VERSION"/>
                <enum value="&quot;VK_MVK_ios_surface&quot;"                name="VK_MVK_IOS_SURFACE_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_IOS_SURFACE_CREATE_INFO_MVK"/>
                <type name="VkIOSSurfaceCreateFlagsMVK"/>
                <type name="VkIOSSurfaceCreateInfoMVK"/>
                <command name="vkCreateIOSSurfaceMVK"/>
            </require>
        </extension>
        <extension name="VK_MVK_macos_surface" number="124" type="instance" requires="VK_KHR_surface" platform="macos" supported="vulkan" author="MVK" contact="Bill Hollings @billhollings">
            <require>
                <enum value="2"                                             name="VK_MVK_MACOS_SURFACE_SPEC_VERSION"/>
                <enum value="&quot;VK_MVK_macos_surface&quot;"              name="VK_MVK_MACOS_SURFACE_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_MACOS_SURFACE_CREATE_INFO_MVK"/>
                <type name="VkMacOSSurfaceCreateFlagsMVK"/>
                <type name="VkMacOSSurfaceCreateInfoMVK"/>
                <command name="vkCreateMacOSSurfaceMVK"/>
            </require>
        </extension>
        <extension name="VK_MVK_moltenvk" number="125" type="instance" author="MVK" contact="Bill Hollings @billhollings" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_MVK_MOLTENVK_SPEC_VERSION"/>
                <enum value="&quot;VK_MVK_moltenvk&quot;"                   name="VK_MVK_MOLTENVK_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_EXT_external_memory_dma_buf" number="126" type="device" requires="VK_KHR_external_memory_fd" author="EXT" contact="Chad Versace @chadversary" supported="vulkan">
            <require>
                <enum value="1"                                             name="VK_EXT_EXTERNAL_MEMORY_DMA_BUF_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_external_memory_dma_buf&quot;"    name="VK_EXT_EXTERNAL_MEMORY_DMA_BUF_EXTENSION_NAME"/>
                <enum bitpos="9" extends="VkExternalMemoryHandleTypeFlagBits" name="VK_EXTERNAL_MEMORY_HANDLE_TYPE_DMA_BUF_BIT_EXT"/>
            </require>
        </extension>
        <extension name="VK_EXT_queue_family_foreign" number="127" type="device" author="EXT" requires="VK_KHR_external_memory" contact="Chad Versace @chadversary" supported="vulkan">
            <require>
                <enum value="1"                                             name="VK_EXT_QUEUE_FAMILY_FOREIGN_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_queue_family_foreign&quot;"       name="VK_EXT_QUEUE_FAMILY_FOREIGN_EXTENSION_NAME"/>
                <enum                                                       name="VK_QUEUE_FAMILY_FOREIGN_EXT"/>
            </require>
        </extension>
        <extension name="VK_KHR_dedicated_allocation" number="128" type="device" author="KHR" requires="VK_KHR_get_memory_requirements2" contact="James Jones @cubanismo" supported="vulkan" promotedto="VK_VERSION_1_1">
            <require>
                <enum value="3"                                             name="VK_KHR_DEDICATED_ALLOCATION_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_dedicated_allocation&quot;"       name="VK_KHR_DEDICATED_ALLOCATION_EXTENSION_NAME"/>
                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS_KHR" alias="VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS"/>
                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO_KHR" alias="VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO"/>
                <type name="VkMemoryDedicatedRequirementsKHR"/>
                <type name="VkMemoryDedicatedAllocateInfoKHR"/>
            </require>
        </extension>
        <extension name="VK_EXT_debug_utils" number="129" type="instance" author="EXT" contact="Mark Young @marky-lunarg" supported="vulkan">
            <require>
                <enum value="1"                                             name="VK_EXT_DEBUG_UTILS_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_debug_utils&quot;"                name="VK_EXT_DEBUG_UTILS_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT"/>
                <enum offset="1" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_TAG_INFO_EXT"/>
                <enum offset="2" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_DEBUG_UTILS_LABEL_EXT"/>
                <enum offset="3" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CALLBACK_DATA_EXT"/>
                <enum offset="4" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT"/>
                <enum offset="0" extends="VkObjectType"                     name="VK_OBJECT_TYPE_DEBUG_UTILS_MESSENGER_EXT"          comment="VkDebugUtilsMessengerEXT"/>
                <type name="VkDebugUtilsObjectNameInfoEXT"/>
                <type name="VkDebugUtilsObjectTagInfoEXT"/>
                <type name="VkDebugUtilsLabelEXT"/>
                <type name="VkDebugUtilsMessengerCallbackDataEXT"/>
                <type name="VkDebugUtilsMessengerCreateInfoEXT"/>
                <command name="vkSetDebugUtilsObjectNameEXT"/>
                <command name="vkSetDebugUtilsObjectTagEXT"/>
                <command name="vkQueueBeginDebugUtilsLabelEXT"/>
                <command name="vkQueueEndDebugUtilsLabelEXT"/>
                <command name="vkQueueInsertDebugUtilsLabelEXT"/>
                <command name="vkCmdBeginDebugUtilsLabelEXT"/>
                <command name="vkCmdEndDebugUtilsLabelEXT"/>
                <command name="vkCmdInsertDebugUtilsLabelEXT"/>
                <command name="vkCreateDebugUtilsMessengerEXT"/>
                <command name="vkDestroyDebugUtilsMessengerEXT"/>
                <command name="vkSubmitDebugUtilsMessageEXT"/>
            </require>
        </extension>
        <extension name="VK_ANDROID_external_memory_android_hardware_buffer" number="130" type="device" author="ANDROID" requires="VK_KHR_sampler_ycbcr_conversion,VK_KHR_external_memory,VK_EXT_queue_family_foreign" platform="android" contact="Jesse Hall @critsec" supported="vulkan">
            <require>
                <enum value="3"                                             name="VK_ANDROID_EXTERNAL_MEMORY_ANDROID_HARDWARE_BUFFER_SPEC_VERSION"/>
                <enum value="&quot;VK_ANDROID_external_memory_android_hardware_buffer&quot;" name="VK_ANDROID_EXTERNAL_MEMORY_ANDROID_HARDWARE_BUFFER_EXTENSION_NAME"/>
                <enum bitpos="10" extends="VkExternalMemoryHandleTypeFlagBits" name="VK_EXTERNAL_MEMORY_HANDLE_TYPE_ANDROID_HARDWARE_BUFFER_BIT_ANDROID"/>
                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_USAGE_ANDROID"/>
                <enum offset="1" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_PROPERTIES_ANDROID"/>
                <enum offset="2" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_ANDROID"/>
                <enum offset="3" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_IMPORT_ANDROID_HARDWARE_BUFFER_INFO_ANDROID"/>
                <enum offset="4" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_MEMORY_GET_ANDROID_HARDWARE_BUFFER_INFO_ANDROID"/>
                <enum offset="5" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_ANDROID"/>
                <type name="VkAndroidHardwareBufferUsageANDROID"/>
                <type name="VkAndroidHardwareBufferPropertiesANDROID"/>
                <type name="VkAndroidHardwareBufferFormatPropertiesANDROID"/>
                <type name="VkImportAndroidHardwareBufferInfoANDROID"/>
                <type name="VkMemoryGetAndroidHardwareBufferInfoANDROID"/>
                <type name="VkExternalFormatANDROID"/>
                <command name="vkGetAndroidHardwareBufferPropertiesANDROID"/>
                <command name="vkGetMemoryAndroidHardwareBufferANDROID"/>
            </require>
        </extension>
        <extension name="VK_EXT_sampler_filter_minmax" number="131" type="device" author="NV" requires="VK_KHR_get_physical_device_properties2" contact="Jeff Bolz @jeffbolznv" supported="vulkan">
            <require>
                <enum value="1"                                             name="VK_EXT_SAMPLER_FILTER_MINMAX_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_sampler_filter_minmax&quot;"      name="VK_EXT_SAMPLER_FILTER_MINMAX_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES_EXT"/>
                <enum offset="1" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO_EXT"/>
                <enum bitpos="16" extends="VkFormatFeatureFlagBits"         name="VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT_EXT" comment="Format can be used with min/max reduction filtering"/>
                <type name="VkSamplerReductionModeEXT"/>
                <type name="VkSamplerReductionModeCreateInfoEXT"/>
                <type name="VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT"/>
            </require>
        </extension>
        <extension name="VK_KHR_storage_buffer_storage_class" number="132" type="device" author="KHR" contact="Alexander Galazin @alegal-arm" supported="vulkan" promotedto="VK_VERSION_1_1">
            <require>
                <enum value="1"                                             name="VK_KHR_STORAGE_BUFFER_STORAGE_CLASS_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_storage_buffer_storage_class&quot;" name="VK_KHR_STORAGE_BUFFER_STORAGE_CLASS_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_AMD_gpu_shader_int16" number="133" type="device" author="AMD" contact="Qun Lin @linqun" supported="vulkan" deprecatedby="VK_KHR_shader_float16_int8">
            <require>
                <enum value="2"                                             name="VK_AMD_GPU_SHADER_INT16_SPEC_VERSION"/>
                <enum value="&quot;VK_AMD_gpu_shader_int16&quot;"           name="VK_AMD_GPU_SHADER_INT16_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_AMD_extension_134" number="134" author="AMD" contact="Mais Alnasser @malnasse" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_AMD_EXTENSION_134_SPEC_VERSION"/>
                <enum value="&quot;VK_AMD_extension_134&quot;"              name="VK_AMD_EXTENSION_134_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_AMD_extension_135" number="135" author="AMD" contact="Mais Alnasser @malnasse" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_AMD_EXTENSION_135_SPEC_VERSION"/>
                <enum value="&quot;VK_AMD_extension_135&quot;"              name="VK_AMD_EXTENSION_135_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_AMD_extension_136" number="136" author="AMD" contact="Mais Alnasser @malnasse" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_AMD_EXTENSION_136_SPEC_VERSION"/>
                <enum value="&quot;VK_AMD_extension_136&quot;"              name="VK_AMD_EXTENSION_136_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_AMD_mixed_attachment_samples" number="137" type="device" author="AMD" contact="Matthaeus G. Chajdas @anteru" supported="vulkan">
            <require>
                <enum value="1"                                             name="VK_AMD_MIXED_ATTACHMENT_SAMPLES_SPEC_VERSION"/>
                <enum value="&quot;VK_AMD_mixed_attachment_samples&quot;"   name="VK_AMD_MIXED_ATTACHMENT_SAMPLES_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_AMD_shader_fragment_mask" number="138" author="AMD" contact="Aaron Hagan @AaronHaganAMD" supported="vulkan" type="device">
            <require>
                <enum value="1"                                             name="VK_AMD_SHADER_FRAGMENT_MASK_SPEC_VERSION"/>
                <enum value="&quot;VK_AMD_shader_fragment_mask&quot;"       name="VK_AMD_SHADER_FRAGMENT_MASK_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_EXT_inline_uniform_block" number="139" type="device" author="EXT" requires="VK_KHR_get_physical_device_properties2,VK_KHR_maintenance1" contact="Daniel Rakos @aqnuep" supported="vulkan">
            <require>
                <enum value="1"                                          name="VK_EXT_INLINE_UNIFORM_BLOCK_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_inline_uniform_block&quot;"    name="VK_EXT_INLINE_UNIFORM_BLOCK_EXTENSION_NAME"/>
                <enum offset="0" extends="VkDescriptorType"              name="VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT"/>
                <enum offset="0" extends="VkStructureType"               name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES_EXT"/>
                <enum offset="1" extends="VkStructureType"               name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES_EXT"/>
                <enum offset="2" extends="VkStructureType"               name="VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK_EXT"/>
                <enum offset="3" extends="VkStructureType"               name="VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO_EXT"/>
                <type name="VkPhysicalDeviceInlineUniformBlockFeaturesEXT"/>
                <type name="VkPhysicalDeviceInlineUniformBlockPropertiesEXT"/>
                <type name="VkWriteDescriptorSetInlineUniformBlockEXT"/>
                <type name="VkDescriptorPoolInlineUniformBlockCreateInfoEXT"/>
            </require>
        </extension>
        <extension name="VK_AMD_extension_140" number="140" author="AMD" contact="Mais Alnasser @malnasse" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_AMD_EXTENSION_140_SPEC_VERSION"/>
                <enum value="&quot;VK_AMD_extension_140&quot;"              name="VK_AMD_EXTENSION_140_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_EXT_shader_stencil_export" number="141" type="device" author="EXT" contact="Dominik Witczak @dominikwitczakamd" supported="vulkan">
            <require>
                <enum value="1"                                             name="VK_EXT_SHADER_STENCIL_EXPORT_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_shader_stencil_export&quot;"      name="VK_EXT_SHADER_STENCIL_EXPORT_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_AMD_extension_142" number="142" author="AMD" contact="Mais Alnasser @malnasse" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_AMD_EXTENSION_142_SPEC_VERSION"/>
                <enum value="&quot;VK_AMD_extension_142&quot;"              name="VK_AMD_EXTENSION_142_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_AMD_extension_143" number="143" author="AMD" contact="Mais Alnasser @malnasse" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_AMD_EXTENSION_143_SPEC_VERSION"/>
                <enum value="&quot;VK_AMD_extension_143&quot;"              name="VK_AMD_EXTENSION_143_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_EXT_sample_locations" number="144" type="device" author="AMD" contact="Daniel Rakos @drakos-amd" supported="vulkan" requires="VK_KHR_get_physical_device_properties2">
            <require>
                <enum value="1"                                             name="VK_EXT_SAMPLE_LOCATIONS_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_sample_locations&quot;"           name="VK_EXT_SAMPLE_LOCATIONS_EXTENSION_NAME"/>
                <enum bitpos="12" extends="VkImageCreateFlagBits"           name="VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT"/>
                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT"/>
                <enum offset="1" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT"/>
                <enum offset="2" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT"/>
                <enum offset="3" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT"/>
                <enum offset="4" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_MULTISAMPLE_PROPERTIES_EXT"/>
                <enum offset="0" extends="VkDynamicState"                   name="VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT"/>
                <type name="VkSampleLocationEXT"/>
                <type name="VkSampleLocationsInfoEXT"/>
                <type name="VkAttachmentSampleLocationsEXT"/>
                <type name="VkSubpassSampleLocationsEXT"/>
                <type name="VkRenderPassSampleLocationsBeginInfoEXT"/>
                <type name="VkPipelineSampleLocationsStateCreateInfoEXT"/>
                <type name="VkPhysicalDeviceSampleLocationsPropertiesEXT"/>
                <type name="VkMultisamplePropertiesEXT"/>
                <command name="vkCmdSetSampleLocationsEXT"/>
                <command name="vkGetPhysicalDeviceMultisamplePropertiesEXT"/>
            </require>
        </extension>
        <extension name="VK_KHR_relaxed_block_layout" number="145" type="device" author="KHR" contact="John Kessenich @johnkslang" supported="vulkan" promotedto="VK_VERSION_1_1">
            <require>
                <enum value="1"                                             name="VK_KHR_RELAXED_BLOCK_LAYOUT_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_relaxed_block_layout&quot;"       name="VK_KHR_RELAXED_BLOCK_LAYOUT_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="RESERVED_DO_NOT_USE_146" number="146" supported="disabled" comment="Used for functionality subsumed into Vulkan 1.1 and not published as an extension">
        </extension>
        <extension name="VK_KHR_get_memory_requirements2" number="147" type="device" author="KHR" contact="Jason Ekstrand @jekstrand" supported="vulkan" promotedto="VK_VERSION_1_1">
            <require>
                <enum value="1" name="VK_KHR_GET_MEMORY_REQUIREMENTS_2_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_get_memory_requirements2&quot;"   name="VK_KHR_GET_MEMORY_REQUIREMENTS_2_EXTENSION_NAME"/>
                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2_KHR" alias="VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2"/>
                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2_KHR" alias="VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2"/>
                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2_KHR" alias="VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2"/>
                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2_KHR" alias="VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2"/>
                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2_KHR" alias="VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2"/>
                <type name="VkBufferMemoryRequirementsInfo2KHR"/>
                <type name="VkImageMemoryRequirementsInfo2KHR"/>
                <type name="VkImageSparseMemoryRequirementsInfo2KHR"/>
                <type name="VkMemoryRequirements2KHR"/>
                <type name="VkSparseImageMemoryRequirements2KHR"/>
                <command name="vkGetImageMemoryRequirements2KHR"/>
                <command name="vkGetBufferMemoryRequirements2KHR"/>
                <command name="vkGetImageSparseMemoryRequirements2KHR"/>
            </require>
        </extension>
        <extension name="VK_KHR_image_format_list" number="148" type="device" author="KHR" contact="Jason Ekstrand @jekstrand" supported="vulkan">
            <require>
                <enum value="1"                                             name="VK_KHR_IMAGE_FORMAT_LIST_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_image_format_list&quot;"          name="VK_KHR_IMAGE_FORMAT_LIST_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO_KHR"/>
                <type name="VkImageFormatListCreateInfoKHR"/>
            </require>
        </extension>
        <extension name="VK_EXT_blend_operation_advanced" number="149" type="device" author="NV" contact="Jeff Bolz @jeffbolznv" supported="vulkan">
            <require>
                <enum value="2"                                             name="VK_EXT_BLEND_OPERATION_ADVANCED_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_blend_operation_advanced&quot;"   name="VK_EXT_BLEND_OPERATION_ADVANCED_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT"/>
                <enum offset="1" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT"/>
                <enum offset="2" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT"/>
                <type name="VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT"/>
                <type name="VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT"/>
                <type name="VkPipelineColorBlendAdvancedStateCreateInfoEXT"/>
                <type name="VkBlendOverlapEXT"/>
                <enum offset="0" extends="VkBlendOp"                        name="VK_BLEND_OP_ZERO_EXT"/>
                <enum offset="1" extends="VkBlendOp"                        name="VK_BLEND_OP_SRC_EXT"/>
                <enum offset="2" extends="VkBlendOp"                        name="VK_BLEND_OP_DST_EXT"/>
                <enum offset="3" extends="VkBlendOp"                        name="VK_BLEND_OP_SRC_OVER_EXT"/>
                <enum offset="4" extends="VkBlendOp"                        name="VK_BLEND_OP_DST_OVER_EXT"/>
                <enum offset="5" extends="VkBlendOp"                        name="VK_BLEND_OP_SRC_IN_EXT"/>
                <enum offset="6" extends="VkBlendOp"                        name="VK_BLEND_OP_DST_IN_EXT"/>
                <enum offset="7" extends="VkBlendOp"                        name="VK_BLEND_OP_SRC_OUT_EXT"/>
                <enum offset="8" extends="VkBlendOp"                        name="VK_BLEND_OP_DST_OUT_EXT"/>
                <enum offset="9" extends="VkBlendOp"                        name="VK_BLEND_OP_SRC_ATOP_EXT"/>
                <enum offset="10" extends="VkBlendOp"                       name="VK_BLEND_OP_DST_ATOP_EXT"/>
                <enum offset="11" extends="VkBlendOp"                       name="VK_BLEND_OP_XOR_EXT"/>
                <enum offset="12" extends="VkBlendOp"                       name="VK_BLEND_OP_MULTIPLY_EXT"/>
                <enum offset="13" extends="VkBlendOp"                       name="VK_BLEND_OP_SCREEN_EXT"/>
                <enum offset="14" extends="VkBlendOp"                       name="VK_BLEND_OP_OVERLAY_EXT"/>
                <enum offset="15" extends="VkBlendOp"                       name="VK_BLEND_OP_DARKEN_EXT"/>
                <enum offset="16" extends="VkBlendOp"                       name="VK_BLEND_OP_LIGHTEN_EXT"/>
                <enum offset="17" extends="VkBlendOp"                       name="VK_BLEND_OP_COLORDODGE_EXT"/>
                <enum offset="18" extends="VkBlendOp"                       name="VK_BLEND_OP_COLORBURN_EXT"/>
                <enum offset="19" extends="VkBlendOp"                       name="VK_BLEND_OP_HARDLIGHT_EXT"/>
                <enum offset="20" extends="VkBlendOp"                       name="VK_BLEND_OP_SOFTLIGHT_EXT"/>
                <enum offset="21" extends="VkBlendOp"                       name="VK_BLEND_OP_DIFFERENCE_EXT"/>
                <enum offset="22" extends="VkBlendOp"                       name="VK_BLEND_OP_EXCLUSION_EXT"/>
                <enum offset="23" extends="VkBlendOp"                       name="VK_BLEND_OP_INVERT_EXT"/>
                <enum offset="24" extends="VkBlendOp"                       name="VK_BLEND_OP_INVERT_RGB_EXT"/>
                <enum offset="25" extends="VkBlendOp"                       name="VK_BLEND_OP_LINEARDODGE_EXT"/>
                <enum offset="26" extends="VkBlendOp"                       name="VK_BLEND_OP_LINEARBURN_EXT"/>
                <enum offset="27" extends="VkBlendOp"                       name="VK_BLEND_OP_VIVIDLIGHT_EXT"/>
                <enum offset="28" extends="VkBlendOp"                       name="VK_BLEND_OP_LINEARLIGHT_EXT"/>
                <enum offset="29" extends="VkBlendOp"                       name="VK_BLEND_OP_PINLIGHT_EXT"/>
                <enum offset="30" extends="VkBlendOp"                       name="VK_BLEND_OP_HARDMIX_EXT"/>
                <enum offset="31" extends="VkBlendOp"                       name="VK_BLEND_OP_HSL_HUE_EXT"/>
                <enum offset="32" extends="VkBlendOp"                       name="VK_BLEND_OP_HSL_SATURATION_EXT"/>
                <enum offset="33" extends="VkBlendOp"                       name="VK_BLEND_OP_HSL_COLOR_EXT"/>
                <enum offset="34" extends="VkBlendOp"                       name="VK_BLEND_OP_HSL_LUMINOSITY_EXT"/>
                <enum offset="35" extends="VkBlendOp"                       name="VK_BLEND_OP_PLUS_EXT"/>
                <enum offset="36" extends="VkBlendOp"                       name="VK_BLEND_OP_PLUS_CLAMPED_EXT"/>
                <enum offset="37" extends="VkBlendOp"                       name="VK_BLEND_OP_PLUS_CLAMPED_ALPHA_EXT"/>
                <enum offset="38" extends="VkBlendOp"                       name="VK_BLEND_OP_PLUS_DARKER_EXT"/>
                <enum offset="39" extends="VkBlendOp"                       name="VK_BLEND_OP_MINUS_EXT"/>
                <enum offset="40" extends="VkBlendOp"                       name="VK_BLEND_OP_MINUS_CLAMPED_EXT"/>
                <enum offset="41" extends="VkBlendOp"                       name="VK_BLEND_OP_CONTRAST_EXT"/>
                <enum offset="42" extends="VkBlendOp"                       name="VK_BLEND_OP_INVERT_OVG_EXT"/>
                <enum offset="43" extends="VkBlendOp"                       name="VK_BLEND_OP_RED_EXT"/>
                <enum offset="44" extends="VkBlendOp"                       name="VK_BLEND_OP_GREEN_EXT"/>
                <enum offset="45" extends="VkBlendOp"                       name="VK_BLEND_OP_BLUE_EXT"/>
                <enum bitpos="19" extends="VkAccessFlagBits"                name="VK_ACCESS_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT"/>
            </require>
        </extension>
        <extension name="VK_NV_fragment_coverage_to_color" number="150" type="device" author="NV" contact="Jeff Bolz @jeffbolznv" supported="vulkan">
            <require>
                <enum value="1"                                             name="VK_NV_FRAGMENT_COVERAGE_TO_COLOR_SPEC_VERSION"/>
                <enum value="&quot;VK_NV_fragment_coverage_to_color&quot;"  name="VK_NV_FRAGMENT_COVERAGE_TO_COLOR_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV"/>
                <type name="VkPipelineCoverageToColorStateCreateFlagsNV"/>
                <type name="VkPipelineCoverageToColorStateCreateInfoNV"/>
            </require>
        </extension>
        <extension name="VK_NV_extension_151" number="151" author="NV" contact="Jeff Bolz @jeffbolznv" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_NV_EXTENSION_151_SPEC_VERSION"/>
                <enum value="&quot;VK_NV_extension_151&quot;"               name="VK_NV_EXTENSION_151_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_NV_extension_152" number="152" author="NV" contact="Jeff Bolz @jeffbolznv" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_NV_EXTENSION_152_SPEC_VERSION"/>
                <enum value="&quot;VK_NV_extension_152&quot;"               name="VK_NV_EXTENSION_152_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_NV_framebuffer_mixed_samples" number="153" type="device" author="NV" contact="Jeff Bolz @jeffbolznv" supported="vulkan">
            <require>
                <enum value="1"                                             name="VK_NV_FRAMEBUFFER_MIXED_SAMPLES_SPEC_VERSION"/>
                <enum value="&quot;VK_NV_framebuffer_mixed_samples&quot;"   name="VK_NV_FRAMEBUFFER_MIXED_SAMPLES_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV"/>
                <type name="VkPipelineCoverageModulationStateCreateInfoNV"/>
                <type name="VkPipelineCoverageModulationStateCreateFlagsNV"/>
                <type name="VkCoverageModulationModeNV"/>
            </require>
        </extension>
        <extension name="VK_NV_fill_rectangle" number="154" type="device" author="NV" contact="Jeff Bolz @jeffbolznv" supported="vulkan">
            <require>
                <enum value="1"                                             name="VK_NV_FILL_RECTANGLE_SPEC_VERSION"/>
                <enum value="&quot;VK_NV_fill_rectangle&quot;"              name="VK_NV_FILL_RECTANGLE_EXTENSION_NAME"/>
                <enum offset="0" extends="VkPolygonMode"                    name="VK_POLYGON_MODE_FILL_RECTANGLE_NV"/>
            </require>
        </extension>
        <extension name="VK_NV_shader_sm_builtins" number="155" type="device" requiresCore="1.1" author="NV" contact="Daniel Koch @dgkoch" supported="vulkan">
            <require>
                <enum value="1"                                             name="VK_NV_SHADER_SM_BUILTINS_SPEC_VERSION"/>
                <enum value="&quot;VK_NV_shader_sm_builtins&quot;"          name="VK_NV_SHADER_SM_BUILTINS_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_FEATURES_NV"/>
                <enum offset="1" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_PROPERTIES_NV"/>
                <type name="VkPhysicalDeviceShaderSMBuiltinsPropertiesNV"/>
                <type name="VkPhysicalDeviceShaderSMBuiltinsFeaturesNV"/>
            </require>
        </extension>
        <extension name="VK_EXT_post_depth_coverage" number="156" type="device" author="NV" contact="Daniel Koch @dgkoch" supported="vulkan">
            <require>
                <enum value="1"                                             name="VK_EXT_POST_DEPTH_COVERAGE_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_post_depth_coverage&quot;"        name="VK_EXT_POST_DEPTH_COVERAGE_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_KHR_sampler_ycbcr_conversion" number="157" type="device" requires="VK_KHR_maintenance1,VK_KHR_bind_memory2,VK_KHR_get_memory_requirements2,VK_KHR_get_physical_device_properties2" author="KHR" contact="Andrew Garrard @fluppeteer" supported="vulkan" promotedto="VK_VERSION_1_1">
            <require>
                <enum value="1"                                             name="VK_KHR_SAMPLER_YCBCR_CONVERSION_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_sampler_ycbcr_conversion&quot;"   name="VK_KHR_SAMPLER_YCBCR_CONVERSION_EXTENSION_NAME"/>
                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO_KHR" alias="VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO"/>
                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO_KHR" alias="VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO"/>
                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO_KHR" alias="VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO"/>
                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO_KHR" alias="VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO"/>
                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES_KHR" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES"/>
                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES_KHR" alias="VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES"/>
                <enum extends="VkDebugReportObjectTypeEXT"                  name="VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_KHR_EXT" alias="VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_EXT"/>
                <enum extends="VkObjectType"                                name="VK_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_KHR" alias="VK_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION"/>
                <enum extends="VkFormat"                                    name="VK_FORMAT_G8B8G8R8_422_UNORM_KHR" alias="VK_FORMAT_G8B8G8R8_422_UNORM"/>
                <enum extends="VkFormat"                                    name="VK_FORMAT_B8G8R8G8_422_UNORM_KHR" alias="VK_FORMAT_B8G8R8G8_422_UNORM"/>
                <enum extends="VkFormat"                                    name="VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM_KHR" alias="VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM"/>
                <enum extends="VkFormat"                                    name="VK_FORMAT_G8_B8R8_2PLANE_420_UNORM_KHR" alias="VK_FORMAT_G8_B8R8_2PLANE_420_UNORM"/>
                <enum extends="VkFormat"                                    name="VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM_KHR" alias="VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM"/>
                <enum extends="VkFormat"                                    name="VK_FORMAT_G8_B8R8_2PLANE_422_UNORM_KHR" alias="VK_FORMAT_G8_B8R8_2PLANE_422_UNORM"/>
                <enum extends="VkFormat"                                    name="VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM_KHR" alias="VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM"/>
                <enum extends="VkFormat"                                    name="VK_FORMAT_R10X6_UNORM_PACK16_KHR" alias="VK_FORMAT_R10X6_UNORM_PACK16"/>
                <enum extends="VkFormat"                                    name="VK_FORMAT_R10X6G10X6_UNORM_2PACK16_KHR" alias="VK_FORMAT_R10X6G10X6_UNORM_2PACK16"/>
                <enum extends="VkFormat"                                    name="VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16_KHR" alias="VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16"/>
                <enum extends="VkFormat"                                    name="VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16_KHR" alias="VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16"/>
                <enum extends="VkFormat"                                    name="VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16_KHR" alias="VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16"/>
                <enum extends="VkFormat"                                    name="VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16_KHR" alias="VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16"/>
                <enum extends="VkFormat"                                    name="VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16_KHR" alias="VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16"/>
                <enum extends="VkFormat"                                    name="VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16_KHR" alias="VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16"/>
                <enum extends="VkFormat"                                    name="VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16_KHR" alias="VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16"/>
                <enum extends="VkFormat"                                    name="VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16_KHR" alias="VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16"/>
                <enum extends="VkFormat"                                    name="VK_FORMAT_R12X4_UNORM_PACK16_KHR" alias="VK_FORMAT_R12X4_UNORM_PACK16"/>
                <enum extends="VkFormat"                                    name="VK_FORMAT_R12X4G12X4_UNORM_2PACK16_KHR" alias="VK_FORMAT_R12X4G12X4_UNORM_2PACK16"/>
                <enum extends="VkFormat"                                    name="VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16_KHR" alias="VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16"/>
                <enum extends="VkFormat"                                    name="VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16_KHR" alias="VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16"/>
                <enum extends="VkFormat"                                    name="VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16_KHR" alias="VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16"/>
                <enum extends="VkFormat"                                    name="VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16_KHR" alias="VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16"/>
                <enum extends="VkFormat"                                    name="VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16_KHR" alias="VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16"/>
                <enum extends="VkFormat"                                    name="VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16_KHR" alias="VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16"/>
                <enum extends="VkFormat"                                    name="VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16_KHR" alias="VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16"/>
                <enum extends="VkFormat"                                    name="VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16_KHR" alias="VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16"/>
                <enum extends="VkFormat"                                    name="VK_FORMAT_G16B16G16R16_422_UNORM_KHR" alias="VK_FORMAT_G16B16G16R16_422_UNORM"/>
                <enum extends="VkFormat"                                    name="VK_FORMAT_B16G16R16G16_422_UNORM_KHR" alias="VK_FORMAT_B16G16R16G16_422_UNORM"/>
                <enum extends="VkFormat"                                    name="VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM_KHR" alias="VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM"/>
                <enum extends="VkFormat"                                    name="VK_FORMAT_G16_B16R16_2PLANE_420_UNORM_KHR" alias="VK_FORMAT_G16_B16R16_2PLANE_420_UNORM"/>
                <enum extends="VkFormat"                                    name="VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM_KHR" alias="VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM"/>
                <enum extends="VkFormat"                                    name="VK_FORMAT_G16_B16R16_2PLANE_422_UNORM_KHR" alias="VK_FORMAT_G16_B16R16_2PLANE_422_UNORM"/>
                <enum extends="VkFormat"                                    name="VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM_KHR" alias="VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM"/>
                <enum extends="VkImageAspectFlagBits"                       name="VK_IMAGE_ASPECT_PLANE_0_BIT_KHR" alias="VK_IMAGE_ASPECT_PLANE_0_BIT"/>
                <enum extends="VkImageAspectFlagBits"                       name="VK_IMAGE_ASPECT_PLANE_1_BIT_KHR" alias="VK_IMAGE_ASPECT_PLANE_1_BIT"/>
                <enum extends="VkImageAspectFlagBits"                       name="VK_IMAGE_ASPECT_PLANE_2_BIT_KHR" alias="VK_IMAGE_ASPECT_PLANE_2_BIT"/>
                <enum extends="VkImageCreateFlagBits"                       name="VK_IMAGE_CREATE_DISJOINT_BIT_KHR" alias="VK_IMAGE_CREATE_DISJOINT_BIT"/>
                <enum extends="VkFormatFeatureFlagBits"                     name="VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT_KHR" alias="VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT"/>
                <enum extends="VkFormatFeatureFlagBits"                     name="VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT_KHR" alias="VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT"/>
                <enum extends="VkFormatFeatureFlagBits"                     name="VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT_KHR" alias="VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT"/>
                <enum extends="VkFormatFeatureFlagBits"                     name="VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT_KHR" alias="VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT"/>
                <enum extends="VkFormatFeatureFlagBits"                     name="VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT_KHR" alias="VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT"/>
                <enum extends="VkFormatFeatureFlagBits"                     name="VK_FORMAT_FEATURE_DISJOINT_BIT_KHR" alias="VK_FORMAT_FEATURE_DISJOINT_BIT"/>
                <enum extends="VkFormatFeatureFlagBits"                     name="VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT_KHR" alias="VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT"/>
                <type name="VkSamplerYcbcrConversionCreateInfoKHR"/>
                <type name="VkSamplerYcbcrConversionInfoKHR"/>
                <type name="VkBindImagePlaneMemoryInfoKHR"/>
                <type name="VkImagePlaneMemoryRequirementsInfoKHR"/>
                <type name="VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR"/>
                <type name="VkSamplerYcbcrConversionImageFormatPropertiesKHR"/>
                <command name="vkCreateSamplerYcbcrConversionKHR"/>
                <command name="vkDestroySamplerYcbcrConversionKHR"/>
                <type name="VkSamplerYcbcrConversionKHR"/>
                <type name="VkSamplerYcbcrModelConversionKHR"/>
                <enum extends="VkSamplerYcbcrModelConversion"               name="VK_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY_KHR" alias="VK_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY"/>
                <enum extends="VkSamplerYcbcrModelConversion"               name="VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_IDENTITY_KHR" alias="VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_IDENTITY"/>
                <enum extends="VkSamplerYcbcrModelConversion"               name="VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_709_KHR" alias="VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_709"/>
                <enum extends="VkSamplerYcbcrModelConversion"               name="VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_601_KHR" alias="VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_601"/>
                <enum extends="VkSamplerYcbcrModelConversion"               name="VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_2020_KHR" alias="VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_2020"/>
                <type name="VkSamplerYcbcrRangeKHR"/>
                <enum extends="VkSamplerYcbcrRange"                         name="VK_SAMPLER_YCBCR_RANGE_ITU_FULL_KHR" alias="VK_SAMPLER_YCBCR_RANGE_ITU_FULL"/>
                <enum extends="VkSamplerYcbcrRange"                         name="VK_SAMPLER_YCBCR_RANGE_ITU_NARROW_KHR" alias="VK_SAMPLER_YCBCR_RANGE_ITU_NARROW"/>
                <type name="VkChromaLocationKHR"/>
                <enum extends="VkChromaLocation"                            name="VK_CHROMA_LOCATION_COSITED_EVEN_KHR" alias="VK_CHROMA_LOCATION_COSITED_EVEN"/>
                <enum extends="VkChromaLocation"                            name="VK_CHROMA_LOCATION_MIDPOINT_KHR" alias="VK_CHROMA_LOCATION_MIDPOINT"/>
            </require>
            <require extension="VK_EXT_debug_report">
                <enum extends="VkDebugReportObjectTypeEXT" offset="0"       name="VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_EXT"/>
            </require>
        </extension>
        <extension name="VK_KHR_bind_memory2" number="158" type="device" author="KHR" contact="Tobias Hector @tobski" supported="vulkan" promotedto="VK_VERSION_1_1">
            <require>
                <enum value="1"                                             name="VK_KHR_BIND_MEMORY_2_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_bind_memory2&quot;"               name="VK_KHR_BIND_MEMORY_2_EXTENSION_NAME"/>
                <command name="vkBindBufferMemory2KHR"/>
                <command name="vkBindImageMemory2KHR"/>
                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO_KHR" alias="VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO"/>
                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO_KHR" alias="VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO"/>
                <enum extends="VkImageCreateFlagBits"                       name="VK_IMAGE_CREATE_ALIAS_BIT_KHR" alias="VK_IMAGE_CREATE_ALIAS_BIT"/>
                <type name="VkBindBufferMemoryInfoKHR"/>
                <type name="VkBindImageMemoryInfoKHR"/>
            </require>
        </extension>
        <extension name="VK_EXT_image_drm_format_modifier" number="159" type="device" requires="VK_KHR_bind_memory2,VK_KHR_get_physical_device_properties2,VK_KHR_image_format_list,VK_KHR_sampler_ycbcr_conversion" author="EXT" contact="Chad Versace @chadversary" supported="vulkan">
            <require>
                <enum value="1"                                             name="VK_EXT_IMAGE_DRM_FORMAT_MODIFIER_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_image_drm_format_modifier&quot;"  name="VK_EXT_IMAGE_DRM_FORMAT_MODIFIER_EXTENSION_NAME"/>

                <enum offset="0" dir="-" extends="VkResult" name="VK_ERROR_INVALID_DRM_FORMAT_MODIFIER_PLANE_LAYOUT_EXT"/>

                <enum offset="0" extends="VkStructureType" name="VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_EXT"/>
                <enum offset="1" extends="VkStructureType" name="VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_EXT"/>
                <enum offset="2" extends="VkStructureType" name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_DRM_FORMAT_MODIFIER_INFO_EXT"/>
                <enum offset="3" extends="VkStructureType" name="VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_LIST_CREATE_INFO_EXT"/>
                <enum offset="4" extends="VkStructureType" name="VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_EXT"/>
                <enum offset="5" extends="VkStructureType" name="VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_PROPERTIES_EXT"/>

                <enum offset="0" extends="VkImageTiling" name="VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT"/>

                <enum bitpos="7"  extends="VkImageAspectFlagBits" name="VK_IMAGE_ASPECT_MEMORY_PLANE_0_BIT_EXT"/>
                <enum bitpos="8"  extends="VkImageAspectFlagBits" name="VK_IMAGE_ASPECT_MEMORY_PLANE_1_BIT_EXT"/>
                <enum bitpos="9"  extends="VkImageAspectFlagBits" name="VK_IMAGE_ASPECT_MEMORY_PLANE_2_BIT_EXT"/>
                <enum bitpos="10" extends="VkImageAspectFlagBits" name="VK_IMAGE_ASPECT_MEMORY_PLANE_3_BIT_EXT"/>

                <type name="VkDrmFormatModifierPropertiesListEXT"/>
                <type name="VkDrmFormatModifierPropertiesEXT"/>
                <type name="VkPhysicalDeviceImageDrmFormatModifierInfoEXT"/>
                <type name="VkImageDrmFormatModifierListCreateInfoEXT"/>
                <type name="VkImageDrmFormatModifierExplicitCreateInfoEXT"/>
                <type name="VkImageDrmFormatModifierPropertiesEXT"/>

                <command name="vkGetImageDrmFormatModifierPropertiesEXT"/>
            </require>
        </extension>
        <extension name="VK_EXT_extension_160" number="160" author="EXT" contact="Mark Young @marky-lunarg" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_EXT_EXTENSION_160_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_extension_160&quot;"              name="VK_EXT_EXTENSION_160_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_EXT_validation_cache" number="161" type="device" author="GOOGLE" contact="Cort Stratton @cdwfs" supported="vulkan">
            <require>
                <enum value="1"                                             name="VK_EXT_VALIDATION_CACHE_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_validation_cache&quot;"           name="VK_EXT_VALIDATION_CACHE_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_VALIDATION_CACHE_CREATE_INFO_EXT"/>
                <enum offset="1" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT"/>
                <enum offset="0" extends="VkObjectType"                     name="VK_OBJECT_TYPE_VALIDATION_CACHE_EXT" comment="VkValidationCacheEXT"/>
                <type name="VkValidationCacheEXT"/>
                <type name="VkValidationCacheCreateInfoEXT"/>
                <type name="VkShaderModuleValidationCacheCreateInfoEXT"/>
                <type name="VkValidationCacheHeaderVersionEXT"/>
                <type name="VkValidationCacheCreateFlagsEXT"/>
                <command name="vkCreateValidationCacheEXT"/>
                <command name="vkDestroyValidationCacheEXT"/>
                <command name="vkMergeValidationCachesEXT"/>
                <command name="vkGetValidationCacheDataEXT"/>
            </require>
        </extension>
        <extension name="VK_EXT_descriptor_indexing" number="162" type="device" requires="VK_KHR_get_physical_device_properties2,VK_KHR_maintenance3" author="NV" contact="Jeff Bolz @jeffbolznv" supported="vulkan">
            <require>
                <enum value="2"                                          name="VK_EXT_DESCRIPTOR_INDEXING_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_descriptor_indexing&quot;"     name="VK_EXT_DESCRIPTOR_INDEXING_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"               name="VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO_EXT"/>
                <enum offset="1" extends="VkStructureType"               name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES_EXT"/>
                <enum offset="2" extends="VkStructureType"               name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES_EXT"/>
                <enum offset="3" extends="VkStructureType"               name="VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO_EXT"/>
                <enum offset="4" extends="VkStructureType"               name="VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT_EXT"/>
                <enum bitpos="1" extends="VkDescriptorPoolCreateFlagBits" name="VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT_EXT"/>
                <enum bitpos="1" extends="VkDescriptorSetLayoutCreateFlagBits" name="VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT"/>
                <enum offset="0" dir="-" extends="VkResult"              name="VK_ERROR_FRAGMENTATION_EXT"/>
                <type name="VkDescriptorSetLayoutBindingFlagsCreateInfoEXT"/>
                <type name="VkPhysicalDeviceDescriptorIndexingFeaturesEXT"/>
                <type name="VkPhysicalDeviceDescriptorIndexingPropertiesEXT"/>
                <type name="VkDescriptorSetVariableDescriptorCountAllocateInfoEXT"/>
                <type name="VkDescriptorSetVariableDescriptorCountLayoutSupportEXT"/>
            </require>
        </extension>
        <extension name="VK_EXT_shader_viewport_index_layer" number="163" type="device" author="NV" contact="Daniel Koch @dgkoch" supported="vulkan">
            <require>
                <enum value="1"                                             name="VK_EXT_SHADER_VIEWPORT_INDEX_LAYER_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_shader_viewport_index_layer&quot;" name="VK_EXT_SHADER_VIEWPORT_INDEX_LAYER_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_NV_extension_164" number="164" author="NV" contact="Daniel Koch @dgkoch" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_EXT_EXTENSION_164_SPEC_VERSION"/>
                <enum value="&quot;VK_NV_extension_164&quot;"               name="VK_EXT_EXTENSION_164_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_NV_shading_rate_image" number="165" type="device" requires="VK_KHR_get_physical_device_properties2" author="NV" contact="Pat Brown @nvpbrown" supported="vulkan">
            <require>
                <enum value="3"                                             name="VK_NV_SHADING_RATE_IMAGE_SPEC_VERSION"/>
                <enum value="&quot;VK_NV_shading_rate_image&quot;"          name="VK_NV_SHADING_RATE_IMAGE_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SHADING_RATE_IMAGE_STATE_CREATE_INFO_NV"/>
                <enum offset="1" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_FEATURES_NV"/>
                <enum offset="2" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_PROPERTIES_NV"/>
                <enum offset="3" extends="VkImageLayout"                    name="VK_IMAGE_LAYOUT_SHADING_RATE_OPTIMAL_NV"/>
                <enum offset="4" extends="VkDynamicState"                   name="VK_DYNAMIC_STATE_VIEWPORT_SHADING_RATE_PALETTE_NV"/>
                <enum bitpos="23" extends="VkAccessFlagBits"                name="VK_ACCESS_SHADING_RATE_IMAGE_READ_BIT_NV"/>
                <enum bitpos="8" extends="VkImageUsageFlagBits"             name="VK_IMAGE_USAGE_SHADING_RATE_IMAGE_BIT_NV"/>
                <enum bitpos="22" extends="VkPipelineStageFlagBits"         name="VK_PIPELINE_STAGE_SHADING_RATE_IMAGE_BIT_NV"/>
                <enum offset="5" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_COARSE_SAMPLE_ORDER_STATE_CREATE_INFO_NV"/>
                <enum offset="6" extends="VkDynamicState"                   name="VK_DYNAMIC_STATE_VIEWPORT_COARSE_SAMPLE_ORDER_NV"/>
                <type name="VkShadingRatePaletteEntryNV"/>
                <type name="VkShadingRatePaletteNV"/>
                <type name="VkPipelineViewportShadingRateImageStateCreateInfoNV"/>
                <type name="VkPhysicalDeviceShadingRateImageFeaturesNV"/>
                <type name="VkPhysicalDeviceShadingRateImagePropertiesNV"/>
                <type name="VkCoarseSampleLocationNV"/>
                <type name="VkCoarseSampleOrderCustomNV"/>
                <type name="VkPipelineViewportCoarseSampleOrderStateCreateInfoNV"/>
                <type name="VkCoarseSampleOrderTypeNV"/>
                <command name="vkCmdBindShadingRateImageNV"/>
                <command name="vkCmdSetViewportShadingRatePaletteNV"/>
                <command name="vkCmdSetCoarseSampleOrderNV"/>
            </require>
        </extension>
        <extension name="VK_NV_ray_tracing" number="166" type="device" requires="VK_KHR_get_physical_device_properties2,VK_KHR_get_memory_requirements2" author="NV" contact="Eric Werness @ewerness" supported="vulkan">
            <require>
                <enum value="3"                                          name="VK_NV_RAY_TRACING_SPEC_VERSION"/>
                <enum value="&quot;VK_NV_ray_tracing&quot;"              name="VK_NV_RAY_TRACING_EXTENSION_NAME"/>
                <enum                                                    name="VK_SHADER_UNUSED_NV"/>
                <enum offset="0" extends="VkStructureType"               name="VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_NV"/>
                <enum offset="1" extends="VkStructureType"               name="VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_NV"/>
                <enum offset="3" extends="VkStructureType"               name="VK_STRUCTURE_TYPE_GEOMETRY_NV"/>
                <enum offset="4" extends="VkStructureType"               name="VK_STRUCTURE_TYPE_GEOMETRY_TRIANGLES_NV"/>
                <enum offset="5" extends="VkStructureType"               name="VK_STRUCTURE_TYPE_GEOMETRY_AABB_NV"/>
                <enum offset="6" extends="VkStructureType"               name="VK_STRUCTURE_TYPE_BIND_ACCELERATION_STRUCTURE_MEMORY_INFO_NV"/>
                <enum offset="7" extends="VkStructureType"               name="VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_NV"/>
                <enum offset="8" extends="VkStructureType"               name="VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_INFO_NV"/>
                <enum offset="9" extends="VkStructureType"               name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PROPERTIES_NV"/>
                <enum offset="11" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_NV"/>
                <enum offset="12" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_INFO_NV"/>
                <enum bitpos="8" extends="VkShaderStageFlagBits"         name="VK_SHADER_STAGE_RAYGEN_BIT_NV"/>
                <enum bitpos="9" extends="VkShaderStageFlagBits"         name="VK_SHADER_STAGE_ANY_HIT_BIT_NV"/>
                <enum bitpos="10" extends="VkShaderStageFlagBits"        name="VK_SHADER_STAGE_CLOSEST_HIT_BIT_NV"/>
                <enum bitpos="11" extends="VkShaderStageFlagBits"        name="VK_SHADER_STAGE_MISS_BIT_NV"/>
                <enum bitpos="12" extends="VkShaderStageFlagBits"        name="VK_SHADER_STAGE_INTERSECTION_BIT_NV"/>
                <enum bitpos="13" extends="VkShaderStageFlagBits"        name="VK_SHADER_STAGE_CALLABLE_BIT_NV"/>
                <enum bitpos="21" extends="VkPipelineStageFlagBits"      name="VK_PIPELINE_STAGE_RAY_TRACING_SHADER_BIT_NV"/>
                <enum bitpos="25" extends="VkPipelineStageFlagBits"      name="VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_NV"/>
                <enum bitpos="10" extends="VkBufferUsageFlagBits"        name="VK_BUFFER_USAGE_RAY_TRACING_BIT_NV"/>
                <enum offset="0" extends="VkPipelineBindPoint"           name="VK_PIPELINE_BIND_POINT_RAY_TRACING_NV"/>
                <enum offset="0" extends="VkDescriptorType"              name="VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_NV"/>
                <enum bitpos="21" extends="VkAccessFlagBits"             name="VK_ACCESS_ACCELERATION_STRUCTURE_READ_BIT_NV"/>
                <enum bitpos="22" extends="VkAccessFlagBits"             name="VK_ACCESS_ACCELERATION_STRUCTURE_WRITE_BIT_NV"/>
                <enum offset="0" extends="VkQueryType"                   name="VK_QUERY_TYPE_ACCELERATION_STRUCTURE_COMPACTED_SIZE_NV"/>
                <enum bitpos="5" extends="VkPipelineCreateFlagBits"      name="VK_PIPELINE_CREATE_DEFER_COMPILE_BIT_NV"/>
                <enum offset="0" extends="VkObjectType"                  name="VK_OBJECT_TYPE_ACCELERATION_STRUCTURE_NV"/>
                <enum offset="0" extends="VkDebugReportObjectTypeEXT"    name="VK_DEBUG_REPORT_OBJECT_TYPE_ACCELERATION_STRUCTURE_NV_EXT"/>
                <enum offset="0" extends="VkIndexType"                   name="VK_INDEX_TYPE_NONE_NV"/>
                <type name="VkRayTracingShaderGroupCreateInfoNV"/>
                <type name="VkRayTracingShaderGroupTypeNV"/>
                <type name="VkRayTracingPipelineCreateInfoNV"/>
                <type name="VkGeometryTrianglesNV"/>
                <type name="VkGeometryAABBNV"/>
                <type name="VkGeometryDataNV"/>
                <type name="VkGeometryNV"/>
                <type name="VkGeometryFlagsNV"/>
                <type name="VkGeometryInstanceFlagsNV"/>
                <type name="VkGeometryFlagBitsNV"/>
                <type name="VkGeometryInstanceFlagBitsNV"/>
                <type name="VkAccelerationStructureInfoNV"/>
                <type name="VkAccelerationStructureCreateInfoNV"/>
                <type name="VkAccelerationStructureNV"/>
                <type name="VkBuildAccelerationStructureFlagBitsNV"/>
                <type name="VkBuildAccelerationStructureFlagsNV"/>
                <type name="VkCopyAccelerationStructureModeNV"/>
                <type name="VkGeometryTypeNV"/>
                <type name="VkBindAccelerationStructureMemoryInfoNV"/>
                <type name="VkWriteDescriptorSetAccelerationStructureNV"/>
                <type name="VkAccelerationStructureMemoryRequirementsInfoNV"/>
                <type name="VkPhysicalDeviceRayTracingPropertiesNV"/>
                <type name="VkMemoryRequirements2KHR"/>
                <type name="VkAccelerationStructureMemoryRequirementsTypeNV"/>
                <command name="vkCreateAccelerationStructureNV"/>
                <command name="vkDestroyAccelerationStructureNV"/>
                <command name="vkGetAccelerationStructureMemoryRequirementsNV"/>
                <command name="vkBindAccelerationStructureMemoryNV"/>
                <command name="vkCmdBuildAccelerationStructureNV"/>
                <command name="vkCmdCopyAccelerationStructureNV"/>
                <command name="vkCmdTraceRaysNV"/>
                <command name="vkCreateRayTracingPipelinesNV"/>
                <command name="vkGetRayTracingShaderGroupHandlesNV"/>
                <command name="vkGetAccelerationStructureHandleNV"/>
                <command name="vkCmdWriteAccelerationStructuresPropertiesNV"/>
                <command name="vkCompileDeferredNV"/>
            </require>
        </extension>
        <extension name="VK_NV_representative_fragment_test" number="167" type="device" author="NV" contact="Kedarnath Thangudu @kthangudu" supported="vulkan">
            <require>
                <enum value="1"                                             name="VK_NV_REPRESENTATIVE_FRAGMENT_TEST_SPEC_VERSION"/>
                <enum value="&quot;VK_NV_representative_fragment_test&quot;" name="VK_NV_REPRESENTATIVE_FRAGMENT_TEST_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_REPRESENTATIVE_FRAGMENT_TEST_FEATURES_NV"/>
                <enum offset="1" extends="VkStructureType"  name="VK_STRUCTURE_TYPE_PIPELINE_REPRESENTATIVE_FRAGMENT_TEST_STATE_CREATE_INFO_NV"/>
                <type name="VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV"/>
                <type name="VkPipelineRepresentativeFragmentTestStateCreateInfoNV"/>
            </require>
        </extension>
        <extension name="VK_NV_extension_168" number="168" author="NV" contact="Daniel Koch @dgkoch" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_EXT_EXTENSION_168_SPEC_VERSION"/>
                <enum value="&quot;VK_NV_extension_168&quot;"               name="VK_EXT_EXTENSION_168_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_KHR_maintenance3" number="169" type="device" requires="VK_KHR_get_physical_device_properties2" author="KHR" contact="Jeff Bolz @jeffbolznv" supported="vulkan" promotedto="VK_VERSION_1_1">
            <require>
                <enum value="1"                                             name="VK_KHR_MAINTENANCE3_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_maintenance3&quot;"               name="VK_KHR_MAINTENANCE3_EXTENSION_NAME"/>
                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES_KHR" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES"/>
                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT_KHR" alias="VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT"/>
                <type name="VkPhysicalDeviceMaintenance3PropertiesKHR"/>
                <type name="VkDescriptorSetLayoutSupportKHR"/>
                <command name="vkGetDescriptorSetLayoutSupportKHR"/>
            </require>
        </extension>
        <extension name="VK_KHR_draw_indirect_count" number="170" type="device" author="KHR" contact="Piers Daniell @pdaniell-nv" supported="vulkan">
            <require>
                <enum value="1"                                          name="VK_KHR_DRAW_INDIRECT_COUNT_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_draw_indirect_count&quot;"     name="VK_KHR_DRAW_INDIRECT_COUNT_EXTENSION_NAME"/>
                <command name="vkCmdDrawIndirectCountKHR"/>
                <command name="vkCmdDrawIndexedIndirectCountKHR"/>
            </require>
        </extension>
        <extension name="VK_EXT_filter_cubic" number="171" type="device" requires="VK_IMG_filter_cubic" author="QCOM" contact="Bill Licea-Kane @wwlk" supported="vulkan">
            <require>
                <enum value="2"                                             name="VK_EXT_FILTER_CUBIC_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_filter_cubic&quot;"               name="VK_EXT_FILTER_CUBIC_EXTENSION_NAME"/>
                <enum extends="VkFilter"                                    name="VK_FILTER_CUBIC_EXT" alias="VK_FILTER_CUBIC_IMG"/>
                <enum extends="VkFormatFeatureFlagBits"                     name="VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT" alias="VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_IMG"/>
                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_IMAGE_FORMAT_INFO_EXT"/>
                <enum offset="1" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_FILTER_CUBIC_IMAGE_VIEW_IMAGE_FORMAT_PROPERTIES_EXT"/>
                <type name="VkPhysicalDeviceImageViewImageFormatInfoEXT"/>
                <type name="VkFilterCubicImageViewImageFormatPropertiesEXT"/>
            </require>
        </extension>
        <extension name="VK_QCOM_extension_172" number="172" author="QCOM" contact="Bill Licea-Kane @wwlk" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_QCOM_extension_172_SPEC_VERSION"/>
                <enum value="&quot;VK_QCOM_extension_172&quot;"             name="VK_QCOM_extension_172_EXTENSION_NAME"/>
                <enum bitpos="2" extends="VkSubpassDescriptionFlagBits"     name="VK_SUBPASS_DESCRIPTION_RESERVED_2_BIT_QCOM"/>
                <enum bitpos="3" extends="VkSubpassDescriptionFlagBits"     name="VK_SUBPASS_DESCRIPTION_RESERVED_3_BIT_QCOM"/>
            </require>
        </extension>
        <extension name="VK_QCOM_extension_173" number="173" author="QCOM" contact="Bill Licea-Kane @wwlk" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_QCOM_extension_173_SPEC_VERSION"/>
                <enum value="&quot;VK_QCOM_extension_173&quot;"             name="VK_QCOM_extension_173_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_QCOM_extension_174" number="174" author="QCOM" contact="Bill Licea-Kane @wwlk" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_QCOM_extension_174_SPEC_VERSION"/>
                <enum value="&quot;VK_QCOM_extension_174&quot;"             name="VK_QCOM_extension_174_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_EXT_global_priority" number="175" type="device" author="EXT" contact="Andres Rodriguez @lostgoat" supported="vulkan">
            <require>
                <enum value="2"                                             name="VK_EXT_GLOBAL_PRIORITY_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_global_priority&quot;"            name="VK_EXT_GLOBAL_PRIORITY_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_EXT"/>
                <enum offset="1" dir="-" extends="VkResult"                 name="VK_ERROR_NOT_PERMITTED_EXT"/>
                <type name="VkDeviceQueueGlobalPriorityCreateInfoEXT"/>
                <type name="VkQueueGlobalPriorityEXT"/>
            </require>
        </extension>
        <extension name="VK_EXT_extension_176" number="176" author="EXT" contact="Neil Henning @sheredom" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_KHR_EXTENSION_176_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_extension_176&quot;"              name="VK_KHR_EXTENSION_176_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_EXT_extension_177" number="177" author="EXT" contact="Neil Henning @sheredom" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_KHR_EXTENSION_177_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_extension_177&quot;"              name="VK_KHR_EXTENSION_177_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_KHR_8bit_storage" number="178" type="device" requires="VK_KHR_get_physical_device_properties2,VK_KHR_storage_buffer_storage_class" author="KHR" contact="Alexander Galazin @alegal-arm" supported="vulkan">
            <require>
                <enum value="1"                                          name="VK_KHR_8BIT_STORAGE_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_8bit_storage&quot;"            name="VK_KHR_8BIT_STORAGE_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"               name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES_KHR"/>
                <type name="VkPhysicalDevice8BitStorageFeaturesKHR"/>
            </require>
        </extension>
        <extension name="VK_EXT_external_memory_host" number="179" type="device" author="EXT" requires="VK_KHR_external_memory" contact="Daniel Rakos @drakos-amd" supported="vulkan">
            <require>
                <enum value="1"                                             name="VK_EXT_EXTERNAL_MEMORY_HOST_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_external_memory_host&quot;"       name="VK_EXT_EXTERNAL_MEMORY_HOST_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT"/>
                <enum offset="1" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_MEMORY_HOST_POINTER_PROPERTIES_EXT"/>
                <enum offset="2" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT"/>
                <enum bitpos="7" extends="VkExternalMemoryHandleTypeFlagBits" name="VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_ALLOCATION_BIT_EXT"/>
                <enum bitpos="8" extends="VkExternalMemoryHandleTypeFlagBits" name="VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_MAPPED_FOREIGN_MEMORY_BIT_EXT"/>
                <type name="VkExternalMemoryHandleTypeFlagsKHR"/>
                <type name="VkExternalMemoryHandleTypeFlagBitsKHR"/>
                <type name="VkImportMemoryHostPointerInfoEXT"/>
                <type name="VkMemoryHostPointerPropertiesEXT"/>
                <type name="VkPhysicalDeviceExternalMemoryHostPropertiesEXT"/>
                <command name="vkGetMemoryHostPointerPropertiesEXT"/>
            </require>
        </extension>
        <extension name="VK_AMD_buffer_marker" number="180" type="device" author="AMD" contact="Daniel Rakos @drakos-amd" supported="vulkan">
            <require>
                <enum value="1"                                          name="VK_AMD_BUFFER_MARKER_SPEC_VERSION"/>
                <enum value="&quot;VK_AMD_buffer_marker&quot;"           name="VK_AMD_BUFFER_MARKER_EXTENSION_NAME"/>
                <command name="vkCmdWriteBufferMarkerAMD"/>
            </require>
        </extension>
        <extension name="VK_KHR_shader_atomic_int64" number="181" type="device" author="KHR" requires="VK_KHR_get_physical_device_properties2" contact="Aaron Hagan @ahagan" supported="vulkan">
            <require>
                <enum value="1"                                             name="VK_KHR_SHADER_ATOMIC_INT64_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_shader_atomic_int64&quot;"        name="VK_KHR_SHADER_ATOMIC_INT64_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES_KHR"/>
                <type name="VkPhysicalDeviceShaderAtomicInt64FeaturesKHR"/>
            </require>
        </extension>
        <extension name="VK_AMD_extension_182" number="182" author="AMD" contact="Daniel Rakos @drakos-amd" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_KHR_EXTENSION_182_SPEC_VERSION"/>
                <enum value="&quot;VK_AMD_extension_182&quot;"              name="VK_KHR_EXTENSION_182_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_AMD_extension_183" number="183" author="AMD" contact="Daniel Rakos @drakos-amd" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_KHR_EXTENSION_183_SPEC_VERSION"/>
                <enum value="&quot;VK_AMD_extension_183&quot;"              name="VK_KHR_EXTENSION_183_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_AMD_extension_184" number="184" author="AMD" contact="Daniel Rakos @drakos-amd" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_KHR_EXTENSION_184_SPEC_VERSION"/>
                <enum value="&quot;VK_AMD_extension_184&quot;"              name="VK_KHR_EXTENSION_184_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_EXT_calibrated_timestamps" number="185" type="device" author="EXT" contact="Daniel Rakos @drakos-amd" supported="vulkan">
            <require>
                <enum value="1"                                             name="VK_EXT_CALIBRATED_TIMESTAMPS_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_calibrated_timestamps&quot;"      name="VK_EXT_CALIBRATED_TIMESTAMPS_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_CALIBRATED_TIMESTAMP_INFO_EXT"/>
                <type name="VkTimeDomainEXT"/>
                <type name="VkCalibratedTimestampInfoEXT"/>
                <command name="vkGetPhysicalDeviceCalibrateableTimeDomainsEXT"/>
                <command name="vkGetCalibratedTimestampsEXT"/>
            </require>
        </extension>
        <extension name="VK_AMD_shader_core_properties" number="186" type="device" author="AMD" requires="VK_KHR_get_physical_device_properties2" contact="Martin Dinkov @mdinkov" supported="vulkan">
            <require>
                <enum value="1"                                          name="VK_AMD_SHADER_CORE_PROPERTIES_SPEC_VERSION"/>
                <enum value="&quot;VK_AMD_shader_core_properties&quot;"  name="VK_AMD_SHADER_CORE_PROPERTIES_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"               name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD"/>
                <type name="VkPhysicalDeviceShaderCorePropertiesAMD"/>
            </require>
        </extension>
        <extension name="VK_AMD_extension_187" number="187" author="AMD" contact="Daniel Rakos @drakos-amd" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_KHR_EXTENSION_187_SPEC_VERSION"/>
                <enum value="&quot;VK_AMD_extension_187&quot;"              name="VK_KHR_EXTENSION_187_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_AMD_extension_188" number="188" author="AMD" contact="Daniel Rakos @drakos-amd" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_KHR_EXTENSION_188_SPEC_VERSION"/>
                <enum value="&quot;VK_AMD_extension_188&quot;"              name="VK_KHR_EXTENSION_188_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_AMD_extension_189" number="189" author="AMD" contact="Daniel Rakos @drakos-amd" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_KHR_EXTENSION_189_SPEC_VERSION"/>
                <enum value="&quot;VK_AMD_extension_189&quot;"              name="VK_KHR_EXTENSION_189_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_AMD_memory_overallocation_behavior" number="190" type="device" author="AMD" contact="Martin Dinkov @mdinkov" supported="vulkan">
            <require>
                <enum value="1"                                             name="VK_AMD_MEMORY_OVERALLOCATION_BEHAVIOR_SPEC_VERSION"/>
                <enum value="&quot;VK_AMD_memory_overallocation_behavior&quot;"    name="VK_AMD_MEMORY_OVERALLOCATION_BEHAVIOR_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_DEVICE_MEMORY_OVERALLOCATION_CREATE_INFO_AMD"/>
                <type name="VkMemoryOverallocationBehaviorAMD"/>
                <type name="VkDeviceMemoryOverallocationCreateInfoAMD"/>
            </require>
        </extension>
        <extension name="VK_EXT_vertex_attribute_divisor" number="191" type="device" requires="VK_KHR_get_physical_device_properties2" author="NV" contact="Vikram Kushwaha @vkushwaha" supported="vulkan">
            <require>
                <enum value="3"                                         name="VK_EXT_VERTEX_ATTRIBUTE_DIVISOR_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_vertex_attribute_divisor&quot;"   name="VK_EXT_VERTEX_ATTRIBUTE_DIVISOR_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT"/>
                <enum offset="1" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO_EXT"/>
                <enum offset="2" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES_EXT"/>
                <type name="VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT"/>
                <type name="VkVertexInputBindingDivisorDescriptionEXT"/>
                <type name="VkPipelineVertexInputDivisorStateCreateInfoEXT"/>
                <type name="VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT"/>
            </require>
        </extension>
        <extension name="VK_GGP_frame_token" number="192" type="device" requires="VK_KHR_swapchain,VK_GGP_stream_descriptor_surface" platform="ggp" author="GGP" contact="Jean-Francois Roy @jfroy" supported="vulkan">
            <require>
                <enum value="1"                                                 name="VK_GGP_FRAME_TOKEN_SPEC_VERSION"/>
                <enum value="&quot;VK_GGP_frame_token&quot;"                    name="VK_GGP_FRAME_TOKEN_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_PRESENT_FRAME_TOKEN_GGP"/>
                <type name="VkPresentFrameTokenGGP"/>
            </require>
        </extension>
        <extension name="VK_EXT_pipeline_creation_feedback" number="193" type="device" author="GOOGLE" contact="Jean-Francois Roy @jfroy" supported="vulkan">
            <require>
                <enum value="1"                                         name="VK_EXT_PIPELINE_CREATION_FEEDBACK_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_pipeline_creation_feedback&quot;" name="VK_EXT_PIPELINE_CREATION_FEEDBACK_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO_EXT"/>
                <type name="VkPipelineCreationFeedbackFlagBitsEXT"/>
                <type name="VkPipelineCreationFeedbackFlagsEXT"/>
                <type name="VkPipelineCreationFeedbackCreateInfoEXT"/>
                <type name="VkPipelineCreationFeedbackEXT"/>
            </require>
        </extension>
        <extension name="VK_GOOGLE_extension_194" number="194" author="GOOGLE" contact="Jean-Francois Roy @jfroy" supported="disabled">
            <require>
                <enum value="0"                                         name="VK_GOOGLE_EXTENSION_194_SPEC_VERSION"/>
                <enum value="&quot;VK_GOOGLE_extension_194&quot;"       name="VK_GOOGLE_EXTENSION_194_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_GOOGLE_extension_195" number="195" author="GOOGLE" contact="Jean-Francois Roy @jfroy" supported="disabled">
            <require>
                <enum value="0"                                         name="VK_GOOGLE_EXTENSION_195_SPEC_VERSION"/>
                <enum value="&quot;VK_GOOGLE_extension_195&quot;"       name="VK_GOOGLE_EXTENSION_195_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_GOOGLE_extension_196" number="196" author="GOOGLE" contact="Jean-Francois Roy @jfroy" supported="disabled">
            <require>
                <enum value="0"                                         name="VK_GOOGLE_EXTENSION_196_SPEC_VERSION"/>
                <enum value="&quot;VK_GOOGLE_extension_196&quot;"       name="VK_GOOGLE_EXTENSION_196_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_KHR_driver_properties" number="197" type="device" requires="VK_KHR_get_physical_device_properties2" author="KHR" contact="Daniel Rakos @drakos-amd" supported="vulkan">
            <require>
                <enum value="1"                                         name="VK_KHR_DRIVER_PROPERTIES_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_driver_properties&quot;"      name="VK_KHR_DRIVER_PROPERTIES_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES_KHR"/>
                <enum name="VK_MAX_DRIVER_NAME_SIZE_KHR"/>
                <enum name="VK_MAX_DRIVER_INFO_SIZE_KHR"/>
                <type name="VkDriverIdKHR"/>
                <type name="VkConformanceVersionKHR"/>
                <type name="VkPhysicalDeviceDriverPropertiesKHR"/>
            </require>
        </extension>
        <extension name="VK_KHR_shader_float_controls" number="198" type="device" requires="VK_KHR_get_physical_device_properties2" author="KHR" contact="Alexander Galazin @alegal-arm" supported="vulkan">
            <require>
                <enum value="1"                                           name="VK_KHR_SHADER_FLOAT_CONTROLS_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_shader_float_controls&quot;"    name="VK_KHR_SHADER_FLOAT_CONTROLS_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES_KHR"/>
                <type name="VkPhysicalDeviceFloatControlsPropertiesKHR"/>
            </require>
        </extension>
        <extension name="VK_NV_shader_subgroup_partitioned" number="199" type="device" requiresCore="1.1" author="NV" contact="Jeff Bolz @jeffbolznv" supported="vulkan">
            <require>
                <enum value="1"                                             name="VK_NV_SHADER_SUBGROUP_PARTITIONED_SPEC_VERSION"/>
                <enum value="&quot;VK_NV_shader_subgroup_partitioned&quot;" name="VK_NV_SHADER_SUBGROUP_PARTITIONED_EXTENSION_NAME"/>
                <enum bitpos="8" extends="VkSubgroupFeatureFlagBits"        name="VK_SUBGROUP_FEATURE_PARTITIONED_BIT_NV"/>
            </require>
        </extension>
        <extension name="VK_KHR_depth_stencil_resolve" number="200" type="device" requires="VK_KHR_create_renderpass2" author="KHR" contact="Jan-Harald Fredriksen @janharald" supported="vulkan">
            <require>
                <enum value="1"                                             name="VK_KHR_DEPTH_STENCIL_RESOLVE_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_depth_stencil_resolve&quot;"      name="VK_KHR_DEPTH_STENCIL_RESOLVE_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES_KHR"/>
                <enum offset="1" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE_KHR"/>
                <type name="VkSubpassDescriptionDepthStencilResolveKHR"/>
                <type name="VkPhysicalDeviceDepthStencilResolvePropertiesKHR"/>
                <type name="VkResolveModeFlagBitsKHR"/>
            </require>
        </extension>
        <extension name="VK_KHR_swapchain_mutable_format" number="201" type="device" author="KHR" requires="VK_KHR_swapchain,VK_KHR_maintenance2,VK_KHR_image_format_list" contact="Daniel Rakos @drakos-arm" supported="vulkan">
            <require>
                <enum value="1"                                         name="VK_KHR_SWAPCHAIN_MUTABLE_FORMAT_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_swapchain_mutable_format&quot;" name="VK_KHR_SWAPCHAIN_MUTABLE_FORMAT_EXTENSION_NAME"/>
                <enum bitpos="2" extends="VkSwapchainCreateFlagBitsKHR" name="VK_SWAPCHAIN_CREATE_MUTABLE_FORMAT_BIT_KHR"/>
            </require>
        </extension>
        <extension name="VK_NV_compute_shader_derivatives" number="202" type="device" requires="VK_KHR_get_physical_device_properties2" author="NV" contact="Pat Brown @nvpbrown" supported="vulkan">
            <require>
                <enum value="1"                                         name="VK_NV_COMPUTE_SHADER_DERIVATIVES_SPEC_VERSION"/>
                <enum value="&quot;VK_NV_compute_shader_derivatives&quot;" name="VK_NV_COMPUTE_SHADER_DERIVATIVES_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType" name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_NV"/>
                <type name="VkPhysicalDeviceComputeShaderDerivativesFeaturesNV"/>
            </require>
        </extension>
        <extension name="VK_NV_mesh_shader" number="203" type="device" requires="VK_KHR_get_physical_device_properties2" author="NV" contact="Christoph Kubisch @pixeljetstream" supported="vulkan">
            <require>
                <enum value="1"                                         name="VK_NV_MESH_SHADER_SPEC_VERSION"/>
                <enum value="&quot;VK_NV_mesh_shader&quot;"             name="VK_NV_MESH_SHADER_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_NV"/>
                <enum offset="1" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_NV"/>
                <enum bitpos="6" extends="VkShaderStageFlagBits"        name="VK_SHADER_STAGE_TASK_BIT_NV"/>
                <enum bitpos="7" extends="VkShaderStageFlagBits"        name="VK_SHADER_STAGE_MESH_BIT_NV"/>
                <enum bitpos="19" extends="VkPipelineStageFlagBits"     name="VK_PIPELINE_STAGE_TASK_SHADER_BIT_NV"/>
                <enum bitpos="20" extends="VkPipelineStageFlagBits"     name="VK_PIPELINE_STAGE_MESH_SHADER_BIT_NV"/>
                <command name="vkCmdDrawMeshTasksNV"/>
                <command name="vkCmdDrawMeshTasksIndirectNV"/>
                <command name="vkCmdDrawMeshTasksIndirectCountNV"/>
                <type name="VkPhysicalDeviceMeshShaderFeaturesNV"/>
                <type name="VkPhysicalDeviceMeshShaderPropertiesNV"/>
                <type name="VkDrawMeshTasksIndirectCommandNV"/>
            </require>
        </extension>
        <extension name="VK_NV_fragment_shader_barycentric" number="204" type="device" requires="VK_KHR_get_physical_device_properties2" author="NV" contact="Pat Brown @nvpbrown" supported="vulkan">
            <require>
                <enum value="1"                                         name="VK_NV_FRAGMENT_SHADER_BARYCENTRIC_SPEC_VERSION"/>
                <enum value="&quot;VK_NV_fragment_shader_barycentric&quot;" name="VK_NV_FRAGMENT_SHADER_BARYCENTRIC_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType" name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_NV"/>
                <type name="VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV"/>
            </require>
        </extension>
        <extension name="VK_NV_shader_image_footprint" number="205" type="device" requires="VK_KHR_get_physical_device_properties2" author="NV" contact="Pat Brown @nvpbrown" supported="vulkan">
            <require>
                <enum value="1"                                         name="VK_NV_SHADER_IMAGE_FOOTPRINT_SPEC_VERSION"/>
                <enum value="&quot;VK_NV_shader_image_footprint&quot;"  name="VK_NV_SHADER_IMAGE_FOOTPRINT_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_FOOTPRINT_FEATURES_NV"/>
                <type name="VkPhysicalDeviceShaderImageFootprintFeaturesNV"/>
            </require>
        </extension>
        <extension name="VK_NV_scissor_exclusive" number="206" type="device" requires="VK_KHR_get_physical_device_properties2" author="NV" contact="Pat Brown @nvpbrown" supported="vulkan">
            <require>
                <enum value="1"                                         name="VK_NV_SCISSOR_EXCLUSIVE_SPEC_VERSION"/>
                <enum value="&quot;VK_NV_scissor_exclusive&quot;"       name="VK_NV_SCISSOR_EXCLUSIVE_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType" name="VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_EXCLUSIVE_SCISSOR_STATE_CREATE_INFO_NV"/>
                <enum offset="1" extends="VkDynamicState" name="VK_DYNAMIC_STATE_EXCLUSIVE_SCISSOR_NV"/>
                <enum offset="2" extends="VkStructureType" name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXCLUSIVE_SCISSOR_FEATURES_NV"/>
                <type name="VkPipelineViewportExclusiveScissorStateCreateInfoNV"/>
                <type name="VkPhysicalDeviceExclusiveScissorFeaturesNV"/>
                <command name="vkCmdSetExclusiveScissorNV"/>
            </require>
        </extension>
        <extension name="VK_NV_device_diagnostic_checkpoints" type="device" number="207" requires="VK_KHR_get_physical_device_properties2" author="NVIDIA" contact="Nuno Subtil @nsubtil" supported="vulkan">
            <require>
                <enum value="2"                                         name="VK_NV_DEVICE_DIAGNOSTIC_CHECKPOINTS_SPEC_VERSION"/>
                <enum value="&quot;VK_NV_device_diagnostic_checkpoints&quot;" name="VK_NV_DEVICE_DIAGNOSTIC_CHECKPOINTS_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_CHECKPOINT_DATA_NV"/>
                <enum offset="1" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_NV"/>
                <type name="VkQueueFamilyCheckpointPropertiesNV"/>
                <type name="VkCheckpointDataNV"/>
                <command name="vkCmdSetCheckpointNV"/>
                <command name="vkGetQueueCheckpointDataNV"/>
            </require>
        </extension>
        <extension name="VK_KHR_extension_208" number="208" type="device" author="KHR" contact="Daniel Rakos @drakos-arm" supported="disabled">
            <require>
                <enum value="0"                                         name="VK_KHR_EXTENSION_208_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_extension_208&quot;"          name="VK_KHR_EXTENSION_208_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_KHR_extension_209" number="209" type="device" author="KHR" contact="Ian Elliott @ianelliott" supported="disabled">
            <require>
                <enum value="0"                                         name="VK_KHR_EXTENSION_209_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_extension_209&quot;"          name="VK_KHR_EXTENSION_209_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_INTEL_shader_integer_functions2" number="210" type="device" requires="VK_KHR_get_physical_device_properties2" author="INTEL" contact="Ian Romanick @ianromanick" supported="vulkan">
            <require>
                <enum value="1"                                         name="VK_INTEL_SHADER_INTEGER_FUNCTIONS2_SPEC_VERSION"/>
                <enum value="&quot;VK_INTEL_shader_integer_functions2&quot;" name="VK_INTEL_SHADER_INTEGER_FUNCTIONS2_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_FUNCTIONS2_FEATURES_INTEL"/>
                <type name="VkPhysicalDeviceShaderIntegerFunctions2INTEL"/>
            </require>
        </extension>
        <extension name="VK_INTEL_performance_query" number="211" type="device" author="INTEL" contact="Lionel Landwerlin @llandwerlin" supported="vulkan">
            <require>
                <enum value="1"                                         name="VK_INTEL_PERFORMANCE_QUERY_SPEC_VERSION"/>
                <enum value="&quot;VK_INTEL_performance_query&quot;"    name="VK_INTEL_PERFORMANCE_QUERY_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO_INTEL"/>
                <enum offset="1" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_INITIALIZE_PERFORMANCE_API_INFO_INTEL"/>
                <enum offset="2" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_PERFORMANCE_MARKER_INFO_INTEL"/>
                <enum offset="3" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_PERFORMANCE_STREAM_MARKER_INFO_INTEL"/>
                <enum offset="4" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_PERFORMANCE_OVERRIDE_INFO_INTEL"/>
                <enum offset="5" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_PERFORMANCE_CONFIGURATION_ACQUIRE_INFO_INTEL"/>
                <enum offset="0" extends="VkQueryType"                  name="VK_QUERY_TYPE_PERFORMANCE_QUERY_INTEL"/>
                <enum offset="0" extends="VkObjectType"                 name="VK_OBJECT_TYPE_PERFORMANCE_CONFIGURATION_INTEL"/>
                <type name="VkPerformanceConfigurationTypeINTEL"/>
                <type name="VkQueryPoolSamplingModeINTEL"/>
                <type name="VkPerformanceOverrideTypeINTEL"/>
                <type name="VkPerformanceParameterTypeINTEL"/>
                <type name="VkPerformanceValueTypeINTEL"/>
                <type name="VkPerformanceValueDataINTEL"/>
                <type name="VkPerformanceValueINTEL"/>
                <type name="VkInitializePerformanceApiInfoINTEL"/>
                <type name="VkQueryPoolCreateInfoINTEL"/>
                <type name="VkPerformanceMarkerInfoINTEL"/>
                <type name="VkPerformanceStreamMarkerInfoINTEL"/>
                <type name="VkPerformanceOverrideInfoINTEL"/>
                <type name="VkPerformanceConfigurationAcquireInfoINTEL"/>
                <type name="VkPerformanceConfigurationINTEL"/>
                <command name="vkInitializePerformanceApiINTEL"/>
                <command name="vkUninitializePerformanceApiINTEL"/>
                <command name="vkCmdSetPerformanceMarkerINTEL"/>
                <command name="vkCmdSetPerformanceStreamMarkerINTEL"/>
                <command name="vkCmdSetPerformanceOverrideINTEL"/>
                <command name="vkAcquirePerformanceConfigurationINTEL"/>
                <command name="vkReleasePerformanceConfigurationINTEL"/>
                <command name="vkQueueSetPerformanceConfigurationINTEL"/>
                <command name="vkGetPerformanceParameterINTEL"/>
            </require>
        </extension>
        <extension name="VK_KHR_vulkan_memory_model" number="212" type="device" author="KHR" contact="Jeff Bolz @jeffbolznv" provisional="true" supported="vulkan">
            <require>
                <enum value="3"                                         name="VK_KHR_VULKAN_MEMORY_MODEL_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_vulkan_memory_model&quot;"    name="VK_KHR_VULKAN_MEMORY_MODEL_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES_KHR"/>
                <type name="VkPhysicalDeviceVulkanMemoryModelFeaturesKHR"/>
            </require>
        </extension>
        <extension name="VK_EXT_pci_bus_info" number="213" type="device" author="EXT" requires="VK_KHR_get_physical_device_properties2" contact="Matthaeus G. Chajdas @anteru" supported="vulkan">
            <require>
                <enum value="2"                                         name="VK_EXT_PCI_BUS_INFO_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_pci_bus_info&quot;"           name="VK_EXT_PCI_BUS_INFO_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PCI_BUS_INFO_PROPERTIES_EXT"/>
                <type name="VkPhysicalDevicePCIBusInfoPropertiesEXT"/>
            </require>
        </extension>
        <extension name="VK_AMD_display_native_hdr" number="214" type="device" author="AMD" requires="VK_KHR_get_physical_device_properties2,VK_KHR_get_surface_capabilities2,VK_KHR_swapchain" contact="Matthaeus G. Chajdas @anteru" supported="vulkan">
            <require>
                <enum value="1"                                         name="VK_AMD_DISPLAY_NATIVE_HDR_SPEC_VERSION"/>
                <enum value="&quot;VK_AMD_display_native_hdr&quot;"     name="VK_AMD_DISPLAY_NATIVE_HDR_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_DISPLAY_NATIVE_HDR_SURFACE_CAPABILITIES_AMD"/>
                <enum offset="1" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_SWAPCHAIN_DISPLAY_NATIVE_HDR_CREATE_INFO_AMD"/>
                <enum offset="0" extends="VkColorSpaceKHR"              name="VK_COLOR_SPACE_DISPLAY_NATIVE_AMD"/>
                <type name="VkDisplayNativeHdrSurfaceCapabilitiesAMD"/>
                <type name="VkSwapchainDisplayNativeHdrCreateInfoAMD"/>
                <command name="vkSetLocalDimmingAMD"/>
            </require>
        </extension>
        <extension name="VK_FUCHSIA_imagepipe_surface" number="215" type="instance" author="FUCHSIA" requires="VK_KHR_surface" platform="fuchsia" contact="Craig Stout @cdotstout" supported="vulkan">
            <require>
                <enum value="1"                                         name="VK_FUCHSIA_IMAGEPIPE_SURFACE_SPEC_VERSION"/>
                <enum value="&quot;VK_FUCHSIA_imagepipe_surface&quot;"  name="VK_FUCHSIA_IMAGEPIPE_SURFACE_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_IMAGEPIPE_SURFACE_CREATE_INFO_FUCHSIA"/>
                <type name="VkImagePipeSurfaceCreateFlagsFUCHSIA"/>
                <type name="VkImagePipeSurfaceCreateInfoFUCHSIA"/>
                <command name="vkCreateImagePipeSurfaceFUCHSIA"/>
            </require>
        </extension>
        <extension name="VK_GOOGLE_extension_216" number="216" author="GOOGLE" contact="Jesse Hall @critsec" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_KHR_EXTENSION_216_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_extension_216&quot;"              name="VK_KHR_EXTENSION_216_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_GOOGLE_extension_217" number="217" author="GOOGLE" contact="Jesse Hall @critsec" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_KHR_EXTENSION_217_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_extension_217&quot;"              name="VK_KHR_EXTENSION_217_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_EXT_metal_surface" number="218" type="instance" requires="VK_KHR_surface" platform="metal" supported="vulkan" author="EXT" contact="Dzmitry Malyshau @kvark">
            <require>
                <enum value="1"                                             name="VK_EXT_METAL_SURFACE_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_metal_surface&quot;"              name="VK_EXT_METAL_SURFACE_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_METAL_SURFACE_CREATE_INFO_EXT"/>
                <type name="VkMetalSurfaceCreateFlagsEXT"/>
                <type name="VkMetalSurfaceCreateInfoEXT"/>
                <command name="vkCreateMetalSurfaceEXT"/>
            </require>
        </extension>
        <extension name="VK_EXT_fragment_density_map" number="219" type="device" requires="VK_KHR_get_physical_device_properties2" author="EXT" contact="Matthew Netsch @mnetsch" supported="vulkan">
            <require>
                <enum value="1"                                             name="VK_EXT_FRAGMENT_DENSITY_MAP_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_fragment_density_map&quot;"       name="VK_EXT_FRAGMENT_DENSITY_MAP_EXTENSION_NAME"/>
                <enum offset="0"  extends="VkStructureType"                 name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_FEATURES_EXT"/>
                <enum offset="1"  extends="VkStructureType"                 name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_PROPERTIES_EXT"/>
                <enum offset="2"  extends="VkStructureType"                 name="VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_CREATE_INFO_EXT"/>
                <enum bitpos="14" extends="VkImageCreateFlagBits"           name="VK_IMAGE_CREATE_SUBSAMPLED_BIT_EXT"/>
                <enum offset="0"  extends="VkImageLayout"                   name="VK_IMAGE_LAYOUT_FRAGMENT_DENSITY_MAP_OPTIMAL_EXT"/>
                <enum bitpos="24" extends="VkAccessFlagBits"                name="VK_ACCESS_FRAGMENT_DENSITY_MAP_READ_BIT_EXT"/>
                <enum bitpos="24" extends="VkFormatFeatureFlagBits"         name="VK_FORMAT_FEATURE_FRAGMENT_DENSITY_MAP_BIT_EXT"/>
                <enum bitpos="9"  extends="VkImageUsageFlagBits"            name="VK_IMAGE_USAGE_FRAGMENT_DENSITY_MAP_BIT_EXT"/>
                <enum bitpos="0"  extends="VkImageViewCreateFlagBits"       name="VK_IMAGE_VIEW_CREATE_FRAGMENT_DENSITY_MAP_DYNAMIC_BIT_EXT"/>
                <enum bitpos="23" extends="VkPipelineStageFlagBits"         name="VK_PIPELINE_STAGE_FRAGMENT_DENSITY_PROCESS_BIT_EXT"/>
                <enum bitpos="0"  extends="VkSamplerCreateFlagBits"         name="VK_SAMPLER_CREATE_SUBSAMPLED_BIT_EXT"/>
                <enum bitpos="1"  extends="VkSamplerCreateFlagBits"         name="VK_SAMPLER_CREATE_SUBSAMPLED_COARSE_RECONSTRUCTION_BIT_EXT"/>
                <type name="VkPhysicalDeviceFragmentDensityMapFeaturesEXT"/>
                <type name="VkPhysicalDeviceFragmentDensityMapPropertiesEXT"/>
                <type name="VkRenderPassFragmentDensityMapCreateInfoEXT"/>
            </require>
        </extension>
        <extension name="VK_EXT_extension_220" number="220" author="EXT" contact="Dzmitry Malyshau @kvark" supported="disabled">
            <require>
                <enum value="0"                                              name="VK_EXT_EXTENSION_220_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_extension_220&quot;"               name="VK_EXT_EXTENSION_220_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_KHR_extension_221" number="221" author="KHR" contact="Tobias Hector @tobski" supported="disabled">
            <require>
                <enum value="0"                                              name="VK_KHR_EXTENSION_221_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_extension_221&quot;"               name="VK_KHR_EXTENSION_221_EXTENSION_NAME"/>
                <enum bitpos="0" extends="VkRenderPassCreateFlagBits"        name="VK_RENDER_PASS_CREATE_RESERVED_0_BIT_KHR"/>
            </require>
        </extension>
        <extension name="VK_EXT_scalar_block_layout" number="222" requires="VK_KHR_get_physical_device_properties2" type="device" author="EXT" contact="Tobias Hector @tobski" supported="vulkan">
            <require>
                <enum value="1"                                             name="VK_EXT_SCALAR_BLOCK_LAYOUT_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_scalar_block_layout&quot;"        name="VK_EXT_SCALAR_BLOCK_LAYOUT_EXTENSION_NAME"/>
                <type                                                       name="VkPhysicalDeviceScalarBlockLayoutFeaturesEXT"/>
                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES_EXT"/>
            </require>
        </extension>
        <extension name="VK_EXT_extension_223" number="223" author="EXT" contact="Tobias Hector @tobski" supported="disabled">
            <require>
                <enum value="0"                                              name="VK_EXT_EXTENSION_223_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_extension_223&quot;"               name="VK_EXT_EXTENSION_223_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_GOOGLE_hlsl_functionality1" number="224" type="device" author="GOOGLE" contact="Hai Nguyen @chaoticbob" supported="vulkan">
            <require>
                <enum value="1"                                             name="VK_GOOGLE_HLSL_FUNCTIONALITY1_SPEC_VERSION"/>
                <enum value="&quot;VK_GOOGLE_hlsl_functionality1&quot;"     name="VK_GOOGLE_HLSL_FUNCTIONALITY1_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_GOOGLE_decorate_string" number="225" type="device" author="GOOGLE" contact="Hai Nguyen @chaoticbob" supported="vulkan">
            <require>
                <enum value="1"                                             name="VK_GOOGLE_DECORATE_STRING_SPEC_VERSION"/>
                <enum value="&quot;VK_GOOGLE_decorate_string&quot;"         name="VK_GOOGLE_DECORATE_STRING_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_AMD_extension_226" number="226" author="AMD" contact="Martin Dinkov @mdinkov" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_AMD_EXTENSION_226_SPEC_VERSION"/>
                <enum value="&quot;VK_AMD_extension_226&quot;"              name="VK_AMD_EXTENSION_226_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_AMD_extension_227" number="227" author="AMD" contact="Martin Dinkov @mdinkov" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_AMD_EXTENSION_227_SPEC_VERSION"/>
                <enum value="&quot;VK_AMD_extension_227&quot;"              name="VK_AMD_EXTENSION_227_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_AMD_extension_228" number="228" author="AMD" contact="Martin Dinkov @mdinkov" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_AMD_EXTENSION_228_SPEC_VERSION"/>
                <enum value="&quot;VK_AMD_extension_228&quot;"              name="VK_AMD_EXTENSION_228_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_AMD_extension_229" number="229" author="AMD" contact="Martin Dinkov @mdinkov" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_AMD_EXTENSION_229_SPEC_VERSION"/>
                <enum value="&quot;VK_AMD_extension_229&quot;"              name="VK_AMD_EXTENSION_229_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_AMD_extension_230" number="230" author="AMD" contact="Martin Dinkov @mdinkov" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_AMD_EXTENSION_230_SPEC_VERSION"/>
                <enum value="&quot;VK_AMD_extension_230&quot;"              name="VK_AMD_EXTENSION_230_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_AMD_extension_231" number="231" author="AMD" contact="Martin Dinkov @mdinkov" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_AMD_EXTENSION_231_SPEC_VERSION"/>
                <enum value="&quot;VK_AMD_extension_231&quot;"              name="VK_AMD_EXTENSION_231_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_AMD_extension_232" number="232" author="AMD" contact="Martin Dinkov @mdinkov" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_AMD_EXTENSION_232_SPEC_VERSION"/>
                <enum value="&quot;VK_AMD_extension_232&quot;"              name="VK_AMD_EXTENSION_232_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_AMD_extension_233" number="233" author="AMD" contact="Martin Dinkov @mdinkov" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_AMD_EXTENSION_233_SPEC_VERSION"/>
                <enum value="&quot;VK_AMD_extension_233&quot;"              name="VK_AMD_EXTENSION_233_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_AMD_extension_234" number="234" author="AMD" contact="Martin Dinkov @mdinkov" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_AMD_EXTENSION_234_SPEC_VERSION"/>
                <enum value="&quot;VK_AMD_extension_234&quot;"              name="VK_AMD_EXTENSION_234_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_AMD_extension_235" number="235" author="AMD" contact="Martin Dinkov @mdinkov" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_AMD_EXTENSION_235_SPEC_VERSION"/>
                <enum value="&quot;VK_AMD_extension_235&quot;"              name="VK_AMD_EXTENSION_235_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_AMD_extension_236" number="236" author="AMD" contact="Martin Dinkov @mdinkov" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_AMD_EXTENSION_236_SPEC_VERSION"/>
                <enum value="&quot;VK_AMD_extension_236&quot;"              name="VK_AMD_EXTENSION_236_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_KHR_extension_237" number="237" author="KHR" contact="Jesse Hall @critsec" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_KHR_EXTENSION_237_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_extension_237&quot;"              name="VK_KHR_EXTENSION_237_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_EXT_memory_budget" number="238" type="device" requires="VK_KHR_get_physical_device_properties2" author="EXT" contact="Jeff Bolz @jeffbolznv" supported="vulkan">
            <require>
                <enum value="1"                                             name="VK_EXT_MEMORY_BUDGET_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_memory_budget&quot;"              name="VK_EXT_MEMORY_BUDGET_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_BUDGET_PROPERTIES_EXT"/>
                <type name="VkPhysicalDeviceMemoryBudgetPropertiesEXT"/>
            </require>
        </extension>
        <extension name="VK_EXT_memory_priority" number="239" type="device" requires="VK_KHR_get_physical_device_properties2"  author="EXT" contact="Jeff Bolz @jeffbolznv" supported="vulkan">
            <require>
                <enum value="1"                                             name="VK_EXT_MEMORY_PRIORITY_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_memory_priority&quot;"            name="VK_EXT_MEMORY_PRIORITY_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PRIORITY_FEATURES_EXT"/>
                <enum offset="1" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_MEMORY_PRIORITY_ALLOCATE_INFO_EXT"/>
                <type name="VkPhysicalDeviceMemoryPriorityFeaturesEXT"/>
                <type name="VkMemoryPriorityAllocateInfoEXT"/>
            </require>
        </extension>
        <extension name="VK_KHR_surface_protected_capabilities" number="240" type="instance" requiresCore="1.1" requires="VK_KHR_get_surface_capabilities2" author="KHR" contact="Sandeep Shinde @sashinde" supported="vulkan">
            <require>
                <enum value="1"                                             name="VK_KHR_SURFACE_PROTECTED_CAPABILITIES_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_surface_protected_capabilities&quot;"   name="VK_KHR_SURFACE_PROTECTED_CAPABILITIES_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_SURFACE_PROTECTED_CAPABILITIES_KHR"/>
                <type name="VkSurfaceProtectedCapabilitiesKHR"/>
            </require>
        </extension>
        <extension name="VK_NV_dedicated_allocation_image_aliasing" number="241" type="device" requires="VK_KHR_dedicated_allocation" author="NVIDIA" contact="Nuno Subtil @nsubtil" supported="vulkan">
            <require>
                <enum value="1"                                                         name="VK_NV_DEDICATED_ALLOCATION_IMAGE_ALIASING_SPEC_VERSION"/>
                <enum value="&quot;VK_NV_dedicated_allocation_image_aliasing&quot;"     name="VK_NV_DEDICATED_ALLOCATION_IMAGE_ALIASING_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                              name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEDICATED_ALLOCATION_IMAGE_ALIASING_FEATURES_NV"/>
                <type name="VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV"/>
            </require>
        </extension>
        <extension name="VK_NV_extension_242" number="242" author="NVIDIA" contact="Nuno Subtil @nsubtil" supported="disabled">
            <require>
                <enum value="0"                                              name="VK_NV_EXTENSION_242_SPEC_VERSION"/>
                <enum value="&quot;VK_NV_extension_242&quot;"                name="VK_NV_EXTENSION_242_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_INTEL_extension_243" number="243" author="INTEL" contact="Slawek Grajewski @sgrajewski" supported="disabled">
            <require>
                <enum value="0"                                              name="VK_INTEL_EXTENSION_243_SPEC_VERSION"/>
                <enum value="&quot;VK_INTEL_extension_243&quot;"             name="VK_INTEL_EXTENSION_243_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_MESA_extension_244" number="244" author="MESA" contact="Andres Rodriguez @lostgoat" supported="disabled">
            <require>
                <enum value="0"                                              name="VK_MESA_EXTENSION_244_SPEC_VERSION"/>
                <enum value="&quot;VK_MESA_extension_244&quot;"              name="VK_MESA_EXTENSION_244_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_EXT_buffer_device_address" number="245" type="device" requires="VK_KHR_get_physical_device_properties2" author="NV" contact="Jeff Bolz @jeffbolznv" supported="vulkan">
            <require>
                <enum value="2"                                             name="VK_EXT_BUFFER_DEVICE_ADDRESS_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_buffer_device_address&quot;"      name="VK_EXT_BUFFER_DEVICE_ADDRESS_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT"/>
                <enum            extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_ADDRESS_FEATURES_EXT" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT"/>
                <enum offset="1" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO_EXT"/>
                <enum offset="2" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_CREATE_INFO_EXT"/>
                <enum bitpos="17" extends="VkBufferUsageFlagBits"           name="VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT_EXT"/>
                <enum bitpos="4"  extends="VkBufferCreateFlagBits"          name="VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_EXT"/>
                <enum offset="0" dir="-" extends="VkResult"                 name="VK_ERROR_INVALID_DEVICE_ADDRESS_EXT"/>
                <type name="VkPhysicalDeviceBufferAddressFeaturesEXT"/>
                <type name="VkPhysicalDeviceBufferDeviceAddressFeaturesEXT"/>
                <type name="VkBufferDeviceAddressInfoEXT"/>
                <type name="VkBufferDeviceAddressCreateInfoEXT"/>
                <command name="vkGetBufferDeviceAddressEXT"/>
            </require>
        </extension>
        <extension name="VK_EXT_extension_246" number="246" author="EXT" contact="Tobias Hector @tobski" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_EXT_EXTENSION_246_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_extension_246&quot;"              name="VK_EXT_EXTENSION_246_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_EXT_separate_stencil_usage" number="247" type="device" author="EXT" contact="Daniel Rakos @drakos-amd" supported="vulkan">
            <require>
                <enum value="1"                                             name="VK_EXT_SEPARATE_STENCIL_USAGE_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_separate_stencil_usage&quot;"     name="VK_EXT_SEPARATE_STENCIL_USAGE_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO_EXT"/>
                <type name="VkImageStencilUsageCreateInfoEXT"/>
            </require>
        </extension>
        <extension name="VK_EXT_validation_features" number="248" type="instance" author="LUNARG" contact="Karl Schultz @karl-lunarg" supported="vulkan">
            <require>
                <enum value="1"                                             name="VK_EXT_VALIDATION_FEATURES_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_validation_features&quot;"        name="VK_EXT_VALIDATION_FEATURES_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_VALIDATION_FEATURES_EXT"/>
                <type name="VkValidationFeaturesEXT"/>
            </require>
        </extension>
        <extension name="VK_KHR_extension_249" number="249" author="KHR" contact="Keith Packard @keithp" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_KHR_EXTENSION_249_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_extension_249&quot;"              name="VK_KHR_EXTENSION_249_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_NV_cooperative_matrix" number="250" type="device" requires="VK_KHR_get_physical_device_properties2" author="NV" contact="Jeff Bolz @jeffbolznv" supported="vulkan">
            <require>
                <enum value="1"                                              name="VK_NV_COOPERATIVE_MATRIX_SPEC_VERSION"/>
                <enum value="&quot;VK_NV_cooperative_matrix&quot;"           name="VK_NV_COOPERATIVE_MATRIX_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                   name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_NV"/>
                <enum offset="1" extends="VkStructureType"                   name="VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_PROPERTIES_NV"/>
                <enum offset="2" extends="VkStructureType"                   name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_NV"/>
                <type name="VkCooperativeMatrixPropertiesNV"/>
                <type name="VkScopeNV"/>
                <type name="VkComponentTypeNV"/>
                <type name="VkPhysicalDeviceCooperativeMatrixFeaturesNV"/>
                <type name="VkPhysicalDeviceCooperativeMatrixPropertiesNV"/>
                <command name="vkGetPhysicalDeviceCooperativeMatrixPropertiesNV"/>
            </require>
        </extension>
        <extension name="VK_NV_coverage_reduction_mode" number="251" requires="VK_NV_framebuffer_mixed_samples" type="device" author="NV" contact="Kedarnath Thangudu @kthangudu" supported="vulkan">
            <require>
                <enum value="1"                                             name="VK_NV_COVERAGE_REDUCTION_MODE_SPEC_VERSION"/>
                <enum value="&quot;VK_NV_coverage_reduction_mode&quot;"     name="VK_NV_COVERAGE_REDUCTION_MODE_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COVERAGE_REDUCTION_MODE_FEATURES_NV"/>
                <enum offset="1" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_REDUCTION_STATE_CREATE_INFO_NV"/>
                <enum offset="2" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_FRAMEBUFFER_MIXED_SAMPLES_COMBINATION_NV"/>
                <type name="VkPhysicalDeviceCoverageReductionModeFeaturesNV"/>
                <type name="VkPipelineCoverageReductionStateCreateInfoNV"/>
                <type name="VkPipelineCoverageReductionStateCreateFlagsNV"/>
                <type name="VkCoverageReductionModeNV"/>
                <type name="VkFramebufferMixedSamplesCombinationNV"/>
                <command name="vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV"/>
            </require>
        </extension>
        <extension name="VK_EXT_fragment_shader_interlock" number="252" author="EXT" type="device" requires="VK_KHR_get_physical_device_properties2" contact="Piers Daniell @pdaniell-nv" supported="vulkan">
            <require>
                <enum value="1"                                                 name="VK_EXT_FRAGMENT_SHADER_INTERLOCK_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_fragment_shader_interlock&quot;"      name="VK_EXT_FRAGMENT_SHADER_INTERLOCK_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_INTERLOCK_FEATURES_EXT"/>
                <type name="VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT"/>
            </require>
        </extension>
        <extension name="VK_EXT_ycbcr_image_arrays" number="253" type="device" requires="VK_KHR_sampler_ycbcr_conversion" author="EXT" contact="Piers Daniell @pdaniell-nv" supported="vulkan">
            <require>
                <enum value="1"                                             name="VK_EXT_YCBCR_IMAGE_ARRAYS_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_ycbcr_image_arrays&quot;"         name="VK_EXT_YCBCR_IMAGE_ARRAYS_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_IMAGE_ARRAYS_FEATURES_EXT"/>
                <type name="VkPhysicalDeviceYcbcrImageArraysFeaturesEXT"/>
            </require>
        </extension>
        <extension name="VK_KHR_uniform_buffer_standard_layout" number="254" requires="VK_KHR_get_physical_device_properties2" type="device" author="KHR" contact="Graeme Leese @gnl21" supported="vulkan">
            <require>
                <enum value="1"                                                 name="VK_KHR_UNIFORM_BUFFER_STANDARD_LAYOUT_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_uniform_buffer_standard_layout&quot;" name="VK_KHR_UNIFORM_BUFFER_STANDARD_LAYOUT_EXTENSION_NAME"/>
                <type                                                           name="VkPhysicalDeviceUniformBufferStandardLayoutFeaturesKHR"/>
                <enum offset="0" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES_KHR"/>
            </require>
        </extension>
        <extension name="VK_EXT_extension_255" number="255" author="EXT" contact="Jesse Hall @jessehall" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_EXT_EXTENSION_255_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_extension_255&quot;"              name="VK_EXT_EXTENSION_255_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_EXT_full_screen_exclusive" number="256" type="device" author="EXT" requires="VK_KHR_get_physical_device_properties2,VK_KHR_surface,VK_KHR_get_surface_capabilities2,VK_KHR_swapchain" platform="win32" contact="James Jones @cubanismo" supported="vulkan">
            <require>
                <enum value="3"                                             name="VK_EXT_FULL_SCREEN_EXCLUSIVE_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_full_screen_exclusive&quot;"      name="VK_EXT_FULL_SCREEN_EXCLUSIVE_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_INFO_EXT"/>
                <enum offset="2" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_FULL_SCREEN_EXCLUSIVE_EXT"/>
                <enum offset="0" extends="VkResult" dir="-"                 name="VK_ERROR_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT"/>
                <type name="VkFullScreenExclusiveEXT"/>
                <type name="VkSurfaceFullScreenExclusiveInfoEXT"/>
                <type name="VkSurfaceCapabilitiesFullScreenExclusiveEXT"/>
                <command name="vkGetPhysicalDeviceSurfacePresentModes2EXT"/>
                <command name="vkAcquireFullScreenExclusiveModeEXT"/>
                <command name="vkReleaseFullScreenExclusiveModeEXT"/>
            </require>
            <require extension="VK_KHR_win32_surface">
                <enum offset="1" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_WIN32_INFO_EXT"/>
                <type name="VkSurfaceFullScreenExclusiveWin32InfoEXT"/>
            </require>
            <require extension="VK_KHR_device_group">
                <command name="vkGetDeviceGroupSurfacePresentModes2EXT"/>
            </require>
            <require feature="VK_VERSION_1_1">
                <command name="vkGetDeviceGroupSurfacePresentModes2EXT"/>
            </require>
        </extension>
        <extension name="VK_EXT_headless_surface" number="257" type="instance" requires="VK_KHR_surface" author="EXT" contact="Ray Smith @raysmith-arm" supported="vulkan">
            <require>
                <enum value="0"                                                 name="VK_EXT_HEADLESS_SURFACE_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_headless_surface&quot;"               name="VK_EXT_HEADLESS_SURFACE_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_HEADLESS_SURFACE_CREATE_INFO_EXT"/>
                <type name="VkHeadlessSurfaceCreateFlagsEXT"/>
                <type name="VkHeadlessSurfaceCreateInfoEXT"/>
                <command name="vkCreateHeadlessSurfaceEXT"/>
            </require>
        </extension>
        <extension name="VK_EXT_extension_258" number="258" author="EXT" contact="Jan-Harald Fredriksen @janharaldfredriksen-arm" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_EXT_EXTENSION_258_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_extension_258&quot;"              name="VK_EXT_EXTENSION_258_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_EXT_extension_259" number="259" author="EXT" contact="Jeff Leger @jackohound" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_EXT_EXTENSION_259_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_extension_259&quot;"              name="VK_EXT_EXTENSION_259_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_EXT_extension_260" number="260" author="EXT" contact="Allen Jensen @allenjensen" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_EXT_EXTENSION_260_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_extension_260&quot;"              name="VK_EXT_extension_260"/>
            </require>
        </extension>
        <extension name="VK_NV_extension_261" number="261" author="NV" contact="Kedarnath Thangudu @kthangudu" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_NV_EXTENSION_261_SPEC_VERSION"/>
                <enum value="&quot;VK_NV_extension_261&quot;"               name="VK_NV_EXTENSION_261_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_EXT_host_query_reset" number="262" author="EXT" contact="Bas Nieuwenhuizen @BNieuwenhuizen" supported="vulkan" type="device" requires="VK_KHR_get_physical_device_properties2">
            <require>
                <enum value="1"                                             name="VK_EXT_HOST_QUERY_RESET_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_host_query_reset&quot;"           name="VK_EXT_HOST_QUERY_RESET_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES_EXT"/>
                <type name="VkPhysicalDeviceHostQueryResetFeaturesEXT"/>
                <command name="vkResetQueryPoolEXT"/>
            </require>
        </extension>
        <extension name="VK_GGP_extension_263" number="263" author="GGP" contact="Jean-Francois Roy @jfroy" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_GOOGLE_EXTENSION_263_SPEC_VERSION"/>
                <enum value="&quot;VK_GGP_extension_263&quot;"              name="VK_GOOGLE_EXTENSION_263_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_BRCM_extension_264" number="264" author="BRCM" contact="Graeme Leese @gnl21" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_BRCM_EXTENSION_264_SPEC_VERSION"/>
                <enum value="&quot;VK_BRCM_extension_264&quot;"             name="VK_BRCM_EXTENSION_264_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_BRCM_extension_265" number="265" author="BRCM" contact="Graeme Leese @gnl21" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_BRCM_EXTENSION_265_SPEC_VERSION"/>
                <enum value="&quot;VK_BRCM_extension_265&quot;"             name="VK_BRCM_EXTENSION_265_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_EXT_extension_266" number="266" type="device" author="EXT" contact="Piers Daniell @pdaniell-nv" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_EXT_EXTENSION_266_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_extension_266&quot;"              name="VK_EXT_extension_266"/>
            </require>
        </extension>
        <extension name="VK_EXT_extension_267" number="267" type="device" author="EXT" contact="Piers Daniell @pdaniell-nv" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_EXT_EXTENSION_267_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_extension_267&quot;"              name="VK_EXT_extension_267"/>
            </require>
        </extension>
        <extension name="VK_KHR_extension_268" number="268" type="device" author="KHR" contact="Piers Daniell @pdaniell-nv" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_EXT_EXTENSION_268_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_extension_268&quot;"              name="VK_EXT_extension_268"/>
            </require>
        </extension>
        <extension name="VK_KHR_extension_269" number="269" type="device" author="KHR" contact="Josh Barczak @jbarczak" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_KHR_EXTENSION_269_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_extension_269&quot;"              name="VK_KHR_extension_269"/>
            </require>
        </extension>
        <extension name="VK_INTEL_extension_270" number="270" type="device" author="INTEL" contact="Jason Ekstrand @jekstrand" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_INTEL_EXTENSION_270_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_extension_270&quot;"              name="VK_INTEL_extension_270"/>
            </require>
        </extension>
        <extension name="VK_INTEL_extension_271" number="271" type="device" author="INTEL" contact="Jason Ekstrand @jekstrand" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_INTEL_EXTENSION_271_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_extension_271&quot;"              name="VK_INTEL_extension_271"/>
            </require>
        </extension>
        <extension name="VK_INTEL_extension_272" number="272" type="device" author="INTEL" contact="Jason Ekstrand @jekstrand" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_INTEL_EXTENSION_272_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_extension_272&quot;"              name="VK_INTEL_extension_272"/>
            </require>
        </extension>
        <extension name="VK_INTEL_extension_273" number="273" type="device" author="INTEL" contact="Jason Ekstrand @jekstrand" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_INTEL_EXTENSION_273_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_extension_273&quot;"              name="VK_INTEL_extension_273"/>
            </require>
        </extension>
        <extension name="VK_INTEL_extension_274" number="274" type="device" author="INTEL" contact="Jason Ekstrand @jekstrand" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_INTEL_EXTENSION_274_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_extension_274&quot;"              name="VK_INTEL_extension_274"/>
            </require>
        </extension>
        <extension name="VK_KHR_extension_275" number="275" type="instance" author="KHR" contact="Lionel Landwerlin @llandwerlin" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_KHR_EXTENSION_275_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_extension_275&quot;"              name="VK_KHR_extension_275"/>
            </require>
        </extension>
        <extension name="VK_KHR_extension_276" number="276" type="device" author="KHR" contact="James Jones @cubanismo" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_KHR_EXTENSION_276_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_extension_276&quot;"              name="VK_KHR_extension_276"/>
            </require>
        </extension>
        <extension name="VK_EXT_shader_demote_to_helper_invocation" number="277" type="device" requires="VK_KHR_get_physical_device_properties2" author="EXT" contact="Jeff Bolz @jeffbolznv" supported="vulkan">
            <require>
                <enum value="1"                                                     name="VK_EXT_SHADER_DEMOTE_TO_HELPER_INVOCATION_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_shader_demote_to_helper_invocation&quot;" name="VK_EXT_SHADER_DEMOTE_TO_HELPER_INVOCATION_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                          name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES_EXT"/>
                <type name="VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT"/>
            </require>
        </extension>
        <extension name="VK_NV_extension_278" number="278" type="device" author="NV" contact="Christoph Kubisch @pixeljetstream" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_NV_EXTENSION_278_SPEC_VERSION"/>
                <enum value="&quot;VK_NV_extension_278&quot;"               name="VK_NV_extension_278"/>
            </require>
        </extension>
        <extension name="VK_NV_extension_279" number="279" type="device" author="NV" contact="Christoph Kubisch @pixeljetstream" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_NV_EXTENSION_279_SPEC_VERSION"/>
                <enum value="&quot;VK_NV_extension_279&quot;"               name="VK_NV_extension_279"/>
            </require>
        </extension>
        <extension name="VK_KHR_extension_280" number="280" type="device" author="KHR" contact="Kevin Petit @kevinpetit" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_KHR_EXTENSION_280_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_extension_280&quot;"              name="VK_KHR_extension_280"/>
            </require>
        </extension>
        <extension name="VK_ARM_extension_281" number="281" type="device" author="ARM" contact="Kevin Petit @kevinpetit" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_ARM_EXTENSION_281_SPEC_VERSION"/>
                <enum value="&quot;VK_ARM_extension_281&quot;"              name="VK_ARM_extension_281"/>
            </require>
        </extension>
        <extension name="VK_EXT_texel_buffer_alignment" number="282" type="device" requires="VK_KHR_get_physical_device_properties2" author="EXT" contact="Jeff Bolz @jeffbolznv" supported="vulkan">
            <require>
                <enum value="1"                                             name="VK_EXT_TEXEL_BUFFER_ALIGNMENT_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_texel_buffer_alignment&quot;"     name="VK_EXT_TEXEL_BUFFER_ALIGNMENT_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_FEATURES_EXT"/>
                <enum offset="1" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES_EXT"/>
                <type name="VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT"/>
                <type name="VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT"/>
            </require>
        </extension>
    </extensions>
</registry>
